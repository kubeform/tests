/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpec{}).Type1()):                   AppSpecSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecJobGit{}).Type1()):             AppSpecSpecJobGitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecJobGithub{}).Type1()):          AppSpecSpecJobGithubCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecJobGitlab{}).Type1()):          AppSpecSpecJobGitlabCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecJobImage{}).Type1()):           AppSpecSpecJobImageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecServiceGit{}).Type1()):         AppSpecSpecServiceGitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecServiceGithub{}).Type1()):      AppSpecSpecServiceGithubCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecServiceGitlab{}).Type1()):      AppSpecSpecServiceGitlabCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecServiceHealthCheck{}).Type1()): AppSpecSpecServiceHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecServiceImage{}).Type1()):       AppSpecSpecServiceImageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecStaticSiteGit{}).Type1()):      AppSpecSpecStaticSiteGitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecStaticSiteGithub{}).Type1()):   AppSpecSpecStaticSiteGithubCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecStaticSiteGitlab{}).Type1()):   AppSpecSpecStaticSiteGitlabCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecWorkerGit{}).Type1()):          AppSpecSpecWorkerGitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecWorkerGithub{}).Type1()):       AppSpecSpecWorkerGithubCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecWorkerGitlab{}).Type1()):       AppSpecSpecWorkerGitlabCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecWorkerImage{}).Type1()):        AppSpecSpecWorkerImageCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpec{}).Type1()):                   AppSpecSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecJobGit{}).Type1()):             AppSpecSpecJobGitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecJobGithub{}).Type1()):          AppSpecSpecJobGithubCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecJobGitlab{}).Type1()):          AppSpecSpecJobGitlabCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecJobImage{}).Type1()):           AppSpecSpecJobImageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecServiceGit{}).Type1()):         AppSpecSpecServiceGitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecServiceGithub{}).Type1()):      AppSpecSpecServiceGithubCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecServiceGitlab{}).Type1()):      AppSpecSpecServiceGitlabCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecServiceHealthCheck{}).Type1()): AppSpecSpecServiceHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecServiceImage{}).Type1()):       AppSpecSpecServiceImageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecStaticSiteGit{}).Type1()):      AppSpecSpecStaticSiteGitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecStaticSiteGithub{}).Type1()):   AppSpecSpecStaticSiteGithubCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecStaticSiteGitlab{}).Type1()):   AppSpecSpecStaticSiteGitlabCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecWorkerGit{}).Type1()):          AppSpecSpecWorkerGitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecWorkerGithub{}).Type1()):       AppSpecSpecWorkerGithubCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecWorkerGitlab{}).Type1()):       AppSpecSpecWorkerGitlabCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecWorkerImage{}).Type1()):        AppSpecSpecWorkerImageCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AppSpecSpecCodec struct {
}

func (AppSpecSpecCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AppSpecSpec)(ptr) == nil
}

func (AppSpecSpecCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AppSpecSpec)(ptr)
	var objs []AppSpecSpec
	if obj != nil {
		objs = []AppSpecSpec{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpec{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AppSpecSpecCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AppSpecSpec)(ptr) = AppSpecSpec{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AppSpecSpec

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpec{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AppSpecSpec)(ptr) = objs[0]
			} else {
				*(*AppSpecSpec)(ptr) = AppSpecSpec{}
			}
		} else {
			*(*AppSpecSpec)(ptr) = AppSpecSpec{}
		}
	default:
		iter.ReportError("decode AppSpecSpec", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AppSpecSpecJobGitCodec struct {
}

func (AppSpecSpecJobGitCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AppSpecSpecJobGit)(ptr) == nil
}

func (AppSpecSpecJobGitCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AppSpecSpecJobGit)(ptr)
	var objs []AppSpecSpecJobGit
	if obj != nil {
		objs = []AppSpecSpecJobGit{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecJobGit{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AppSpecSpecJobGitCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AppSpecSpecJobGit)(ptr) = AppSpecSpecJobGit{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AppSpecSpecJobGit

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecJobGit{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AppSpecSpecJobGit)(ptr) = objs[0]
			} else {
				*(*AppSpecSpecJobGit)(ptr) = AppSpecSpecJobGit{}
			}
		} else {
			*(*AppSpecSpecJobGit)(ptr) = AppSpecSpecJobGit{}
		}
	default:
		iter.ReportError("decode AppSpecSpecJobGit", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AppSpecSpecJobGithubCodec struct {
}

func (AppSpecSpecJobGithubCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AppSpecSpecJobGithub)(ptr) == nil
}

func (AppSpecSpecJobGithubCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AppSpecSpecJobGithub)(ptr)
	var objs []AppSpecSpecJobGithub
	if obj != nil {
		objs = []AppSpecSpecJobGithub{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecJobGithub{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AppSpecSpecJobGithubCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AppSpecSpecJobGithub)(ptr) = AppSpecSpecJobGithub{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AppSpecSpecJobGithub

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecJobGithub{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AppSpecSpecJobGithub)(ptr) = objs[0]
			} else {
				*(*AppSpecSpecJobGithub)(ptr) = AppSpecSpecJobGithub{}
			}
		} else {
			*(*AppSpecSpecJobGithub)(ptr) = AppSpecSpecJobGithub{}
		}
	default:
		iter.ReportError("decode AppSpecSpecJobGithub", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AppSpecSpecJobGitlabCodec struct {
}

func (AppSpecSpecJobGitlabCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AppSpecSpecJobGitlab)(ptr) == nil
}

func (AppSpecSpecJobGitlabCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AppSpecSpecJobGitlab)(ptr)
	var objs []AppSpecSpecJobGitlab
	if obj != nil {
		objs = []AppSpecSpecJobGitlab{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecJobGitlab{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AppSpecSpecJobGitlabCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AppSpecSpecJobGitlab)(ptr) = AppSpecSpecJobGitlab{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AppSpecSpecJobGitlab

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecJobGitlab{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AppSpecSpecJobGitlab)(ptr) = objs[0]
			} else {
				*(*AppSpecSpecJobGitlab)(ptr) = AppSpecSpecJobGitlab{}
			}
		} else {
			*(*AppSpecSpecJobGitlab)(ptr) = AppSpecSpecJobGitlab{}
		}
	default:
		iter.ReportError("decode AppSpecSpecJobGitlab", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AppSpecSpecJobImageCodec struct {
}

func (AppSpecSpecJobImageCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AppSpecSpecJobImage)(ptr) == nil
}

func (AppSpecSpecJobImageCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AppSpecSpecJobImage)(ptr)
	var objs []AppSpecSpecJobImage
	if obj != nil {
		objs = []AppSpecSpecJobImage{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecJobImage{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AppSpecSpecJobImageCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AppSpecSpecJobImage)(ptr) = AppSpecSpecJobImage{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AppSpecSpecJobImage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecJobImage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AppSpecSpecJobImage)(ptr) = objs[0]
			} else {
				*(*AppSpecSpecJobImage)(ptr) = AppSpecSpecJobImage{}
			}
		} else {
			*(*AppSpecSpecJobImage)(ptr) = AppSpecSpecJobImage{}
		}
	default:
		iter.ReportError("decode AppSpecSpecJobImage", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AppSpecSpecServiceGitCodec struct {
}

func (AppSpecSpecServiceGitCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AppSpecSpecServiceGit)(ptr) == nil
}

func (AppSpecSpecServiceGitCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AppSpecSpecServiceGit)(ptr)
	var objs []AppSpecSpecServiceGit
	if obj != nil {
		objs = []AppSpecSpecServiceGit{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecServiceGit{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AppSpecSpecServiceGitCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AppSpecSpecServiceGit)(ptr) = AppSpecSpecServiceGit{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AppSpecSpecServiceGit

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecServiceGit{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AppSpecSpecServiceGit)(ptr) = objs[0]
			} else {
				*(*AppSpecSpecServiceGit)(ptr) = AppSpecSpecServiceGit{}
			}
		} else {
			*(*AppSpecSpecServiceGit)(ptr) = AppSpecSpecServiceGit{}
		}
	default:
		iter.ReportError("decode AppSpecSpecServiceGit", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AppSpecSpecServiceGithubCodec struct {
}

func (AppSpecSpecServiceGithubCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AppSpecSpecServiceGithub)(ptr) == nil
}

func (AppSpecSpecServiceGithubCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AppSpecSpecServiceGithub)(ptr)
	var objs []AppSpecSpecServiceGithub
	if obj != nil {
		objs = []AppSpecSpecServiceGithub{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecServiceGithub{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AppSpecSpecServiceGithubCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AppSpecSpecServiceGithub)(ptr) = AppSpecSpecServiceGithub{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AppSpecSpecServiceGithub

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecServiceGithub{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AppSpecSpecServiceGithub)(ptr) = objs[0]
			} else {
				*(*AppSpecSpecServiceGithub)(ptr) = AppSpecSpecServiceGithub{}
			}
		} else {
			*(*AppSpecSpecServiceGithub)(ptr) = AppSpecSpecServiceGithub{}
		}
	default:
		iter.ReportError("decode AppSpecSpecServiceGithub", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AppSpecSpecServiceGitlabCodec struct {
}

func (AppSpecSpecServiceGitlabCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AppSpecSpecServiceGitlab)(ptr) == nil
}

func (AppSpecSpecServiceGitlabCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AppSpecSpecServiceGitlab)(ptr)
	var objs []AppSpecSpecServiceGitlab
	if obj != nil {
		objs = []AppSpecSpecServiceGitlab{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecServiceGitlab{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AppSpecSpecServiceGitlabCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AppSpecSpecServiceGitlab)(ptr) = AppSpecSpecServiceGitlab{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AppSpecSpecServiceGitlab

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecServiceGitlab{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AppSpecSpecServiceGitlab)(ptr) = objs[0]
			} else {
				*(*AppSpecSpecServiceGitlab)(ptr) = AppSpecSpecServiceGitlab{}
			}
		} else {
			*(*AppSpecSpecServiceGitlab)(ptr) = AppSpecSpecServiceGitlab{}
		}
	default:
		iter.ReportError("decode AppSpecSpecServiceGitlab", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AppSpecSpecServiceHealthCheckCodec struct {
}

func (AppSpecSpecServiceHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AppSpecSpecServiceHealthCheck)(ptr) == nil
}

func (AppSpecSpecServiceHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AppSpecSpecServiceHealthCheck)(ptr)
	var objs []AppSpecSpecServiceHealthCheck
	if obj != nil {
		objs = []AppSpecSpecServiceHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecServiceHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AppSpecSpecServiceHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AppSpecSpecServiceHealthCheck)(ptr) = AppSpecSpecServiceHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AppSpecSpecServiceHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecServiceHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AppSpecSpecServiceHealthCheck)(ptr) = objs[0]
			} else {
				*(*AppSpecSpecServiceHealthCheck)(ptr) = AppSpecSpecServiceHealthCheck{}
			}
		} else {
			*(*AppSpecSpecServiceHealthCheck)(ptr) = AppSpecSpecServiceHealthCheck{}
		}
	default:
		iter.ReportError("decode AppSpecSpecServiceHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AppSpecSpecServiceImageCodec struct {
}

func (AppSpecSpecServiceImageCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AppSpecSpecServiceImage)(ptr) == nil
}

func (AppSpecSpecServiceImageCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AppSpecSpecServiceImage)(ptr)
	var objs []AppSpecSpecServiceImage
	if obj != nil {
		objs = []AppSpecSpecServiceImage{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecServiceImage{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AppSpecSpecServiceImageCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AppSpecSpecServiceImage)(ptr) = AppSpecSpecServiceImage{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AppSpecSpecServiceImage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecServiceImage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AppSpecSpecServiceImage)(ptr) = objs[0]
			} else {
				*(*AppSpecSpecServiceImage)(ptr) = AppSpecSpecServiceImage{}
			}
		} else {
			*(*AppSpecSpecServiceImage)(ptr) = AppSpecSpecServiceImage{}
		}
	default:
		iter.ReportError("decode AppSpecSpecServiceImage", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AppSpecSpecStaticSiteGitCodec struct {
}

func (AppSpecSpecStaticSiteGitCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AppSpecSpecStaticSiteGit)(ptr) == nil
}

func (AppSpecSpecStaticSiteGitCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AppSpecSpecStaticSiteGit)(ptr)
	var objs []AppSpecSpecStaticSiteGit
	if obj != nil {
		objs = []AppSpecSpecStaticSiteGit{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecStaticSiteGit{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AppSpecSpecStaticSiteGitCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AppSpecSpecStaticSiteGit)(ptr) = AppSpecSpecStaticSiteGit{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AppSpecSpecStaticSiteGit

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecStaticSiteGit{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AppSpecSpecStaticSiteGit)(ptr) = objs[0]
			} else {
				*(*AppSpecSpecStaticSiteGit)(ptr) = AppSpecSpecStaticSiteGit{}
			}
		} else {
			*(*AppSpecSpecStaticSiteGit)(ptr) = AppSpecSpecStaticSiteGit{}
		}
	default:
		iter.ReportError("decode AppSpecSpecStaticSiteGit", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AppSpecSpecStaticSiteGithubCodec struct {
}

func (AppSpecSpecStaticSiteGithubCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AppSpecSpecStaticSiteGithub)(ptr) == nil
}

func (AppSpecSpecStaticSiteGithubCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AppSpecSpecStaticSiteGithub)(ptr)
	var objs []AppSpecSpecStaticSiteGithub
	if obj != nil {
		objs = []AppSpecSpecStaticSiteGithub{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecStaticSiteGithub{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AppSpecSpecStaticSiteGithubCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AppSpecSpecStaticSiteGithub)(ptr) = AppSpecSpecStaticSiteGithub{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AppSpecSpecStaticSiteGithub

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecStaticSiteGithub{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AppSpecSpecStaticSiteGithub)(ptr) = objs[0]
			} else {
				*(*AppSpecSpecStaticSiteGithub)(ptr) = AppSpecSpecStaticSiteGithub{}
			}
		} else {
			*(*AppSpecSpecStaticSiteGithub)(ptr) = AppSpecSpecStaticSiteGithub{}
		}
	default:
		iter.ReportError("decode AppSpecSpecStaticSiteGithub", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AppSpecSpecStaticSiteGitlabCodec struct {
}

func (AppSpecSpecStaticSiteGitlabCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AppSpecSpecStaticSiteGitlab)(ptr) == nil
}

func (AppSpecSpecStaticSiteGitlabCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AppSpecSpecStaticSiteGitlab)(ptr)
	var objs []AppSpecSpecStaticSiteGitlab
	if obj != nil {
		objs = []AppSpecSpecStaticSiteGitlab{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecStaticSiteGitlab{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AppSpecSpecStaticSiteGitlabCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AppSpecSpecStaticSiteGitlab)(ptr) = AppSpecSpecStaticSiteGitlab{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AppSpecSpecStaticSiteGitlab

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecStaticSiteGitlab{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AppSpecSpecStaticSiteGitlab)(ptr) = objs[0]
			} else {
				*(*AppSpecSpecStaticSiteGitlab)(ptr) = AppSpecSpecStaticSiteGitlab{}
			}
		} else {
			*(*AppSpecSpecStaticSiteGitlab)(ptr) = AppSpecSpecStaticSiteGitlab{}
		}
	default:
		iter.ReportError("decode AppSpecSpecStaticSiteGitlab", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AppSpecSpecWorkerGitCodec struct {
}

func (AppSpecSpecWorkerGitCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AppSpecSpecWorkerGit)(ptr) == nil
}

func (AppSpecSpecWorkerGitCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AppSpecSpecWorkerGit)(ptr)
	var objs []AppSpecSpecWorkerGit
	if obj != nil {
		objs = []AppSpecSpecWorkerGit{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecWorkerGit{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AppSpecSpecWorkerGitCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AppSpecSpecWorkerGit)(ptr) = AppSpecSpecWorkerGit{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AppSpecSpecWorkerGit

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecWorkerGit{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AppSpecSpecWorkerGit)(ptr) = objs[0]
			} else {
				*(*AppSpecSpecWorkerGit)(ptr) = AppSpecSpecWorkerGit{}
			}
		} else {
			*(*AppSpecSpecWorkerGit)(ptr) = AppSpecSpecWorkerGit{}
		}
	default:
		iter.ReportError("decode AppSpecSpecWorkerGit", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AppSpecSpecWorkerGithubCodec struct {
}

func (AppSpecSpecWorkerGithubCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AppSpecSpecWorkerGithub)(ptr) == nil
}

func (AppSpecSpecWorkerGithubCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AppSpecSpecWorkerGithub)(ptr)
	var objs []AppSpecSpecWorkerGithub
	if obj != nil {
		objs = []AppSpecSpecWorkerGithub{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecWorkerGithub{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AppSpecSpecWorkerGithubCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AppSpecSpecWorkerGithub)(ptr) = AppSpecSpecWorkerGithub{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AppSpecSpecWorkerGithub

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecWorkerGithub{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AppSpecSpecWorkerGithub)(ptr) = objs[0]
			} else {
				*(*AppSpecSpecWorkerGithub)(ptr) = AppSpecSpecWorkerGithub{}
			}
		} else {
			*(*AppSpecSpecWorkerGithub)(ptr) = AppSpecSpecWorkerGithub{}
		}
	default:
		iter.ReportError("decode AppSpecSpecWorkerGithub", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AppSpecSpecWorkerGitlabCodec struct {
}

func (AppSpecSpecWorkerGitlabCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AppSpecSpecWorkerGitlab)(ptr) == nil
}

func (AppSpecSpecWorkerGitlabCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AppSpecSpecWorkerGitlab)(ptr)
	var objs []AppSpecSpecWorkerGitlab
	if obj != nil {
		objs = []AppSpecSpecWorkerGitlab{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecWorkerGitlab{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AppSpecSpecWorkerGitlabCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AppSpecSpecWorkerGitlab)(ptr) = AppSpecSpecWorkerGitlab{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AppSpecSpecWorkerGitlab

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecWorkerGitlab{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AppSpecSpecWorkerGitlab)(ptr) = objs[0]
			} else {
				*(*AppSpecSpecWorkerGitlab)(ptr) = AppSpecSpecWorkerGitlab{}
			}
		} else {
			*(*AppSpecSpecWorkerGitlab)(ptr) = AppSpecSpecWorkerGitlab{}
		}
	default:
		iter.ReportError("decode AppSpecSpecWorkerGitlab", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AppSpecSpecWorkerImageCodec struct {
}

func (AppSpecSpecWorkerImageCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AppSpecSpecWorkerImage)(ptr) == nil
}

func (AppSpecSpecWorkerImageCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AppSpecSpecWorkerImage)(ptr)
	var objs []AppSpecSpecWorkerImage
	if obj != nil {
		objs = []AppSpecSpecWorkerImage{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecWorkerImage{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AppSpecSpecWorkerImageCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AppSpecSpecWorkerImage)(ptr) = AppSpecSpecWorkerImage{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AppSpecSpecWorkerImage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppSpecSpecWorkerImage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AppSpecSpecWorkerImage)(ptr) = objs[0]
			} else {
				*(*AppSpecSpecWorkerImage)(ptr) = AppSpecSpecWorkerImage{}
			}
		} else {
			*(*AppSpecSpecWorkerImage)(ptr) = AppSpecSpecWorkerImage{}
		}
	default:
		iter.ReportError("decode AppSpecSpecWorkerImage", "unexpected JSON type")
	}
}
