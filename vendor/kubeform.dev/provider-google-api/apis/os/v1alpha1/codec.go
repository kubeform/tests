/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecInstanceFilter{}).Type1()):                                    ConfigPatchDeploymentSpecInstanceFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecOneTimeSchedule{}).Type1()):                                   ConfigPatchDeploymentSpecOneTimeScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfig{}).Type1()):                                       ConfigPatchDeploymentSpecPatchConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigApt{}).Type1()):                                    ConfigPatchDeploymentSpecPatchConfigAptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigGoo{}).Type1()):                                    ConfigPatchDeploymentSpecPatchConfigGooCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPostStep{}).Type1()):                               ConfigPatchDeploymentSpecPatchConfigPostStepCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfig{}).Type1()):            ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigGcsObject{}).Type1()):   ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigGcsObjectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfig{}).Type1()):          ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigGcsObject{}).Type1()): ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigGcsObjectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPreStep{}).Type1()):                                ConfigPatchDeploymentSpecPatchConfigPreStepCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfig{}).Type1()):             ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigGcsObject{}).Type1()):    ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigGcsObjectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfig{}).Type1()):           ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigGcsObject{}).Type1()):  ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigGcsObjectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigWindowsUpdate{}).Type1()):                          ConfigPatchDeploymentSpecPatchConfigWindowsUpdateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigYum{}).Type1()):                                    ConfigPatchDeploymentSpecPatchConfigYumCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigZypper{}).Type1()):                                 ConfigPatchDeploymentSpecPatchConfigZypperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringSchedule{}).Type1()):                                 ConfigPatchDeploymentSpecRecurringScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringScheduleMonthly{}).Type1()):                          ConfigPatchDeploymentSpecRecurringScheduleMonthlyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringScheduleMonthlyWeekDayOfMonth{}).Type1()):            ConfigPatchDeploymentSpecRecurringScheduleMonthlyWeekDayOfMonthCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringScheduleTimeOfDay{}).Type1()):                        ConfigPatchDeploymentSpecRecurringScheduleTimeOfDayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringScheduleTimeZone{}).Type1()):                         ConfigPatchDeploymentSpecRecurringScheduleTimeZoneCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringScheduleWeekly{}).Type1()):                           ConfigPatchDeploymentSpecRecurringScheduleWeeklyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRollout{}).Type1()):                                           ConfigPatchDeploymentSpecRolloutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRolloutDisruptionBudget{}).Type1()):                           ConfigPatchDeploymentSpecRolloutDisruptionBudgetCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecInstanceFilter{}).Type1()):                                    ConfigPatchDeploymentSpecInstanceFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecOneTimeSchedule{}).Type1()):                                   ConfigPatchDeploymentSpecOneTimeScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfig{}).Type1()):                                       ConfigPatchDeploymentSpecPatchConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigApt{}).Type1()):                                    ConfigPatchDeploymentSpecPatchConfigAptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigGoo{}).Type1()):                                    ConfigPatchDeploymentSpecPatchConfigGooCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPostStep{}).Type1()):                               ConfigPatchDeploymentSpecPatchConfigPostStepCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfig{}).Type1()):            ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigGcsObject{}).Type1()):   ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigGcsObjectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfig{}).Type1()):          ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigGcsObject{}).Type1()): ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigGcsObjectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPreStep{}).Type1()):                                ConfigPatchDeploymentSpecPatchConfigPreStepCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfig{}).Type1()):             ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigGcsObject{}).Type1()):    ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigGcsObjectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfig{}).Type1()):           ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigGcsObject{}).Type1()):  ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigGcsObjectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigWindowsUpdate{}).Type1()):                          ConfigPatchDeploymentSpecPatchConfigWindowsUpdateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigYum{}).Type1()):                                    ConfigPatchDeploymentSpecPatchConfigYumCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigZypper{}).Type1()):                                 ConfigPatchDeploymentSpecPatchConfigZypperCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringSchedule{}).Type1()):                                 ConfigPatchDeploymentSpecRecurringScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringScheduleMonthly{}).Type1()):                          ConfigPatchDeploymentSpecRecurringScheduleMonthlyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringScheduleMonthlyWeekDayOfMonth{}).Type1()):            ConfigPatchDeploymentSpecRecurringScheduleMonthlyWeekDayOfMonthCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringScheduleTimeOfDay{}).Type1()):                        ConfigPatchDeploymentSpecRecurringScheduleTimeOfDayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringScheduleTimeZone{}).Type1()):                         ConfigPatchDeploymentSpecRecurringScheduleTimeZoneCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringScheduleWeekly{}).Type1()):                           ConfigPatchDeploymentSpecRecurringScheduleWeeklyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRollout{}).Type1()):                                           ConfigPatchDeploymentSpecRolloutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRolloutDisruptionBudget{}).Type1()):                           ConfigPatchDeploymentSpecRolloutDisruptionBudgetCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecInstanceFilterCodec struct {
}

func (ConfigPatchDeploymentSpecInstanceFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecInstanceFilter)(ptr) == nil
}

func (ConfigPatchDeploymentSpecInstanceFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecInstanceFilter)(ptr)
	var objs []ConfigPatchDeploymentSpecInstanceFilter
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecInstanceFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecInstanceFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecInstanceFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecInstanceFilter)(ptr) = ConfigPatchDeploymentSpecInstanceFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecInstanceFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecInstanceFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecInstanceFilter)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecInstanceFilter)(ptr) = ConfigPatchDeploymentSpecInstanceFilter{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecInstanceFilter)(ptr) = ConfigPatchDeploymentSpecInstanceFilter{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecInstanceFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecOneTimeScheduleCodec struct {
}

func (ConfigPatchDeploymentSpecOneTimeScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecOneTimeSchedule)(ptr) == nil
}

func (ConfigPatchDeploymentSpecOneTimeScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecOneTimeSchedule)(ptr)
	var objs []ConfigPatchDeploymentSpecOneTimeSchedule
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecOneTimeSchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecOneTimeSchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecOneTimeScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecOneTimeSchedule)(ptr) = ConfigPatchDeploymentSpecOneTimeSchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecOneTimeSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecOneTimeSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecOneTimeSchedule)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecOneTimeSchedule)(ptr) = ConfigPatchDeploymentSpecOneTimeSchedule{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecOneTimeSchedule)(ptr) = ConfigPatchDeploymentSpecOneTimeSchedule{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecOneTimeSchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecPatchConfigCodec struct {
}

func (ConfigPatchDeploymentSpecPatchConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecPatchConfig)(ptr) == nil
}

func (ConfigPatchDeploymentSpecPatchConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecPatchConfig)(ptr)
	var objs []ConfigPatchDeploymentSpecPatchConfig
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecPatchConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecPatchConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecPatchConfig)(ptr) = ConfigPatchDeploymentSpecPatchConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecPatchConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecPatchConfig)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecPatchConfig)(ptr) = ConfigPatchDeploymentSpecPatchConfig{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecPatchConfig)(ptr) = ConfigPatchDeploymentSpecPatchConfig{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecPatchConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecPatchConfigAptCodec struct {
}

func (ConfigPatchDeploymentSpecPatchConfigAptCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecPatchConfigApt)(ptr) == nil
}

func (ConfigPatchDeploymentSpecPatchConfigAptCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecPatchConfigApt)(ptr)
	var objs []ConfigPatchDeploymentSpecPatchConfigApt
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecPatchConfigApt{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigApt{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecPatchConfigAptCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecPatchConfigApt)(ptr) = ConfigPatchDeploymentSpecPatchConfigApt{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecPatchConfigApt

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigApt{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecPatchConfigApt)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecPatchConfigApt)(ptr) = ConfigPatchDeploymentSpecPatchConfigApt{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecPatchConfigApt)(ptr) = ConfigPatchDeploymentSpecPatchConfigApt{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecPatchConfigApt", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecPatchConfigGooCodec struct {
}

func (ConfigPatchDeploymentSpecPatchConfigGooCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecPatchConfigGoo)(ptr) == nil
}

func (ConfigPatchDeploymentSpecPatchConfigGooCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecPatchConfigGoo)(ptr)
	var objs []ConfigPatchDeploymentSpecPatchConfigGoo
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecPatchConfigGoo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigGoo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecPatchConfigGooCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecPatchConfigGoo)(ptr) = ConfigPatchDeploymentSpecPatchConfigGoo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecPatchConfigGoo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigGoo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecPatchConfigGoo)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecPatchConfigGoo)(ptr) = ConfigPatchDeploymentSpecPatchConfigGoo{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecPatchConfigGoo)(ptr) = ConfigPatchDeploymentSpecPatchConfigGoo{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecPatchConfigGoo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecPatchConfigPostStepCodec struct {
}

func (ConfigPatchDeploymentSpecPatchConfigPostStepCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecPatchConfigPostStep)(ptr) == nil
}

func (ConfigPatchDeploymentSpecPatchConfigPostStepCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecPatchConfigPostStep)(ptr)
	var objs []ConfigPatchDeploymentSpecPatchConfigPostStep
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecPatchConfigPostStep{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPostStep{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecPatchConfigPostStepCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecPatchConfigPostStep)(ptr) = ConfigPatchDeploymentSpecPatchConfigPostStep{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecPatchConfigPostStep

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPostStep{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecPatchConfigPostStep)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecPatchConfigPostStep)(ptr) = ConfigPatchDeploymentSpecPatchConfigPostStep{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecPatchConfigPostStep)(ptr) = ConfigPatchDeploymentSpecPatchConfigPostStep{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecPatchConfigPostStep", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigCodec struct {
}

func (ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfig)(ptr) == nil
}

func (ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfig)(ptr)
	var objs []ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfig
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfig)(ptr) = ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfig)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfig)(ptr) = ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfig{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfig)(ptr) = ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfig{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigGcsObjectCodec struct {
}

func (ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigGcsObjectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigGcsObject)(ptr) == nil
}

func (ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigGcsObjectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigGcsObject)(ptr)
	var objs []ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigGcsObject
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigGcsObject{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigGcsObject{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigGcsObjectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigGcsObject)(ptr) = ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigGcsObject{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigGcsObject

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigGcsObject{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigGcsObject)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigGcsObject)(ptr) = ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigGcsObject{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigGcsObject)(ptr) = ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigGcsObject{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecPatchConfigPostStepLinuxExecStepConfigGcsObject", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigCodec struct {
}

func (ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfig)(ptr) == nil
}

func (ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfig)(ptr)
	var objs []ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfig
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfig)(ptr) = ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfig)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfig)(ptr) = ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfig{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfig)(ptr) = ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfig{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigGcsObjectCodec struct {
}

func (ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigGcsObjectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigGcsObject)(ptr) == nil
}

func (ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigGcsObjectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigGcsObject)(ptr)
	var objs []ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigGcsObject
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigGcsObject{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigGcsObject{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigGcsObjectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigGcsObject)(ptr) = ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigGcsObject{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigGcsObject

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigGcsObject{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigGcsObject)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigGcsObject)(ptr) = ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigGcsObject{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigGcsObject)(ptr) = ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigGcsObject{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecPatchConfigPostStepWindowsExecStepConfigGcsObject", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecPatchConfigPreStepCodec struct {
}

func (ConfigPatchDeploymentSpecPatchConfigPreStepCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecPatchConfigPreStep)(ptr) == nil
}

func (ConfigPatchDeploymentSpecPatchConfigPreStepCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecPatchConfigPreStep)(ptr)
	var objs []ConfigPatchDeploymentSpecPatchConfigPreStep
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecPatchConfigPreStep{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPreStep{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecPatchConfigPreStepCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecPatchConfigPreStep)(ptr) = ConfigPatchDeploymentSpecPatchConfigPreStep{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecPatchConfigPreStep

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPreStep{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecPatchConfigPreStep)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecPatchConfigPreStep)(ptr) = ConfigPatchDeploymentSpecPatchConfigPreStep{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecPatchConfigPreStep)(ptr) = ConfigPatchDeploymentSpecPatchConfigPreStep{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecPatchConfigPreStep", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigCodec struct {
}

func (ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfig)(ptr) == nil
}

func (ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfig)(ptr)
	var objs []ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfig
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfig)(ptr) = ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfig)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfig)(ptr) = ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfig{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfig)(ptr) = ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfig{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigGcsObjectCodec struct {
}

func (ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigGcsObjectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigGcsObject)(ptr) == nil
}

func (ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigGcsObjectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigGcsObject)(ptr)
	var objs []ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigGcsObject
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigGcsObject{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigGcsObject{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigGcsObjectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigGcsObject)(ptr) = ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigGcsObject{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigGcsObject

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigGcsObject{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigGcsObject)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigGcsObject)(ptr) = ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigGcsObject{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigGcsObject)(ptr) = ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigGcsObject{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecPatchConfigPreStepLinuxExecStepConfigGcsObject", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigCodec struct {
}

func (ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfig)(ptr) == nil
}

func (ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfig)(ptr)
	var objs []ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfig
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfig)(ptr) = ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfig)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfig)(ptr) = ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfig{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfig)(ptr) = ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfig{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigGcsObjectCodec struct {
}

func (ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigGcsObjectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigGcsObject)(ptr) == nil
}

func (ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigGcsObjectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigGcsObject)(ptr)
	var objs []ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigGcsObject
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigGcsObject{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigGcsObject{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigGcsObjectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigGcsObject)(ptr) = ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigGcsObject{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigGcsObject

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigGcsObject{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigGcsObject)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigGcsObject)(ptr) = ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigGcsObject{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigGcsObject)(ptr) = ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigGcsObject{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecPatchConfigPreStepWindowsExecStepConfigGcsObject", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecPatchConfigWindowsUpdateCodec struct {
}

func (ConfigPatchDeploymentSpecPatchConfigWindowsUpdateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecPatchConfigWindowsUpdate)(ptr) == nil
}

func (ConfigPatchDeploymentSpecPatchConfigWindowsUpdateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecPatchConfigWindowsUpdate)(ptr)
	var objs []ConfigPatchDeploymentSpecPatchConfigWindowsUpdate
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecPatchConfigWindowsUpdate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigWindowsUpdate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecPatchConfigWindowsUpdateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecPatchConfigWindowsUpdate)(ptr) = ConfigPatchDeploymentSpecPatchConfigWindowsUpdate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecPatchConfigWindowsUpdate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigWindowsUpdate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecPatchConfigWindowsUpdate)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecPatchConfigWindowsUpdate)(ptr) = ConfigPatchDeploymentSpecPatchConfigWindowsUpdate{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecPatchConfigWindowsUpdate)(ptr) = ConfigPatchDeploymentSpecPatchConfigWindowsUpdate{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecPatchConfigWindowsUpdate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecPatchConfigYumCodec struct {
}

func (ConfigPatchDeploymentSpecPatchConfigYumCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecPatchConfigYum)(ptr) == nil
}

func (ConfigPatchDeploymentSpecPatchConfigYumCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecPatchConfigYum)(ptr)
	var objs []ConfigPatchDeploymentSpecPatchConfigYum
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecPatchConfigYum{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigYum{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecPatchConfigYumCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecPatchConfigYum)(ptr) = ConfigPatchDeploymentSpecPatchConfigYum{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecPatchConfigYum

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigYum{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecPatchConfigYum)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecPatchConfigYum)(ptr) = ConfigPatchDeploymentSpecPatchConfigYum{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecPatchConfigYum)(ptr) = ConfigPatchDeploymentSpecPatchConfigYum{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecPatchConfigYum", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecPatchConfigZypperCodec struct {
}

func (ConfigPatchDeploymentSpecPatchConfigZypperCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecPatchConfigZypper)(ptr) == nil
}

func (ConfigPatchDeploymentSpecPatchConfigZypperCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecPatchConfigZypper)(ptr)
	var objs []ConfigPatchDeploymentSpecPatchConfigZypper
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecPatchConfigZypper{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigZypper{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecPatchConfigZypperCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecPatchConfigZypper)(ptr) = ConfigPatchDeploymentSpecPatchConfigZypper{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecPatchConfigZypper

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecPatchConfigZypper{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecPatchConfigZypper)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecPatchConfigZypper)(ptr) = ConfigPatchDeploymentSpecPatchConfigZypper{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecPatchConfigZypper)(ptr) = ConfigPatchDeploymentSpecPatchConfigZypper{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecPatchConfigZypper", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecRecurringScheduleCodec struct {
}

func (ConfigPatchDeploymentSpecRecurringScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecRecurringSchedule)(ptr) == nil
}

func (ConfigPatchDeploymentSpecRecurringScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecRecurringSchedule)(ptr)
	var objs []ConfigPatchDeploymentSpecRecurringSchedule
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecRecurringSchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringSchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecRecurringScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecRecurringSchedule)(ptr) = ConfigPatchDeploymentSpecRecurringSchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecRecurringSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecRecurringSchedule)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecRecurringSchedule)(ptr) = ConfigPatchDeploymentSpecRecurringSchedule{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecRecurringSchedule)(ptr) = ConfigPatchDeploymentSpecRecurringSchedule{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecRecurringSchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecRecurringScheduleMonthlyCodec struct {
}

func (ConfigPatchDeploymentSpecRecurringScheduleMonthlyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecRecurringScheduleMonthly)(ptr) == nil
}

func (ConfigPatchDeploymentSpecRecurringScheduleMonthlyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecRecurringScheduleMonthly)(ptr)
	var objs []ConfigPatchDeploymentSpecRecurringScheduleMonthly
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecRecurringScheduleMonthly{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringScheduleMonthly{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecRecurringScheduleMonthlyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecRecurringScheduleMonthly)(ptr) = ConfigPatchDeploymentSpecRecurringScheduleMonthly{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecRecurringScheduleMonthly

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringScheduleMonthly{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecRecurringScheduleMonthly)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecRecurringScheduleMonthly)(ptr) = ConfigPatchDeploymentSpecRecurringScheduleMonthly{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecRecurringScheduleMonthly)(ptr) = ConfigPatchDeploymentSpecRecurringScheduleMonthly{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecRecurringScheduleMonthly", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecRecurringScheduleMonthlyWeekDayOfMonthCodec struct {
}

func (ConfigPatchDeploymentSpecRecurringScheduleMonthlyWeekDayOfMonthCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecRecurringScheduleMonthlyWeekDayOfMonth)(ptr) == nil
}

func (ConfigPatchDeploymentSpecRecurringScheduleMonthlyWeekDayOfMonthCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecRecurringScheduleMonthlyWeekDayOfMonth)(ptr)
	var objs []ConfigPatchDeploymentSpecRecurringScheduleMonthlyWeekDayOfMonth
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecRecurringScheduleMonthlyWeekDayOfMonth{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringScheduleMonthlyWeekDayOfMonth{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecRecurringScheduleMonthlyWeekDayOfMonthCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecRecurringScheduleMonthlyWeekDayOfMonth)(ptr) = ConfigPatchDeploymentSpecRecurringScheduleMonthlyWeekDayOfMonth{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecRecurringScheduleMonthlyWeekDayOfMonth

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringScheduleMonthlyWeekDayOfMonth{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecRecurringScheduleMonthlyWeekDayOfMonth)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecRecurringScheduleMonthlyWeekDayOfMonth)(ptr) = ConfigPatchDeploymentSpecRecurringScheduleMonthlyWeekDayOfMonth{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecRecurringScheduleMonthlyWeekDayOfMonth)(ptr) = ConfigPatchDeploymentSpecRecurringScheduleMonthlyWeekDayOfMonth{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecRecurringScheduleMonthlyWeekDayOfMonth", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecRecurringScheduleTimeOfDayCodec struct {
}

func (ConfigPatchDeploymentSpecRecurringScheduleTimeOfDayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecRecurringScheduleTimeOfDay)(ptr) == nil
}

func (ConfigPatchDeploymentSpecRecurringScheduleTimeOfDayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecRecurringScheduleTimeOfDay)(ptr)
	var objs []ConfigPatchDeploymentSpecRecurringScheduleTimeOfDay
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecRecurringScheduleTimeOfDay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringScheduleTimeOfDay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecRecurringScheduleTimeOfDayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecRecurringScheduleTimeOfDay)(ptr) = ConfigPatchDeploymentSpecRecurringScheduleTimeOfDay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecRecurringScheduleTimeOfDay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringScheduleTimeOfDay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecRecurringScheduleTimeOfDay)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecRecurringScheduleTimeOfDay)(ptr) = ConfigPatchDeploymentSpecRecurringScheduleTimeOfDay{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecRecurringScheduleTimeOfDay)(ptr) = ConfigPatchDeploymentSpecRecurringScheduleTimeOfDay{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecRecurringScheduleTimeOfDay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecRecurringScheduleTimeZoneCodec struct {
}

func (ConfigPatchDeploymentSpecRecurringScheduleTimeZoneCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecRecurringScheduleTimeZone)(ptr) == nil
}

func (ConfigPatchDeploymentSpecRecurringScheduleTimeZoneCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecRecurringScheduleTimeZone)(ptr)
	var objs []ConfigPatchDeploymentSpecRecurringScheduleTimeZone
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecRecurringScheduleTimeZone{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringScheduleTimeZone{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecRecurringScheduleTimeZoneCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecRecurringScheduleTimeZone)(ptr) = ConfigPatchDeploymentSpecRecurringScheduleTimeZone{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecRecurringScheduleTimeZone

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringScheduleTimeZone{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecRecurringScheduleTimeZone)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecRecurringScheduleTimeZone)(ptr) = ConfigPatchDeploymentSpecRecurringScheduleTimeZone{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecRecurringScheduleTimeZone)(ptr) = ConfigPatchDeploymentSpecRecurringScheduleTimeZone{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecRecurringScheduleTimeZone", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecRecurringScheduleWeeklyCodec struct {
}

func (ConfigPatchDeploymentSpecRecurringScheduleWeeklyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecRecurringScheduleWeekly)(ptr) == nil
}

func (ConfigPatchDeploymentSpecRecurringScheduleWeeklyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecRecurringScheduleWeekly)(ptr)
	var objs []ConfigPatchDeploymentSpecRecurringScheduleWeekly
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecRecurringScheduleWeekly{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringScheduleWeekly{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecRecurringScheduleWeeklyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecRecurringScheduleWeekly)(ptr) = ConfigPatchDeploymentSpecRecurringScheduleWeekly{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecRecurringScheduleWeekly

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRecurringScheduleWeekly{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecRecurringScheduleWeekly)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecRecurringScheduleWeekly)(ptr) = ConfigPatchDeploymentSpecRecurringScheduleWeekly{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecRecurringScheduleWeekly)(ptr) = ConfigPatchDeploymentSpecRecurringScheduleWeekly{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecRecurringScheduleWeekly", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecRolloutCodec struct {
}

func (ConfigPatchDeploymentSpecRolloutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecRollout)(ptr) == nil
}

func (ConfigPatchDeploymentSpecRolloutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecRollout)(ptr)
	var objs []ConfigPatchDeploymentSpecRollout
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecRollout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRollout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecRolloutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecRollout)(ptr) = ConfigPatchDeploymentSpecRollout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecRollout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRollout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecRollout)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecRollout)(ptr) = ConfigPatchDeploymentSpecRollout{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecRollout)(ptr) = ConfigPatchDeploymentSpecRollout{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecRollout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigPatchDeploymentSpecRolloutDisruptionBudgetCodec struct {
}

func (ConfigPatchDeploymentSpecRolloutDisruptionBudgetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigPatchDeploymentSpecRolloutDisruptionBudget)(ptr) == nil
}

func (ConfigPatchDeploymentSpecRolloutDisruptionBudgetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigPatchDeploymentSpecRolloutDisruptionBudget)(ptr)
	var objs []ConfigPatchDeploymentSpecRolloutDisruptionBudget
	if obj != nil {
		objs = []ConfigPatchDeploymentSpecRolloutDisruptionBudget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRolloutDisruptionBudget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigPatchDeploymentSpecRolloutDisruptionBudgetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigPatchDeploymentSpecRolloutDisruptionBudget)(ptr) = ConfigPatchDeploymentSpecRolloutDisruptionBudget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigPatchDeploymentSpecRolloutDisruptionBudget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigPatchDeploymentSpecRolloutDisruptionBudget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigPatchDeploymentSpecRolloutDisruptionBudget)(ptr) = objs[0]
			} else {
				*(*ConfigPatchDeploymentSpecRolloutDisruptionBudget)(ptr) = ConfigPatchDeploymentSpecRolloutDisruptionBudget{}
			}
		} else {
			*(*ConfigPatchDeploymentSpecRolloutDisruptionBudget)(ptr) = ConfigPatchDeploymentSpecRolloutDisruptionBudget{}
		}
	default:
		iter.ReportError("decode ConfigPatchDeploymentSpecRolloutDisruptionBudget", "unexpected JSON type")
	}
}
