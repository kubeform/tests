/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecEncryption{}).Type1()):                                   BucketSpecEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecLifecycleRuleAction{}).Type1()):                          BucketSpecLifecycleRuleActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecLifecycleRuleCondition{}).Type1()):                       BucketSpecLifecycleRuleConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecLogging{}).Type1()):                                      BucketSpecLoggingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecRetentionPolicy{}).Type1()):                              BucketSpecRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecVersioning{}).Type1()):                                   BucketSpecVersioningCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecWebsite{}).Type1()):                                      BucketSpecWebsiteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketIamBindingSpecCondition{}).Type1()):                          BucketIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketIamMemberSpecCondition{}).Type1()):                           BucketIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecSchedule{}).Type1()):                                TransferJobSpecScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecScheduleScheduleEndDate{}).Type1()):                 TransferJobSpecScheduleScheduleEndDateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecScheduleScheduleStartDate{}).Type1()):               TransferJobSpecScheduleScheduleStartDateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecScheduleStartTimeOfDay{}).Type1()):                  TransferJobSpecScheduleStartTimeOfDayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpec{}).Type1()):                            TransferJobSpecTransferSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecAwsS3DataSource{}).Type1()):             TransferJobSpecTransferSpecAwsS3DataSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecAwsS3DataSourceAwsAccessKey{}).Type1()): TransferJobSpecTransferSpecAwsS3DataSourceAwsAccessKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecGcsDataSink{}).Type1()):                 TransferJobSpecTransferSpecGcsDataSinkCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecGcsDataSource{}).Type1()):               TransferJobSpecTransferSpecGcsDataSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecHttpDataSource{}).Type1()):              TransferJobSpecTransferSpecHttpDataSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecObjectConditions{}).Type1()):            TransferJobSpecTransferSpecObjectConditionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecTransferOptions{}).Type1()):             TransferJobSpecTransferSpecTransferOptionsCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecEncryption{}).Type1()):                                   BucketSpecEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecLifecycleRuleAction{}).Type1()):                          BucketSpecLifecycleRuleActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecLifecycleRuleCondition{}).Type1()):                       BucketSpecLifecycleRuleConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecLogging{}).Type1()):                                      BucketSpecLoggingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecRetentionPolicy{}).Type1()):                              BucketSpecRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecVersioning{}).Type1()):                                   BucketSpecVersioningCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecWebsite{}).Type1()):                                      BucketSpecWebsiteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketIamBindingSpecCondition{}).Type1()):                          BucketIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketIamMemberSpecCondition{}).Type1()):                           BucketIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecSchedule{}).Type1()):                                TransferJobSpecScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecScheduleScheduleEndDate{}).Type1()):                 TransferJobSpecScheduleScheduleEndDateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecScheduleScheduleStartDate{}).Type1()):               TransferJobSpecScheduleScheduleStartDateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecScheduleStartTimeOfDay{}).Type1()):                  TransferJobSpecScheduleStartTimeOfDayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpec{}).Type1()):                            TransferJobSpecTransferSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecAwsS3DataSource{}).Type1()):             TransferJobSpecTransferSpecAwsS3DataSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecAwsS3DataSourceAwsAccessKey{}).Type1()): TransferJobSpecTransferSpecAwsS3DataSourceAwsAccessKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecGcsDataSink{}).Type1()):                 TransferJobSpecTransferSpecGcsDataSinkCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecGcsDataSource{}).Type1()):               TransferJobSpecTransferSpecGcsDataSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecHttpDataSource{}).Type1()):              TransferJobSpecTransferSpecHttpDataSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecObjectConditions{}).Type1()):            TransferJobSpecTransferSpecObjectConditionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecTransferOptions{}).Type1()):             TransferJobSpecTransferSpecTransferOptionsCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type BucketSpecEncryptionCodec struct {
}

func (BucketSpecEncryptionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecEncryption)(ptr) == nil
}

func (BucketSpecEncryptionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecEncryption)(ptr)
	var objs []BucketSpecEncryption
	if obj != nil {
		objs = []BucketSpecEncryption{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecEncryption{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecEncryptionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecEncryption)(ptr) = BucketSpecEncryption{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecEncryption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecEncryption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecEncryption)(ptr) = objs[0]
			} else {
				*(*BucketSpecEncryption)(ptr) = BucketSpecEncryption{}
			}
		} else {
			*(*BucketSpecEncryption)(ptr) = BucketSpecEncryption{}
		}
	default:
		iter.ReportError("decode BucketSpecEncryption", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketSpecLifecycleRuleActionCodec struct {
}

func (BucketSpecLifecycleRuleActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecLifecycleRuleAction)(ptr) == nil
}

func (BucketSpecLifecycleRuleActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecLifecycleRuleAction)(ptr)
	var objs []BucketSpecLifecycleRuleAction
	if obj != nil {
		objs = []BucketSpecLifecycleRuleAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecLifecycleRuleAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecLifecycleRuleActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecLifecycleRuleAction)(ptr) = BucketSpecLifecycleRuleAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecLifecycleRuleAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecLifecycleRuleAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecLifecycleRuleAction)(ptr) = objs[0]
			} else {
				*(*BucketSpecLifecycleRuleAction)(ptr) = BucketSpecLifecycleRuleAction{}
			}
		} else {
			*(*BucketSpecLifecycleRuleAction)(ptr) = BucketSpecLifecycleRuleAction{}
		}
	default:
		iter.ReportError("decode BucketSpecLifecycleRuleAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketSpecLifecycleRuleConditionCodec struct {
}

func (BucketSpecLifecycleRuleConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecLifecycleRuleCondition)(ptr) == nil
}

func (BucketSpecLifecycleRuleConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecLifecycleRuleCondition)(ptr)
	var objs []BucketSpecLifecycleRuleCondition
	if obj != nil {
		objs = []BucketSpecLifecycleRuleCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecLifecycleRuleCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecLifecycleRuleConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecLifecycleRuleCondition)(ptr) = BucketSpecLifecycleRuleCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecLifecycleRuleCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecLifecycleRuleCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecLifecycleRuleCondition)(ptr) = objs[0]
			} else {
				*(*BucketSpecLifecycleRuleCondition)(ptr) = BucketSpecLifecycleRuleCondition{}
			}
		} else {
			*(*BucketSpecLifecycleRuleCondition)(ptr) = BucketSpecLifecycleRuleCondition{}
		}
	default:
		iter.ReportError("decode BucketSpecLifecycleRuleCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketSpecLoggingCodec struct {
}

func (BucketSpecLoggingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecLogging)(ptr) == nil
}

func (BucketSpecLoggingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecLogging)(ptr)
	var objs []BucketSpecLogging
	if obj != nil {
		objs = []BucketSpecLogging{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecLogging{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecLoggingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecLogging)(ptr) = BucketSpecLogging{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecLogging

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecLogging{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecLogging)(ptr) = objs[0]
			} else {
				*(*BucketSpecLogging)(ptr) = BucketSpecLogging{}
			}
		} else {
			*(*BucketSpecLogging)(ptr) = BucketSpecLogging{}
		}
	default:
		iter.ReportError("decode BucketSpecLogging", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketSpecRetentionPolicyCodec struct {
}

func (BucketSpecRetentionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecRetentionPolicy)(ptr) == nil
}

func (BucketSpecRetentionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecRetentionPolicy)(ptr)
	var objs []BucketSpecRetentionPolicy
	if obj != nil {
		objs = []BucketSpecRetentionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecRetentionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecRetentionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecRetentionPolicy)(ptr) = BucketSpecRetentionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecRetentionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecRetentionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecRetentionPolicy)(ptr) = objs[0]
			} else {
				*(*BucketSpecRetentionPolicy)(ptr) = BucketSpecRetentionPolicy{}
			}
		} else {
			*(*BucketSpecRetentionPolicy)(ptr) = BucketSpecRetentionPolicy{}
		}
	default:
		iter.ReportError("decode BucketSpecRetentionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketSpecVersioningCodec struct {
}

func (BucketSpecVersioningCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecVersioning)(ptr) == nil
}

func (BucketSpecVersioningCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecVersioning)(ptr)
	var objs []BucketSpecVersioning
	if obj != nil {
		objs = []BucketSpecVersioning{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecVersioning{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecVersioningCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecVersioning)(ptr) = BucketSpecVersioning{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecVersioning

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecVersioning{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecVersioning)(ptr) = objs[0]
			} else {
				*(*BucketSpecVersioning)(ptr) = BucketSpecVersioning{}
			}
		} else {
			*(*BucketSpecVersioning)(ptr) = BucketSpecVersioning{}
		}
	default:
		iter.ReportError("decode BucketSpecVersioning", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketSpecWebsiteCodec struct {
}

func (BucketSpecWebsiteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecWebsite)(ptr) == nil
}

func (BucketSpecWebsiteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecWebsite)(ptr)
	var objs []BucketSpecWebsite
	if obj != nil {
		objs = []BucketSpecWebsite{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecWebsite{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecWebsiteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecWebsite)(ptr) = BucketSpecWebsite{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecWebsite

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecWebsite{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecWebsite)(ptr) = objs[0]
			} else {
				*(*BucketSpecWebsite)(ptr) = BucketSpecWebsite{}
			}
		} else {
			*(*BucketSpecWebsite)(ptr) = BucketSpecWebsite{}
		}
	default:
		iter.ReportError("decode BucketSpecWebsite", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketIamBindingSpecConditionCodec struct {
}

func (BucketIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketIamBindingSpecCondition)(ptr) == nil
}

func (BucketIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketIamBindingSpecCondition)(ptr)
	var objs []BucketIamBindingSpecCondition
	if obj != nil {
		objs = []BucketIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketIamBindingSpecCondition)(ptr) = BucketIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*BucketIamBindingSpecCondition)(ptr) = BucketIamBindingSpecCondition{}
			}
		} else {
			*(*BucketIamBindingSpecCondition)(ptr) = BucketIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode BucketIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketIamMemberSpecConditionCodec struct {
}

func (BucketIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketIamMemberSpecCondition)(ptr) == nil
}

func (BucketIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketIamMemberSpecCondition)(ptr)
	var objs []BucketIamMemberSpecCondition
	if obj != nil {
		objs = []BucketIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketIamMemberSpecCondition)(ptr) = BucketIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*BucketIamMemberSpecCondition)(ptr) = BucketIamMemberSpecCondition{}
			}
		} else {
			*(*BucketIamMemberSpecCondition)(ptr) = BucketIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode BucketIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TransferJobSpecScheduleCodec struct {
}

func (TransferJobSpecScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TransferJobSpecSchedule)(ptr) == nil
}

func (TransferJobSpecScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TransferJobSpecSchedule)(ptr)
	var objs []TransferJobSpecSchedule
	if obj != nil {
		objs = []TransferJobSpecSchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecSchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TransferJobSpecScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TransferJobSpecSchedule)(ptr) = TransferJobSpecSchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TransferJobSpecSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TransferJobSpecSchedule)(ptr) = objs[0]
			} else {
				*(*TransferJobSpecSchedule)(ptr) = TransferJobSpecSchedule{}
			}
		} else {
			*(*TransferJobSpecSchedule)(ptr) = TransferJobSpecSchedule{}
		}
	default:
		iter.ReportError("decode TransferJobSpecSchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TransferJobSpecScheduleScheduleEndDateCodec struct {
}

func (TransferJobSpecScheduleScheduleEndDateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TransferJobSpecScheduleScheduleEndDate)(ptr) == nil
}

func (TransferJobSpecScheduleScheduleEndDateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TransferJobSpecScheduleScheduleEndDate)(ptr)
	var objs []TransferJobSpecScheduleScheduleEndDate
	if obj != nil {
		objs = []TransferJobSpecScheduleScheduleEndDate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecScheduleScheduleEndDate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TransferJobSpecScheduleScheduleEndDateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TransferJobSpecScheduleScheduleEndDate)(ptr) = TransferJobSpecScheduleScheduleEndDate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TransferJobSpecScheduleScheduleEndDate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecScheduleScheduleEndDate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TransferJobSpecScheduleScheduleEndDate)(ptr) = objs[0]
			} else {
				*(*TransferJobSpecScheduleScheduleEndDate)(ptr) = TransferJobSpecScheduleScheduleEndDate{}
			}
		} else {
			*(*TransferJobSpecScheduleScheduleEndDate)(ptr) = TransferJobSpecScheduleScheduleEndDate{}
		}
	default:
		iter.ReportError("decode TransferJobSpecScheduleScheduleEndDate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TransferJobSpecScheduleScheduleStartDateCodec struct {
}

func (TransferJobSpecScheduleScheduleStartDateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TransferJobSpecScheduleScheduleStartDate)(ptr) == nil
}

func (TransferJobSpecScheduleScheduleStartDateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TransferJobSpecScheduleScheduleStartDate)(ptr)
	var objs []TransferJobSpecScheduleScheduleStartDate
	if obj != nil {
		objs = []TransferJobSpecScheduleScheduleStartDate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecScheduleScheduleStartDate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TransferJobSpecScheduleScheduleStartDateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TransferJobSpecScheduleScheduleStartDate)(ptr) = TransferJobSpecScheduleScheduleStartDate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TransferJobSpecScheduleScheduleStartDate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecScheduleScheduleStartDate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TransferJobSpecScheduleScheduleStartDate)(ptr) = objs[0]
			} else {
				*(*TransferJobSpecScheduleScheduleStartDate)(ptr) = TransferJobSpecScheduleScheduleStartDate{}
			}
		} else {
			*(*TransferJobSpecScheduleScheduleStartDate)(ptr) = TransferJobSpecScheduleScheduleStartDate{}
		}
	default:
		iter.ReportError("decode TransferJobSpecScheduleScheduleStartDate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TransferJobSpecScheduleStartTimeOfDayCodec struct {
}

func (TransferJobSpecScheduleStartTimeOfDayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TransferJobSpecScheduleStartTimeOfDay)(ptr) == nil
}

func (TransferJobSpecScheduleStartTimeOfDayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TransferJobSpecScheduleStartTimeOfDay)(ptr)
	var objs []TransferJobSpecScheduleStartTimeOfDay
	if obj != nil {
		objs = []TransferJobSpecScheduleStartTimeOfDay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecScheduleStartTimeOfDay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TransferJobSpecScheduleStartTimeOfDayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TransferJobSpecScheduleStartTimeOfDay)(ptr) = TransferJobSpecScheduleStartTimeOfDay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TransferJobSpecScheduleStartTimeOfDay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecScheduleStartTimeOfDay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TransferJobSpecScheduleStartTimeOfDay)(ptr) = objs[0]
			} else {
				*(*TransferJobSpecScheduleStartTimeOfDay)(ptr) = TransferJobSpecScheduleStartTimeOfDay{}
			}
		} else {
			*(*TransferJobSpecScheduleStartTimeOfDay)(ptr) = TransferJobSpecScheduleStartTimeOfDay{}
		}
	default:
		iter.ReportError("decode TransferJobSpecScheduleStartTimeOfDay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TransferJobSpecTransferSpecCodec struct {
}

func (TransferJobSpecTransferSpecCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TransferJobSpecTransferSpec)(ptr) == nil
}

func (TransferJobSpecTransferSpecCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TransferJobSpecTransferSpec)(ptr)
	var objs []TransferJobSpecTransferSpec
	if obj != nil {
		objs = []TransferJobSpecTransferSpec{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpec{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TransferJobSpecTransferSpecCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TransferJobSpecTransferSpec)(ptr) = TransferJobSpecTransferSpec{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TransferJobSpecTransferSpec

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpec{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TransferJobSpecTransferSpec)(ptr) = objs[0]
			} else {
				*(*TransferJobSpecTransferSpec)(ptr) = TransferJobSpecTransferSpec{}
			}
		} else {
			*(*TransferJobSpecTransferSpec)(ptr) = TransferJobSpecTransferSpec{}
		}
	default:
		iter.ReportError("decode TransferJobSpecTransferSpec", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TransferJobSpecTransferSpecAwsS3DataSourceCodec struct {
}

func (TransferJobSpecTransferSpecAwsS3DataSourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TransferJobSpecTransferSpecAwsS3DataSource)(ptr) == nil
}

func (TransferJobSpecTransferSpecAwsS3DataSourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TransferJobSpecTransferSpecAwsS3DataSource)(ptr)
	var objs []TransferJobSpecTransferSpecAwsS3DataSource
	if obj != nil {
		objs = []TransferJobSpecTransferSpecAwsS3DataSource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecAwsS3DataSource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TransferJobSpecTransferSpecAwsS3DataSourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TransferJobSpecTransferSpecAwsS3DataSource)(ptr) = TransferJobSpecTransferSpecAwsS3DataSource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TransferJobSpecTransferSpecAwsS3DataSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecAwsS3DataSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TransferJobSpecTransferSpecAwsS3DataSource)(ptr) = objs[0]
			} else {
				*(*TransferJobSpecTransferSpecAwsS3DataSource)(ptr) = TransferJobSpecTransferSpecAwsS3DataSource{}
			}
		} else {
			*(*TransferJobSpecTransferSpecAwsS3DataSource)(ptr) = TransferJobSpecTransferSpecAwsS3DataSource{}
		}
	default:
		iter.ReportError("decode TransferJobSpecTransferSpecAwsS3DataSource", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TransferJobSpecTransferSpecAwsS3DataSourceAwsAccessKeyCodec struct {
}

func (TransferJobSpecTransferSpecAwsS3DataSourceAwsAccessKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TransferJobSpecTransferSpecAwsS3DataSourceAwsAccessKey)(ptr) == nil
}

func (TransferJobSpecTransferSpecAwsS3DataSourceAwsAccessKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TransferJobSpecTransferSpecAwsS3DataSourceAwsAccessKey)(ptr)
	var objs []TransferJobSpecTransferSpecAwsS3DataSourceAwsAccessKey
	if obj != nil {
		objs = []TransferJobSpecTransferSpecAwsS3DataSourceAwsAccessKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecAwsS3DataSourceAwsAccessKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TransferJobSpecTransferSpecAwsS3DataSourceAwsAccessKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TransferJobSpecTransferSpecAwsS3DataSourceAwsAccessKey)(ptr) = TransferJobSpecTransferSpecAwsS3DataSourceAwsAccessKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TransferJobSpecTransferSpecAwsS3DataSourceAwsAccessKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecAwsS3DataSourceAwsAccessKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TransferJobSpecTransferSpecAwsS3DataSourceAwsAccessKey)(ptr) = objs[0]
			} else {
				*(*TransferJobSpecTransferSpecAwsS3DataSourceAwsAccessKey)(ptr) = TransferJobSpecTransferSpecAwsS3DataSourceAwsAccessKey{}
			}
		} else {
			*(*TransferJobSpecTransferSpecAwsS3DataSourceAwsAccessKey)(ptr) = TransferJobSpecTransferSpecAwsS3DataSourceAwsAccessKey{}
		}
	default:
		iter.ReportError("decode TransferJobSpecTransferSpecAwsS3DataSourceAwsAccessKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TransferJobSpecTransferSpecGcsDataSinkCodec struct {
}

func (TransferJobSpecTransferSpecGcsDataSinkCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TransferJobSpecTransferSpecGcsDataSink)(ptr) == nil
}

func (TransferJobSpecTransferSpecGcsDataSinkCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TransferJobSpecTransferSpecGcsDataSink)(ptr)
	var objs []TransferJobSpecTransferSpecGcsDataSink
	if obj != nil {
		objs = []TransferJobSpecTransferSpecGcsDataSink{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecGcsDataSink{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TransferJobSpecTransferSpecGcsDataSinkCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TransferJobSpecTransferSpecGcsDataSink)(ptr) = TransferJobSpecTransferSpecGcsDataSink{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TransferJobSpecTransferSpecGcsDataSink

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecGcsDataSink{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TransferJobSpecTransferSpecGcsDataSink)(ptr) = objs[0]
			} else {
				*(*TransferJobSpecTransferSpecGcsDataSink)(ptr) = TransferJobSpecTransferSpecGcsDataSink{}
			}
		} else {
			*(*TransferJobSpecTransferSpecGcsDataSink)(ptr) = TransferJobSpecTransferSpecGcsDataSink{}
		}
	default:
		iter.ReportError("decode TransferJobSpecTransferSpecGcsDataSink", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TransferJobSpecTransferSpecGcsDataSourceCodec struct {
}

func (TransferJobSpecTransferSpecGcsDataSourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TransferJobSpecTransferSpecGcsDataSource)(ptr) == nil
}

func (TransferJobSpecTransferSpecGcsDataSourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TransferJobSpecTransferSpecGcsDataSource)(ptr)
	var objs []TransferJobSpecTransferSpecGcsDataSource
	if obj != nil {
		objs = []TransferJobSpecTransferSpecGcsDataSource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecGcsDataSource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TransferJobSpecTransferSpecGcsDataSourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TransferJobSpecTransferSpecGcsDataSource)(ptr) = TransferJobSpecTransferSpecGcsDataSource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TransferJobSpecTransferSpecGcsDataSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecGcsDataSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TransferJobSpecTransferSpecGcsDataSource)(ptr) = objs[0]
			} else {
				*(*TransferJobSpecTransferSpecGcsDataSource)(ptr) = TransferJobSpecTransferSpecGcsDataSource{}
			}
		} else {
			*(*TransferJobSpecTransferSpecGcsDataSource)(ptr) = TransferJobSpecTransferSpecGcsDataSource{}
		}
	default:
		iter.ReportError("decode TransferJobSpecTransferSpecGcsDataSource", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TransferJobSpecTransferSpecHttpDataSourceCodec struct {
}

func (TransferJobSpecTransferSpecHttpDataSourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TransferJobSpecTransferSpecHttpDataSource)(ptr) == nil
}

func (TransferJobSpecTransferSpecHttpDataSourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TransferJobSpecTransferSpecHttpDataSource)(ptr)
	var objs []TransferJobSpecTransferSpecHttpDataSource
	if obj != nil {
		objs = []TransferJobSpecTransferSpecHttpDataSource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecHttpDataSource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TransferJobSpecTransferSpecHttpDataSourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TransferJobSpecTransferSpecHttpDataSource)(ptr) = TransferJobSpecTransferSpecHttpDataSource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TransferJobSpecTransferSpecHttpDataSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecHttpDataSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TransferJobSpecTransferSpecHttpDataSource)(ptr) = objs[0]
			} else {
				*(*TransferJobSpecTransferSpecHttpDataSource)(ptr) = TransferJobSpecTransferSpecHttpDataSource{}
			}
		} else {
			*(*TransferJobSpecTransferSpecHttpDataSource)(ptr) = TransferJobSpecTransferSpecHttpDataSource{}
		}
	default:
		iter.ReportError("decode TransferJobSpecTransferSpecHttpDataSource", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TransferJobSpecTransferSpecObjectConditionsCodec struct {
}

func (TransferJobSpecTransferSpecObjectConditionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TransferJobSpecTransferSpecObjectConditions)(ptr) == nil
}

func (TransferJobSpecTransferSpecObjectConditionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TransferJobSpecTransferSpecObjectConditions)(ptr)
	var objs []TransferJobSpecTransferSpecObjectConditions
	if obj != nil {
		objs = []TransferJobSpecTransferSpecObjectConditions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecObjectConditions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TransferJobSpecTransferSpecObjectConditionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TransferJobSpecTransferSpecObjectConditions)(ptr) = TransferJobSpecTransferSpecObjectConditions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TransferJobSpecTransferSpecObjectConditions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecObjectConditions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TransferJobSpecTransferSpecObjectConditions)(ptr) = objs[0]
			} else {
				*(*TransferJobSpecTransferSpecObjectConditions)(ptr) = TransferJobSpecTransferSpecObjectConditions{}
			}
		} else {
			*(*TransferJobSpecTransferSpecObjectConditions)(ptr) = TransferJobSpecTransferSpecObjectConditions{}
		}
	default:
		iter.ReportError("decode TransferJobSpecTransferSpecObjectConditions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TransferJobSpecTransferSpecTransferOptionsCodec struct {
}

func (TransferJobSpecTransferSpecTransferOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TransferJobSpecTransferSpecTransferOptions)(ptr) == nil
}

func (TransferJobSpecTransferSpecTransferOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TransferJobSpecTransferSpecTransferOptions)(ptr)
	var objs []TransferJobSpecTransferSpecTransferOptions
	if obj != nil {
		objs = []TransferJobSpecTransferSpecTransferOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecTransferOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TransferJobSpecTransferSpecTransferOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TransferJobSpecTransferSpecTransferOptions)(ptr) = TransferJobSpecTransferSpecTransferOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TransferJobSpecTransferSpecTransferOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransferJobSpecTransferSpecTransferOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TransferJobSpecTransferSpecTransferOptions)(ptr) = objs[0]
			} else {
				*(*TransferJobSpecTransferSpecTransferOptions)(ptr) = TransferJobSpecTransferSpecTransferOptions{}
			}
		} else {
			*(*TransferJobSpecTransferSpecTransferOptions)(ptr) = TransferJobSpecTransferSpecTransferOptions{}
		}
	default:
		iter.ReportError("decode TransferJobSpecTransferSpecTransferOptions", "unexpected JSON type")
	}
}
