/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuild{}).Type1()):                    TriggerSpecBuildCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildArtifacts{}).Type1()):           TriggerSpecBuildArtifactsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildArtifactsObjects{}).Type1()):    TriggerSpecBuildArtifactsObjectsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildOptions{}).Type1()):             TriggerSpecBuildOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildSource{}).Type1()):              TriggerSpecBuildSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildSourceRepoSource{}).Type1()):    TriggerSpecBuildSourceRepoSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildSourceStorageSource{}).Type1()): TriggerSpecBuildSourceStorageSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecGithub{}).Type1()):                   TriggerSpecGithubCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecGithubPullRequest{}).Type1()):        TriggerSpecGithubPullRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecGithubPush{}).Type1()):               TriggerSpecGithubPushCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecTriggerTemplate{}).Type1()):          TriggerSpecTriggerTemplateCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuild{}).Type1()):                    TriggerSpecBuildCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildArtifacts{}).Type1()):           TriggerSpecBuildArtifactsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildArtifactsObjects{}).Type1()):    TriggerSpecBuildArtifactsObjectsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildOptions{}).Type1()):             TriggerSpecBuildOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildSource{}).Type1()):              TriggerSpecBuildSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildSourceRepoSource{}).Type1()):    TriggerSpecBuildSourceRepoSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildSourceStorageSource{}).Type1()): TriggerSpecBuildSourceStorageSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecGithub{}).Type1()):                   TriggerSpecGithubCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecGithubPullRequest{}).Type1()):        TriggerSpecGithubPullRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecGithubPush{}).Type1()):               TriggerSpecGithubPushCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecTriggerTemplate{}).Type1()):          TriggerSpecTriggerTemplateCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type TriggerSpecBuildCodec struct {
}

func (TriggerSpecBuildCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TriggerSpecBuild)(ptr) == nil
}

func (TriggerSpecBuildCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TriggerSpecBuild)(ptr)
	var objs []TriggerSpecBuild
	if obj != nil {
		objs = []TriggerSpecBuild{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuild{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TriggerSpecBuildCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TriggerSpecBuild)(ptr) = TriggerSpecBuild{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TriggerSpecBuild

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuild{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TriggerSpecBuild)(ptr) = objs[0]
			} else {
				*(*TriggerSpecBuild)(ptr) = TriggerSpecBuild{}
			}
		} else {
			*(*TriggerSpecBuild)(ptr) = TriggerSpecBuild{}
		}
	default:
		iter.ReportError("decode TriggerSpecBuild", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TriggerSpecBuildArtifactsCodec struct {
}

func (TriggerSpecBuildArtifactsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TriggerSpecBuildArtifacts)(ptr) == nil
}

func (TriggerSpecBuildArtifactsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TriggerSpecBuildArtifacts)(ptr)
	var objs []TriggerSpecBuildArtifacts
	if obj != nil {
		objs = []TriggerSpecBuildArtifacts{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildArtifacts{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TriggerSpecBuildArtifactsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TriggerSpecBuildArtifacts)(ptr) = TriggerSpecBuildArtifacts{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TriggerSpecBuildArtifacts

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildArtifacts{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TriggerSpecBuildArtifacts)(ptr) = objs[0]
			} else {
				*(*TriggerSpecBuildArtifacts)(ptr) = TriggerSpecBuildArtifacts{}
			}
		} else {
			*(*TriggerSpecBuildArtifacts)(ptr) = TriggerSpecBuildArtifacts{}
		}
	default:
		iter.ReportError("decode TriggerSpecBuildArtifacts", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TriggerSpecBuildArtifactsObjectsCodec struct {
}

func (TriggerSpecBuildArtifactsObjectsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TriggerSpecBuildArtifactsObjects)(ptr) == nil
}

func (TriggerSpecBuildArtifactsObjectsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TriggerSpecBuildArtifactsObjects)(ptr)
	var objs []TriggerSpecBuildArtifactsObjects
	if obj != nil {
		objs = []TriggerSpecBuildArtifactsObjects{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildArtifactsObjects{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TriggerSpecBuildArtifactsObjectsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TriggerSpecBuildArtifactsObjects)(ptr) = TriggerSpecBuildArtifactsObjects{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TriggerSpecBuildArtifactsObjects

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildArtifactsObjects{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TriggerSpecBuildArtifactsObjects)(ptr) = objs[0]
			} else {
				*(*TriggerSpecBuildArtifactsObjects)(ptr) = TriggerSpecBuildArtifactsObjects{}
			}
		} else {
			*(*TriggerSpecBuildArtifactsObjects)(ptr) = TriggerSpecBuildArtifactsObjects{}
		}
	default:
		iter.ReportError("decode TriggerSpecBuildArtifactsObjects", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TriggerSpecBuildOptionsCodec struct {
}

func (TriggerSpecBuildOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TriggerSpecBuildOptions)(ptr) == nil
}

func (TriggerSpecBuildOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TriggerSpecBuildOptions)(ptr)
	var objs []TriggerSpecBuildOptions
	if obj != nil {
		objs = []TriggerSpecBuildOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TriggerSpecBuildOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TriggerSpecBuildOptions)(ptr) = TriggerSpecBuildOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TriggerSpecBuildOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TriggerSpecBuildOptions)(ptr) = objs[0]
			} else {
				*(*TriggerSpecBuildOptions)(ptr) = TriggerSpecBuildOptions{}
			}
		} else {
			*(*TriggerSpecBuildOptions)(ptr) = TriggerSpecBuildOptions{}
		}
	default:
		iter.ReportError("decode TriggerSpecBuildOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TriggerSpecBuildSourceCodec struct {
}

func (TriggerSpecBuildSourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TriggerSpecBuildSource)(ptr) == nil
}

func (TriggerSpecBuildSourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TriggerSpecBuildSource)(ptr)
	var objs []TriggerSpecBuildSource
	if obj != nil {
		objs = []TriggerSpecBuildSource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildSource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TriggerSpecBuildSourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TriggerSpecBuildSource)(ptr) = TriggerSpecBuildSource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TriggerSpecBuildSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TriggerSpecBuildSource)(ptr) = objs[0]
			} else {
				*(*TriggerSpecBuildSource)(ptr) = TriggerSpecBuildSource{}
			}
		} else {
			*(*TriggerSpecBuildSource)(ptr) = TriggerSpecBuildSource{}
		}
	default:
		iter.ReportError("decode TriggerSpecBuildSource", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TriggerSpecBuildSourceRepoSourceCodec struct {
}

func (TriggerSpecBuildSourceRepoSourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TriggerSpecBuildSourceRepoSource)(ptr) == nil
}

func (TriggerSpecBuildSourceRepoSourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TriggerSpecBuildSourceRepoSource)(ptr)
	var objs []TriggerSpecBuildSourceRepoSource
	if obj != nil {
		objs = []TriggerSpecBuildSourceRepoSource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildSourceRepoSource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TriggerSpecBuildSourceRepoSourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TriggerSpecBuildSourceRepoSource)(ptr) = TriggerSpecBuildSourceRepoSource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TriggerSpecBuildSourceRepoSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildSourceRepoSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TriggerSpecBuildSourceRepoSource)(ptr) = objs[0]
			} else {
				*(*TriggerSpecBuildSourceRepoSource)(ptr) = TriggerSpecBuildSourceRepoSource{}
			}
		} else {
			*(*TriggerSpecBuildSourceRepoSource)(ptr) = TriggerSpecBuildSourceRepoSource{}
		}
	default:
		iter.ReportError("decode TriggerSpecBuildSourceRepoSource", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TriggerSpecBuildSourceStorageSourceCodec struct {
}

func (TriggerSpecBuildSourceStorageSourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TriggerSpecBuildSourceStorageSource)(ptr) == nil
}

func (TriggerSpecBuildSourceStorageSourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TriggerSpecBuildSourceStorageSource)(ptr)
	var objs []TriggerSpecBuildSourceStorageSource
	if obj != nil {
		objs = []TriggerSpecBuildSourceStorageSource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildSourceStorageSource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TriggerSpecBuildSourceStorageSourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TriggerSpecBuildSourceStorageSource)(ptr) = TriggerSpecBuildSourceStorageSource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TriggerSpecBuildSourceStorageSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecBuildSourceStorageSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TriggerSpecBuildSourceStorageSource)(ptr) = objs[0]
			} else {
				*(*TriggerSpecBuildSourceStorageSource)(ptr) = TriggerSpecBuildSourceStorageSource{}
			}
		} else {
			*(*TriggerSpecBuildSourceStorageSource)(ptr) = TriggerSpecBuildSourceStorageSource{}
		}
	default:
		iter.ReportError("decode TriggerSpecBuildSourceStorageSource", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TriggerSpecGithubCodec struct {
}

func (TriggerSpecGithubCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TriggerSpecGithub)(ptr) == nil
}

func (TriggerSpecGithubCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TriggerSpecGithub)(ptr)
	var objs []TriggerSpecGithub
	if obj != nil {
		objs = []TriggerSpecGithub{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecGithub{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TriggerSpecGithubCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TriggerSpecGithub)(ptr) = TriggerSpecGithub{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TriggerSpecGithub

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecGithub{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TriggerSpecGithub)(ptr) = objs[0]
			} else {
				*(*TriggerSpecGithub)(ptr) = TriggerSpecGithub{}
			}
		} else {
			*(*TriggerSpecGithub)(ptr) = TriggerSpecGithub{}
		}
	default:
		iter.ReportError("decode TriggerSpecGithub", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TriggerSpecGithubPullRequestCodec struct {
}

func (TriggerSpecGithubPullRequestCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TriggerSpecGithubPullRequest)(ptr) == nil
}

func (TriggerSpecGithubPullRequestCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TriggerSpecGithubPullRequest)(ptr)
	var objs []TriggerSpecGithubPullRequest
	if obj != nil {
		objs = []TriggerSpecGithubPullRequest{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecGithubPullRequest{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TriggerSpecGithubPullRequestCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TriggerSpecGithubPullRequest)(ptr) = TriggerSpecGithubPullRequest{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TriggerSpecGithubPullRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecGithubPullRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TriggerSpecGithubPullRequest)(ptr) = objs[0]
			} else {
				*(*TriggerSpecGithubPullRequest)(ptr) = TriggerSpecGithubPullRequest{}
			}
		} else {
			*(*TriggerSpecGithubPullRequest)(ptr) = TriggerSpecGithubPullRequest{}
		}
	default:
		iter.ReportError("decode TriggerSpecGithubPullRequest", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TriggerSpecGithubPushCodec struct {
}

func (TriggerSpecGithubPushCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TriggerSpecGithubPush)(ptr) == nil
}

func (TriggerSpecGithubPushCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TriggerSpecGithubPush)(ptr)
	var objs []TriggerSpecGithubPush
	if obj != nil {
		objs = []TriggerSpecGithubPush{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecGithubPush{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TriggerSpecGithubPushCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TriggerSpecGithubPush)(ptr) = TriggerSpecGithubPush{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TriggerSpecGithubPush

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecGithubPush{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TriggerSpecGithubPush)(ptr) = objs[0]
			} else {
				*(*TriggerSpecGithubPush)(ptr) = TriggerSpecGithubPush{}
			}
		} else {
			*(*TriggerSpecGithubPush)(ptr) = TriggerSpecGithubPush{}
		}
	default:
		iter.ReportError("decode TriggerSpecGithubPush", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TriggerSpecTriggerTemplateCodec struct {
}

func (TriggerSpecTriggerTemplateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TriggerSpecTriggerTemplate)(ptr) == nil
}

func (TriggerSpecTriggerTemplateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TriggerSpecTriggerTemplate)(ptr)
	var objs []TriggerSpecTriggerTemplate
	if obj != nil {
		objs = []TriggerSpecTriggerTemplate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecTriggerTemplate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TriggerSpecTriggerTemplateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TriggerSpecTriggerTemplate)(ptr) = TriggerSpecTriggerTemplate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TriggerSpecTriggerTemplate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecTriggerTemplate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TriggerSpecTriggerTemplate)(ptr) = objs[0]
			} else {
				*(*TriggerSpecTriggerTemplate)(ptr) = TriggerSpecTriggerTemplate{}
			}
		} else {
			*(*TriggerSpecTriggerTemplate)(ptr) = TriggerSpecTriggerTemplate{}
		}
	default:
		iter.ReportError("decode TriggerSpecTriggerTemplate", "unexpected JSON type")
	}
}
