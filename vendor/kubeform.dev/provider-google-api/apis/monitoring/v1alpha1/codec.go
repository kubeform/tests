/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionAbsent{}).Type1()):                                     AlertPolicySpecConditionsConditionAbsentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionAbsentTrigger{}).Type1()):                              AlertPolicySpecConditionsConditionAbsentTriggerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionMonitoringQueryLanguage{}).Type1()):                    AlertPolicySpecConditionsConditionMonitoringQueryLanguageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger{}).Type1()):             AlertPolicySpecConditionsConditionMonitoringQueryLanguageTriggerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionThreshold{}).Type1()):                                  AlertPolicySpecConditionsConditionThresholdCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionThresholdTrigger{}).Type1()):                           AlertPolicySpecConditionsConditionThresholdTriggerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecDocumentation{}).Type1()):                                                 AlertPolicySpecDocumentationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomServiceSpecTelemetry{}).Type1()):                                                   CustomServiceSpecTelemetryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MetricDescriptorSpecMetadata{}).Type1()):                                                 MetricDescriptorSpecMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationChannelSpecSensitiveLabels{}).Type1()):                                       NotificationChannelSpecSensitiveLabelsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecBasicSli{}).Type1()):                                                              SloSpecBasicSliCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecBasicSliAvailability{}).Type1()):                                                  SloSpecBasicSliAvailabilityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecBasicSliLatency{}).Type1()):                                                       SloSpecBasicSliLatencyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecRequestBasedSli{}).Type1()):                                                       SloSpecRequestBasedSliCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecRequestBasedSliDistributionCut{}).Type1()):                                        SloSpecRequestBasedSliDistributionCutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecRequestBasedSliDistributionCutRange{}).Type1()):                                   SloSpecRequestBasedSliDistributionCutRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecRequestBasedSliGoodTotalRatio{}).Type1()):                                         SloSpecRequestBasedSliGoodTotalRatioCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSli{}).Type1()):                                                       SloSpecWindowsBasedSliCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThreshold{}).Type1()):                                SloSpecWindowsBasedSliGoodTotalRatioThresholdCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance{}).Type1()):             SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability{}).Type1()): SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailabilityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency{}).Type1()):      SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatencyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformance{}).Type1()):                     SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut{}).Type1()):      SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange{}).Type1()): SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio{}).Type1()):       SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliMetricMeanInRange{}).Type1()):                                      SloSpecWindowsBasedSliMetricMeanInRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliMetricMeanInRangeRange{}).Type1()):                                 SloSpecWindowsBasedSliMetricMeanInRangeRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliMetricSumInRange{}).Type1()):                                       SloSpecWindowsBasedSliMetricSumInRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliMetricSumInRangeRange{}).Type1()):                                  SloSpecWindowsBasedSliMetricSumInRangeRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UptimeCheckConfigSpecHttpCheck{}).Type1()):                                               UptimeCheckConfigSpecHttpCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UptimeCheckConfigSpecHttpCheckAuthInfo{}).Type1()):                                       UptimeCheckConfigSpecHttpCheckAuthInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UptimeCheckConfigSpecMonitoredResource{}).Type1()):                                       UptimeCheckConfigSpecMonitoredResourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UptimeCheckConfigSpecResourceGroup{}).Type1()):                                           UptimeCheckConfigSpecResourceGroupCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UptimeCheckConfigSpecTcpCheck{}).Type1()):                                                UptimeCheckConfigSpecTcpCheckCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionAbsent{}).Type1()):                                     AlertPolicySpecConditionsConditionAbsentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionAbsentTrigger{}).Type1()):                              AlertPolicySpecConditionsConditionAbsentTriggerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionMonitoringQueryLanguage{}).Type1()):                    AlertPolicySpecConditionsConditionMonitoringQueryLanguageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger{}).Type1()):             AlertPolicySpecConditionsConditionMonitoringQueryLanguageTriggerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionThreshold{}).Type1()):                                  AlertPolicySpecConditionsConditionThresholdCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionThresholdTrigger{}).Type1()):                           AlertPolicySpecConditionsConditionThresholdTriggerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecDocumentation{}).Type1()):                                                 AlertPolicySpecDocumentationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CustomServiceSpecTelemetry{}).Type1()):                                                   CustomServiceSpecTelemetryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MetricDescriptorSpecMetadata{}).Type1()):                                                 MetricDescriptorSpecMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NotificationChannelSpecSensitiveLabels{}).Type1()):                                       NotificationChannelSpecSensitiveLabelsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecBasicSli{}).Type1()):                                                              SloSpecBasicSliCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecBasicSliAvailability{}).Type1()):                                                  SloSpecBasicSliAvailabilityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecBasicSliLatency{}).Type1()):                                                       SloSpecBasicSliLatencyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecRequestBasedSli{}).Type1()):                                                       SloSpecRequestBasedSliCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecRequestBasedSliDistributionCut{}).Type1()):                                        SloSpecRequestBasedSliDistributionCutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecRequestBasedSliDistributionCutRange{}).Type1()):                                   SloSpecRequestBasedSliDistributionCutRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecRequestBasedSliGoodTotalRatio{}).Type1()):                                         SloSpecRequestBasedSliGoodTotalRatioCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSli{}).Type1()):                                                       SloSpecWindowsBasedSliCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThreshold{}).Type1()):                                SloSpecWindowsBasedSliGoodTotalRatioThresholdCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance{}).Type1()):             SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability{}).Type1()): SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailabilityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency{}).Type1()):      SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatencyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformance{}).Type1()):                     SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut{}).Type1()):      SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange{}).Type1()): SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio{}).Type1()):       SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliMetricMeanInRange{}).Type1()):                                      SloSpecWindowsBasedSliMetricMeanInRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliMetricMeanInRangeRange{}).Type1()):                                 SloSpecWindowsBasedSliMetricMeanInRangeRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliMetricSumInRange{}).Type1()):                                       SloSpecWindowsBasedSliMetricSumInRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliMetricSumInRangeRange{}).Type1()):                                  SloSpecWindowsBasedSliMetricSumInRangeRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UptimeCheckConfigSpecHttpCheck{}).Type1()):                                               UptimeCheckConfigSpecHttpCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UptimeCheckConfigSpecHttpCheckAuthInfo{}).Type1()):                                       UptimeCheckConfigSpecHttpCheckAuthInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UptimeCheckConfigSpecMonitoredResource{}).Type1()):                                       UptimeCheckConfigSpecMonitoredResourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UptimeCheckConfigSpecResourceGroup{}).Type1()):                                           UptimeCheckConfigSpecResourceGroupCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UptimeCheckConfigSpecTcpCheck{}).Type1()):                                                UptimeCheckConfigSpecTcpCheckCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AlertPolicySpecConditionsConditionAbsentCodec struct {
}

func (AlertPolicySpecConditionsConditionAbsentCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AlertPolicySpecConditionsConditionAbsent)(ptr) == nil
}

func (AlertPolicySpecConditionsConditionAbsentCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AlertPolicySpecConditionsConditionAbsent)(ptr)
	var objs []AlertPolicySpecConditionsConditionAbsent
	if obj != nil {
		objs = []AlertPolicySpecConditionsConditionAbsent{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionAbsent{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AlertPolicySpecConditionsConditionAbsentCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AlertPolicySpecConditionsConditionAbsent)(ptr) = AlertPolicySpecConditionsConditionAbsent{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AlertPolicySpecConditionsConditionAbsent

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionAbsent{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AlertPolicySpecConditionsConditionAbsent)(ptr) = objs[0]
			} else {
				*(*AlertPolicySpecConditionsConditionAbsent)(ptr) = AlertPolicySpecConditionsConditionAbsent{}
			}
		} else {
			*(*AlertPolicySpecConditionsConditionAbsent)(ptr) = AlertPolicySpecConditionsConditionAbsent{}
		}
	default:
		iter.ReportError("decode AlertPolicySpecConditionsConditionAbsent", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AlertPolicySpecConditionsConditionAbsentTriggerCodec struct {
}

func (AlertPolicySpecConditionsConditionAbsentTriggerCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AlertPolicySpecConditionsConditionAbsentTrigger)(ptr) == nil
}

func (AlertPolicySpecConditionsConditionAbsentTriggerCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AlertPolicySpecConditionsConditionAbsentTrigger)(ptr)
	var objs []AlertPolicySpecConditionsConditionAbsentTrigger
	if obj != nil {
		objs = []AlertPolicySpecConditionsConditionAbsentTrigger{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionAbsentTrigger{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AlertPolicySpecConditionsConditionAbsentTriggerCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AlertPolicySpecConditionsConditionAbsentTrigger)(ptr) = AlertPolicySpecConditionsConditionAbsentTrigger{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AlertPolicySpecConditionsConditionAbsentTrigger

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionAbsentTrigger{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AlertPolicySpecConditionsConditionAbsentTrigger)(ptr) = objs[0]
			} else {
				*(*AlertPolicySpecConditionsConditionAbsentTrigger)(ptr) = AlertPolicySpecConditionsConditionAbsentTrigger{}
			}
		} else {
			*(*AlertPolicySpecConditionsConditionAbsentTrigger)(ptr) = AlertPolicySpecConditionsConditionAbsentTrigger{}
		}
	default:
		iter.ReportError("decode AlertPolicySpecConditionsConditionAbsentTrigger", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AlertPolicySpecConditionsConditionMonitoringQueryLanguageCodec struct {
}

func (AlertPolicySpecConditionsConditionMonitoringQueryLanguageCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AlertPolicySpecConditionsConditionMonitoringQueryLanguage)(ptr) == nil
}

func (AlertPolicySpecConditionsConditionMonitoringQueryLanguageCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AlertPolicySpecConditionsConditionMonitoringQueryLanguage)(ptr)
	var objs []AlertPolicySpecConditionsConditionMonitoringQueryLanguage
	if obj != nil {
		objs = []AlertPolicySpecConditionsConditionMonitoringQueryLanguage{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionMonitoringQueryLanguage{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AlertPolicySpecConditionsConditionMonitoringQueryLanguageCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AlertPolicySpecConditionsConditionMonitoringQueryLanguage)(ptr) = AlertPolicySpecConditionsConditionMonitoringQueryLanguage{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AlertPolicySpecConditionsConditionMonitoringQueryLanguage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionMonitoringQueryLanguage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AlertPolicySpecConditionsConditionMonitoringQueryLanguage)(ptr) = objs[0]
			} else {
				*(*AlertPolicySpecConditionsConditionMonitoringQueryLanguage)(ptr) = AlertPolicySpecConditionsConditionMonitoringQueryLanguage{}
			}
		} else {
			*(*AlertPolicySpecConditionsConditionMonitoringQueryLanguage)(ptr) = AlertPolicySpecConditionsConditionMonitoringQueryLanguage{}
		}
	default:
		iter.ReportError("decode AlertPolicySpecConditionsConditionMonitoringQueryLanguage", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AlertPolicySpecConditionsConditionMonitoringQueryLanguageTriggerCodec struct {
}

func (AlertPolicySpecConditionsConditionMonitoringQueryLanguageTriggerCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger)(ptr) == nil
}

func (AlertPolicySpecConditionsConditionMonitoringQueryLanguageTriggerCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger)(ptr)
	var objs []AlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger
	if obj != nil {
		objs = []AlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AlertPolicySpecConditionsConditionMonitoringQueryLanguageTriggerCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger)(ptr) = AlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger)(ptr) = objs[0]
			} else {
				*(*AlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger)(ptr) = AlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger{}
			}
		} else {
			*(*AlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger)(ptr) = AlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger{}
		}
	default:
		iter.ReportError("decode AlertPolicySpecConditionsConditionMonitoringQueryLanguageTrigger", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AlertPolicySpecConditionsConditionThresholdCodec struct {
}

func (AlertPolicySpecConditionsConditionThresholdCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AlertPolicySpecConditionsConditionThreshold)(ptr) == nil
}

func (AlertPolicySpecConditionsConditionThresholdCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AlertPolicySpecConditionsConditionThreshold)(ptr)
	var objs []AlertPolicySpecConditionsConditionThreshold
	if obj != nil {
		objs = []AlertPolicySpecConditionsConditionThreshold{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionThreshold{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AlertPolicySpecConditionsConditionThresholdCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AlertPolicySpecConditionsConditionThreshold)(ptr) = AlertPolicySpecConditionsConditionThreshold{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AlertPolicySpecConditionsConditionThreshold

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionThreshold{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AlertPolicySpecConditionsConditionThreshold)(ptr) = objs[0]
			} else {
				*(*AlertPolicySpecConditionsConditionThreshold)(ptr) = AlertPolicySpecConditionsConditionThreshold{}
			}
		} else {
			*(*AlertPolicySpecConditionsConditionThreshold)(ptr) = AlertPolicySpecConditionsConditionThreshold{}
		}
	default:
		iter.ReportError("decode AlertPolicySpecConditionsConditionThreshold", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AlertPolicySpecConditionsConditionThresholdTriggerCodec struct {
}

func (AlertPolicySpecConditionsConditionThresholdTriggerCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AlertPolicySpecConditionsConditionThresholdTrigger)(ptr) == nil
}

func (AlertPolicySpecConditionsConditionThresholdTriggerCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AlertPolicySpecConditionsConditionThresholdTrigger)(ptr)
	var objs []AlertPolicySpecConditionsConditionThresholdTrigger
	if obj != nil {
		objs = []AlertPolicySpecConditionsConditionThresholdTrigger{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionThresholdTrigger{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AlertPolicySpecConditionsConditionThresholdTriggerCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AlertPolicySpecConditionsConditionThresholdTrigger)(ptr) = AlertPolicySpecConditionsConditionThresholdTrigger{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AlertPolicySpecConditionsConditionThresholdTrigger

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecConditionsConditionThresholdTrigger{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AlertPolicySpecConditionsConditionThresholdTrigger)(ptr) = objs[0]
			} else {
				*(*AlertPolicySpecConditionsConditionThresholdTrigger)(ptr) = AlertPolicySpecConditionsConditionThresholdTrigger{}
			}
		} else {
			*(*AlertPolicySpecConditionsConditionThresholdTrigger)(ptr) = AlertPolicySpecConditionsConditionThresholdTrigger{}
		}
	default:
		iter.ReportError("decode AlertPolicySpecConditionsConditionThresholdTrigger", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AlertPolicySpecDocumentationCodec struct {
}

func (AlertPolicySpecDocumentationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AlertPolicySpecDocumentation)(ptr) == nil
}

func (AlertPolicySpecDocumentationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AlertPolicySpecDocumentation)(ptr)
	var objs []AlertPolicySpecDocumentation
	if obj != nil {
		objs = []AlertPolicySpecDocumentation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecDocumentation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AlertPolicySpecDocumentationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AlertPolicySpecDocumentation)(ptr) = AlertPolicySpecDocumentation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AlertPolicySpecDocumentation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlertPolicySpecDocumentation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AlertPolicySpecDocumentation)(ptr) = objs[0]
			} else {
				*(*AlertPolicySpecDocumentation)(ptr) = AlertPolicySpecDocumentation{}
			}
		} else {
			*(*AlertPolicySpecDocumentation)(ptr) = AlertPolicySpecDocumentation{}
		}
	default:
		iter.ReportError("decode AlertPolicySpecDocumentation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CustomServiceSpecTelemetryCodec struct {
}

func (CustomServiceSpecTelemetryCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CustomServiceSpecTelemetry)(ptr) == nil
}

func (CustomServiceSpecTelemetryCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CustomServiceSpecTelemetry)(ptr)
	var objs []CustomServiceSpecTelemetry
	if obj != nil {
		objs = []CustomServiceSpecTelemetry{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomServiceSpecTelemetry{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CustomServiceSpecTelemetryCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CustomServiceSpecTelemetry)(ptr) = CustomServiceSpecTelemetry{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CustomServiceSpecTelemetry

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CustomServiceSpecTelemetry{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CustomServiceSpecTelemetry)(ptr) = objs[0]
			} else {
				*(*CustomServiceSpecTelemetry)(ptr) = CustomServiceSpecTelemetry{}
			}
		} else {
			*(*CustomServiceSpecTelemetry)(ptr) = CustomServiceSpecTelemetry{}
		}
	default:
		iter.ReportError("decode CustomServiceSpecTelemetry", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MetricDescriptorSpecMetadataCodec struct {
}

func (MetricDescriptorSpecMetadataCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MetricDescriptorSpecMetadata)(ptr) == nil
}

func (MetricDescriptorSpecMetadataCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MetricDescriptorSpecMetadata)(ptr)
	var objs []MetricDescriptorSpecMetadata
	if obj != nil {
		objs = []MetricDescriptorSpecMetadata{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricDescriptorSpecMetadata{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MetricDescriptorSpecMetadataCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MetricDescriptorSpecMetadata)(ptr) = MetricDescriptorSpecMetadata{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MetricDescriptorSpecMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricDescriptorSpecMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MetricDescriptorSpecMetadata)(ptr) = objs[0]
			} else {
				*(*MetricDescriptorSpecMetadata)(ptr) = MetricDescriptorSpecMetadata{}
			}
		} else {
			*(*MetricDescriptorSpecMetadata)(ptr) = MetricDescriptorSpecMetadata{}
		}
	default:
		iter.ReportError("decode MetricDescriptorSpecMetadata", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NotificationChannelSpecSensitiveLabelsCodec struct {
}

func (NotificationChannelSpecSensitiveLabelsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NotificationChannelSpecSensitiveLabels)(ptr) == nil
}

func (NotificationChannelSpecSensitiveLabelsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NotificationChannelSpecSensitiveLabels)(ptr)
	var objs []NotificationChannelSpecSensitiveLabels
	if obj != nil {
		objs = []NotificationChannelSpecSensitiveLabels{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationChannelSpecSensitiveLabels{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NotificationChannelSpecSensitiveLabelsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NotificationChannelSpecSensitiveLabels)(ptr) = NotificationChannelSpecSensitiveLabels{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NotificationChannelSpecSensitiveLabels

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NotificationChannelSpecSensitiveLabels{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NotificationChannelSpecSensitiveLabels)(ptr) = objs[0]
			} else {
				*(*NotificationChannelSpecSensitiveLabels)(ptr) = NotificationChannelSpecSensitiveLabels{}
			}
		} else {
			*(*NotificationChannelSpecSensitiveLabels)(ptr) = NotificationChannelSpecSensitiveLabels{}
		}
	default:
		iter.ReportError("decode NotificationChannelSpecSensitiveLabels", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SloSpecBasicSliCodec struct {
}

func (SloSpecBasicSliCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SloSpecBasicSli)(ptr) == nil
}

func (SloSpecBasicSliCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SloSpecBasicSli)(ptr)
	var objs []SloSpecBasicSli
	if obj != nil {
		objs = []SloSpecBasicSli{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecBasicSli{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SloSpecBasicSliCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SloSpecBasicSli)(ptr) = SloSpecBasicSli{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SloSpecBasicSli

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecBasicSli{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SloSpecBasicSli)(ptr) = objs[0]
			} else {
				*(*SloSpecBasicSli)(ptr) = SloSpecBasicSli{}
			}
		} else {
			*(*SloSpecBasicSli)(ptr) = SloSpecBasicSli{}
		}
	default:
		iter.ReportError("decode SloSpecBasicSli", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SloSpecBasicSliAvailabilityCodec struct {
}

func (SloSpecBasicSliAvailabilityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SloSpecBasicSliAvailability)(ptr) == nil
}

func (SloSpecBasicSliAvailabilityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SloSpecBasicSliAvailability)(ptr)
	var objs []SloSpecBasicSliAvailability
	if obj != nil {
		objs = []SloSpecBasicSliAvailability{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecBasicSliAvailability{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SloSpecBasicSliAvailabilityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SloSpecBasicSliAvailability)(ptr) = SloSpecBasicSliAvailability{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SloSpecBasicSliAvailability

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecBasicSliAvailability{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SloSpecBasicSliAvailability)(ptr) = objs[0]
			} else {
				*(*SloSpecBasicSliAvailability)(ptr) = SloSpecBasicSliAvailability{}
			}
		} else {
			*(*SloSpecBasicSliAvailability)(ptr) = SloSpecBasicSliAvailability{}
		}
	default:
		iter.ReportError("decode SloSpecBasicSliAvailability", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SloSpecBasicSliLatencyCodec struct {
}

func (SloSpecBasicSliLatencyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SloSpecBasicSliLatency)(ptr) == nil
}

func (SloSpecBasicSliLatencyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SloSpecBasicSliLatency)(ptr)
	var objs []SloSpecBasicSliLatency
	if obj != nil {
		objs = []SloSpecBasicSliLatency{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecBasicSliLatency{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SloSpecBasicSliLatencyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SloSpecBasicSliLatency)(ptr) = SloSpecBasicSliLatency{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SloSpecBasicSliLatency

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecBasicSliLatency{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SloSpecBasicSliLatency)(ptr) = objs[0]
			} else {
				*(*SloSpecBasicSliLatency)(ptr) = SloSpecBasicSliLatency{}
			}
		} else {
			*(*SloSpecBasicSliLatency)(ptr) = SloSpecBasicSliLatency{}
		}
	default:
		iter.ReportError("decode SloSpecBasicSliLatency", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SloSpecRequestBasedSliCodec struct {
}

func (SloSpecRequestBasedSliCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SloSpecRequestBasedSli)(ptr) == nil
}

func (SloSpecRequestBasedSliCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SloSpecRequestBasedSli)(ptr)
	var objs []SloSpecRequestBasedSli
	if obj != nil {
		objs = []SloSpecRequestBasedSli{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecRequestBasedSli{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SloSpecRequestBasedSliCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SloSpecRequestBasedSli)(ptr) = SloSpecRequestBasedSli{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SloSpecRequestBasedSli

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecRequestBasedSli{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SloSpecRequestBasedSli)(ptr) = objs[0]
			} else {
				*(*SloSpecRequestBasedSli)(ptr) = SloSpecRequestBasedSli{}
			}
		} else {
			*(*SloSpecRequestBasedSli)(ptr) = SloSpecRequestBasedSli{}
		}
	default:
		iter.ReportError("decode SloSpecRequestBasedSli", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SloSpecRequestBasedSliDistributionCutCodec struct {
}

func (SloSpecRequestBasedSliDistributionCutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SloSpecRequestBasedSliDistributionCut)(ptr) == nil
}

func (SloSpecRequestBasedSliDistributionCutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SloSpecRequestBasedSliDistributionCut)(ptr)
	var objs []SloSpecRequestBasedSliDistributionCut
	if obj != nil {
		objs = []SloSpecRequestBasedSliDistributionCut{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecRequestBasedSliDistributionCut{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SloSpecRequestBasedSliDistributionCutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SloSpecRequestBasedSliDistributionCut)(ptr) = SloSpecRequestBasedSliDistributionCut{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SloSpecRequestBasedSliDistributionCut

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecRequestBasedSliDistributionCut{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SloSpecRequestBasedSliDistributionCut)(ptr) = objs[0]
			} else {
				*(*SloSpecRequestBasedSliDistributionCut)(ptr) = SloSpecRequestBasedSliDistributionCut{}
			}
		} else {
			*(*SloSpecRequestBasedSliDistributionCut)(ptr) = SloSpecRequestBasedSliDistributionCut{}
		}
	default:
		iter.ReportError("decode SloSpecRequestBasedSliDistributionCut", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SloSpecRequestBasedSliDistributionCutRangeCodec struct {
}

func (SloSpecRequestBasedSliDistributionCutRangeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SloSpecRequestBasedSliDistributionCutRange)(ptr) == nil
}

func (SloSpecRequestBasedSliDistributionCutRangeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SloSpecRequestBasedSliDistributionCutRange)(ptr)
	var objs []SloSpecRequestBasedSliDistributionCutRange
	if obj != nil {
		objs = []SloSpecRequestBasedSliDistributionCutRange{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecRequestBasedSliDistributionCutRange{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SloSpecRequestBasedSliDistributionCutRangeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SloSpecRequestBasedSliDistributionCutRange)(ptr) = SloSpecRequestBasedSliDistributionCutRange{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SloSpecRequestBasedSliDistributionCutRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecRequestBasedSliDistributionCutRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SloSpecRequestBasedSliDistributionCutRange)(ptr) = objs[0]
			} else {
				*(*SloSpecRequestBasedSliDistributionCutRange)(ptr) = SloSpecRequestBasedSliDistributionCutRange{}
			}
		} else {
			*(*SloSpecRequestBasedSliDistributionCutRange)(ptr) = SloSpecRequestBasedSliDistributionCutRange{}
		}
	default:
		iter.ReportError("decode SloSpecRequestBasedSliDistributionCutRange", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SloSpecRequestBasedSliGoodTotalRatioCodec struct {
}

func (SloSpecRequestBasedSliGoodTotalRatioCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SloSpecRequestBasedSliGoodTotalRatio)(ptr) == nil
}

func (SloSpecRequestBasedSliGoodTotalRatioCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SloSpecRequestBasedSliGoodTotalRatio)(ptr)
	var objs []SloSpecRequestBasedSliGoodTotalRatio
	if obj != nil {
		objs = []SloSpecRequestBasedSliGoodTotalRatio{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecRequestBasedSliGoodTotalRatio{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SloSpecRequestBasedSliGoodTotalRatioCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SloSpecRequestBasedSliGoodTotalRatio)(ptr) = SloSpecRequestBasedSliGoodTotalRatio{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SloSpecRequestBasedSliGoodTotalRatio

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecRequestBasedSliGoodTotalRatio{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SloSpecRequestBasedSliGoodTotalRatio)(ptr) = objs[0]
			} else {
				*(*SloSpecRequestBasedSliGoodTotalRatio)(ptr) = SloSpecRequestBasedSliGoodTotalRatio{}
			}
		} else {
			*(*SloSpecRequestBasedSliGoodTotalRatio)(ptr) = SloSpecRequestBasedSliGoodTotalRatio{}
		}
	default:
		iter.ReportError("decode SloSpecRequestBasedSliGoodTotalRatio", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SloSpecWindowsBasedSliCodec struct {
}

func (SloSpecWindowsBasedSliCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SloSpecWindowsBasedSli)(ptr) == nil
}

func (SloSpecWindowsBasedSliCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SloSpecWindowsBasedSli)(ptr)
	var objs []SloSpecWindowsBasedSli
	if obj != nil {
		objs = []SloSpecWindowsBasedSli{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSli{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SloSpecWindowsBasedSliCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SloSpecWindowsBasedSli)(ptr) = SloSpecWindowsBasedSli{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SloSpecWindowsBasedSli

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSli{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SloSpecWindowsBasedSli)(ptr) = objs[0]
			} else {
				*(*SloSpecWindowsBasedSli)(ptr) = SloSpecWindowsBasedSli{}
			}
		} else {
			*(*SloSpecWindowsBasedSli)(ptr) = SloSpecWindowsBasedSli{}
		}
	default:
		iter.ReportError("decode SloSpecWindowsBasedSli", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SloSpecWindowsBasedSliGoodTotalRatioThresholdCodec struct {
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SloSpecWindowsBasedSliGoodTotalRatioThreshold)(ptr) == nil
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SloSpecWindowsBasedSliGoodTotalRatioThreshold)(ptr)
	var objs []SloSpecWindowsBasedSliGoodTotalRatioThreshold
	if obj != nil {
		objs = []SloSpecWindowsBasedSliGoodTotalRatioThreshold{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThreshold{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SloSpecWindowsBasedSliGoodTotalRatioThreshold)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThreshold{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SloSpecWindowsBasedSliGoodTotalRatioThreshold

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThreshold{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SloSpecWindowsBasedSliGoodTotalRatioThreshold)(ptr) = objs[0]
			} else {
				*(*SloSpecWindowsBasedSliGoodTotalRatioThreshold)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThreshold{}
			}
		} else {
			*(*SloSpecWindowsBasedSliGoodTotalRatioThreshold)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThreshold{}
		}
	default:
		iter.ReportError("decode SloSpecWindowsBasedSliGoodTotalRatioThreshold", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceCodec struct {
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance)(ptr) == nil
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance)(ptr)
	var objs []SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance
	if obj != nil {
		objs = []SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance)(ptr) = objs[0]
			} else {
				*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance{}
			}
		} else {
			*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance{}
		}
	default:
		iter.ReportError("decode SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformance", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailabilityCodec struct {
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailabilityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability)(ptr) == nil
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailabilityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability)(ptr)
	var objs []SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability
	if obj != nil {
		objs = []SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailabilityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability)(ptr) = objs[0]
			} else {
				*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability{}
			}
		} else {
			*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability{}
		}
	default:
		iter.ReportError("decode SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceAvailability", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatencyCodec struct {
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatencyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency)(ptr) == nil
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatencyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency)(ptr)
	var objs []SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency
	if obj != nil {
		objs = []SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatencyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency)(ptr) = objs[0]
			} else {
				*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency{}
			}
		} else {
			*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency{}
		}
	default:
		iter.ReportError("decode SloSpecWindowsBasedSliGoodTotalRatioThresholdBasicSliPerformanceLatency", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceCodec struct {
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformance)(ptr) == nil
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformance)(ptr)
	var objs []SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformance
	if obj != nil {
		objs = []SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformance{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformance{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformance)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformance{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformance

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformance{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformance)(ptr) = objs[0]
			} else {
				*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformance)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformance{}
			}
		} else {
			*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformance)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformance{}
		}
	default:
		iter.ReportError("decode SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformance", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutCodec struct {
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut)(ptr) == nil
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut)(ptr)
	var objs []SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut
	if obj != nil {
		objs = []SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut)(ptr) = objs[0]
			} else {
				*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut{}
			}
		} else {
			*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut{}
		}
	default:
		iter.ReportError("decode SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCut", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeCodec struct {
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange)(ptr) == nil
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange)(ptr)
	var objs []SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange
	if obj != nil {
		objs = []SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRangeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange)(ptr) = objs[0]
			} else {
				*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange{}
			}
		} else {
			*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange{}
		}
	default:
		iter.ReportError("decode SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceDistributionCutRange", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioCodec struct {
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio)(ptr) == nil
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio)(ptr)
	var objs []SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio
	if obj != nil {
		objs = []SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatioCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio)(ptr) = objs[0]
			} else {
				*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio{}
			}
		} else {
			*(*SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio)(ptr) = SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio{}
		}
	default:
		iter.ReportError("decode SloSpecWindowsBasedSliGoodTotalRatioThresholdPerformanceGoodTotalRatio", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SloSpecWindowsBasedSliMetricMeanInRangeCodec struct {
}

func (SloSpecWindowsBasedSliMetricMeanInRangeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SloSpecWindowsBasedSliMetricMeanInRange)(ptr) == nil
}

func (SloSpecWindowsBasedSliMetricMeanInRangeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SloSpecWindowsBasedSliMetricMeanInRange)(ptr)
	var objs []SloSpecWindowsBasedSliMetricMeanInRange
	if obj != nil {
		objs = []SloSpecWindowsBasedSliMetricMeanInRange{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliMetricMeanInRange{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SloSpecWindowsBasedSliMetricMeanInRangeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SloSpecWindowsBasedSliMetricMeanInRange)(ptr) = SloSpecWindowsBasedSliMetricMeanInRange{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SloSpecWindowsBasedSliMetricMeanInRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliMetricMeanInRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SloSpecWindowsBasedSliMetricMeanInRange)(ptr) = objs[0]
			} else {
				*(*SloSpecWindowsBasedSliMetricMeanInRange)(ptr) = SloSpecWindowsBasedSliMetricMeanInRange{}
			}
		} else {
			*(*SloSpecWindowsBasedSliMetricMeanInRange)(ptr) = SloSpecWindowsBasedSliMetricMeanInRange{}
		}
	default:
		iter.ReportError("decode SloSpecWindowsBasedSliMetricMeanInRange", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SloSpecWindowsBasedSliMetricMeanInRangeRangeCodec struct {
}

func (SloSpecWindowsBasedSliMetricMeanInRangeRangeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SloSpecWindowsBasedSliMetricMeanInRangeRange)(ptr) == nil
}

func (SloSpecWindowsBasedSliMetricMeanInRangeRangeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SloSpecWindowsBasedSliMetricMeanInRangeRange)(ptr)
	var objs []SloSpecWindowsBasedSliMetricMeanInRangeRange
	if obj != nil {
		objs = []SloSpecWindowsBasedSliMetricMeanInRangeRange{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliMetricMeanInRangeRange{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SloSpecWindowsBasedSliMetricMeanInRangeRangeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SloSpecWindowsBasedSliMetricMeanInRangeRange)(ptr) = SloSpecWindowsBasedSliMetricMeanInRangeRange{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SloSpecWindowsBasedSliMetricMeanInRangeRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliMetricMeanInRangeRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SloSpecWindowsBasedSliMetricMeanInRangeRange)(ptr) = objs[0]
			} else {
				*(*SloSpecWindowsBasedSliMetricMeanInRangeRange)(ptr) = SloSpecWindowsBasedSliMetricMeanInRangeRange{}
			}
		} else {
			*(*SloSpecWindowsBasedSliMetricMeanInRangeRange)(ptr) = SloSpecWindowsBasedSliMetricMeanInRangeRange{}
		}
	default:
		iter.ReportError("decode SloSpecWindowsBasedSliMetricMeanInRangeRange", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SloSpecWindowsBasedSliMetricSumInRangeCodec struct {
}

func (SloSpecWindowsBasedSliMetricSumInRangeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SloSpecWindowsBasedSliMetricSumInRange)(ptr) == nil
}

func (SloSpecWindowsBasedSliMetricSumInRangeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SloSpecWindowsBasedSliMetricSumInRange)(ptr)
	var objs []SloSpecWindowsBasedSliMetricSumInRange
	if obj != nil {
		objs = []SloSpecWindowsBasedSliMetricSumInRange{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliMetricSumInRange{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SloSpecWindowsBasedSliMetricSumInRangeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SloSpecWindowsBasedSliMetricSumInRange)(ptr) = SloSpecWindowsBasedSliMetricSumInRange{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SloSpecWindowsBasedSliMetricSumInRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliMetricSumInRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SloSpecWindowsBasedSliMetricSumInRange)(ptr) = objs[0]
			} else {
				*(*SloSpecWindowsBasedSliMetricSumInRange)(ptr) = SloSpecWindowsBasedSliMetricSumInRange{}
			}
		} else {
			*(*SloSpecWindowsBasedSliMetricSumInRange)(ptr) = SloSpecWindowsBasedSliMetricSumInRange{}
		}
	default:
		iter.ReportError("decode SloSpecWindowsBasedSliMetricSumInRange", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SloSpecWindowsBasedSliMetricSumInRangeRangeCodec struct {
}

func (SloSpecWindowsBasedSliMetricSumInRangeRangeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SloSpecWindowsBasedSliMetricSumInRangeRange)(ptr) == nil
}

func (SloSpecWindowsBasedSliMetricSumInRangeRangeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SloSpecWindowsBasedSliMetricSumInRangeRange)(ptr)
	var objs []SloSpecWindowsBasedSliMetricSumInRangeRange
	if obj != nil {
		objs = []SloSpecWindowsBasedSliMetricSumInRangeRange{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliMetricSumInRangeRange{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SloSpecWindowsBasedSliMetricSumInRangeRangeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SloSpecWindowsBasedSliMetricSumInRangeRange)(ptr) = SloSpecWindowsBasedSliMetricSumInRangeRange{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SloSpecWindowsBasedSliMetricSumInRangeRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SloSpecWindowsBasedSliMetricSumInRangeRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SloSpecWindowsBasedSliMetricSumInRangeRange)(ptr) = objs[0]
			} else {
				*(*SloSpecWindowsBasedSliMetricSumInRangeRange)(ptr) = SloSpecWindowsBasedSliMetricSumInRangeRange{}
			}
		} else {
			*(*SloSpecWindowsBasedSliMetricSumInRangeRange)(ptr) = SloSpecWindowsBasedSliMetricSumInRangeRange{}
		}
	default:
		iter.ReportError("decode SloSpecWindowsBasedSliMetricSumInRangeRange", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UptimeCheckConfigSpecHttpCheckCodec struct {
}

func (UptimeCheckConfigSpecHttpCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UptimeCheckConfigSpecHttpCheck)(ptr) == nil
}

func (UptimeCheckConfigSpecHttpCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UptimeCheckConfigSpecHttpCheck)(ptr)
	var objs []UptimeCheckConfigSpecHttpCheck
	if obj != nil {
		objs = []UptimeCheckConfigSpecHttpCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UptimeCheckConfigSpecHttpCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UptimeCheckConfigSpecHttpCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UptimeCheckConfigSpecHttpCheck)(ptr) = UptimeCheckConfigSpecHttpCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UptimeCheckConfigSpecHttpCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UptimeCheckConfigSpecHttpCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UptimeCheckConfigSpecHttpCheck)(ptr) = objs[0]
			} else {
				*(*UptimeCheckConfigSpecHttpCheck)(ptr) = UptimeCheckConfigSpecHttpCheck{}
			}
		} else {
			*(*UptimeCheckConfigSpecHttpCheck)(ptr) = UptimeCheckConfigSpecHttpCheck{}
		}
	default:
		iter.ReportError("decode UptimeCheckConfigSpecHttpCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UptimeCheckConfigSpecHttpCheckAuthInfoCodec struct {
}

func (UptimeCheckConfigSpecHttpCheckAuthInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UptimeCheckConfigSpecHttpCheckAuthInfo)(ptr) == nil
}

func (UptimeCheckConfigSpecHttpCheckAuthInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UptimeCheckConfigSpecHttpCheckAuthInfo)(ptr)
	var objs []UptimeCheckConfigSpecHttpCheckAuthInfo
	if obj != nil {
		objs = []UptimeCheckConfigSpecHttpCheckAuthInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UptimeCheckConfigSpecHttpCheckAuthInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UptimeCheckConfigSpecHttpCheckAuthInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UptimeCheckConfigSpecHttpCheckAuthInfo)(ptr) = UptimeCheckConfigSpecHttpCheckAuthInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UptimeCheckConfigSpecHttpCheckAuthInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UptimeCheckConfigSpecHttpCheckAuthInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UptimeCheckConfigSpecHttpCheckAuthInfo)(ptr) = objs[0]
			} else {
				*(*UptimeCheckConfigSpecHttpCheckAuthInfo)(ptr) = UptimeCheckConfigSpecHttpCheckAuthInfo{}
			}
		} else {
			*(*UptimeCheckConfigSpecHttpCheckAuthInfo)(ptr) = UptimeCheckConfigSpecHttpCheckAuthInfo{}
		}
	default:
		iter.ReportError("decode UptimeCheckConfigSpecHttpCheckAuthInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UptimeCheckConfigSpecMonitoredResourceCodec struct {
}

func (UptimeCheckConfigSpecMonitoredResourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UptimeCheckConfigSpecMonitoredResource)(ptr) == nil
}

func (UptimeCheckConfigSpecMonitoredResourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UptimeCheckConfigSpecMonitoredResource)(ptr)
	var objs []UptimeCheckConfigSpecMonitoredResource
	if obj != nil {
		objs = []UptimeCheckConfigSpecMonitoredResource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UptimeCheckConfigSpecMonitoredResource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UptimeCheckConfigSpecMonitoredResourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UptimeCheckConfigSpecMonitoredResource)(ptr) = UptimeCheckConfigSpecMonitoredResource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UptimeCheckConfigSpecMonitoredResource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UptimeCheckConfigSpecMonitoredResource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UptimeCheckConfigSpecMonitoredResource)(ptr) = objs[0]
			} else {
				*(*UptimeCheckConfigSpecMonitoredResource)(ptr) = UptimeCheckConfigSpecMonitoredResource{}
			}
		} else {
			*(*UptimeCheckConfigSpecMonitoredResource)(ptr) = UptimeCheckConfigSpecMonitoredResource{}
		}
	default:
		iter.ReportError("decode UptimeCheckConfigSpecMonitoredResource", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UptimeCheckConfigSpecResourceGroupCodec struct {
}

func (UptimeCheckConfigSpecResourceGroupCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UptimeCheckConfigSpecResourceGroup)(ptr) == nil
}

func (UptimeCheckConfigSpecResourceGroupCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UptimeCheckConfigSpecResourceGroup)(ptr)
	var objs []UptimeCheckConfigSpecResourceGroup
	if obj != nil {
		objs = []UptimeCheckConfigSpecResourceGroup{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UptimeCheckConfigSpecResourceGroup{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UptimeCheckConfigSpecResourceGroupCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UptimeCheckConfigSpecResourceGroup)(ptr) = UptimeCheckConfigSpecResourceGroup{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UptimeCheckConfigSpecResourceGroup

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UptimeCheckConfigSpecResourceGroup{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UptimeCheckConfigSpecResourceGroup)(ptr) = objs[0]
			} else {
				*(*UptimeCheckConfigSpecResourceGroup)(ptr) = UptimeCheckConfigSpecResourceGroup{}
			}
		} else {
			*(*UptimeCheckConfigSpecResourceGroup)(ptr) = UptimeCheckConfigSpecResourceGroup{}
		}
	default:
		iter.ReportError("decode UptimeCheckConfigSpecResourceGroup", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UptimeCheckConfigSpecTcpCheckCodec struct {
}

func (UptimeCheckConfigSpecTcpCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UptimeCheckConfigSpecTcpCheck)(ptr) == nil
}

func (UptimeCheckConfigSpecTcpCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UptimeCheckConfigSpecTcpCheck)(ptr)
	var objs []UptimeCheckConfigSpecTcpCheck
	if obj != nil {
		objs = []UptimeCheckConfigSpecTcpCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UptimeCheckConfigSpecTcpCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UptimeCheckConfigSpecTcpCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UptimeCheckConfigSpecTcpCheck)(ptr) = UptimeCheckConfigSpecTcpCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UptimeCheckConfigSpecTcpCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UptimeCheckConfigSpecTcpCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UptimeCheckConfigSpecTcpCheck)(ptr) = objs[0]
			} else {
				*(*UptimeCheckConfigSpecTcpCheck)(ptr) = UptimeCheckConfigSpecTcpCheck{}
			}
		} else {
			*(*UptimeCheckConfigSpecTcpCheck)(ptr) = UptimeCheckConfigSpecTcpCheck{}
		}
	default:
		iter.ReportError("decode UptimeCheckConfigSpecTcpCheck", "unexpected JSON type")
	}
}
