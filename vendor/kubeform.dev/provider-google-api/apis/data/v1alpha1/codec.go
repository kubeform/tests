/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogEntrySpecGcsFilesetSpec{}).Type1()):                                                                                                                  CatalogEntrySpecGcsFilesetSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogEntryGroupIamBindingSpecCondition{}).Type1()):                                                                                                        CatalogEntryGroupIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogEntryGroupIamMemberSpecCondition{}).Type1()):                                                                                                         CatalogEntryGroupIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogTagTemplateSpecFieldsType{}).Type1()):                                                                                                                CatalogTagTemplateSpecFieldsTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogTagTemplateSpecFieldsTypeEnumType{}).Type1()):                                                                                                        CatalogTagTemplateSpecFieldsTypeEnumTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogTagTemplateIamBindingSpecCondition{}).Type1()):                                                                                                       CatalogTagTemplateIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogTagTemplateIamMemberSpecCondition{}).Type1()):                                                                                                        CatalogTagTemplateIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfig{}).Type1()):                                                                                            LossPreventionDeidentifyTemplateSpecDeidentifyConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations{}).Type1()):                                                                     LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation{}).Type1()):                               LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig{}).Type1()):            LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig{}).Type1()):                  LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue{}).Type1()):          LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue{}).Type1()): LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue{}).Type1()): LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfig{}).Type1()):                                                                                                  LossPreventionInspectTemplateSpecInspectConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionary{}).Type1()):                                                                         LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath{}).Type1()):                                                         LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePathCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList{}).Type1()):                                                                 LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordListCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesInfoType{}).Type1()):                                                                           LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesInfoTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesRegex{}).Type1()):                                                                              LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesRegexCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesStoredType{}).Type1()):                                                                         LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesStoredTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigLimits{}).Type1()):                                                                                            LossPreventionInspectTemplateSpecInspectConfigLimitsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType{}).Type1()):                                                              LossPreventionInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule{}).Type1()):                                                                         LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary{}).Type1()):                                                               LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath{}).Type1()):                                               LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePathCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList{}).Type1()):                                                       LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordListCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes{}).Type1()):                                                         LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex{}).Type1()):                                                                    LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegexCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule{}).Type1()):                                                                           LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex{}).Type1()):                                                               LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegexCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment{}).Type1()):                                                       LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustmentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity{}).Type1()):                                                                  LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJob{}).Type1()):                                                                                                          LossPreventionJobTriggerSpecInspectJobCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobActionsSaveFindings{}).Type1()):                                                                                       LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig{}).Type1()):                                                                           LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable{}).Type1()):                                                                      LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfig{}).Type1()):                                                                                             LossPreventionJobTriggerSpecInspectJobStorageConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptions{}).Type1()):                                                                              LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference{}).Type1()):                                                                LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptions{}).Type1()):                                                                          LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet{}).Type1()):                                                                   LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet{}).Type1()):                                                       LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptions{}).Type1()):                                                                             LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind{}).Type1()):                                                                         LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKindCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionID{}).Type1()):                                                                  LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionIDCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfig{}).Type1()):                                                                               LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField{}).Type1()):                                                                 LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampFieldCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecTriggersSchedule{}).Type1()):                                                                                                    LossPreventionJobTriggerSpecTriggersScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecDictionary{}).Type1()):                                                                                                      LossPreventionStoredInfoTypeSpecDictionaryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecDictionaryCloudStoragePath{}).Type1()):                                                                                      LossPreventionStoredInfoTypeSpecDictionaryCloudStoragePathCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecDictionaryWordList{}).Type1()):                                                                                              LossPreventionStoredInfoTypeSpecDictionaryWordListCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionary{}).Type1()):                                                                                           LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryField{}).Type1()):                                                                              LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField{}).Type1()):                                                                         LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldFieldCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable{}).Type1()):                                                                         LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet{}).Type1()):                                                                        LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionaryOutputPath{}).Type1()):                                                                                 LossPreventionStoredInfoTypeSpecLargeCustomDictionaryOutputPathCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecRegex{}).Type1()):                                                                                                           LossPreventionStoredInfoTypeSpecRegexCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogEntrySpecGcsFilesetSpec{}).Type1()):                                                                                                                  CatalogEntrySpecGcsFilesetSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogEntryGroupIamBindingSpecCondition{}).Type1()):                                                                                                        CatalogEntryGroupIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogEntryGroupIamMemberSpecCondition{}).Type1()):                                                                                                         CatalogEntryGroupIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogTagTemplateSpecFieldsType{}).Type1()):                                                                                                                CatalogTagTemplateSpecFieldsTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogTagTemplateSpecFieldsTypeEnumType{}).Type1()):                                                                                                        CatalogTagTemplateSpecFieldsTypeEnumTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogTagTemplateIamBindingSpecCondition{}).Type1()):                                                                                                       CatalogTagTemplateIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogTagTemplateIamMemberSpecCondition{}).Type1()):                                                                                                        CatalogTagTemplateIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfig{}).Type1()):                                                                                            LossPreventionDeidentifyTemplateSpecDeidentifyConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations{}).Type1()):                                                                     LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation{}).Type1()):                               LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig{}).Type1()):            LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig{}).Type1()):                  LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue{}).Type1()):          LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue{}).Type1()): LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue{}).Type1()): LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValueCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfig{}).Type1()):                                                                                                  LossPreventionInspectTemplateSpecInspectConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionary{}).Type1()):                                                                         LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath{}).Type1()):                                                         LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePathCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList{}).Type1()):                                                                 LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordListCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesInfoType{}).Type1()):                                                                           LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesInfoTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesRegex{}).Type1()):                                                                              LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesRegexCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesStoredType{}).Type1()):                                                                         LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesStoredTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigLimits{}).Type1()):                                                                                            LossPreventionInspectTemplateSpecInspectConfigLimitsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType{}).Type1()):                                                              LossPreventionInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule{}).Type1()):                                                                         LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary{}).Type1()):                                                               LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath{}).Type1()):                                               LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePathCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList{}).Type1()):                                                       LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordListCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes{}).Type1()):                                                         LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex{}).Type1()):                                                                    LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegexCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule{}).Type1()):                                                                           LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex{}).Type1()):                                                               LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegexCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment{}).Type1()):                                                       LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustmentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity{}).Type1()):                                                                  LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJob{}).Type1()):                                                                                                          LossPreventionJobTriggerSpecInspectJobCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobActionsSaveFindings{}).Type1()):                                                                                       LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig{}).Type1()):                                                                           LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable{}).Type1()):                                                                      LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfig{}).Type1()):                                                                                             LossPreventionJobTriggerSpecInspectJobStorageConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptions{}).Type1()):                                                                              LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference{}).Type1()):                                                                LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptions{}).Type1()):                                                                          LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet{}).Type1()):                                                                   LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet{}).Type1()):                                                       LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptions{}).Type1()):                                                                             LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind{}).Type1()):                                                                         LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKindCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionID{}).Type1()):                                                                  LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionIDCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfig{}).Type1()):                                                                               LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField{}).Type1()):                                                                 LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampFieldCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecTriggersSchedule{}).Type1()):                                                                                                    LossPreventionJobTriggerSpecTriggersScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecDictionary{}).Type1()):                                                                                                      LossPreventionStoredInfoTypeSpecDictionaryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecDictionaryCloudStoragePath{}).Type1()):                                                                                      LossPreventionStoredInfoTypeSpecDictionaryCloudStoragePathCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecDictionaryWordList{}).Type1()):                                                                                              LossPreventionStoredInfoTypeSpecDictionaryWordListCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionary{}).Type1()):                                                                                           LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryField{}).Type1()):                                                                              LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField{}).Type1()):                                                                         LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldFieldCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable{}).Type1()):                                                                         LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet{}).Type1()):                                                                        LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionaryOutputPath{}).Type1()):                                                                                 LossPreventionStoredInfoTypeSpecLargeCustomDictionaryOutputPathCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecRegex{}).Type1()):                                                                                                           LossPreventionStoredInfoTypeSpecRegexCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type CatalogEntrySpecGcsFilesetSpecCodec struct {
}

func (CatalogEntrySpecGcsFilesetSpecCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CatalogEntrySpecGcsFilesetSpec)(ptr) == nil
}

func (CatalogEntrySpecGcsFilesetSpecCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CatalogEntrySpecGcsFilesetSpec)(ptr)
	var objs []CatalogEntrySpecGcsFilesetSpec
	if obj != nil {
		objs = []CatalogEntrySpecGcsFilesetSpec{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogEntrySpecGcsFilesetSpec{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CatalogEntrySpecGcsFilesetSpecCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CatalogEntrySpecGcsFilesetSpec)(ptr) = CatalogEntrySpecGcsFilesetSpec{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CatalogEntrySpecGcsFilesetSpec

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogEntrySpecGcsFilesetSpec{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CatalogEntrySpecGcsFilesetSpec)(ptr) = objs[0]
			} else {
				*(*CatalogEntrySpecGcsFilesetSpec)(ptr) = CatalogEntrySpecGcsFilesetSpec{}
			}
		} else {
			*(*CatalogEntrySpecGcsFilesetSpec)(ptr) = CatalogEntrySpecGcsFilesetSpec{}
		}
	default:
		iter.ReportError("decode CatalogEntrySpecGcsFilesetSpec", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CatalogEntryGroupIamBindingSpecConditionCodec struct {
}

func (CatalogEntryGroupIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CatalogEntryGroupIamBindingSpecCondition)(ptr) == nil
}

func (CatalogEntryGroupIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CatalogEntryGroupIamBindingSpecCondition)(ptr)
	var objs []CatalogEntryGroupIamBindingSpecCondition
	if obj != nil {
		objs = []CatalogEntryGroupIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogEntryGroupIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CatalogEntryGroupIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CatalogEntryGroupIamBindingSpecCondition)(ptr) = CatalogEntryGroupIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CatalogEntryGroupIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogEntryGroupIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CatalogEntryGroupIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*CatalogEntryGroupIamBindingSpecCondition)(ptr) = CatalogEntryGroupIamBindingSpecCondition{}
			}
		} else {
			*(*CatalogEntryGroupIamBindingSpecCondition)(ptr) = CatalogEntryGroupIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode CatalogEntryGroupIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CatalogEntryGroupIamMemberSpecConditionCodec struct {
}

func (CatalogEntryGroupIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CatalogEntryGroupIamMemberSpecCondition)(ptr) == nil
}

func (CatalogEntryGroupIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CatalogEntryGroupIamMemberSpecCondition)(ptr)
	var objs []CatalogEntryGroupIamMemberSpecCondition
	if obj != nil {
		objs = []CatalogEntryGroupIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogEntryGroupIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CatalogEntryGroupIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CatalogEntryGroupIamMemberSpecCondition)(ptr) = CatalogEntryGroupIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CatalogEntryGroupIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogEntryGroupIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CatalogEntryGroupIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*CatalogEntryGroupIamMemberSpecCondition)(ptr) = CatalogEntryGroupIamMemberSpecCondition{}
			}
		} else {
			*(*CatalogEntryGroupIamMemberSpecCondition)(ptr) = CatalogEntryGroupIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode CatalogEntryGroupIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CatalogTagTemplateSpecFieldsTypeCodec struct {
}

func (CatalogTagTemplateSpecFieldsTypeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CatalogTagTemplateSpecFieldsType)(ptr) == nil
}

func (CatalogTagTemplateSpecFieldsTypeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CatalogTagTemplateSpecFieldsType)(ptr)
	var objs []CatalogTagTemplateSpecFieldsType
	if obj != nil {
		objs = []CatalogTagTemplateSpecFieldsType{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogTagTemplateSpecFieldsType{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CatalogTagTemplateSpecFieldsTypeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CatalogTagTemplateSpecFieldsType)(ptr) = CatalogTagTemplateSpecFieldsType{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CatalogTagTemplateSpecFieldsType

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogTagTemplateSpecFieldsType{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CatalogTagTemplateSpecFieldsType)(ptr) = objs[0]
			} else {
				*(*CatalogTagTemplateSpecFieldsType)(ptr) = CatalogTagTemplateSpecFieldsType{}
			}
		} else {
			*(*CatalogTagTemplateSpecFieldsType)(ptr) = CatalogTagTemplateSpecFieldsType{}
		}
	default:
		iter.ReportError("decode CatalogTagTemplateSpecFieldsType", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CatalogTagTemplateSpecFieldsTypeEnumTypeCodec struct {
}

func (CatalogTagTemplateSpecFieldsTypeEnumTypeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CatalogTagTemplateSpecFieldsTypeEnumType)(ptr) == nil
}

func (CatalogTagTemplateSpecFieldsTypeEnumTypeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CatalogTagTemplateSpecFieldsTypeEnumType)(ptr)
	var objs []CatalogTagTemplateSpecFieldsTypeEnumType
	if obj != nil {
		objs = []CatalogTagTemplateSpecFieldsTypeEnumType{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogTagTemplateSpecFieldsTypeEnumType{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CatalogTagTemplateSpecFieldsTypeEnumTypeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CatalogTagTemplateSpecFieldsTypeEnumType)(ptr) = CatalogTagTemplateSpecFieldsTypeEnumType{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CatalogTagTemplateSpecFieldsTypeEnumType

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogTagTemplateSpecFieldsTypeEnumType{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CatalogTagTemplateSpecFieldsTypeEnumType)(ptr) = objs[0]
			} else {
				*(*CatalogTagTemplateSpecFieldsTypeEnumType)(ptr) = CatalogTagTemplateSpecFieldsTypeEnumType{}
			}
		} else {
			*(*CatalogTagTemplateSpecFieldsTypeEnumType)(ptr) = CatalogTagTemplateSpecFieldsTypeEnumType{}
		}
	default:
		iter.ReportError("decode CatalogTagTemplateSpecFieldsTypeEnumType", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CatalogTagTemplateIamBindingSpecConditionCodec struct {
}

func (CatalogTagTemplateIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CatalogTagTemplateIamBindingSpecCondition)(ptr) == nil
}

func (CatalogTagTemplateIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CatalogTagTemplateIamBindingSpecCondition)(ptr)
	var objs []CatalogTagTemplateIamBindingSpecCondition
	if obj != nil {
		objs = []CatalogTagTemplateIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogTagTemplateIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CatalogTagTemplateIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CatalogTagTemplateIamBindingSpecCondition)(ptr) = CatalogTagTemplateIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CatalogTagTemplateIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogTagTemplateIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CatalogTagTemplateIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*CatalogTagTemplateIamBindingSpecCondition)(ptr) = CatalogTagTemplateIamBindingSpecCondition{}
			}
		} else {
			*(*CatalogTagTemplateIamBindingSpecCondition)(ptr) = CatalogTagTemplateIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode CatalogTagTemplateIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CatalogTagTemplateIamMemberSpecConditionCodec struct {
}

func (CatalogTagTemplateIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CatalogTagTemplateIamMemberSpecCondition)(ptr) == nil
}

func (CatalogTagTemplateIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CatalogTagTemplateIamMemberSpecCondition)(ptr)
	var objs []CatalogTagTemplateIamMemberSpecCondition
	if obj != nil {
		objs = []CatalogTagTemplateIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogTagTemplateIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CatalogTagTemplateIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CatalogTagTemplateIamMemberSpecCondition)(ptr) = CatalogTagTemplateIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CatalogTagTemplateIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogTagTemplateIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CatalogTagTemplateIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*CatalogTagTemplateIamMemberSpecCondition)(ptr) = CatalogTagTemplateIamMemberSpecCondition{}
			}
		} else {
			*(*CatalogTagTemplateIamMemberSpecCondition)(ptr) = CatalogTagTemplateIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode CatalogTagTemplateIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionDeidentifyTemplateSpecDeidentifyConfigCodec struct {
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionDeidentifyTemplateSpecDeidentifyConfig)(ptr) == nil
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionDeidentifyTemplateSpecDeidentifyConfig)(ptr)
	var objs []LossPreventionDeidentifyTemplateSpecDeidentifyConfig
	if obj != nil {
		objs = []LossPreventionDeidentifyTemplateSpecDeidentifyConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfig)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionDeidentifyTemplateSpecDeidentifyConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfig)(ptr) = objs[0]
			} else {
				*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfig)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfig{}
			}
		} else {
			*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfig)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfig{}
		}
	default:
		iter.ReportError("decode LossPreventionDeidentifyTemplateSpecDeidentifyConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsCodec struct {
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations)(ptr) == nil
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations)(ptr)
	var objs []LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations
	if obj != nil {
		objs = []LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations)(ptr) = objs[0]
			} else {
				*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations{}
			}
		} else {
			*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations{}
		}
	default:
		iter.ReportError("decode LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformations", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCodec struct {
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation)(ptr) == nil
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation)(ptr)
	var objs []LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation
	if obj != nil {
		objs = []LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation)(ptr) = objs[0]
			} else {
				*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation{}
			}
		} else {
			*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation{}
		}
	default:
		iter.ReportError("decode LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCodec struct {
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig)(ptr) == nil
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig)(ptr)
	var objs []LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig
	if obj != nil {
		objs = []LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig)(ptr) = objs[0]
			} else {
				*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig{}
			}
		} else {
			*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig{}
		}
	default:
		iter.ReportError("decode LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationCharacterMaskConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigCodec struct {
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig)(ptr) == nil
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig)(ptr)
	var objs []LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig
	if obj != nil {
		objs = []LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig)(ptr) = objs[0]
			} else {
				*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig{}
			}
		} else {
			*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig{}
		}
	default:
		iter.ReportError("decode LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueCodec struct {
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue)(ptr) == nil
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue)(ptr)
	var objs []LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue
	if obj != nil {
		objs = []LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue)(ptr) = objs[0]
			} else {
				*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue{}
			}
		} else {
			*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue{}
		}
	default:
		iter.ReportError("decode LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValueCodec struct {
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue)(ptr) == nil
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue)(ptr)
	var objs []LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue
	if obj != nil {
		objs = []LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue)(ptr) = objs[0]
			} else {
				*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue{}
			}
		} else {
			*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue{}
		}
	default:
		iter.ReportError("decode LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueDateValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValueCodec struct {
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValueCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue)(ptr) == nil
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValueCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue)(ptr)
	var objs []LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue
	if obj != nil {
		objs = []LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValueCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue)(ptr) = objs[0]
			} else {
				*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue{}
			}
		} else {
			*(*LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue)(ptr) = LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue{}
		}
	default:
		iter.ReportError("decode LossPreventionDeidentifyTemplateSpecDeidentifyConfigInfoTypeTransformationsTransformationsPrimitiveTransformationReplaceConfigNewValueTimeValue", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionInspectTemplateSpecInspectConfigCodec struct {
}

func (LossPreventionInspectTemplateSpecInspectConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionInspectTemplateSpecInspectConfig)(ptr) == nil
}

func (LossPreventionInspectTemplateSpecInspectConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionInspectTemplateSpecInspectConfig)(ptr)
	var objs []LossPreventionInspectTemplateSpecInspectConfig
	if obj != nil {
		objs = []LossPreventionInspectTemplateSpecInspectConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionInspectTemplateSpecInspectConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionInspectTemplateSpecInspectConfig)(ptr) = LossPreventionInspectTemplateSpecInspectConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionInspectTemplateSpecInspectConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionInspectTemplateSpecInspectConfig)(ptr) = objs[0]
			} else {
				*(*LossPreventionInspectTemplateSpecInspectConfig)(ptr) = LossPreventionInspectTemplateSpecInspectConfig{}
			}
		} else {
			*(*LossPreventionInspectTemplateSpecInspectConfig)(ptr) = LossPreventionInspectTemplateSpecInspectConfig{}
		}
	default:
		iter.ReportError("decode LossPreventionInspectTemplateSpecInspectConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCodec struct {
}

func (LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionary)(ptr) == nil
}

func (LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionary)(ptr)
	var objs []LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionary
	if obj != nil {
		objs = []LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionary{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionary{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionary)(ptr) = LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionary{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionary

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionary{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionary)(ptr) = objs[0]
			} else {
				*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionary)(ptr) = LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionary{}
			}
		} else {
			*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionary)(ptr) = LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionary{}
		}
	default:
		iter.ReportError("decode LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionary", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePathCodec struct {
}

func (LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePathCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath)(ptr) == nil
}

func (LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePathCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath)(ptr)
	var objs []LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath
	if obj != nil {
		objs = []LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePathCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath)(ptr) = LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath)(ptr) = objs[0]
			} else {
				*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath)(ptr) = LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath{}
			}
		} else {
			*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath)(ptr) = LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath{}
		}
	default:
		iter.ReportError("decode LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryCloudStoragePath", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordListCodec struct {
}

func (LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordListCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList)(ptr) == nil
}

func (LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordListCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList)(ptr)
	var objs []LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList
	if obj != nil {
		objs = []LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordListCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList)(ptr) = LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList)(ptr) = objs[0]
			} else {
				*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList)(ptr) = LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList{}
			}
		} else {
			*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList)(ptr) = LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList{}
		}
	default:
		iter.ReportError("decode LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesDictionaryWordList", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesInfoTypeCodec struct {
}

func (LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesInfoTypeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesInfoType)(ptr) == nil
}

func (LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesInfoTypeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesInfoType)(ptr)
	var objs []LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesInfoType
	if obj != nil {
		objs = []LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesInfoType{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesInfoType{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesInfoTypeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesInfoType)(ptr) = LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesInfoType{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesInfoType

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesInfoType{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesInfoType)(ptr) = objs[0]
			} else {
				*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesInfoType)(ptr) = LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesInfoType{}
			}
		} else {
			*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesInfoType)(ptr) = LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesInfoType{}
		}
	default:
		iter.ReportError("decode LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesInfoType", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesRegexCodec struct {
}

func (LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesRegexCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesRegex)(ptr) == nil
}

func (LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesRegexCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesRegex)(ptr)
	var objs []LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesRegex
	if obj != nil {
		objs = []LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesRegex{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesRegex{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesRegexCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesRegex)(ptr) = LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesRegex{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesRegex

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesRegex{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesRegex)(ptr) = objs[0]
			} else {
				*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesRegex)(ptr) = LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesRegex{}
			}
		} else {
			*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesRegex)(ptr) = LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesRegex{}
		}
	default:
		iter.ReportError("decode LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesRegex", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesStoredTypeCodec struct {
}

func (LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesStoredTypeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesStoredType)(ptr) == nil
}

func (LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesStoredTypeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesStoredType)(ptr)
	var objs []LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesStoredType
	if obj != nil {
		objs = []LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesStoredType{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesStoredType{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesStoredTypeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesStoredType)(ptr) = LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesStoredType{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesStoredType

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesStoredType{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesStoredType)(ptr) = objs[0]
			} else {
				*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesStoredType)(ptr) = LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesStoredType{}
			}
		} else {
			*(*LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesStoredType)(ptr) = LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesStoredType{}
		}
	default:
		iter.ReportError("decode LossPreventionInspectTemplateSpecInspectConfigCustomInfoTypesStoredType", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionInspectTemplateSpecInspectConfigLimitsCodec struct {
}

func (LossPreventionInspectTemplateSpecInspectConfigLimitsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionInspectTemplateSpecInspectConfigLimits)(ptr) == nil
}

func (LossPreventionInspectTemplateSpecInspectConfigLimitsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionInspectTemplateSpecInspectConfigLimits)(ptr)
	var objs []LossPreventionInspectTemplateSpecInspectConfigLimits
	if obj != nil {
		objs = []LossPreventionInspectTemplateSpecInspectConfigLimits{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigLimits{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionInspectTemplateSpecInspectConfigLimitsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionInspectTemplateSpecInspectConfigLimits)(ptr) = LossPreventionInspectTemplateSpecInspectConfigLimits{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionInspectTemplateSpecInspectConfigLimits

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigLimits{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionInspectTemplateSpecInspectConfigLimits)(ptr) = objs[0]
			} else {
				*(*LossPreventionInspectTemplateSpecInspectConfigLimits)(ptr) = LossPreventionInspectTemplateSpecInspectConfigLimits{}
			}
		} else {
			*(*LossPreventionInspectTemplateSpecInspectConfigLimits)(ptr) = LossPreventionInspectTemplateSpecInspectConfigLimits{}
		}
	default:
		iter.ReportError("decode LossPreventionInspectTemplateSpecInspectConfigLimits", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeCodec struct {
}

func (LossPreventionInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType)(ptr) == nil
}

func (LossPreventionInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType)(ptr)
	var objs []LossPreventionInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType
	if obj != nil {
		objs = []LossPreventionInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType)(ptr) = LossPreventionInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType)(ptr) = objs[0]
			} else {
				*(*LossPreventionInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType)(ptr) = LossPreventionInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType{}
			}
		} else {
			*(*LossPreventionInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType)(ptr) = LossPreventionInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType{}
		}
	default:
		iter.ReportError("decode LossPreventionInspectTemplateSpecInspectConfigLimitsMaxFindingsPerInfoTypeInfoType", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleCodec struct {
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule)(ptr) == nil
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule)(ptr)
	var objs []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule
	if obj != nil {
		objs = []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule)(ptr) = objs[0]
			} else {
				*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule{}
			}
		} else {
			*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule{}
		}
	default:
		iter.ReportError("decode LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCodec struct {
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary)(ptr) == nil
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary)(ptr)
	var objs []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary
	if obj != nil {
		objs = []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary)(ptr) = objs[0]
			} else {
				*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary{}
			}
		} else {
			*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary{}
		}
	default:
		iter.ReportError("decode LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionary", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePathCodec struct {
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePathCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath)(ptr) == nil
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePathCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath)(ptr)
	var objs []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath
	if obj != nil {
		objs = []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePathCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath)(ptr) = objs[0]
			} else {
				*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath{}
			}
		} else {
			*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath{}
		}
	default:
		iter.ReportError("decode LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryCloudStoragePath", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordListCodec struct {
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordListCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList)(ptr) == nil
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordListCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList)(ptr)
	var objs []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList
	if obj != nil {
		objs = []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordListCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList)(ptr) = objs[0]
			} else {
				*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList{}
			}
		} else {
			*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList{}
		}
	default:
		iter.ReportError("decode LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleDictionaryWordList", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesCodec struct {
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes)(ptr) == nil
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes)(ptr)
	var objs []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes
	if obj != nil {
		objs = []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes)(ptr) = objs[0]
			} else {
				*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes{}
			}
		} else {
			*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes{}
		}
	default:
		iter.ReportError("decode LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleExcludeInfoTypes", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegexCodec struct {
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegexCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex)(ptr) == nil
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegexCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex)(ptr)
	var objs []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex
	if obj != nil {
		objs = []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegexCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex)(ptr) = objs[0]
			} else {
				*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex{}
			}
		} else {
			*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex{}
		}
	default:
		iter.ReportError("decode LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesExclusionRuleRegex", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleCodec struct {
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule)(ptr) == nil
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule)(ptr)
	var objs []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule
	if obj != nil {
		objs = []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule)(ptr) = objs[0]
			} else {
				*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule{}
			}
		} else {
			*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule{}
		}
	default:
		iter.ReportError("decode LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegexCodec struct {
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegexCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex)(ptr) == nil
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegexCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex)(ptr)
	var objs []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex
	if obj != nil {
		objs = []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegexCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex)(ptr) = objs[0]
			} else {
				*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex{}
			}
		} else {
			*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex{}
		}
	default:
		iter.ReportError("decode LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleHotwordRegex", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustmentCodec struct {
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustmentCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment)(ptr) == nil
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustmentCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment)(ptr)
	var objs []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment
	if obj != nil {
		objs = []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustmentCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment)(ptr) = objs[0]
			} else {
				*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment{}
			}
		} else {
			*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment{}
		}
	default:
		iter.ReportError("decode LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleLikelihoodAdjustment", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximityCodec struct {
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity)(ptr) == nil
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity)(ptr)
	var objs []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity
	if obj != nil {
		objs = []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity)(ptr) = objs[0]
			} else {
				*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity{}
			}
		} else {
			*(*LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity)(ptr) = LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity{}
		}
	default:
		iter.ReportError("decode LossPreventionInspectTemplateSpecInspectConfigRuleSetRulesHotwordRuleProximity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionJobTriggerSpecInspectJobCodec struct {
}

func (LossPreventionJobTriggerSpecInspectJobCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionJobTriggerSpecInspectJob)(ptr) == nil
}

func (LossPreventionJobTriggerSpecInspectJobCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionJobTriggerSpecInspectJob)(ptr)
	var objs []LossPreventionJobTriggerSpecInspectJob
	if obj != nil {
		objs = []LossPreventionJobTriggerSpecInspectJob{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJob{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionJobTriggerSpecInspectJobCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionJobTriggerSpecInspectJob)(ptr) = LossPreventionJobTriggerSpecInspectJob{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionJobTriggerSpecInspectJob

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJob{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionJobTriggerSpecInspectJob)(ptr) = objs[0]
			} else {
				*(*LossPreventionJobTriggerSpecInspectJob)(ptr) = LossPreventionJobTriggerSpecInspectJob{}
			}
		} else {
			*(*LossPreventionJobTriggerSpecInspectJob)(ptr) = LossPreventionJobTriggerSpecInspectJob{}
		}
	default:
		iter.ReportError("decode LossPreventionJobTriggerSpecInspectJob", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsCodec struct {
}

func (LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionJobTriggerSpecInspectJobActionsSaveFindings)(ptr) == nil
}

func (LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionJobTriggerSpecInspectJobActionsSaveFindings)(ptr)
	var objs []LossPreventionJobTriggerSpecInspectJobActionsSaveFindings
	if obj != nil {
		objs = []LossPreventionJobTriggerSpecInspectJobActionsSaveFindings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobActionsSaveFindings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionJobTriggerSpecInspectJobActionsSaveFindings)(ptr) = LossPreventionJobTriggerSpecInspectJobActionsSaveFindings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionJobTriggerSpecInspectJobActionsSaveFindings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobActionsSaveFindings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionJobTriggerSpecInspectJobActionsSaveFindings)(ptr) = objs[0]
			} else {
				*(*LossPreventionJobTriggerSpecInspectJobActionsSaveFindings)(ptr) = LossPreventionJobTriggerSpecInspectJobActionsSaveFindings{}
			}
		} else {
			*(*LossPreventionJobTriggerSpecInspectJobActionsSaveFindings)(ptr) = LossPreventionJobTriggerSpecInspectJobActionsSaveFindings{}
		}
	default:
		iter.ReportError("decode LossPreventionJobTriggerSpecInspectJobActionsSaveFindings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigCodec struct {
}

func (LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig)(ptr) == nil
}

func (LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig)(ptr)
	var objs []LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig
	if obj != nil {
		objs = []LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig)(ptr) = LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig)(ptr) = objs[0]
			} else {
				*(*LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig)(ptr) = LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig{}
			}
		} else {
			*(*LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig)(ptr) = LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig{}
		}
	default:
		iter.ReportError("decode LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableCodec struct {
}

func (LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable)(ptr) == nil
}

func (LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable)(ptr)
	var objs []LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable
	if obj != nil {
		objs = []LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTableCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable)(ptr) = LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable)(ptr) = objs[0]
			} else {
				*(*LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable)(ptr) = LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable{}
			}
		} else {
			*(*LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable)(ptr) = LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable{}
		}
	default:
		iter.ReportError("decode LossPreventionJobTriggerSpecInspectJobActionsSaveFindingsOutputConfigTable", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionJobTriggerSpecInspectJobStorageConfigCodec struct {
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionJobTriggerSpecInspectJobStorageConfig)(ptr) == nil
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionJobTriggerSpecInspectJobStorageConfig)(ptr)
	var objs []LossPreventionJobTriggerSpecInspectJobStorageConfig
	if obj != nil {
		objs = []LossPreventionJobTriggerSpecInspectJobStorageConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionJobTriggerSpecInspectJobStorageConfig)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionJobTriggerSpecInspectJobStorageConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionJobTriggerSpecInspectJobStorageConfig)(ptr) = objs[0]
			} else {
				*(*LossPreventionJobTriggerSpecInspectJobStorageConfig)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfig{}
			}
		} else {
			*(*LossPreventionJobTriggerSpecInspectJobStorageConfig)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfig{}
		}
	default:
		iter.ReportError("decode LossPreventionJobTriggerSpecInspectJobStorageConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsCodec struct {
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptions)(ptr) == nil
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptions)(ptr)
	var objs []LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptions
	if obj != nil {
		objs = []LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptions)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptions)(ptr) = objs[0]
			} else {
				*(*LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptions)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptions{}
			}
		} else {
			*(*LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptions)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptions{}
		}
	default:
		iter.ReportError("decode LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceCodec struct {
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference)(ptr) == nil
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference)(ptr)
	var objs []LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference
	if obj != nil {
		objs = []LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReferenceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference)(ptr) = objs[0]
			} else {
				*(*LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference{}
			}
		} else {
			*(*LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference{}
		}
	default:
		iter.ReportError("decode LossPreventionJobTriggerSpecInspectJobStorageConfigBigQueryOptionsTableReference", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsCodec struct {
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptions)(ptr) == nil
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptions)(ptr)
	var objs []LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptions
	if obj != nil {
		objs = []LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptions)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptions)(ptr) = objs[0]
			} else {
				*(*LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptions)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptions{}
			}
		} else {
			*(*LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptions)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptions{}
		}
	default:
		iter.ReportError("decode LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetCodec struct {
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet)(ptr) == nil
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet)(ptr)
	var objs []LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet
	if obj != nil {
		objs = []LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet)(ptr) = objs[0]
			} else {
				*(*LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet{}
			}
		} else {
			*(*LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet{}
		}
	default:
		iter.ReportError("decode LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSet", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetCodec struct {
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet)(ptr) == nil
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet)(ptr)
	var objs []LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet
	if obj != nil {
		objs = []LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet)(ptr) = objs[0]
			} else {
				*(*LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet{}
			}
		} else {
			*(*LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet{}
		}
	default:
		iter.ReportError("decode LossPreventionJobTriggerSpecInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSet", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsCodec struct {
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptions)(ptr) == nil
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptions)(ptr)
	var objs []LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptions
	if obj != nil {
		objs = []LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptions)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptions)(ptr) = objs[0]
			} else {
				*(*LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptions)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptions{}
			}
		} else {
			*(*LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptions)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptions{}
		}
	default:
		iter.ReportError("decode LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKindCodec struct {
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKindCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind)(ptr) == nil
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKindCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind)(ptr)
	var objs []LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind
	if obj != nil {
		objs = []LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKindCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind)(ptr) = objs[0]
			} else {
				*(*LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind{}
			}
		} else {
			*(*LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind{}
		}
	default:
		iter.ReportError("decode LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsKind", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionIDCodec struct {
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionIDCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionID)(ptr) == nil
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionIDCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionID)(ptr)
	var objs []LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionID
	if obj != nil {
		objs = []LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionID{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionID{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionIDCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionID)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionID{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionID

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionID{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionID)(ptr) = objs[0]
			} else {
				*(*LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionID)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionID{}
			}
		} else {
			*(*LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionID)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionID{}
		}
	default:
		iter.ReportError("decode LossPreventionJobTriggerSpecInspectJobStorageConfigDatastoreOptionsPartitionID", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigCodec struct {
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfig)(ptr) == nil
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfig)(ptr)
	var objs []LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfig
	if obj != nil {
		objs = []LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfig)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfig)(ptr) = objs[0]
			} else {
				*(*LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfig)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfig{}
			}
		} else {
			*(*LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfig)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfig{}
		}
	default:
		iter.ReportError("decode LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampFieldCodec struct {
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampFieldCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField)(ptr) == nil
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampFieldCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField)(ptr)
	var objs []LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField
	if obj != nil {
		objs = []LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampFieldCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField)(ptr) = objs[0]
			} else {
				*(*LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField{}
			}
		} else {
			*(*LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField)(ptr) = LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField{}
		}
	default:
		iter.ReportError("decode LossPreventionJobTriggerSpecInspectJobStorageConfigTimespanConfigTimestampField", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionJobTriggerSpecTriggersScheduleCodec struct {
}

func (LossPreventionJobTriggerSpecTriggersScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionJobTriggerSpecTriggersSchedule)(ptr) == nil
}

func (LossPreventionJobTriggerSpecTriggersScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionJobTriggerSpecTriggersSchedule)(ptr)
	var objs []LossPreventionJobTriggerSpecTriggersSchedule
	if obj != nil {
		objs = []LossPreventionJobTriggerSpecTriggersSchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecTriggersSchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionJobTriggerSpecTriggersScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionJobTriggerSpecTriggersSchedule)(ptr) = LossPreventionJobTriggerSpecTriggersSchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionJobTriggerSpecTriggersSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionJobTriggerSpecTriggersSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionJobTriggerSpecTriggersSchedule)(ptr) = objs[0]
			} else {
				*(*LossPreventionJobTriggerSpecTriggersSchedule)(ptr) = LossPreventionJobTriggerSpecTriggersSchedule{}
			}
		} else {
			*(*LossPreventionJobTriggerSpecTriggersSchedule)(ptr) = LossPreventionJobTriggerSpecTriggersSchedule{}
		}
	default:
		iter.ReportError("decode LossPreventionJobTriggerSpecTriggersSchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionStoredInfoTypeSpecDictionaryCodec struct {
}

func (LossPreventionStoredInfoTypeSpecDictionaryCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionStoredInfoTypeSpecDictionary)(ptr) == nil
}

func (LossPreventionStoredInfoTypeSpecDictionaryCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionStoredInfoTypeSpecDictionary)(ptr)
	var objs []LossPreventionStoredInfoTypeSpecDictionary
	if obj != nil {
		objs = []LossPreventionStoredInfoTypeSpecDictionary{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecDictionary{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionStoredInfoTypeSpecDictionaryCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionStoredInfoTypeSpecDictionary)(ptr) = LossPreventionStoredInfoTypeSpecDictionary{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionStoredInfoTypeSpecDictionary

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecDictionary{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionStoredInfoTypeSpecDictionary)(ptr) = objs[0]
			} else {
				*(*LossPreventionStoredInfoTypeSpecDictionary)(ptr) = LossPreventionStoredInfoTypeSpecDictionary{}
			}
		} else {
			*(*LossPreventionStoredInfoTypeSpecDictionary)(ptr) = LossPreventionStoredInfoTypeSpecDictionary{}
		}
	default:
		iter.ReportError("decode LossPreventionStoredInfoTypeSpecDictionary", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionStoredInfoTypeSpecDictionaryCloudStoragePathCodec struct {
}

func (LossPreventionStoredInfoTypeSpecDictionaryCloudStoragePathCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionStoredInfoTypeSpecDictionaryCloudStoragePath)(ptr) == nil
}

func (LossPreventionStoredInfoTypeSpecDictionaryCloudStoragePathCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionStoredInfoTypeSpecDictionaryCloudStoragePath)(ptr)
	var objs []LossPreventionStoredInfoTypeSpecDictionaryCloudStoragePath
	if obj != nil {
		objs = []LossPreventionStoredInfoTypeSpecDictionaryCloudStoragePath{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecDictionaryCloudStoragePath{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionStoredInfoTypeSpecDictionaryCloudStoragePathCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionStoredInfoTypeSpecDictionaryCloudStoragePath)(ptr) = LossPreventionStoredInfoTypeSpecDictionaryCloudStoragePath{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionStoredInfoTypeSpecDictionaryCloudStoragePath

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecDictionaryCloudStoragePath{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionStoredInfoTypeSpecDictionaryCloudStoragePath)(ptr) = objs[0]
			} else {
				*(*LossPreventionStoredInfoTypeSpecDictionaryCloudStoragePath)(ptr) = LossPreventionStoredInfoTypeSpecDictionaryCloudStoragePath{}
			}
		} else {
			*(*LossPreventionStoredInfoTypeSpecDictionaryCloudStoragePath)(ptr) = LossPreventionStoredInfoTypeSpecDictionaryCloudStoragePath{}
		}
	default:
		iter.ReportError("decode LossPreventionStoredInfoTypeSpecDictionaryCloudStoragePath", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionStoredInfoTypeSpecDictionaryWordListCodec struct {
}

func (LossPreventionStoredInfoTypeSpecDictionaryWordListCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionStoredInfoTypeSpecDictionaryWordList)(ptr) == nil
}

func (LossPreventionStoredInfoTypeSpecDictionaryWordListCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionStoredInfoTypeSpecDictionaryWordList)(ptr)
	var objs []LossPreventionStoredInfoTypeSpecDictionaryWordList
	if obj != nil {
		objs = []LossPreventionStoredInfoTypeSpecDictionaryWordList{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecDictionaryWordList{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionStoredInfoTypeSpecDictionaryWordListCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionStoredInfoTypeSpecDictionaryWordList)(ptr) = LossPreventionStoredInfoTypeSpecDictionaryWordList{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionStoredInfoTypeSpecDictionaryWordList

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecDictionaryWordList{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionStoredInfoTypeSpecDictionaryWordList)(ptr) = objs[0]
			} else {
				*(*LossPreventionStoredInfoTypeSpecDictionaryWordList)(ptr) = LossPreventionStoredInfoTypeSpecDictionaryWordList{}
			}
		} else {
			*(*LossPreventionStoredInfoTypeSpecDictionaryWordList)(ptr) = LossPreventionStoredInfoTypeSpecDictionaryWordList{}
		}
	default:
		iter.ReportError("decode LossPreventionStoredInfoTypeSpecDictionaryWordList", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCodec struct {
}

func (LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionStoredInfoTypeSpecLargeCustomDictionary)(ptr) == nil
}

func (LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionStoredInfoTypeSpecLargeCustomDictionary)(ptr)
	var objs []LossPreventionStoredInfoTypeSpecLargeCustomDictionary
	if obj != nil {
		objs = []LossPreventionStoredInfoTypeSpecLargeCustomDictionary{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionary{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionary)(ptr) = LossPreventionStoredInfoTypeSpecLargeCustomDictionary{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionStoredInfoTypeSpecLargeCustomDictionary

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionary{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionary)(ptr) = objs[0]
			} else {
				*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionary)(ptr) = LossPreventionStoredInfoTypeSpecLargeCustomDictionary{}
			}
		} else {
			*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionary)(ptr) = LossPreventionStoredInfoTypeSpecLargeCustomDictionary{}
		}
	default:
		iter.ReportError("decode LossPreventionStoredInfoTypeSpecLargeCustomDictionary", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldCodec struct {
}

func (LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryField)(ptr) == nil
}

func (LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryField)(ptr)
	var objs []LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryField
	if obj != nil {
		objs = []LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryField{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryField{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryField)(ptr) = LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryField{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryField

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryField{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryField)(ptr) = objs[0]
			} else {
				*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryField)(ptr) = LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryField{}
			}
		} else {
			*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryField)(ptr) = LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryField{}
		}
	default:
		iter.ReportError("decode LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryField", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldFieldCodec struct {
}

func (LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldFieldCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField)(ptr) == nil
}

func (LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldFieldCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField)(ptr)
	var objs []LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField
	if obj != nil {
		objs = []LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldFieldCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField)(ptr) = LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField)(ptr) = objs[0]
			} else {
				*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField)(ptr) = LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField{}
			}
		} else {
			*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField)(ptr) = LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField{}
		}
	default:
		iter.ReportError("decode LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldField", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableCodec struct {
}

func (LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable)(ptr) == nil
}

func (LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable)(ptr)
	var objs []LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable
	if obj != nil {
		objs = []LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTableCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable)(ptr) = LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable)(ptr) = objs[0]
			} else {
				*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable)(ptr) = LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable{}
			}
		} else {
			*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable)(ptr) = LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable{}
		}
	default:
		iter.ReportError("decode LossPreventionStoredInfoTypeSpecLargeCustomDictionaryBigQueryFieldTable", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSetCodec struct {
}

func (LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet)(ptr) == nil
}

func (LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet)(ptr)
	var objs []LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet
	if obj != nil {
		objs = []LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet)(ptr) = LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet)(ptr) = objs[0]
			} else {
				*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet)(ptr) = LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet{}
			}
		} else {
			*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet)(ptr) = LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet{}
		}
	default:
		iter.ReportError("decode LossPreventionStoredInfoTypeSpecLargeCustomDictionaryCloudStorageFileSet", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionStoredInfoTypeSpecLargeCustomDictionaryOutputPathCodec struct {
}

func (LossPreventionStoredInfoTypeSpecLargeCustomDictionaryOutputPathCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryOutputPath)(ptr) == nil
}

func (LossPreventionStoredInfoTypeSpecLargeCustomDictionaryOutputPathCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryOutputPath)(ptr)
	var objs []LossPreventionStoredInfoTypeSpecLargeCustomDictionaryOutputPath
	if obj != nil {
		objs = []LossPreventionStoredInfoTypeSpecLargeCustomDictionaryOutputPath{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionaryOutputPath{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionStoredInfoTypeSpecLargeCustomDictionaryOutputPathCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryOutputPath)(ptr) = LossPreventionStoredInfoTypeSpecLargeCustomDictionaryOutputPath{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionStoredInfoTypeSpecLargeCustomDictionaryOutputPath

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecLargeCustomDictionaryOutputPath{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryOutputPath)(ptr) = objs[0]
			} else {
				*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryOutputPath)(ptr) = LossPreventionStoredInfoTypeSpecLargeCustomDictionaryOutputPath{}
			}
		} else {
			*(*LossPreventionStoredInfoTypeSpecLargeCustomDictionaryOutputPath)(ptr) = LossPreventionStoredInfoTypeSpecLargeCustomDictionaryOutputPath{}
		}
	default:
		iter.ReportError("decode LossPreventionStoredInfoTypeSpecLargeCustomDictionaryOutputPath", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LossPreventionStoredInfoTypeSpecRegexCodec struct {
}

func (LossPreventionStoredInfoTypeSpecRegexCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LossPreventionStoredInfoTypeSpecRegex)(ptr) == nil
}

func (LossPreventionStoredInfoTypeSpecRegexCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LossPreventionStoredInfoTypeSpecRegex)(ptr)
	var objs []LossPreventionStoredInfoTypeSpecRegex
	if obj != nil {
		objs = []LossPreventionStoredInfoTypeSpecRegex{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecRegex{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LossPreventionStoredInfoTypeSpecRegexCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LossPreventionStoredInfoTypeSpecRegex)(ptr) = LossPreventionStoredInfoTypeSpecRegex{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LossPreventionStoredInfoTypeSpecRegex

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LossPreventionStoredInfoTypeSpecRegex{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LossPreventionStoredInfoTypeSpecRegex)(ptr) = objs[0]
			} else {
				*(*LossPreventionStoredInfoTypeSpecRegex)(ptr) = LossPreventionStoredInfoTypeSpecRegex{}
			}
		} else {
			*(*LossPreventionStoredInfoTypeSpecRegex)(ptr) = LossPreventionStoredInfoTypeSpecRegex{}
		}
	default:
		iter.ReportError("decode LossPreventionStoredInfoTypeSpecRegex", "unexpected JSON type")
	}
}
