/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicy{}).Type1()):                                                     AutoscalerSpecAutoscalingPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyCpuUtilization{}).Type1()):                                       AutoscalerSpecAutoscalingPolicyCpuUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}).Type1()):                             AutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyScaleInControl{}).Type1()):                                       AutoscalerSpecAutoscalingPolicyScaleInControlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}).Type1()):                    AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendBucketSpecCdnPolicy{}).Type1()):                                                          BackendBucketSpecCdnPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCdnPolicy{}).Type1()):                                                         BackendServiceSpecCdnPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCdnPolicyCacheKeyPolicy{}).Type1()):                                           BackendServiceSpecCdnPolicyCacheKeyPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCircuitBreakers{}).Type1()):                                                   BackendServiceSpecCircuitBreakersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHash{}).Type1()):                                                    BackendServiceSpecConsistentHashCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHashHttpCookie{}).Type1()):                                          BackendServiceSpecConsistentHashHttpCookieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHashHttpCookieTtl{}).Type1()):                                       BackendServiceSpecConsistentHashHttpCookieTtlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecIap{}).Type1()):                                                               BackendServiceSpecIapCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecLogConfig{}).Type1()):                                                         BackendServiceSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetection{}).Type1()):                                                  BackendServiceSpecOutlierDetectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetectionBaseEjectionTime{}).Type1()):                                  BackendServiceSpecOutlierDetectionBaseEjectionTimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetectionInterval{}).Type1()):                                          BackendServiceSpecOutlierDetectionIntervalCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecDiskEncryptionKey{}).Type1()):                                                           DiskSpecDiskEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecSourceImageEncryptionKey{}).Type1()):                                                    DiskSpecSourceImageEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecSourceSnapshotEncryptionKey{}).Type1()):                                                 DiskSpecSourceSnapshotEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiskIamBindingSpecCondition{}).Type1()):                                                         DiskIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiskIamMemberSpecCondition{}).Type1()):                                                          DiskIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecLogConfig{}).Type1()):                                                               FirewallSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecGrpcHealthCheck{}).Type1()):                                                      HealthCheckSpecGrpcHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttp2HealthCheck{}).Type1()):                                                     HealthCheckSpecHttp2HealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttpHealthCheck{}).Type1()):                                                      HealthCheckSpecHttpHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttpsHealthCheck{}).Type1()):                                                     HealthCheckSpecHttpsHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecSslHealthCheck{}).Type1()):                                                       HealthCheckSpecSslHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecTcpHealthCheck{}).Type1()):                                                       HealthCheckSpecTcpHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecRawDisk{}).Type1()):                                                                    ImageSpecRawDiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ImageIamBindingSpecCondition{}).Type1()):                                                        ImageIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ImageIamMemberSpecCondition{}).Type1()):                                                         ImageIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecBootDisk{}).Type1()):                                                                InstanceSpecBootDiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecBootDiskInitializeParams{}).Type1()):                                                InstanceSpecBootDiskInitializeParamsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfidentialInstanceConfig{}).Type1()):                                              InstanceSpecConfidentialInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecScheduling{}).Type1()):                                                              InstanceSpecSchedulingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecServiceAccount{}).Type1()):                                                          InstanceSpecServiceAccountCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecShieldedInstanceConfig{}).Type1()):                                                  InstanceSpecShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecBootDisk{}).Type1()):                                                    InstanceFromTemplateSpecBootDiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecBootDiskInitializeParams{}).Type1()):                                    InstanceFromTemplateSpecBootDiskInitializeParamsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecConfidentialInstanceConfig{}).Type1()):                                  InstanceFromTemplateSpecConfidentialInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecScheduling{}).Type1()):                                                  InstanceFromTemplateSpecSchedulingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecServiceAccount{}).Type1()):                                              InstanceFromTemplateSpecServiceAccountCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecShieldedInstanceConfig{}).Type1()):                                      InstanceFromTemplateSpecShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecAutoHealingPolicies{}).Type1()):                                         InstanceGroupManagerSpecAutoHealingPoliciesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecUpdatePolicy{}).Type1()):                                                InstanceGroupManagerSpecUpdatePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecVersionTargetSize{}).Type1()):                                           InstanceGroupManagerSpecVersionTargetSizeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceIamBindingSpecCondition{}).Type1()):                                                     InstanceIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceIamMemberSpecCondition{}).Type1()):                                                      InstanceIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecConfidentialInstanceConfig{}).Type1()):                                      InstanceTemplateSpecConfidentialInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecDiskDiskEncryptionKey{}).Type1()):                                           InstanceTemplateSpecDiskDiskEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecScheduling{}).Type1()):                                                      InstanceTemplateSpecSchedulingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecServiceAccount{}).Type1()):                                                  InstanceTemplateSpecServiceAccountCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecShieldedInstanceConfig{}).Type1()):                                          InstanceTemplateSpecShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagedSSLCertificateSpecManaged{}).Type1()):                                                    ManagedSSLCertificateSpecManagedCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodeGroupSpecAutoscalingPolicy{}).Type1()):                                                      NodeGroupSpecAutoscalingPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodeGroupSpecMaintenanceWindow{}).Type1()):                                                      NodeGroupSpecMaintenanceWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodeTemplateSpecNodeTypeFlexibility{}).Type1()):                                                 NodeTemplateSpecNodeTypeFlexibilityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodeTemplateSpecServerBinding{}).Type1()):                                                       NodeTemplateSpecServerBindingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecCollectorIlb{}).Type1()):                                                     PacketMirroringSpecCollectorIlbCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecFilter{}).Type1()):                                                           PacketMirroringSpecFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecMirroredResources{}).Type1()):                                                PacketMirroringSpecMirroredResourcesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecNetwork{}).Type1()):                                                          PacketMirroringSpecNetworkCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PerInstanceConfigSpecPreservedState{}).Type1()):                                                 PerInstanceConfigSpecPreservedStateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicy{}).Type1()):                                               RegionAutoscalerSpecAutoscalingPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyCpuUtilization{}).Type1()):                                 RegionAutoscalerSpecAutoscalingPolicyCpuUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}).Type1()):                       RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyScaleInControl{}).Type1()):                                 RegionAutoscalerSpecAutoscalingPolicyScaleInControlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}).Type1()):              RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCdnPolicy{}).Type1()):                                                   RegionBackendServiceSpecCdnPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCdnPolicyCacheKeyPolicy{}).Type1()):                                     RegionBackendServiceSpecCdnPolicyCacheKeyPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCircuitBreakers{}).Type1()):                                             RegionBackendServiceSpecCircuitBreakersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHash{}).Type1()):                                              RegionBackendServiceSpecConsistentHashCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHashHttpCookie{}).Type1()):                                    RegionBackendServiceSpecConsistentHashHttpCookieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHashHttpCookieTtl{}).Type1()):                                 RegionBackendServiceSpecConsistentHashHttpCookieTtlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecFailoverPolicy{}).Type1()):                                              RegionBackendServiceSpecFailoverPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecLogConfig{}).Type1()):                                                   RegionBackendServiceSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetection{}).Type1()):                                            RegionBackendServiceSpecOutlierDetectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetectionBaseEjectionTime{}).Type1()):                            RegionBackendServiceSpecOutlierDetectionBaseEjectionTimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetectionInterval{}).Type1()):                                    RegionBackendServiceSpecOutlierDetectionIntervalCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskSpecDiskEncryptionKey{}).Type1()):                                                     RegionDiskSpecDiskEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskSpecSourceSnapshotEncryptionKey{}).Type1()):                                           RegionDiskSpecSourceSnapshotEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskIamBindingSpecCondition{}).Type1()):                                                   RegionDiskIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskIamMemberSpecCondition{}).Type1()):                                                    RegionDiskIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecGrpcHealthCheck{}).Type1()):                                                RegionHealthCheckSpecGrpcHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttp2HealthCheck{}).Type1()):                                               RegionHealthCheckSpecHttp2HealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttpHealthCheck{}).Type1()):                                                RegionHealthCheckSpecHttpHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttpsHealthCheck{}).Type1()):                                               RegionHealthCheckSpecHttpsHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecSslHealthCheck{}).Type1()):                                                 RegionHealthCheckSpecSslHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecTcpHealthCheck{}).Type1()):                                                 RegionHealthCheckSpecTcpHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecAutoHealingPolicies{}).Type1()):                                   RegionInstanceGroupManagerSpecAutoHealingPoliciesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecUpdatePolicy{}).Type1()):                                          RegionInstanceGroupManagerSpecUpdatePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecVersionTargetSize{}).Type1()):                                     RegionInstanceGroupManagerSpecVersionTargetSizeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecAppEngine{}).Type1()):                                             RegionNetworkEndpointGroupSpecAppEngineCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecCloudFunction{}).Type1()):                                         RegionNetworkEndpointGroupSpecCloudFunctionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecCloudRun{}).Type1()):                                              RegionNetworkEndpointGroupSpecCloudRunCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionPerInstanceConfigSpecPreservedState{}).Type1()):                                           RegionPerInstanceConfigSpecPreservedStateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecDefaultURLRedirect{}).Type1()):                                                  RegionURLMapSpecDefaultURLRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherDefaultURLRedirect{}).Type1()):                                       RegionURLMapSpecPathMatcherDefaultURLRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteAction{}).Type1()):                                      RegionURLMapSpecPathMatcherPathRuleRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}).Type1()):                            RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}).Type1()):                  RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}).Type1()):             RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}).Type1()):             RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()):   RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}).Type1()):                   RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}).Type1()):                           RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}).Type1()):              RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout{}).Type1()):                               RegionURLMapSpecPathMatcherPathRuleRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}).Type1()):                            RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}).Type1()):   RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleUrlRedirect{}).Type1()):                                      RegionURLMapSpecPathMatcherPathRuleUrlRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesHeaderAction{}).Type1()):                                   RegionURLMapSpecPathMatcherRouteRulesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}).Type1()):              RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteAction{}).Type1()):                                    RegionURLMapSpecPathMatcherRouteRulesRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}).Type1()):                          RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}).Type1()):                RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}).Type1()):           RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}).Type1()):           RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()): RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}).Type1()):                 RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}).Type1()):                         RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}).Type1()):            RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout{}).Type1()):                             RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}).Type1()):                          RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}).Type1()): RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesUrlRedirect{}).Type1()):                                    RegionURLMapSpecPathMatcherRouteRulesUrlRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ReservationSpecSpecificReservation{}).Type1()):                                                  ReservationSpecSpecificReservationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ReservationSpecSpecificReservationInstanceProperties{}).Type1()):                                ReservationSpecSpecificReservationInstancePropertiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecGroupPlacementPolicy{}).Type1()):                                              ResourcePolicySpecGroupPlacementPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicy{}).Type1()):                                            ResourcePolicySpecSnapshotSchedulePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy{}).Type1()):                             ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicySchedule{}).Type1()):                                    ResourcePolicySpecSnapshotSchedulePolicyScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule{}).Type1()):                       ResourcePolicySpecSnapshotSchedulePolicyScheduleDailyScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule{}).Type1()):                      ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlyScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule{}).Type1()):                      ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklyScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties{}).Type1()):                          ResourcePolicySpecSnapshotSchedulePolicySnapshotPropertiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouterSpecBgp{}).Type1()):                                                                       RouterSpecBgpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouterNATSpecLogConfig{}).Type1()):                                                              RouterNATSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatch{}).Type1()):                                                         SecurityPolicySpecRuleMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatchConfig{}).Type1()):                                                   SecurityPolicySpecRuleMatchConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatchExpr{}).Type1()):                                                     SecurityPolicySpecRuleMatchExprCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SnapshotSpecSnapshotEncryptionKey{}).Type1()):                                                   SnapshotSpecSnapshotEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SnapshotSpecSourceDiskEncryptionKey{}).Type1()):                                                 SnapshotSpecSourceDiskEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkSpecLogConfig{}).Type1()):                                                             SubnetworkSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkIamBindingSpecCondition{}).Type1()):                                                   SubnetworkIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkIamMemberSpecCondition{}).Type1()):                                                    SubnetworkIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteAction{}).Type1()):                                                        UrlMapSpecDefaultRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionCorsPolicy{}).Type1()):                                              UrlMapSpecDefaultRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicy{}).Type1()):                                    UrlMapSpecDefaultRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort{}).Type1()):                               UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay{}).Type1()):                               UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()):                     UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRequestMirrorPolicy{}).Type1()):                                     UrlMapSpecDefaultRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRetryPolicy{}).Type1()):                                             UrlMapSpecDefaultRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout{}).Type1()):                                UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionTimeout{}).Type1()):                                                 UrlMapSpecDefaultRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionUrlRewrite{}).Type1()):                                              UrlMapSpecDefaultRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction{}).Type1()):                     UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultURLRedirect{}).Type1()):                                                        UrlMapSpecDefaultURLRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecHeaderAction{}).Type1()):                                                              UrlMapSpecHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteAction{}).Type1()):                                             UrlMapSpecPathMatcherDefaultRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy{}).Type1()):                                   UrlMapSpecPathMatcherDefaultRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy{}).Type1()):                         UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort{}).Type1()):                    UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay{}).Type1()):                    UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()):          UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy{}).Type1()):                          UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy{}).Type1()):                                  UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout{}).Type1()):                     UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionTimeout{}).Type1()):                                      UrlMapSpecPathMatcherDefaultRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite{}).Type1()):                                   UrlMapSpecPathMatcherDefaultRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction{}).Type1()):          UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultURLRedirect{}).Type1()):                                             UrlMapSpecPathMatcherDefaultURLRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherHeaderAction{}).Type1()):                                                   UrlMapSpecPathMatcherHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteAction{}).Type1()):                                            UrlMapSpecPathMatcherPathRuleRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}).Type1()):                                  UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}).Type1()):                        UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}).Type1()):                   UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}).Type1()):                   UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()):         UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}).Type1()):                         UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}).Type1()):                                 UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}).Type1()):                    UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionTimeout{}).Type1()):                                     UrlMapSpecPathMatcherPathRuleRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}).Type1()):                                  UrlMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}).Type1()):         UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleUrlRedirect{}).Type1()):                                            UrlMapSpecPathMatcherPathRuleUrlRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesHeaderAction{}).Type1()):                                         UrlMapSpecPathMatcherRouteRulesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}).Type1()):                    UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteAction{}).Type1()):                                          UrlMapSpecPathMatcherRouteRulesRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}).Type1()):                                UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}).Type1()):                      UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}).Type1()):                 UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}).Type1()):                 UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()):       UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}).Type1()):                       UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}).Type1()):                               UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}).Type1()):                  UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionTimeout{}).Type1()):                                   UrlMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}).Type1()):                                UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}).Type1()):       UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesUrlRedirect{}).Type1()):                                          UrlMapSpecPathMatcherRouteRulesUrlRedirectCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicy{}).Type1()):                                                     AutoscalerSpecAutoscalingPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyCpuUtilization{}).Type1()):                                       AutoscalerSpecAutoscalingPolicyCpuUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}).Type1()):                             AutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyScaleInControl{}).Type1()):                                       AutoscalerSpecAutoscalingPolicyScaleInControlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}).Type1()):                    AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendBucketSpecCdnPolicy{}).Type1()):                                                          BackendBucketSpecCdnPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCdnPolicy{}).Type1()):                                                         BackendServiceSpecCdnPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCdnPolicyCacheKeyPolicy{}).Type1()):                                           BackendServiceSpecCdnPolicyCacheKeyPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCircuitBreakers{}).Type1()):                                                   BackendServiceSpecCircuitBreakersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHash{}).Type1()):                                                    BackendServiceSpecConsistentHashCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHashHttpCookie{}).Type1()):                                          BackendServiceSpecConsistentHashHttpCookieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHashHttpCookieTtl{}).Type1()):                                       BackendServiceSpecConsistentHashHttpCookieTtlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecIap{}).Type1()):                                                               BackendServiceSpecIapCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecLogConfig{}).Type1()):                                                         BackendServiceSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetection{}).Type1()):                                                  BackendServiceSpecOutlierDetectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetectionBaseEjectionTime{}).Type1()):                                  BackendServiceSpecOutlierDetectionBaseEjectionTimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetectionInterval{}).Type1()):                                          BackendServiceSpecOutlierDetectionIntervalCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecDiskEncryptionKey{}).Type1()):                                                           DiskSpecDiskEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecSourceImageEncryptionKey{}).Type1()):                                                    DiskSpecSourceImageEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecSourceSnapshotEncryptionKey{}).Type1()):                                                 DiskSpecSourceSnapshotEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiskIamBindingSpecCondition{}).Type1()):                                                         DiskIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiskIamMemberSpecCondition{}).Type1()):                                                          DiskIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecLogConfig{}).Type1()):                                                               FirewallSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecGrpcHealthCheck{}).Type1()):                                                      HealthCheckSpecGrpcHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttp2HealthCheck{}).Type1()):                                                     HealthCheckSpecHttp2HealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttpHealthCheck{}).Type1()):                                                      HealthCheckSpecHttpHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttpsHealthCheck{}).Type1()):                                                     HealthCheckSpecHttpsHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecSslHealthCheck{}).Type1()):                                                       HealthCheckSpecSslHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecTcpHealthCheck{}).Type1()):                                                       HealthCheckSpecTcpHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecRawDisk{}).Type1()):                                                                    ImageSpecRawDiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ImageIamBindingSpecCondition{}).Type1()):                                                        ImageIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ImageIamMemberSpecCondition{}).Type1()):                                                         ImageIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecBootDisk{}).Type1()):                                                                InstanceSpecBootDiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecBootDiskInitializeParams{}).Type1()):                                                InstanceSpecBootDiskInitializeParamsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfidentialInstanceConfig{}).Type1()):                                              InstanceSpecConfidentialInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecScheduling{}).Type1()):                                                              InstanceSpecSchedulingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecServiceAccount{}).Type1()):                                                          InstanceSpecServiceAccountCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecShieldedInstanceConfig{}).Type1()):                                                  InstanceSpecShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecBootDisk{}).Type1()):                                                    InstanceFromTemplateSpecBootDiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecBootDiskInitializeParams{}).Type1()):                                    InstanceFromTemplateSpecBootDiskInitializeParamsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecConfidentialInstanceConfig{}).Type1()):                                  InstanceFromTemplateSpecConfidentialInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecScheduling{}).Type1()):                                                  InstanceFromTemplateSpecSchedulingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecServiceAccount{}).Type1()):                                              InstanceFromTemplateSpecServiceAccountCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecShieldedInstanceConfig{}).Type1()):                                      InstanceFromTemplateSpecShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecAutoHealingPolicies{}).Type1()):                                         InstanceGroupManagerSpecAutoHealingPoliciesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecUpdatePolicy{}).Type1()):                                                InstanceGroupManagerSpecUpdatePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecVersionTargetSize{}).Type1()):                                           InstanceGroupManagerSpecVersionTargetSizeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceIamBindingSpecCondition{}).Type1()):                                                     InstanceIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceIamMemberSpecCondition{}).Type1()):                                                      InstanceIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecConfidentialInstanceConfig{}).Type1()):                                      InstanceTemplateSpecConfidentialInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecDiskDiskEncryptionKey{}).Type1()):                                           InstanceTemplateSpecDiskDiskEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecScheduling{}).Type1()):                                                      InstanceTemplateSpecSchedulingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecServiceAccount{}).Type1()):                                                  InstanceTemplateSpecServiceAccountCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecShieldedInstanceConfig{}).Type1()):                                          InstanceTemplateSpecShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagedSSLCertificateSpecManaged{}).Type1()):                                                    ManagedSSLCertificateSpecManagedCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodeGroupSpecAutoscalingPolicy{}).Type1()):                                                      NodeGroupSpecAutoscalingPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodeGroupSpecMaintenanceWindow{}).Type1()):                                                      NodeGroupSpecMaintenanceWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodeTemplateSpecNodeTypeFlexibility{}).Type1()):                                                 NodeTemplateSpecNodeTypeFlexibilityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodeTemplateSpecServerBinding{}).Type1()):                                                       NodeTemplateSpecServerBindingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecCollectorIlb{}).Type1()):                                                     PacketMirroringSpecCollectorIlbCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecFilter{}).Type1()):                                                           PacketMirroringSpecFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecMirroredResources{}).Type1()):                                                PacketMirroringSpecMirroredResourcesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecNetwork{}).Type1()):                                                          PacketMirroringSpecNetworkCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PerInstanceConfigSpecPreservedState{}).Type1()):                                                 PerInstanceConfigSpecPreservedStateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicy{}).Type1()):                                               RegionAutoscalerSpecAutoscalingPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyCpuUtilization{}).Type1()):                                 RegionAutoscalerSpecAutoscalingPolicyCpuUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}).Type1()):                       RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyScaleInControl{}).Type1()):                                 RegionAutoscalerSpecAutoscalingPolicyScaleInControlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}).Type1()):              RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCdnPolicy{}).Type1()):                                                   RegionBackendServiceSpecCdnPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCdnPolicyCacheKeyPolicy{}).Type1()):                                     RegionBackendServiceSpecCdnPolicyCacheKeyPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCircuitBreakers{}).Type1()):                                             RegionBackendServiceSpecCircuitBreakersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHash{}).Type1()):                                              RegionBackendServiceSpecConsistentHashCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHashHttpCookie{}).Type1()):                                    RegionBackendServiceSpecConsistentHashHttpCookieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHashHttpCookieTtl{}).Type1()):                                 RegionBackendServiceSpecConsistentHashHttpCookieTtlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecFailoverPolicy{}).Type1()):                                              RegionBackendServiceSpecFailoverPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecLogConfig{}).Type1()):                                                   RegionBackendServiceSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetection{}).Type1()):                                            RegionBackendServiceSpecOutlierDetectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetectionBaseEjectionTime{}).Type1()):                            RegionBackendServiceSpecOutlierDetectionBaseEjectionTimeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetectionInterval{}).Type1()):                                    RegionBackendServiceSpecOutlierDetectionIntervalCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskSpecDiskEncryptionKey{}).Type1()):                                                     RegionDiskSpecDiskEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskSpecSourceSnapshotEncryptionKey{}).Type1()):                                           RegionDiskSpecSourceSnapshotEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskIamBindingSpecCondition{}).Type1()):                                                   RegionDiskIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskIamMemberSpecCondition{}).Type1()):                                                    RegionDiskIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecGrpcHealthCheck{}).Type1()):                                                RegionHealthCheckSpecGrpcHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttp2HealthCheck{}).Type1()):                                               RegionHealthCheckSpecHttp2HealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttpHealthCheck{}).Type1()):                                                RegionHealthCheckSpecHttpHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttpsHealthCheck{}).Type1()):                                               RegionHealthCheckSpecHttpsHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecSslHealthCheck{}).Type1()):                                                 RegionHealthCheckSpecSslHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecTcpHealthCheck{}).Type1()):                                                 RegionHealthCheckSpecTcpHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecAutoHealingPolicies{}).Type1()):                                   RegionInstanceGroupManagerSpecAutoHealingPoliciesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecUpdatePolicy{}).Type1()):                                          RegionInstanceGroupManagerSpecUpdatePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecVersionTargetSize{}).Type1()):                                     RegionInstanceGroupManagerSpecVersionTargetSizeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecAppEngine{}).Type1()):                                             RegionNetworkEndpointGroupSpecAppEngineCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecCloudFunction{}).Type1()):                                         RegionNetworkEndpointGroupSpecCloudFunctionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecCloudRun{}).Type1()):                                              RegionNetworkEndpointGroupSpecCloudRunCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionPerInstanceConfigSpecPreservedState{}).Type1()):                                           RegionPerInstanceConfigSpecPreservedStateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecDefaultURLRedirect{}).Type1()):                                                  RegionURLMapSpecDefaultURLRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherDefaultURLRedirect{}).Type1()):                                       RegionURLMapSpecPathMatcherDefaultURLRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteAction{}).Type1()):                                      RegionURLMapSpecPathMatcherPathRuleRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}).Type1()):                            RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}).Type1()):                  RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}).Type1()):             RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}).Type1()):             RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()):   RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}).Type1()):                   RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}).Type1()):                           RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}).Type1()):              RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout{}).Type1()):                               RegionURLMapSpecPathMatcherPathRuleRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}).Type1()):                            RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}).Type1()):   RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleUrlRedirect{}).Type1()):                                      RegionURLMapSpecPathMatcherPathRuleUrlRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesHeaderAction{}).Type1()):                                   RegionURLMapSpecPathMatcherRouteRulesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}).Type1()):              RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteAction{}).Type1()):                                    RegionURLMapSpecPathMatcherRouteRulesRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}).Type1()):                          RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}).Type1()):                RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}).Type1()):           RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}).Type1()):           RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()): RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}).Type1()):                 RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}).Type1()):                         RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}).Type1()):            RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout{}).Type1()):                             RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}).Type1()):                          RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}).Type1()): RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesUrlRedirect{}).Type1()):                                    RegionURLMapSpecPathMatcherRouteRulesUrlRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ReservationSpecSpecificReservation{}).Type1()):                                                  ReservationSpecSpecificReservationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ReservationSpecSpecificReservationInstanceProperties{}).Type1()):                                ReservationSpecSpecificReservationInstancePropertiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecGroupPlacementPolicy{}).Type1()):                                              ResourcePolicySpecGroupPlacementPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicy{}).Type1()):                                            ResourcePolicySpecSnapshotSchedulePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy{}).Type1()):                             ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicySchedule{}).Type1()):                                    ResourcePolicySpecSnapshotSchedulePolicyScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule{}).Type1()):                       ResourcePolicySpecSnapshotSchedulePolicyScheduleDailyScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule{}).Type1()):                      ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlyScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule{}).Type1()):                      ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklyScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties{}).Type1()):                          ResourcePolicySpecSnapshotSchedulePolicySnapshotPropertiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouterSpecBgp{}).Type1()):                                                                       RouterSpecBgpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouterNATSpecLogConfig{}).Type1()):                                                              RouterNATSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatch{}).Type1()):                                                         SecurityPolicySpecRuleMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatchConfig{}).Type1()):                                                   SecurityPolicySpecRuleMatchConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatchExpr{}).Type1()):                                                     SecurityPolicySpecRuleMatchExprCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SnapshotSpecSnapshotEncryptionKey{}).Type1()):                                                   SnapshotSpecSnapshotEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SnapshotSpecSourceDiskEncryptionKey{}).Type1()):                                                 SnapshotSpecSourceDiskEncryptionKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkSpecLogConfig{}).Type1()):                                                             SubnetworkSpecLogConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkIamBindingSpecCondition{}).Type1()):                                                   SubnetworkIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkIamMemberSpecCondition{}).Type1()):                                                    SubnetworkIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteAction{}).Type1()):                                                        UrlMapSpecDefaultRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionCorsPolicy{}).Type1()):                                              UrlMapSpecDefaultRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicy{}).Type1()):                                    UrlMapSpecDefaultRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort{}).Type1()):                               UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay{}).Type1()):                               UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()):                     UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRequestMirrorPolicy{}).Type1()):                                     UrlMapSpecDefaultRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRetryPolicy{}).Type1()):                                             UrlMapSpecDefaultRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout{}).Type1()):                                UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionTimeout{}).Type1()):                                                 UrlMapSpecDefaultRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionUrlRewrite{}).Type1()):                                              UrlMapSpecDefaultRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction{}).Type1()):                     UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultURLRedirect{}).Type1()):                                                        UrlMapSpecDefaultURLRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecHeaderAction{}).Type1()):                                                              UrlMapSpecHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteAction{}).Type1()):                                             UrlMapSpecPathMatcherDefaultRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy{}).Type1()):                                   UrlMapSpecPathMatcherDefaultRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy{}).Type1()):                         UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort{}).Type1()):                    UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay{}).Type1()):                    UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()):          UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy{}).Type1()):                          UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy{}).Type1()):                                  UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout{}).Type1()):                     UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionTimeout{}).Type1()):                                      UrlMapSpecPathMatcherDefaultRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite{}).Type1()):                                   UrlMapSpecPathMatcherDefaultRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction{}).Type1()):          UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultURLRedirect{}).Type1()):                                             UrlMapSpecPathMatcherDefaultURLRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherHeaderAction{}).Type1()):                                                   UrlMapSpecPathMatcherHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteAction{}).Type1()):                                            UrlMapSpecPathMatcherPathRuleRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}).Type1()):                                  UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}).Type1()):                        UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}).Type1()):                   UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}).Type1()):                   UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()):         UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}).Type1()):                         UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}).Type1()):                                 UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}).Type1()):                    UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionTimeout{}).Type1()):                                     UrlMapSpecPathMatcherPathRuleRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}).Type1()):                                  UrlMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}).Type1()):         UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleUrlRedirect{}).Type1()):                                            UrlMapSpecPathMatcherPathRuleUrlRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesHeaderAction{}).Type1()):                                         UrlMapSpecPathMatcherRouteRulesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}).Type1()):                    UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteAction{}).Type1()):                                          UrlMapSpecPathMatcherRouteRulesRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}).Type1()):                                UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}).Type1()):                      UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}).Type1()):                 UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}).Type1()):                 UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1()):       UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}).Type1()):                       UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}).Type1()):                               UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}).Type1()):                  UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionTimeout{}).Type1()):                                   UrlMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}).Type1()):                                UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}).Type1()):       UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesUrlRedirect{}).Type1()):                                          UrlMapSpecPathMatcherRouteRulesUrlRedirectCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AutoscalerSpecAutoscalingPolicyCodec struct {
}

func (AutoscalerSpecAutoscalingPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscalerSpecAutoscalingPolicy)(ptr) == nil
}

func (AutoscalerSpecAutoscalingPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscalerSpecAutoscalingPolicy)(ptr)
	var objs []AutoscalerSpecAutoscalingPolicy
	if obj != nil {
		objs = []AutoscalerSpecAutoscalingPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscalerSpecAutoscalingPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscalerSpecAutoscalingPolicy)(ptr) = AutoscalerSpecAutoscalingPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscalerSpecAutoscalingPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscalerSpecAutoscalingPolicy)(ptr) = objs[0]
			} else {
				*(*AutoscalerSpecAutoscalingPolicy)(ptr) = AutoscalerSpecAutoscalingPolicy{}
			}
		} else {
			*(*AutoscalerSpecAutoscalingPolicy)(ptr) = AutoscalerSpecAutoscalingPolicy{}
		}
	default:
		iter.ReportError("decode AutoscalerSpecAutoscalingPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoscalerSpecAutoscalingPolicyCpuUtilizationCodec struct {
}

func (AutoscalerSpecAutoscalingPolicyCpuUtilizationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) == nil
}

func (AutoscalerSpecAutoscalingPolicyCpuUtilizationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr)
	var objs []AutoscalerSpecAutoscalingPolicyCpuUtilization
	if obj != nil {
		objs = []AutoscalerSpecAutoscalingPolicyCpuUtilization{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyCpuUtilization{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscalerSpecAutoscalingPolicyCpuUtilizationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) = AutoscalerSpecAutoscalingPolicyCpuUtilization{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscalerSpecAutoscalingPolicyCpuUtilization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyCpuUtilization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) = objs[0]
			} else {
				*(*AutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) = AutoscalerSpecAutoscalingPolicyCpuUtilization{}
			}
		} else {
			*(*AutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) = AutoscalerSpecAutoscalingPolicyCpuUtilization{}
		}
	default:
		iter.ReportError("decode AutoscalerSpecAutoscalingPolicyCpuUtilization", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec struct {
}

func (AutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) == nil
}

func (AutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr)
	var objs []AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization
	if obj != nil {
		objs = []AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) = AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) = objs[0]
			} else {
				*(*AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) = AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}
			}
		} else {
			*(*AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) = AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}
		}
	default:
		iter.ReportError("decode AutoscalerSpecAutoscalingPolicyLoadBalancingUtilization", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoscalerSpecAutoscalingPolicyScaleInControlCodec struct {
}

func (AutoscalerSpecAutoscalingPolicyScaleInControlCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) == nil
}

func (AutoscalerSpecAutoscalingPolicyScaleInControlCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscalerSpecAutoscalingPolicyScaleInControl)(ptr)
	var objs []AutoscalerSpecAutoscalingPolicyScaleInControl
	if obj != nil {
		objs = []AutoscalerSpecAutoscalingPolicyScaleInControl{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyScaleInControl{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscalerSpecAutoscalingPolicyScaleInControlCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) = AutoscalerSpecAutoscalingPolicyScaleInControl{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscalerSpecAutoscalingPolicyScaleInControl

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyScaleInControl{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) = objs[0]
			} else {
				*(*AutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) = AutoscalerSpecAutoscalingPolicyScaleInControl{}
			}
		} else {
			*(*AutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) = AutoscalerSpecAutoscalingPolicyScaleInControl{}
		}
	default:
		iter.ReportError("decode AutoscalerSpecAutoscalingPolicyScaleInControl", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec struct {
}

func (AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) == nil
}

func (AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr)
	var objs []AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas
	if obj != nil {
		objs = []AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) = AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) = objs[0]
			} else {
				*(*AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) = AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}
			}
		} else {
			*(*AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) = AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}
		}
	default:
		iter.ReportError("decode AutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendBucketSpecCdnPolicyCodec struct {
}

func (BackendBucketSpecCdnPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendBucketSpecCdnPolicy)(ptr) == nil
}

func (BackendBucketSpecCdnPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendBucketSpecCdnPolicy)(ptr)
	var objs []BackendBucketSpecCdnPolicy
	if obj != nil {
		objs = []BackendBucketSpecCdnPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendBucketSpecCdnPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendBucketSpecCdnPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendBucketSpecCdnPolicy)(ptr) = BackendBucketSpecCdnPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendBucketSpecCdnPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendBucketSpecCdnPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendBucketSpecCdnPolicy)(ptr) = objs[0]
			} else {
				*(*BackendBucketSpecCdnPolicy)(ptr) = BackendBucketSpecCdnPolicy{}
			}
		} else {
			*(*BackendBucketSpecCdnPolicy)(ptr) = BackendBucketSpecCdnPolicy{}
		}
	default:
		iter.ReportError("decode BackendBucketSpecCdnPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendServiceSpecCdnPolicyCodec struct {
}

func (BackendServiceSpecCdnPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendServiceSpecCdnPolicy)(ptr) == nil
}

func (BackendServiceSpecCdnPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendServiceSpecCdnPolicy)(ptr)
	var objs []BackendServiceSpecCdnPolicy
	if obj != nil {
		objs = []BackendServiceSpecCdnPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCdnPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendServiceSpecCdnPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendServiceSpecCdnPolicy)(ptr) = BackendServiceSpecCdnPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendServiceSpecCdnPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCdnPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendServiceSpecCdnPolicy)(ptr) = objs[0]
			} else {
				*(*BackendServiceSpecCdnPolicy)(ptr) = BackendServiceSpecCdnPolicy{}
			}
		} else {
			*(*BackendServiceSpecCdnPolicy)(ptr) = BackendServiceSpecCdnPolicy{}
		}
	default:
		iter.ReportError("decode BackendServiceSpecCdnPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendServiceSpecCdnPolicyCacheKeyPolicyCodec struct {
}

func (BackendServiceSpecCdnPolicyCacheKeyPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) == nil
}

func (BackendServiceSpecCdnPolicyCacheKeyPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr)
	var objs []BackendServiceSpecCdnPolicyCacheKeyPolicy
	if obj != nil {
		objs = []BackendServiceSpecCdnPolicyCacheKeyPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCdnPolicyCacheKeyPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendServiceSpecCdnPolicyCacheKeyPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) = BackendServiceSpecCdnPolicyCacheKeyPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendServiceSpecCdnPolicyCacheKeyPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCdnPolicyCacheKeyPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) = objs[0]
			} else {
				*(*BackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) = BackendServiceSpecCdnPolicyCacheKeyPolicy{}
			}
		} else {
			*(*BackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) = BackendServiceSpecCdnPolicyCacheKeyPolicy{}
		}
	default:
		iter.ReportError("decode BackendServiceSpecCdnPolicyCacheKeyPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendServiceSpecCircuitBreakersCodec struct {
}

func (BackendServiceSpecCircuitBreakersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendServiceSpecCircuitBreakers)(ptr) == nil
}

func (BackendServiceSpecCircuitBreakersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendServiceSpecCircuitBreakers)(ptr)
	var objs []BackendServiceSpecCircuitBreakers
	if obj != nil {
		objs = []BackendServiceSpecCircuitBreakers{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCircuitBreakers{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendServiceSpecCircuitBreakersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendServiceSpecCircuitBreakers)(ptr) = BackendServiceSpecCircuitBreakers{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendServiceSpecCircuitBreakers

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecCircuitBreakers{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendServiceSpecCircuitBreakers)(ptr) = objs[0]
			} else {
				*(*BackendServiceSpecCircuitBreakers)(ptr) = BackendServiceSpecCircuitBreakers{}
			}
		} else {
			*(*BackendServiceSpecCircuitBreakers)(ptr) = BackendServiceSpecCircuitBreakers{}
		}
	default:
		iter.ReportError("decode BackendServiceSpecCircuitBreakers", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendServiceSpecConsistentHashCodec struct {
}

func (BackendServiceSpecConsistentHashCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendServiceSpecConsistentHash)(ptr) == nil
}

func (BackendServiceSpecConsistentHashCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendServiceSpecConsistentHash)(ptr)
	var objs []BackendServiceSpecConsistentHash
	if obj != nil {
		objs = []BackendServiceSpecConsistentHash{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHash{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendServiceSpecConsistentHashCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendServiceSpecConsistentHash)(ptr) = BackendServiceSpecConsistentHash{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendServiceSpecConsistentHash

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHash{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendServiceSpecConsistentHash)(ptr) = objs[0]
			} else {
				*(*BackendServiceSpecConsistentHash)(ptr) = BackendServiceSpecConsistentHash{}
			}
		} else {
			*(*BackendServiceSpecConsistentHash)(ptr) = BackendServiceSpecConsistentHash{}
		}
	default:
		iter.ReportError("decode BackendServiceSpecConsistentHash", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendServiceSpecConsistentHashHttpCookieCodec struct {
}

func (BackendServiceSpecConsistentHashHttpCookieCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendServiceSpecConsistentHashHttpCookie)(ptr) == nil
}

func (BackendServiceSpecConsistentHashHttpCookieCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendServiceSpecConsistentHashHttpCookie)(ptr)
	var objs []BackendServiceSpecConsistentHashHttpCookie
	if obj != nil {
		objs = []BackendServiceSpecConsistentHashHttpCookie{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHashHttpCookie{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendServiceSpecConsistentHashHttpCookieCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendServiceSpecConsistentHashHttpCookie)(ptr) = BackendServiceSpecConsistentHashHttpCookie{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendServiceSpecConsistentHashHttpCookie

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHashHttpCookie{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendServiceSpecConsistentHashHttpCookie)(ptr) = objs[0]
			} else {
				*(*BackendServiceSpecConsistentHashHttpCookie)(ptr) = BackendServiceSpecConsistentHashHttpCookie{}
			}
		} else {
			*(*BackendServiceSpecConsistentHashHttpCookie)(ptr) = BackendServiceSpecConsistentHashHttpCookie{}
		}
	default:
		iter.ReportError("decode BackendServiceSpecConsistentHashHttpCookie", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendServiceSpecConsistentHashHttpCookieTtlCodec struct {
}

func (BackendServiceSpecConsistentHashHttpCookieTtlCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendServiceSpecConsistentHashHttpCookieTtl)(ptr) == nil
}

func (BackendServiceSpecConsistentHashHttpCookieTtlCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendServiceSpecConsistentHashHttpCookieTtl)(ptr)
	var objs []BackendServiceSpecConsistentHashHttpCookieTtl
	if obj != nil {
		objs = []BackendServiceSpecConsistentHashHttpCookieTtl{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHashHttpCookieTtl{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendServiceSpecConsistentHashHttpCookieTtlCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendServiceSpecConsistentHashHttpCookieTtl)(ptr) = BackendServiceSpecConsistentHashHttpCookieTtl{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendServiceSpecConsistentHashHttpCookieTtl

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecConsistentHashHttpCookieTtl{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendServiceSpecConsistentHashHttpCookieTtl)(ptr) = objs[0]
			} else {
				*(*BackendServiceSpecConsistentHashHttpCookieTtl)(ptr) = BackendServiceSpecConsistentHashHttpCookieTtl{}
			}
		} else {
			*(*BackendServiceSpecConsistentHashHttpCookieTtl)(ptr) = BackendServiceSpecConsistentHashHttpCookieTtl{}
		}
	default:
		iter.ReportError("decode BackendServiceSpecConsistentHashHttpCookieTtl", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendServiceSpecIapCodec struct {
}

func (BackendServiceSpecIapCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendServiceSpecIap)(ptr) == nil
}

func (BackendServiceSpecIapCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendServiceSpecIap)(ptr)
	var objs []BackendServiceSpecIap
	if obj != nil {
		objs = []BackendServiceSpecIap{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecIap{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendServiceSpecIapCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendServiceSpecIap)(ptr) = BackendServiceSpecIap{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendServiceSpecIap

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecIap{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendServiceSpecIap)(ptr) = objs[0]
			} else {
				*(*BackendServiceSpecIap)(ptr) = BackendServiceSpecIap{}
			}
		} else {
			*(*BackendServiceSpecIap)(ptr) = BackendServiceSpecIap{}
		}
	default:
		iter.ReportError("decode BackendServiceSpecIap", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendServiceSpecLogConfigCodec struct {
}

func (BackendServiceSpecLogConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendServiceSpecLogConfig)(ptr) == nil
}

func (BackendServiceSpecLogConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendServiceSpecLogConfig)(ptr)
	var objs []BackendServiceSpecLogConfig
	if obj != nil {
		objs = []BackendServiceSpecLogConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecLogConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendServiceSpecLogConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendServiceSpecLogConfig)(ptr) = BackendServiceSpecLogConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendServiceSpecLogConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecLogConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendServiceSpecLogConfig)(ptr) = objs[0]
			} else {
				*(*BackendServiceSpecLogConfig)(ptr) = BackendServiceSpecLogConfig{}
			}
		} else {
			*(*BackendServiceSpecLogConfig)(ptr) = BackendServiceSpecLogConfig{}
		}
	default:
		iter.ReportError("decode BackendServiceSpecLogConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendServiceSpecOutlierDetectionCodec struct {
}

func (BackendServiceSpecOutlierDetectionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendServiceSpecOutlierDetection)(ptr) == nil
}

func (BackendServiceSpecOutlierDetectionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendServiceSpecOutlierDetection)(ptr)
	var objs []BackendServiceSpecOutlierDetection
	if obj != nil {
		objs = []BackendServiceSpecOutlierDetection{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetection{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendServiceSpecOutlierDetectionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendServiceSpecOutlierDetection)(ptr) = BackendServiceSpecOutlierDetection{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendServiceSpecOutlierDetection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendServiceSpecOutlierDetection)(ptr) = objs[0]
			} else {
				*(*BackendServiceSpecOutlierDetection)(ptr) = BackendServiceSpecOutlierDetection{}
			}
		} else {
			*(*BackendServiceSpecOutlierDetection)(ptr) = BackendServiceSpecOutlierDetection{}
		}
	default:
		iter.ReportError("decode BackendServiceSpecOutlierDetection", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendServiceSpecOutlierDetectionBaseEjectionTimeCodec struct {
}

func (BackendServiceSpecOutlierDetectionBaseEjectionTimeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) == nil
}

func (BackendServiceSpecOutlierDetectionBaseEjectionTimeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr)
	var objs []BackendServiceSpecOutlierDetectionBaseEjectionTime
	if obj != nil {
		objs = []BackendServiceSpecOutlierDetectionBaseEjectionTime{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetectionBaseEjectionTime{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendServiceSpecOutlierDetectionBaseEjectionTimeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) = BackendServiceSpecOutlierDetectionBaseEjectionTime{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendServiceSpecOutlierDetectionBaseEjectionTime

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetectionBaseEjectionTime{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) = objs[0]
			} else {
				*(*BackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) = BackendServiceSpecOutlierDetectionBaseEjectionTime{}
			}
		} else {
			*(*BackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) = BackendServiceSpecOutlierDetectionBaseEjectionTime{}
		}
	default:
		iter.ReportError("decode BackendServiceSpecOutlierDetectionBaseEjectionTime", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendServiceSpecOutlierDetectionIntervalCodec struct {
}

func (BackendServiceSpecOutlierDetectionIntervalCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendServiceSpecOutlierDetectionInterval)(ptr) == nil
}

func (BackendServiceSpecOutlierDetectionIntervalCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendServiceSpecOutlierDetectionInterval)(ptr)
	var objs []BackendServiceSpecOutlierDetectionInterval
	if obj != nil {
		objs = []BackendServiceSpecOutlierDetectionInterval{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetectionInterval{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendServiceSpecOutlierDetectionIntervalCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendServiceSpecOutlierDetectionInterval)(ptr) = BackendServiceSpecOutlierDetectionInterval{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendServiceSpecOutlierDetectionInterval

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendServiceSpecOutlierDetectionInterval{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendServiceSpecOutlierDetectionInterval)(ptr) = objs[0]
			} else {
				*(*BackendServiceSpecOutlierDetectionInterval)(ptr) = BackendServiceSpecOutlierDetectionInterval{}
			}
		} else {
			*(*BackendServiceSpecOutlierDetectionInterval)(ptr) = BackendServiceSpecOutlierDetectionInterval{}
		}
	default:
		iter.ReportError("decode BackendServiceSpecOutlierDetectionInterval", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiskSpecDiskEncryptionKeyCodec struct {
}

func (DiskSpecDiskEncryptionKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiskSpecDiskEncryptionKey)(ptr) == nil
}

func (DiskSpecDiskEncryptionKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiskSpecDiskEncryptionKey)(ptr)
	var objs []DiskSpecDiskEncryptionKey
	if obj != nil {
		objs = []DiskSpecDiskEncryptionKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecDiskEncryptionKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiskSpecDiskEncryptionKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiskSpecDiskEncryptionKey)(ptr) = DiskSpecDiskEncryptionKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiskSpecDiskEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecDiskEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiskSpecDiskEncryptionKey)(ptr) = objs[0]
			} else {
				*(*DiskSpecDiskEncryptionKey)(ptr) = DiskSpecDiskEncryptionKey{}
			}
		} else {
			*(*DiskSpecDiskEncryptionKey)(ptr) = DiskSpecDiskEncryptionKey{}
		}
	default:
		iter.ReportError("decode DiskSpecDiskEncryptionKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiskSpecSourceImageEncryptionKeyCodec struct {
}

func (DiskSpecSourceImageEncryptionKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiskSpecSourceImageEncryptionKey)(ptr) == nil
}

func (DiskSpecSourceImageEncryptionKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiskSpecSourceImageEncryptionKey)(ptr)
	var objs []DiskSpecSourceImageEncryptionKey
	if obj != nil {
		objs = []DiskSpecSourceImageEncryptionKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecSourceImageEncryptionKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiskSpecSourceImageEncryptionKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiskSpecSourceImageEncryptionKey)(ptr) = DiskSpecSourceImageEncryptionKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiskSpecSourceImageEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecSourceImageEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiskSpecSourceImageEncryptionKey)(ptr) = objs[0]
			} else {
				*(*DiskSpecSourceImageEncryptionKey)(ptr) = DiskSpecSourceImageEncryptionKey{}
			}
		} else {
			*(*DiskSpecSourceImageEncryptionKey)(ptr) = DiskSpecSourceImageEncryptionKey{}
		}
	default:
		iter.ReportError("decode DiskSpecSourceImageEncryptionKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiskSpecSourceSnapshotEncryptionKeyCodec struct {
}

func (DiskSpecSourceSnapshotEncryptionKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiskSpecSourceSnapshotEncryptionKey)(ptr) == nil
}

func (DiskSpecSourceSnapshotEncryptionKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiskSpecSourceSnapshotEncryptionKey)(ptr)
	var objs []DiskSpecSourceSnapshotEncryptionKey
	if obj != nil {
		objs = []DiskSpecSourceSnapshotEncryptionKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecSourceSnapshotEncryptionKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiskSpecSourceSnapshotEncryptionKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiskSpecSourceSnapshotEncryptionKey)(ptr) = DiskSpecSourceSnapshotEncryptionKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiskSpecSourceSnapshotEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskSpecSourceSnapshotEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiskSpecSourceSnapshotEncryptionKey)(ptr) = objs[0]
			} else {
				*(*DiskSpecSourceSnapshotEncryptionKey)(ptr) = DiskSpecSourceSnapshotEncryptionKey{}
			}
		} else {
			*(*DiskSpecSourceSnapshotEncryptionKey)(ptr) = DiskSpecSourceSnapshotEncryptionKey{}
		}
	default:
		iter.ReportError("decode DiskSpecSourceSnapshotEncryptionKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiskIamBindingSpecConditionCodec struct {
}

func (DiskIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiskIamBindingSpecCondition)(ptr) == nil
}

func (DiskIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiskIamBindingSpecCondition)(ptr)
	var objs []DiskIamBindingSpecCondition
	if obj != nil {
		objs = []DiskIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiskIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiskIamBindingSpecCondition)(ptr) = DiskIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiskIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiskIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*DiskIamBindingSpecCondition)(ptr) = DiskIamBindingSpecCondition{}
			}
		} else {
			*(*DiskIamBindingSpecCondition)(ptr) = DiskIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode DiskIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiskIamMemberSpecConditionCodec struct {
}

func (DiskIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiskIamMemberSpecCondition)(ptr) == nil
}

func (DiskIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiskIamMemberSpecCondition)(ptr)
	var objs []DiskIamMemberSpecCondition
	if obj != nil {
		objs = []DiskIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiskIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiskIamMemberSpecCondition)(ptr) = DiskIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiskIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiskIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiskIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*DiskIamMemberSpecCondition)(ptr) = DiskIamMemberSpecCondition{}
			}
		} else {
			*(*DiskIamMemberSpecCondition)(ptr) = DiskIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode DiskIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirewallSpecLogConfigCodec struct {
}

func (FirewallSpecLogConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirewallSpecLogConfig)(ptr) == nil
}

func (FirewallSpecLogConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirewallSpecLogConfig)(ptr)
	var objs []FirewallSpecLogConfig
	if obj != nil {
		objs = []FirewallSpecLogConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecLogConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirewallSpecLogConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirewallSpecLogConfig)(ptr) = FirewallSpecLogConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirewallSpecLogConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallSpecLogConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirewallSpecLogConfig)(ptr) = objs[0]
			} else {
				*(*FirewallSpecLogConfig)(ptr) = FirewallSpecLogConfig{}
			}
		} else {
			*(*FirewallSpecLogConfig)(ptr) = FirewallSpecLogConfig{}
		}
	default:
		iter.ReportError("decode FirewallSpecLogConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HealthCheckSpecGrpcHealthCheckCodec struct {
}

func (HealthCheckSpecGrpcHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HealthCheckSpecGrpcHealthCheck)(ptr) == nil
}

func (HealthCheckSpecGrpcHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HealthCheckSpecGrpcHealthCheck)(ptr)
	var objs []HealthCheckSpecGrpcHealthCheck
	if obj != nil {
		objs = []HealthCheckSpecGrpcHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecGrpcHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HealthCheckSpecGrpcHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HealthCheckSpecGrpcHealthCheck)(ptr) = HealthCheckSpecGrpcHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HealthCheckSpecGrpcHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecGrpcHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HealthCheckSpecGrpcHealthCheck)(ptr) = objs[0]
			} else {
				*(*HealthCheckSpecGrpcHealthCheck)(ptr) = HealthCheckSpecGrpcHealthCheck{}
			}
		} else {
			*(*HealthCheckSpecGrpcHealthCheck)(ptr) = HealthCheckSpecGrpcHealthCheck{}
		}
	default:
		iter.ReportError("decode HealthCheckSpecGrpcHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HealthCheckSpecHttp2HealthCheckCodec struct {
}

func (HealthCheckSpecHttp2HealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HealthCheckSpecHttp2HealthCheck)(ptr) == nil
}

func (HealthCheckSpecHttp2HealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HealthCheckSpecHttp2HealthCheck)(ptr)
	var objs []HealthCheckSpecHttp2HealthCheck
	if obj != nil {
		objs = []HealthCheckSpecHttp2HealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttp2HealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HealthCheckSpecHttp2HealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HealthCheckSpecHttp2HealthCheck)(ptr) = HealthCheckSpecHttp2HealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HealthCheckSpecHttp2HealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttp2HealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HealthCheckSpecHttp2HealthCheck)(ptr) = objs[0]
			} else {
				*(*HealthCheckSpecHttp2HealthCheck)(ptr) = HealthCheckSpecHttp2HealthCheck{}
			}
		} else {
			*(*HealthCheckSpecHttp2HealthCheck)(ptr) = HealthCheckSpecHttp2HealthCheck{}
		}
	default:
		iter.ReportError("decode HealthCheckSpecHttp2HealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HealthCheckSpecHttpHealthCheckCodec struct {
}

func (HealthCheckSpecHttpHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HealthCheckSpecHttpHealthCheck)(ptr) == nil
}

func (HealthCheckSpecHttpHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HealthCheckSpecHttpHealthCheck)(ptr)
	var objs []HealthCheckSpecHttpHealthCheck
	if obj != nil {
		objs = []HealthCheckSpecHttpHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttpHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HealthCheckSpecHttpHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HealthCheckSpecHttpHealthCheck)(ptr) = HealthCheckSpecHttpHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HealthCheckSpecHttpHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttpHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HealthCheckSpecHttpHealthCheck)(ptr) = objs[0]
			} else {
				*(*HealthCheckSpecHttpHealthCheck)(ptr) = HealthCheckSpecHttpHealthCheck{}
			}
		} else {
			*(*HealthCheckSpecHttpHealthCheck)(ptr) = HealthCheckSpecHttpHealthCheck{}
		}
	default:
		iter.ReportError("decode HealthCheckSpecHttpHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HealthCheckSpecHttpsHealthCheckCodec struct {
}

func (HealthCheckSpecHttpsHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HealthCheckSpecHttpsHealthCheck)(ptr) == nil
}

func (HealthCheckSpecHttpsHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HealthCheckSpecHttpsHealthCheck)(ptr)
	var objs []HealthCheckSpecHttpsHealthCheck
	if obj != nil {
		objs = []HealthCheckSpecHttpsHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttpsHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HealthCheckSpecHttpsHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HealthCheckSpecHttpsHealthCheck)(ptr) = HealthCheckSpecHttpsHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HealthCheckSpecHttpsHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecHttpsHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HealthCheckSpecHttpsHealthCheck)(ptr) = objs[0]
			} else {
				*(*HealthCheckSpecHttpsHealthCheck)(ptr) = HealthCheckSpecHttpsHealthCheck{}
			}
		} else {
			*(*HealthCheckSpecHttpsHealthCheck)(ptr) = HealthCheckSpecHttpsHealthCheck{}
		}
	default:
		iter.ReportError("decode HealthCheckSpecHttpsHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HealthCheckSpecSslHealthCheckCodec struct {
}

func (HealthCheckSpecSslHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HealthCheckSpecSslHealthCheck)(ptr) == nil
}

func (HealthCheckSpecSslHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HealthCheckSpecSslHealthCheck)(ptr)
	var objs []HealthCheckSpecSslHealthCheck
	if obj != nil {
		objs = []HealthCheckSpecSslHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecSslHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HealthCheckSpecSslHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HealthCheckSpecSslHealthCheck)(ptr) = HealthCheckSpecSslHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HealthCheckSpecSslHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecSslHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HealthCheckSpecSslHealthCheck)(ptr) = objs[0]
			} else {
				*(*HealthCheckSpecSslHealthCheck)(ptr) = HealthCheckSpecSslHealthCheck{}
			}
		} else {
			*(*HealthCheckSpecSslHealthCheck)(ptr) = HealthCheckSpecSslHealthCheck{}
		}
	default:
		iter.ReportError("decode HealthCheckSpecSslHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HealthCheckSpecTcpHealthCheckCodec struct {
}

func (HealthCheckSpecTcpHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HealthCheckSpecTcpHealthCheck)(ptr) == nil
}

func (HealthCheckSpecTcpHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HealthCheckSpecTcpHealthCheck)(ptr)
	var objs []HealthCheckSpecTcpHealthCheck
	if obj != nil {
		objs = []HealthCheckSpecTcpHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecTcpHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HealthCheckSpecTcpHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HealthCheckSpecTcpHealthCheck)(ptr) = HealthCheckSpecTcpHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HealthCheckSpecTcpHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HealthCheckSpecTcpHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HealthCheckSpecTcpHealthCheck)(ptr) = objs[0]
			} else {
				*(*HealthCheckSpecTcpHealthCheck)(ptr) = HealthCheckSpecTcpHealthCheck{}
			}
		} else {
			*(*HealthCheckSpecTcpHealthCheck)(ptr) = HealthCheckSpecTcpHealthCheck{}
		}
	default:
		iter.ReportError("decode HealthCheckSpecTcpHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ImageSpecRawDiskCodec struct {
}

func (ImageSpecRawDiskCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ImageSpecRawDisk)(ptr) == nil
}

func (ImageSpecRawDiskCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ImageSpecRawDisk)(ptr)
	var objs []ImageSpecRawDisk
	if obj != nil {
		objs = []ImageSpecRawDisk{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecRawDisk{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ImageSpecRawDiskCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ImageSpecRawDisk)(ptr) = ImageSpecRawDisk{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ImageSpecRawDisk

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageSpecRawDisk{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ImageSpecRawDisk)(ptr) = objs[0]
			} else {
				*(*ImageSpecRawDisk)(ptr) = ImageSpecRawDisk{}
			}
		} else {
			*(*ImageSpecRawDisk)(ptr) = ImageSpecRawDisk{}
		}
	default:
		iter.ReportError("decode ImageSpecRawDisk", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ImageIamBindingSpecConditionCodec struct {
}

func (ImageIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ImageIamBindingSpecCondition)(ptr) == nil
}

func (ImageIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ImageIamBindingSpecCondition)(ptr)
	var objs []ImageIamBindingSpecCondition
	if obj != nil {
		objs = []ImageIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ImageIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ImageIamBindingSpecCondition)(ptr) = ImageIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ImageIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ImageIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*ImageIamBindingSpecCondition)(ptr) = ImageIamBindingSpecCondition{}
			}
		} else {
			*(*ImageIamBindingSpecCondition)(ptr) = ImageIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode ImageIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ImageIamMemberSpecConditionCodec struct {
}

func (ImageIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ImageIamMemberSpecCondition)(ptr) == nil
}

func (ImageIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ImageIamMemberSpecCondition)(ptr)
	var objs []ImageIamMemberSpecCondition
	if obj != nil {
		objs = []ImageIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ImageIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ImageIamMemberSpecCondition)(ptr) = ImageIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ImageIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ImageIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ImageIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*ImageIamMemberSpecCondition)(ptr) = ImageIamMemberSpecCondition{}
			}
		} else {
			*(*ImageIamMemberSpecCondition)(ptr) = ImageIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode ImageIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecBootDiskCodec struct {
}

func (InstanceSpecBootDiskCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecBootDisk)(ptr) == nil
}

func (InstanceSpecBootDiskCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecBootDisk)(ptr)
	var objs []InstanceSpecBootDisk
	if obj != nil {
		objs = []InstanceSpecBootDisk{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecBootDisk{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecBootDiskCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecBootDisk)(ptr) = InstanceSpecBootDisk{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecBootDisk

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecBootDisk{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecBootDisk)(ptr) = objs[0]
			} else {
				*(*InstanceSpecBootDisk)(ptr) = InstanceSpecBootDisk{}
			}
		} else {
			*(*InstanceSpecBootDisk)(ptr) = InstanceSpecBootDisk{}
		}
	default:
		iter.ReportError("decode InstanceSpecBootDisk", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecBootDiskInitializeParamsCodec struct {
}

func (InstanceSpecBootDiskInitializeParamsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecBootDiskInitializeParams)(ptr) == nil
}

func (InstanceSpecBootDiskInitializeParamsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecBootDiskInitializeParams)(ptr)
	var objs []InstanceSpecBootDiskInitializeParams
	if obj != nil {
		objs = []InstanceSpecBootDiskInitializeParams{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecBootDiskInitializeParams{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecBootDiskInitializeParamsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecBootDiskInitializeParams)(ptr) = InstanceSpecBootDiskInitializeParams{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecBootDiskInitializeParams

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecBootDiskInitializeParams{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecBootDiskInitializeParams)(ptr) = objs[0]
			} else {
				*(*InstanceSpecBootDiskInitializeParams)(ptr) = InstanceSpecBootDiskInitializeParams{}
			}
		} else {
			*(*InstanceSpecBootDiskInitializeParams)(ptr) = InstanceSpecBootDiskInitializeParams{}
		}
	default:
		iter.ReportError("decode InstanceSpecBootDiskInitializeParams", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecConfidentialInstanceConfigCodec struct {
}

func (InstanceSpecConfidentialInstanceConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecConfidentialInstanceConfig)(ptr) == nil
}

func (InstanceSpecConfidentialInstanceConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecConfidentialInstanceConfig)(ptr)
	var objs []InstanceSpecConfidentialInstanceConfig
	if obj != nil {
		objs = []InstanceSpecConfidentialInstanceConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfidentialInstanceConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecConfidentialInstanceConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecConfidentialInstanceConfig)(ptr) = InstanceSpecConfidentialInstanceConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecConfidentialInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfidentialInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecConfidentialInstanceConfig)(ptr) = objs[0]
			} else {
				*(*InstanceSpecConfidentialInstanceConfig)(ptr) = InstanceSpecConfidentialInstanceConfig{}
			}
		} else {
			*(*InstanceSpecConfidentialInstanceConfig)(ptr) = InstanceSpecConfidentialInstanceConfig{}
		}
	default:
		iter.ReportError("decode InstanceSpecConfidentialInstanceConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecSchedulingCodec struct {
}

func (InstanceSpecSchedulingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecScheduling)(ptr) == nil
}

func (InstanceSpecSchedulingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecScheduling)(ptr)
	var objs []InstanceSpecScheduling
	if obj != nil {
		objs = []InstanceSpecScheduling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecScheduling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecSchedulingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecScheduling)(ptr) = InstanceSpecScheduling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecScheduling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecScheduling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecScheduling)(ptr) = objs[0]
			} else {
				*(*InstanceSpecScheduling)(ptr) = InstanceSpecScheduling{}
			}
		} else {
			*(*InstanceSpecScheduling)(ptr) = InstanceSpecScheduling{}
		}
	default:
		iter.ReportError("decode InstanceSpecScheduling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecServiceAccountCodec struct {
}

func (InstanceSpecServiceAccountCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecServiceAccount)(ptr) == nil
}

func (InstanceSpecServiceAccountCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecServiceAccount)(ptr)
	var objs []InstanceSpecServiceAccount
	if obj != nil {
		objs = []InstanceSpecServiceAccount{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecServiceAccount{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecServiceAccountCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecServiceAccount)(ptr) = InstanceSpecServiceAccount{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecServiceAccount

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecServiceAccount{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecServiceAccount)(ptr) = objs[0]
			} else {
				*(*InstanceSpecServiceAccount)(ptr) = InstanceSpecServiceAccount{}
			}
		} else {
			*(*InstanceSpecServiceAccount)(ptr) = InstanceSpecServiceAccount{}
		}
	default:
		iter.ReportError("decode InstanceSpecServiceAccount", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecShieldedInstanceConfigCodec struct {
}

func (InstanceSpecShieldedInstanceConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecShieldedInstanceConfig)(ptr) == nil
}

func (InstanceSpecShieldedInstanceConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecShieldedInstanceConfig)(ptr)
	var objs []InstanceSpecShieldedInstanceConfig
	if obj != nil {
		objs = []InstanceSpecShieldedInstanceConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecShieldedInstanceConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecShieldedInstanceConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecShieldedInstanceConfig)(ptr) = InstanceSpecShieldedInstanceConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecShieldedInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecShieldedInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecShieldedInstanceConfig)(ptr) = objs[0]
			} else {
				*(*InstanceSpecShieldedInstanceConfig)(ptr) = InstanceSpecShieldedInstanceConfig{}
			}
		} else {
			*(*InstanceSpecShieldedInstanceConfig)(ptr) = InstanceSpecShieldedInstanceConfig{}
		}
	default:
		iter.ReportError("decode InstanceSpecShieldedInstanceConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceFromTemplateSpecBootDiskCodec struct {
}

func (InstanceFromTemplateSpecBootDiskCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceFromTemplateSpecBootDisk)(ptr) == nil
}

func (InstanceFromTemplateSpecBootDiskCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceFromTemplateSpecBootDisk)(ptr)
	var objs []InstanceFromTemplateSpecBootDisk
	if obj != nil {
		objs = []InstanceFromTemplateSpecBootDisk{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecBootDisk{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceFromTemplateSpecBootDiskCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceFromTemplateSpecBootDisk)(ptr) = InstanceFromTemplateSpecBootDisk{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceFromTemplateSpecBootDisk

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecBootDisk{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceFromTemplateSpecBootDisk)(ptr) = objs[0]
			} else {
				*(*InstanceFromTemplateSpecBootDisk)(ptr) = InstanceFromTemplateSpecBootDisk{}
			}
		} else {
			*(*InstanceFromTemplateSpecBootDisk)(ptr) = InstanceFromTemplateSpecBootDisk{}
		}
	default:
		iter.ReportError("decode InstanceFromTemplateSpecBootDisk", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceFromTemplateSpecBootDiskInitializeParamsCodec struct {
}

func (InstanceFromTemplateSpecBootDiskInitializeParamsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceFromTemplateSpecBootDiskInitializeParams)(ptr) == nil
}

func (InstanceFromTemplateSpecBootDiskInitializeParamsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceFromTemplateSpecBootDiskInitializeParams)(ptr)
	var objs []InstanceFromTemplateSpecBootDiskInitializeParams
	if obj != nil {
		objs = []InstanceFromTemplateSpecBootDiskInitializeParams{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecBootDiskInitializeParams{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceFromTemplateSpecBootDiskInitializeParamsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceFromTemplateSpecBootDiskInitializeParams)(ptr) = InstanceFromTemplateSpecBootDiskInitializeParams{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceFromTemplateSpecBootDiskInitializeParams

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecBootDiskInitializeParams{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceFromTemplateSpecBootDiskInitializeParams)(ptr) = objs[0]
			} else {
				*(*InstanceFromTemplateSpecBootDiskInitializeParams)(ptr) = InstanceFromTemplateSpecBootDiskInitializeParams{}
			}
		} else {
			*(*InstanceFromTemplateSpecBootDiskInitializeParams)(ptr) = InstanceFromTemplateSpecBootDiskInitializeParams{}
		}
	default:
		iter.ReportError("decode InstanceFromTemplateSpecBootDiskInitializeParams", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceFromTemplateSpecConfidentialInstanceConfigCodec struct {
}

func (InstanceFromTemplateSpecConfidentialInstanceConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceFromTemplateSpecConfidentialInstanceConfig)(ptr) == nil
}

func (InstanceFromTemplateSpecConfidentialInstanceConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceFromTemplateSpecConfidentialInstanceConfig)(ptr)
	var objs []InstanceFromTemplateSpecConfidentialInstanceConfig
	if obj != nil {
		objs = []InstanceFromTemplateSpecConfidentialInstanceConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecConfidentialInstanceConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceFromTemplateSpecConfidentialInstanceConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceFromTemplateSpecConfidentialInstanceConfig)(ptr) = InstanceFromTemplateSpecConfidentialInstanceConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceFromTemplateSpecConfidentialInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecConfidentialInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceFromTemplateSpecConfidentialInstanceConfig)(ptr) = objs[0]
			} else {
				*(*InstanceFromTemplateSpecConfidentialInstanceConfig)(ptr) = InstanceFromTemplateSpecConfidentialInstanceConfig{}
			}
		} else {
			*(*InstanceFromTemplateSpecConfidentialInstanceConfig)(ptr) = InstanceFromTemplateSpecConfidentialInstanceConfig{}
		}
	default:
		iter.ReportError("decode InstanceFromTemplateSpecConfidentialInstanceConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceFromTemplateSpecSchedulingCodec struct {
}

func (InstanceFromTemplateSpecSchedulingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceFromTemplateSpecScheduling)(ptr) == nil
}

func (InstanceFromTemplateSpecSchedulingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceFromTemplateSpecScheduling)(ptr)
	var objs []InstanceFromTemplateSpecScheduling
	if obj != nil {
		objs = []InstanceFromTemplateSpecScheduling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecScheduling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceFromTemplateSpecSchedulingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceFromTemplateSpecScheduling)(ptr) = InstanceFromTemplateSpecScheduling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceFromTemplateSpecScheduling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecScheduling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceFromTemplateSpecScheduling)(ptr) = objs[0]
			} else {
				*(*InstanceFromTemplateSpecScheduling)(ptr) = InstanceFromTemplateSpecScheduling{}
			}
		} else {
			*(*InstanceFromTemplateSpecScheduling)(ptr) = InstanceFromTemplateSpecScheduling{}
		}
	default:
		iter.ReportError("decode InstanceFromTemplateSpecScheduling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceFromTemplateSpecServiceAccountCodec struct {
}

func (InstanceFromTemplateSpecServiceAccountCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceFromTemplateSpecServiceAccount)(ptr) == nil
}

func (InstanceFromTemplateSpecServiceAccountCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceFromTemplateSpecServiceAccount)(ptr)
	var objs []InstanceFromTemplateSpecServiceAccount
	if obj != nil {
		objs = []InstanceFromTemplateSpecServiceAccount{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecServiceAccount{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceFromTemplateSpecServiceAccountCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceFromTemplateSpecServiceAccount)(ptr) = InstanceFromTemplateSpecServiceAccount{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceFromTemplateSpecServiceAccount

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecServiceAccount{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceFromTemplateSpecServiceAccount)(ptr) = objs[0]
			} else {
				*(*InstanceFromTemplateSpecServiceAccount)(ptr) = InstanceFromTemplateSpecServiceAccount{}
			}
		} else {
			*(*InstanceFromTemplateSpecServiceAccount)(ptr) = InstanceFromTemplateSpecServiceAccount{}
		}
	default:
		iter.ReportError("decode InstanceFromTemplateSpecServiceAccount", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceFromTemplateSpecShieldedInstanceConfigCodec struct {
}

func (InstanceFromTemplateSpecShieldedInstanceConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceFromTemplateSpecShieldedInstanceConfig)(ptr) == nil
}

func (InstanceFromTemplateSpecShieldedInstanceConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceFromTemplateSpecShieldedInstanceConfig)(ptr)
	var objs []InstanceFromTemplateSpecShieldedInstanceConfig
	if obj != nil {
		objs = []InstanceFromTemplateSpecShieldedInstanceConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecShieldedInstanceConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceFromTemplateSpecShieldedInstanceConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceFromTemplateSpecShieldedInstanceConfig)(ptr) = InstanceFromTemplateSpecShieldedInstanceConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceFromTemplateSpecShieldedInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceFromTemplateSpecShieldedInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceFromTemplateSpecShieldedInstanceConfig)(ptr) = objs[0]
			} else {
				*(*InstanceFromTemplateSpecShieldedInstanceConfig)(ptr) = InstanceFromTemplateSpecShieldedInstanceConfig{}
			}
		} else {
			*(*InstanceFromTemplateSpecShieldedInstanceConfig)(ptr) = InstanceFromTemplateSpecShieldedInstanceConfig{}
		}
	default:
		iter.ReportError("decode InstanceFromTemplateSpecShieldedInstanceConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceGroupManagerSpecAutoHealingPoliciesCodec struct {
}

func (InstanceGroupManagerSpecAutoHealingPoliciesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceGroupManagerSpecAutoHealingPolicies)(ptr) == nil
}

func (InstanceGroupManagerSpecAutoHealingPoliciesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceGroupManagerSpecAutoHealingPolicies)(ptr)
	var objs []InstanceGroupManagerSpecAutoHealingPolicies
	if obj != nil {
		objs = []InstanceGroupManagerSpecAutoHealingPolicies{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecAutoHealingPolicies{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceGroupManagerSpecAutoHealingPoliciesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceGroupManagerSpecAutoHealingPolicies)(ptr) = InstanceGroupManagerSpecAutoHealingPolicies{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceGroupManagerSpecAutoHealingPolicies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecAutoHealingPolicies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceGroupManagerSpecAutoHealingPolicies)(ptr) = objs[0]
			} else {
				*(*InstanceGroupManagerSpecAutoHealingPolicies)(ptr) = InstanceGroupManagerSpecAutoHealingPolicies{}
			}
		} else {
			*(*InstanceGroupManagerSpecAutoHealingPolicies)(ptr) = InstanceGroupManagerSpecAutoHealingPolicies{}
		}
	default:
		iter.ReportError("decode InstanceGroupManagerSpecAutoHealingPolicies", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceGroupManagerSpecUpdatePolicyCodec struct {
}

func (InstanceGroupManagerSpecUpdatePolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceGroupManagerSpecUpdatePolicy)(ptr) == nil
}

func (InstanceGroupManagerSpecUpdatePolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceGroupManagerSpecUpdatePolicy)(ptr)
	var objs []InstanceGroupManagerSpecUpdatePolicy
	if obj != nil {
		objs = []InstanceGroupManagerSpecUpdatePolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecUpdatePolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceGroupManagerSpecUpdatePolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceGroupManagerSpecUpdatePolicy)(ptr) = InstanceGroupManagerSpecUpdatePolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceGroupManagerSpecUpdatePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecUpdatePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceGroupManagerSpecUpdatePolicy)(ptr) = objs[0]
			} else {
				*(*InstanceGroupManagerSpecUpdatePolicy)(ptr) = InstanceGroupManagerSpecUpdatePolicy{}
			}
		} else {
			*(*InstanceGroupManagerSpecUpdatePolicy)(ptr) = InstanceGroupManagerSpecUpdatePolicy{}
		}
	default:
		iter.ReportError("decode InstanceGroupManagerSpecUpdatePolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceGroupManagerSpecVersionTargetSizeCodec struct {
}

func (InstanceGroupManagerSpecVersionTargetSizeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceGroupManagerSpecVersionTargetSize)(ptr) == nil
}

func (InstanceGroupManagerSpecVersionTargetSizeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceGroupManagerSpecVersionTargetSize)(ptr)
	var objs []InstanceGroupManagerSpecVersionTargetSize
	if obj != nil {
		objs = []InstanceGroupManagerSpecVersionTargetSize{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecVersionTargetSize{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceGroupManagerSpecVersionTargetSizeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceGroupManagerSpecVersionTargetSize)(ptr) = InstanceGroupManagerSpecVersionTargetSize{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceGroupManagerSpecVersionTargetSize

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceGroupManagerSpecVersionTargetSize{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceGroupManagerSpecVersionTargetSize)(ptr) = objs[0]
			} else {
				*(*InstanceGroupManagerSpecVersionTargetSize)(ptr) = InstanceGroupManagerSpecVersionTargetSize{}
			}
		} else {
			*(*InstanceGroupManagerSpecVersionTargetSize)(ptr) = InstanceGroupManagerSpecVersionTargetSize{}
		}
	default:
		iter.ReportError("decode InstanceGroupManagerSpecVersionTargetSize", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceIamBindingSpecConditionCodec struct {
}

func (InstanceIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceIamBindingSpecCondition)(ptr) == nil
}

func (InstanceIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceIamBindingSpecCondition)(ptr)
	var objs []InstanceIamBindingSpecCondition
	if obj != nil {
		objs = []InstanceIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceIamBindingSpecCondition)(ptr) = InstanceIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*InstanceIamBindingSpecCondition)(ptr) = InstanceIamBindingSpecCondition{}
			}
		} else {
			*(*InstanceIamBindingSpecCondition)(ptr) = InstanceIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode InstanceIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceIamMemberSpecConditionCodec struct {
}

func (InstanceIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceIamMemberSpecCondition)(ptr) == nil
}

func (InstanceIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceIamMemberSpecCondition)(ptr)
	var objs []InstanceIamMemberSpecCondition
	if obj != nil {
		objs = []InstanceIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceIamMemberSpecCondition)(ptr) = InstanceIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*InstanceIamMemberSpecCondition)(ptr) = InstanceIamMemberSpecCondition{}
			}
		} else {
			*(*InstanceIamMemberSpecCondition)(ptr) = InstanceIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode InstanceIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceTemplateSpecConfidentialInstanceConfigCodec struct {
}

func (InstanceTemplateSpecConfidentialInstanceConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceTemplateSpecConfidentialInstanceConfig)(ptr) == nil
}

func (InstanceTemplateSpecConfidentialInstanceConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceTemplateSpecConfidentialInstanceConfig)(ptr)
	var objs []InstanceTemplateSpecConfidentialInstanceConfig
	if obj != nil {
		objs = []InstanceTemplateSpecConfidentialInstanceConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecConfidentialInstanceConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceTemplateSpecConfidentialInstanceConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceTemplateSpecConfidentialInstanceConfig)(ptr) = InstanceTemplateSpecConfidentialInstanceConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceTemplateSpecConfidentialInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecConfidentialInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceTemplateSpecConfidentialInstanceConfig)(ptr) = objs[0]
			} else {
				*(*InstanceTemplateSpecConfidentialInstanceConfig)(ptr) = InstanceTemplateSpecConfidentialInstanceConfig{}
			}
		} else {
			*(*InstanceTemplateSpecConfidentialInstanceConfig)(ptr) = InstanceTemplateSpecConfidentialInstanceConfig{}
		}
	default:
		iter.ReportError("decode InstanceTemplateSpecConfidentialInstanceConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceTemplateSpecDiskDiskEncryptionKeyCodec struct {
}

func (InstanceTemplateSpecDiskDiskEncryptionKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceTemplateSpecDiskDiskEncryptionKey)(ptr) == nil
}

func (InstanceTemplateSpecDiskDiskEncryptionKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceTemplateSpecDiskDiskEncryptionKey)(ptr)
	var objs []InstanceTemplateSpecDiskDiskEncryptionKey
	if obj != nil {
		objs = []InstanceTemplateSpecDiskDiskEncryptionKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecDiskDiskEncryptionKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceTemplateSpecDiskDiskEncryptionKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceTemplateSpecDiskDiskEncryptionKey)(ptr) = InstanceTemplateSpecDiskDiskEncryptionKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceTemplateSpecDiskDiskEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecDiskDiskEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceTemplateSpecDiskDiskEncryptionKey)(ptr) = objs[0]
			} else {
				*(*InstanceTemplateSpecDiskDiskEncryptionKey)(ptr) = InstanceTemplateSpecDiskDiskEncryptionKey{}
			}
		} else {
			*(*InstanceTemplateSpecDiskDiskEncryptionKey)(ptr) = InstanceTemplateSpecDiskDiskEncryptionKey{}
		}
	default:
		iter.ReportError("decode InstanceTemplateSpecDiskDiskEncryptionKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceTemplateSpecSchedulingCodec struct {
}

func (InstanceTemplateSpecSchedulingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceTemplateSpecScheduling)(ptr) == nil
}

func (InstanceTemplateSpecSchedulingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceTemplateSpecScheduling)(ptr)
	var objs []InstanceTemplateSpecScheduling
	if obj != nil {
		objs = []InstanceTemplateSpecScheduling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecScheduling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceTemplateSpecSchedulingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceTemplateSpecScheduling)(ptr) = InstanceTemplateSpecScheduling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceTemplateSpecScheduling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecScheduling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceTemplateSpecScheduling)(ptr) = objs[0]
			} else {
				*(*InstanceTemplateSpecScheduling)(ptr) = InstanceTemplateSpecScheduling{}
			}
		} else {
			*(*InstanceTemplateSpecScheduling)(ptr) = InstanceTemplateSpecScheduling{}
		}
	default:
		iter.ReportError("decode InstanceTemplateSpecScheduling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceTemplateSpecServiceAccountCodec struct {
}

func (InstanceTemplateSpecServiceAccountCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceTemplateSpecServiceAccount)(ptr) == nil
}

func (InstanceTemplateSpecServiceAccountCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceTemplateSpecServiceAccount)(ptr)
	var objs []InstanceTemplateSpecServiceAccount
	if obj != nil {
		objs = []InstanceTemplateSpecServiceAccount{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecServiceAccount{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceTemplateSpecServiceAccountCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceTemplateSpecServiceAccount)(ptr) = InstanceTemplateSpecServiceAccount{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceTemplateSpecServiceAccount

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecServiceAccount{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceTemplateSpecServiceAccount)(ptr) = objs[0]
			} else {
				*(*InstanceTemplateSpecServiceAccount)(ptr) = InstanceTemplateSpecServiceAccount{}
			}
		} else {
			*(*InstanceTemplateSpecServiceAccount)(ptr) = InstanceTemplateSpecServiceAccount{}
		}
	default:
		iter.ReportError("decode InstanceTemplateSpecServiceAccount", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceTemplateSpecShieldedInstanceConfigCodec struct {
}

func (InstanceTemplateSpecShieldedInstanceConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceTemplateSpecShieldedInstanceConfig)(ptr) == nil
}

func (InstanceTemplateSpecShieldedInstanceConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceTemplateSpecShieldedInstanceConfig)(ptr)
	var objs []InstanceTemplateSpecShieldedInstanceConfig
	if obj != nil {
		objs = []InstanceTemplateSpecShieldedInstanceConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecShieldedInstanceConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceTemplateSpecShieldedInstanceConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceTemplateSpecShieldedInstanceConfig)(ptr) = InstanceTemplateSpecShieldedInstanceConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceTemplateSpecShieldedInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceTemplateSpecShieldedInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceTemplateSpecShieldedInstanceConfig)(ptr) = objs[0]
			} else {
				*(*InstanceTemplateSpecShieldedInstanceConfig)(ptr) = InstanceTemplateSpecShieldedInstanceConfig{}
			}
		} else {
			*(*InstanceTemplateSpecShieldedInstanceConfig)(ptr) = InstanceTemplateSpecShieldedInstanceConfig{}
		}
	default:
		iter.ReportError("decode InstanceTemplateSpecShieldedInstanceConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagedSSLCertificateSpecManagedCodec struct {
}

func (ManagedSSLCertificateSpecManagedCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagedSSLCertificateSpecManaged)(ptr) == nil
}

func (ManagedSSLCertificateSpecManagedCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagedSSLCertificateSpecManaged)(ptr)
	var objs []ManagedSSLCertificateSpecManaged
	if obj != nil {
		objs = []ManagedSSLCertificateSpecManaged{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagedSSLCertificateSpecManaged{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagedSSLCertificateSpecManagedCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagedSSLCertificateSpecManaged)(ptr) = ManagedSSLCertificateSpecManaged{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagedSSLCertificateSpecManaged

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagedSSLCertificateSpecManaged{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagedSSLCertificateSpecManaged)(ptr) = objs[0]
			} else {
				*(*ManagedSSLCertificateSpecManaged)(ptr) = ManagedSSLCertificateSpecManaged{}
			}
		} else {
			*(*ManagedSSLCertificateSpecManaged)(ptr) = ManagedSSLCertificateSpecManaged{}
		}
	default:
		iter.ReportError("decode ManagedSSLCertificateSpecManaged", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodeGroupSpecAutoscalingPolicyCodec struct {
}

func (NodeGroupSpecAutoscalingPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodeGroupSpecAutoscalingPolicy)(ptr) == nil
}

func (NodeGroupSpecAutoscalingPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodeGroupSpecAutoscalingPolicy)(ptr)
	var objs []NodeGroupSpecAutoscalingPolicy
	if obj != nil {
		objs = []NodeGroupSpecAutoscalingPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodeGroupSpecAutoscalingPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodeGroupSpecAutoscalingPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodeGroupSpecAutoscalingPolicy)(ptr) = NodeGroupSpecAutoscalingPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodeGroupSpecAutoscalingPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodeGroupSpecAutoscalingPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodeGroupSpecAutoscalingPolicy)(ptr) = objs[0]
			} else {
				*(*NodeGroupSpecAutoscalingPolicy)(ptr) = NodeGroupSpecAutoscalingPolicy{}
			}
		} else {
			*(*NodeGroupSpecAutoscalingPolicy)(ptr) = NodeGroupSpecAutoscalingPolicy{}
		}
	default:
		iter.ReportError("decode NodeGroupSpecAutoscalingPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodeGroupSpecMaintenanceWindowCodec struct {
}

func (NodeGroupSpecMaintenanceWindowCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodeGroupSpecMaintenanceWindow)(ptr) == nil
}

func (NodeGroupSpecMaintenanceWindowCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodeGroupSpecMaintenanceWindow)(ptr)
	var objs []NodeGroupSpecMaintenanceWindow
	if obj != nil {
		objs = []NodeGroupSpecMaintenanceWindow{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodeGroupSpecMaintenanceWindow{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodeGroupSpecMaintenanceWindowCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodeGroupSpecMaintenanceWindow)(ptr) = NodeGroupSpecMaintenanceWindow{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodeGroupSpecMaintenanceWindow

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodeGroupSpecMaintenanceWindow{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodeGroupSpecMaintenanceWindow)(ptr) = objs[0]
			} else {
				*(*NodeGroupSpecMaintenanceWindow)(ptr) = NodeGroupSpecMaintenanceWindow{}
			}
		} else {
			*(*NodeGroupSpecMaintenanceWindow)(ptr) = NodeGroupSpecMaintenanceWindow{}
		}
	default:
		iter.ReportError("decode NodeGroupSpecMaintenanceWindow", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodeTemplateSpecNodeTypeFlexibilityCodec struct {
}

func (NodeTemplateSpecNodeTypeFlexibilityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodeTemplateSpecNodeTypeFlexibility)(ptr) == nil
}

func (NodeTemplateSpecNodeTypeFlexibilityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodeTemplateSpecNodeTypeFlexibility)(ptr)
	var objs []NodeTemplateSpecNodeTypeFlexibility
	if obj != nil {
		objs = []NodeTemplateSpecNodeTypeFlexibility{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodeTemplateSpecNodeTypeFlexibility{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodeTemplateSpecNodeTypeFlexibilityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodeTemplateSpecNodeTypeFlexibility)(ptr) = NodeTemplateSpecNodeTypeFlexibility{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodeTemplateSpecNodeTypeFlexibility

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodeTemplateSpecNodeTypeFlexibility{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodeTemplateSpecNodeTypeFlexibility)(ptr) = objs[0]
			} else {
				*(*NodeTemplateSpecNodeTypeFlexibility)(ptr) = NodeTemplateSpecNodeTypeFlexibility{}
			}
		} else {
			*(*NodeTemplateSpecNodeTypeFlexibility)(ptr) = NodeTemplateSpecNodeTypeFlexibility{}
		}
	default:
		iter.ReportError("decode NodeTemplateSpecNodeTypeFlexibility", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodeTemplateSpecServerBindingCodec struct {
}

func (NodeTemplateSpecServerBindingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodeTemplateSpecServerBinding)(ptr) == nil
}

func (NodeTemplateSpecServerBindingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodeTemplateSpecServerBinding)(ptr)
	var objs []NodeTemplateSpecServerBinding
	if obj != nil {
		objs = []NodeTemplateSpecServerBinding{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodeTemplateSpecServerBinding{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodeTemplateSpecServerBindingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodeTemplateSpecServerBinding)(ptr) = NodeTemplateSpecServerBinding{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodeTemplateSpecServerBinding

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodeTemplateSpecServerBinding{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodeTemplateSpecServerBinding)(ptr) = objs[0]
			} else {
				*(*NodeTemplateSpecServerBinding)(ptr) = NodeTemplateSpecServerBinding{}
			}
		} else {
			*(*NodeTemplateSpecServerBinding)(ptr) = NodeTemplateSpecServerBinding{}
		}
	default:
		iter.ReportError("decode NodeTemplateSpecServerBinding", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PacketMirroringSpecCollectorIlbCodec struct {
}

func (PacketMirroringSpecCollectorIlbCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PacketMirroringSpecCollectorIlb)(ptr) == nil
}

func (PacketMirroringSpecCollectorIlbCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PacketMirroringSpecCollectorIlb)(ptr)
	var objs []PacketMirroringSpecCollectorIlb
	if obj != nil {
		objs = []PacketMirroringSpecCollectorIlb{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecCollectorIlb{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PacketMirroringSpecCollectorIlbCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PacketMirroringSpecCollectorIlb)(ptr) = PacketMirroringSpecCollectorIlb{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PacketMirroringSpecCollectorIlb

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecCollectorIlb{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PacketMirroringSpecCollectorIlb)(ptr) = objs[0]
			} else {
				*(*PacketMirroringSpecCollectorIlb)(ptr) = PacketMirroringSpecCollectorIlb{}
			}
		} else {
			*(*PacketMirroringSpecCollectorIlb)(ptr) = PacketMirroringSpecCollectorIlb{}
		}
	default:
		iter.ReportError("decode PacketMirroringSpecCollectorIlb", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PacketMirroringSpecFilterCodec struct {
}

func (PacketMirroringSpecFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PacketMirroringSpecFilter)(ptr) == nil
}

func (PacketMirroringSpecFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PacketMirroringSpecFilter)(ptr)
	var objs []PacketMirroringSpecFilter
	if obj != nil {
		objs = []PacketMirroringSpecFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PacketMirroringSpecFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PacketMirroringSpecFilter)(ptr) = PacketMirroringSpecFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PacketMirroringSpecFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PacketMirroringSpecFilter)(ptr) = objs[0]
			} else {
				*(*PacketMirroringSpecFilter)(ptr) = PacketMirroringSpecFilter{}
			}
		} else {
			*(*PacketMirroringSpecFilter)(ptr) = PacketMirroringSpecFilter{}
		}
	default:
		iter.ReportError("decode PacketMirroringSpecFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PacketMirroringSpecMirroredResourcesCodec struct {
}

func (PacketMirroringSpecMirroredResourcesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PacketMirroringSpecMirroredResources)(ptr) == nil
}

func (PacketMirroringSpecMirroredResourcesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PacketMirroringSpecMirroredResources)(ptr)
	var objs []PacketMirroringSpecMirroredResources
	if obj != nil {
		objs = []PacketMirroringSpecMirroredResources{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecMirroredResources{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PacketMirroringSpecMirroredResourcesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PacketMirroringSpecMirroredResources)(ptr) = PacketMirroringSpecMirroredResources{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PacketMirroringSpecMirroredResources

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecMirroredResources{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PacketMirroringSpecMirroredResources)(ptr) = objs[0]
			} else {
				*(*PacketMirroringSpecMirroredResources)(ptr) = PacketMirroringSpecMirroredResources{}
			}
		} else {
			*(*PacketMirroringSpecMirroredResources)(ptr) = PacketMirroringSpecMirroredResources{}
		}
	default:
		iter.ReportError("decode PacketMirroringSpecMirroredResources", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PacketMirroringSpecNetworkCodec struct {
}

func (PacketMirroringSpecNetworkCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PacketMirroringSpecNetwork)(ptr) == nil
}

func (PacketMirroringSpecNetworkCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PacketMirroringSpecNetwork)(ptr)
	var objs []PacketMirroringSpecNetwork
	if obj != nil {
		objs = []PacketMirroringSpecNetwork{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecNetwork{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PacketMirroringSpecNetworkCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PacketMirroringSpecNetwork)(ptr) = PacketMirroringSpecNetwork{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PacketMirroringSpecNetwork

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PacketMirroringSpecNetwork{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PacketMirroringSpecNetwork)(ptr) = objs[0]
			} else {
				*(*PacketMirroringSpecNetwork)(ptr) = PacketMirroringSpecNetwork{}
			}
		} else {
			*(*PacketMirroringSpecNetwork)(ptr) = PacketMirroringSpecNetwork{}
		}
	default:
		iter.ReportError("decode PacketMirroringSpecNetwork", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PerInstanceConfigSpecPreservedStateCodec struct {
}

func (PerInstanceConfigSpecPreservedStateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PerInstanceConfigSpecPreservedState)(ptr) == nil
}

func (PerInstanceConfigSpecPreservedStateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PerInstanceConfigSpecPreservedState)(ptr)
	var objs []PerInstanceConfigSpecPreservedState
	if obj != nil {
		objs = []PerInstanceConfigSpecPreservedState{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PerInstanceConfigSpecPreservedState{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PerInstanceConfigSpecPreservedStateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PerInstanceConfigSpecPreservedState)(ptr) = PerInstanceConfigSpecPreservedState{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PerInstanceConfigSpecPreservedState

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PerInstanceConfigSpecPreservedState{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PerInstanceConfigSpecPreservedState)(ptr) = objs[0]
			} else {
				*(*PerInstanceConfigSpecPreservedState)(ptr) = PerInstanceConfigSpecPreservedState{}
			}
		} else {
			*(*PerInstanceConfigSpecPreservedState)(ptr) = PerInstanceConfigSpecPreservedState{}
		}
	default:
		iter.ReportError("decode PerInstanceConfigSpecPreservedState", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionAutoscalerSpecAutoscalingPolicyCodec struct {
}

func (RegionAutoscalerSpecAutoscalingPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionAutoscalerSpecAutoscalingPolicy)(ptr) == nil
}

func (RegionAutoscalerSpecAutoscalingPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionAutoscalerSpecAutoscalingPolicy)(ptr)
	var objs []RegionAutoscalerSpecAutoscalingPolicy
	if obj != nil {
		objs = []RegionAutoscalerSpecAutoscalingPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionAutoscalerSpecAutoscalingPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionAutoscalerSpecAutoscalingPolicy)(ptr) = RegionAutoscalerSpecAutoscalingPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionAutoscalerSpecAutoscalingPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionAutoscalerSpecAutoscalingPolicy)(ptr) = objs[0]
			} else {
				*(*RegionAutoscalerSpecAutoscalingPolicy)(ptr) = RegionAutoscalerSpecAutoscalingPolicy{}
			}
		} else {
			*(*RegionAutoscalerSpecAutoscalingPolicy)(ptr) = RegionAutoscalerSpecAutoscalingPolicy{}
		}
	default:
		iter.ReportError("decode RegionAutoscalerSpecAutoscalingPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionAutoscalerSpecAutoscalingPolicyCpuUtilizationCodec struct {
}

func (RegionAutoscalerSpecAutoscalingPolicyCpuUtilizationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionAutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) == nil
}

func (RegionAutoscalerSpecAutoscalingPolicyCpuUtilizationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionAutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr)
	var objs []RegionAutoscalerSpecAutoscalingPolicyCpuUtilization
	if obj != nil {
		objs = []RegionAutoscalerSpecAutoscalingPolicyCpuUtilization{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyCpuUtilization{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionAutoscalerSpecAutoscalingPolicyCpuUtilizationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionAutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) = RegionAutoscalerSpecAutoscalingPolicyCpuUtilization{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionAutoscalerSpecAutoscalingPolicyCpuUtilization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyCpuUtilization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionAutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) = objs[0]
			} else {
				*(*RegionAutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) = RegionAutoscalerSpecAutoscalingPolicyCpuUtilization{}
			}
		} else {
			*(*RegionAutoscalerSpecAutoscalingPolicyCpuUtilization)(ptr) = RegionAutoscalerSpecAutoscalingPolicyCpuUtilization{}
		}
	default:
		iter.ReportError("decode RegionAutoscalerSpecAutoscalingPolicyCpuUtilization", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec struct {
}

func (RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) == nil
}

func (RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr)
	var objs []RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization
	if obj != nil {
		objs = []RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilizationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) = RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) = objs[0]
			} else {
				*(*RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) = RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}
			}
		} else {
			*(*RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization)(ptr) = RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization{}
		}
	default:
		iter.ReportError("decode RegionAutoscalerSpecAutoscalingPolicyLoadBalancingUtilization", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionAutoscalerSpecAutoscalingPolicyScaleInControlCodec struct {
}

func (RegionAutoscalerSpecAutoscalingPolicyScaleInControlCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionAutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) == nil
}

func (RegionAutoscalerSpecAutoscalingPolicyScaleInControlCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionAutoscalerSpecAutoscalingPolicyScaleInControl)(ptr)
	var objs []RegionAutoscalerSpecAutoscalingPolicyScaleInControl
	if obj != nil {
		objs = []RegionAutoscalerSpecAutoscalingPolicyScaleInControl{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyScaleInControl{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionAutoscalerSpecAutoscalingPolicyScaleInControlCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionAutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) = RegionAutoscalerSpecAutoscalingPolicyScaleInControl{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionAutoscalerSpecAutoscalingPolicyScaleInControl

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyScaleInControl{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionAutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) = objs[0]
			} else {
				*(*RegionAutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) = RegionAutoscalerSpecAutoscalingPolicyScaleInControl{}
			}
		} else {
			*(*RegionAutoscalerSpecAutoscalingPolicyScaleInControl)(ptr) = RegionAutoscalerSpecAutoscalingPolicyScaleInControl{}
		}
	default:
		iter.ReportError("decode RegionAutoscalerSpecAutoscalingPolicyScaleInControl", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec struct {
}

func (RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) == nil
}

func (RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr)
	var objs []RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas
	if obj != nil {
		objs = []RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicasCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) = RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) = objs[0]
			} else {
				*(*RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) = RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}
			}
		} else {
			*(*RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas)(ptr) = RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas{}
		}
	default:
		iter.ReportError("decode RegionAutoscalerSpecAutoscalingPolicyScaleInControlMaxScaledInReplicas", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionBackendServiceSpecCdnPolicyCodec struct {
}

func (RegionBackendServiceSpecCdnPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionBackendServiceSpecCdnPolicy)(ptr) == nil
}

func (RegionBackendServiceSpecCdnPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionBackendServiceSpecCdnPolicy)(ptr)
	var objs []RegionBackendServiceSpecCdnPolicy
	if obj != nil {
		objs = []RegionBackendServiceSpecCdnPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCdnPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionBackendServiceSpecCdnPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionBackendServiceSpecCdnPolicy)(ptr) = RegionBackendServiceSpecCdnPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionBackendServiceSpecCdnPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCdnPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionBackendServiceSpecCdnPolicy)(ptr) = objs[0]
			} else {
				*(*RegionBackendServiceSpecCdnPolicy)(ptr) = RegionBackendServiceSpecCdnPolicy{}
			}
		} else {
			*(*RegionBackendServiceSpecCdnPolicy)(ptr) = RegionBackendServiceSpecCdnPolicy{}
		}
	default:
		iter.ReportError("decode RegionBackendServiceSpecCdnPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionBackendServiceSpecCdnPolicyCacheKeyPolicyCodec struct {
}

func (RegionBackendServiceSpecCdnPolicyCacheKeyPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionBackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) == nil
}

func (RegionBackendServiceSpecCdnPolicyCacheKeyPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionBackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr)
	var objs []RegionBackendServiceSpecCdnPolicyCacheKeyPolicy
	if obj != nil {
		objs = []RegionBackendServiceSpecCdnPolicyCacheKeyPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCdnPolicyCacheKeyPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionBackendServiceSpecCdnPolicyCacheKeyPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionBackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) = RegionBackendServiceSpecCdnPolicyCacheKeyPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionBackendServiceSpecCdnPolicyCacheKeyPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCdnPolicyCacheKeyPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionBackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) = objs[0]
			} else {
				*(*RegionBackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) = RegionBackendServiceSpecCdnPolicyCacheKeyPolicy{}
			}
		} else {
			*(*RegionBackendServiceSpecCdnPolicyCacheKeyPolicy)(ptr) = RegionBackendServiceSpecCdnPolicyCacheKeyPolicy{}
		}
	default:
		iter.ReportError("decode RegionBackendServiceSpecCdnPolicyCacheKeyPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionBackendServiceSpecCircuitBreakersCodec struct {
}

func (RegionBackendServiceSpecCircuitBreakersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionBackendServiceSpecCircuitBreakers)(ptr) == nil
}

func (RegionBackendServiceSpecCircuitBreakersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionBackendServiceSpecCircuitBreakers)(ptr)
	var objs []RegionBackendServiceSpecCircuitBreakers
	if obj != nil {
		objs = []RegionBackendServiceSpecCircuitBreakers{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCircuitBreakers{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionBackendServiceSpecCircuitBreakersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionBackendServiceSpecCircuitBreakers)(ptr) = RegionBackendServiceSpecCircuitBreakers{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionBackendServiceSpecCircuitBreakers

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecCircuitBreakers{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionBackendServiceSpecCircuitBreakers)(ptr) = objs[0]
			} else {
				*(*RegionBackendServiceSpecCircuitBreakers)(ptr) = RegionBackendServiceSpecCircuitBreakers{}
			}
		} else {
			*(*RegionBackendServiceSpecCircuitBreakers)(ptr) = RegionBackendServiceSpecCircuitBreakers{}
		}
	default:
		iter.ReportError("decode RegionBackendServiceSpecCircuitBreakers", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionBackendServiceSpecConsistentHashCodec struct {
}

func (RegionBackendServiceSpecConsistentHashCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionBackendServiceSpecConsistentHash)(ptr) == nil
}

func (RegionBackendServiceSpecConsistentHashCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionBackendServiceSpecConsistentHash)(ptr)
	var objs []RegionBackendServiceSpecConsistentHash
	if obj != nil {
		objs = []RegionBackendServiceSpecConsistentHash{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHash{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionBackendServiceSpecConsistentHashCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionBackendServiceSpecConsistentHash)(ptr) = RegionBackendServiceSpecConsistentHash{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionBackendServiceSpecConsistentHash

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHash{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionBackendServiceSpecConsistentHash)(ptr) = objs[0]
			} else {
				*(*RegionBackendServiceSpecConsistentHash)(ptr) = RegionBackendServiceSpecConsistentHash{}
			}
		} else {
			*(*RegionBackendServiceSpecConsistentHash)(ptr) = RegionBackendServiceSpecConsistentHash{}
		}
	default:
		iter.ReportError("decode RegionBackendServiceSpecConsistentHash", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionBackendServiceSpecConsistentHashHttpCookieCodec struct {
}

func (RegionBackendServiceSpecConsistentHashHttpCookieCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionBackendServiceSpecConsistentHashHttpCookie)(ptr) == nil
}

func (RegionBackendServiceSpecConsistentHashHttpCookieCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionBackendServiceSpecConsistentHashHttpCookie)(ptr)
	var objs []RegionBackendServiceSpecConsistentHashHttpCookie
	if obj != nil {
		objs = []RegionBackendServiceSpecConsistentHashHttpCookie{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHashHttpCookie{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionBackendServiceSpecConsistentHashHttpCookieCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionBackendServiceSpecConsistentHashHttpCookie)(ptr) = RegionBackendServiceSpecConsistentHashHttpCookie{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionBackendServiceSpecConsistentHashHttpCookie

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHashHttpCookie{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionBackendServiceSpecConsistentHashHttpCookie)(ptr) = objs[0]
			} else {
				*(*RegionBackendServiceSpecConsistentHashHttpCookie)(ptr) = RegionBackendServiceSpecConsistentHashHttpCookie{}
			}
		} else {
			*(*RegionBackendServiceSpecConsistentHashHttpCookie)(ptr) = RegionBackendServiceSpecConsistentHashHttpCookie{}
		}
	default:
		iter.ReportError("decode RegionBackendServiceSpecConsistentHashHttpCookie", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionBackendServiceSpecConsistentHashHttpCookieTtlCodec struct {
}

func (RegionBackendServiceSpecConsistentHashHttpCookieTtlCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionBackendServiceSpecConsistentHashHttpCookieTtl)(ptr) == nil
}

func (RegionBackendServiceSpecConsistentHashHttpCookieTtlCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionBackendServiceSpecConsistentHashHttpCookieTtl)(ptr)
	var objs []RegionBackendServiceSpecConsistentHashHttpCookieTtl
	if obj != nil {
		objs = []RegionBackendServiceSpecConsistentHashHttpCookieTtl{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHashHttpCookieTtl{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionBackendServiceSpecConsistentHashHttpCookieTtlCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionBackendServiceSpecConsistentHashHttpCookieTtl)(ptr) = RegionBackendServiceSpecConsistentHashHttpCookieTtl{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionBackendServiceSpecConsistentHashHttpCookieTtl

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecConsistentHashHttpCookieTtl{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionBackendServiceSpecConsistentHashHttpCookieTtl)(ptr) = objs[0]
			} else {
				*(*RegionBackendServiceSpecConsistentHashHttpCookieTtl)(ptr) = RegionBackendServiceSpecConsistentHashHttpCookieTtl{}
			}
		} else {
			*(*RegionBackendServiceSpecConsistentHashHttpCookieTtl)(ptr) = RegionBackendServiceSpecConsistentHashHttpCookieTtl{}
		}
	default:
		iter.ReportError("decode RegionBackendServiceSpecConsistentHashHttpCookieTtl", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionBackendServiceSpecFailoverPolicyCodec struct {
}

func (RegionBackendServiceSpecFailoverPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionBackendServiceSpecFailoverPolicy)(ptr) == nil
}

func (RegionBackendServiceSpecFailoverPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionBackendServiceSpecFailoverPolicy)(ptr)
	var objs []RegionBackendServiceSpecFailoverPolicy
	if obj != nil {
		objs = []RegionBackendServiceSpecFailoverPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecFailoverPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionBackendServiceSpecFailoverPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionBackendServiceSpecFailoverPolicy)(ptr) = RegionBackendServiceSpecFailoverPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionBackendServiceSpecFailoverPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecFailoverPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionBackendServiceSpecFailoverPolicy)(ptr) = objs[0]
			} else {
				*(*RegionBackendServiceSpecFailoverPolicy)(ptr) = RegionBackendServiceSpecFailoverPolicy{}
			}
		} else {
			*(*RegionBackendServiceSpecFailoverPolicy)(ptr) = RegionBackendServiceSpecFailoverPolicy{}
		}
	default:
		iter.ReportError("decode RegionBackendServiceSpecFailoverPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionBackendServiceSpecLogConfigCodec struct {
}

func (RegionBackendServiceSpecLogConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionBackendServiceSpecLogConfig)(ptr) == nil
}

func (RegionBackendServiceSpecLogConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionBackendServiceSpecLogConfig)(ptr)
	var objs []RegionBackendServiceSpecLogConfig
	if obj != nil {
		objs = []RegionBackendServiceSpecLogConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecLogConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionBackendServiceSpecLogConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionBackendServiceSpecLogConfig)(ptr) = RegionBackendServiceSpecLogConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionBackendServiceSpecLogConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecLogConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionBackendServiceSpecLogConfig)(ptr) = objs[0]
			} else {
				*(*RegionBackendServiceSpecLogConfig)(ptr) = RegionBackendServiceSpecLogConfig{}
			}
		} else {
			*(*RegionBackendServiceSpecLogConfig)(ptr) = RegionBackendServiceSpecLogConfig{}
		}
	default:
		iter.ReportError("decode RegionBackendServiceSpecLogConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionBackendServiceSpecOutlierDetectionCodec struct {
}

func (RegionBackendServiceSpecOutlierDetectionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionBackendServiceSpecOutlierDetection)(ptr) == nil
}

func (RegionBackendServiceSpecOutlierDetectionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionBackendServiceSpecOutlierDetection)(ptr)
	var objs []RegionBackendServiceSpecOutlierDetection
	if obj != nil {
		objs = []RegionBackendServiceSpecOutlierDetection{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetection{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionBackendServiceSpecOutlierDetectionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionBackendServiceSpecOutlierDetection)(ptr) = RegionBackendServiceSpecOutlierDetection{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionBackendServiceSpecOutlierDetection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionBackendServiceSpecOutlierDetection)(ptr) = objs[0]
			} else {
				*(*RegionBackendServiceSpecOutlierDetection)(ptr) = RegionBackendServiceSpecOutlierDetection{}
			}
		} else {
			*(*RegionBackendServiceSpecOutlierDetection)(ptr) = RegionBackendServiceSpecOutlierDetection{}
		}
	default:
		iter.ReportError("decode RegionBackendServiceSpecOutlierDetection", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionBackendServiceSpecOutlierDetectionBaseEjectionTimeCodec struct {
}

func (RegionBackendServiceSpecOutlierDetectionBaseEjectionTimeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionBackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) == nil
}

func (RegionBackendServiceSpecOutlierDetectionBaseEjectionTimeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionBackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr)
	var objs []RegionBackendServiceSpecOutlierDetectionBaseEjectionTime
	if obj != nil {
		objs = []RegionBackendServiceSpecOutlierDetectionBaseEjectionTime{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetectionBaseEjectionTime{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionBackendServiceSpecOutlierDetectionBaseEjectionTimeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionBackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) = RegionBackendServiceSpecOutlierDetectionBaseEjectionTime{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionBackendServiceSpecOutlierDetectionBaseEjectionTime

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetectionBaseEjectionTime{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionBackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) = objs[0]
			} else {
				*(*RegionBackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) = RegionBackendServiceSpecOutlierDetectionBaseEjectionTime{}
			}
		} else {
			*(*RegionBackendServiceSpecOutlierDetectionBaseEjectionTime)(ptr) = RegionBackendServiceSpecOutlierDetectionBaseEjectionTime{}
		}
	default:
		iter.ReportError("decode RegionBackendServiceSpecOutlierDetectionBaseEjectionTime", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionBackendServiceSpecOutlierDetectionIntervalCodec struct {
}

func (RegionBackendServiceSpecOutlierDetectionIntervalCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionBackendServiceSpecOutlierDetectionInterval)(ptr) == nil
}

func (RegionBackendServiceSpecOutlierDetectionIntervalCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionBackendServiceSpecOutlierDetectionInterval)(ptr)
	var objs []RegionBackendServiceSpecOutlierDetectionInterval
	if obj != nil {
		objs = []RegionBackendServiceSpecOutlierDetectionInterval{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetectionInterval{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionBackendServiceSpecOutlierDetectionIntervalCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionBackendServiceSpecOutlierDetectionInterval)(ptr) = RegionBackendServiceSpecOutlierDetectionInterval{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionBackendServiceSpecOutlierDetectionInterval

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionBackendServiceSpecOutlierDetectionInterval{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionBackendServiceSpecOutlierDetectionInterval)(ptr) = objs[0]
			} else {
				*(*RegionBackendServiceSpecOutlierDetectionInterval)(ptr) = RegionBackendServiceSpecOutlierDetectionInterval{}
			}
		} else {
			*(*RegionBackendServiceSpecOutlierDetectionInterval)(ptr) = RegionBackendServiceSpecOutlierDetectionInterval{}
		}
	default:
		iter.ReportError("decode RegionBackendServiceSpecOutlierDetectionInterval", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionDiskSpecDiskEncryptionKeyCodec struct {
}

func (RegionDiskSpecDiskEncryptionKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionDiskSpecDiskEncryptionKey)(ptr) == nil
}

func (RegionDiskSpecDiskEncryptionKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionDiskSpecDiskEncryptionKey)(ptr)
	var objs []RegionDiskSpecDiskEncryptionKey
	if obj != nil {
		objs = []RegionDiskSpecDiskEncryptionKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskSpecDiskEncryptionKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionDiskSpecDiskEncryptionKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionDiskSpecDiskEncryptionKey)(ptr) = RegionDiskSpecDiskEncryptionKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionDiskSpecDiskEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskSpecDiskEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionDiskSpecDiskEncryptionKey)(ptr) = objs[0]
			} else {
				*(*RegionDiskSpecDiskEncryptionKey)(ptr) = RegionDiskSpecDiskEncryptionKey{}
			}
		} else {
			*(*RegionDiskSpecDiskEncryptionKey)(ptr) = RegionDiskSpecDiskEncryptionKey{}
		}
	default:
		iter.ReportError("decode RegionDiskSpecDiskEncryptionKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionDiskSpecSourceSnapshotEncryptionKeyCodec struct {
}

func (RegionDiskSpecSourceSnapshotEncryptionKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionDiskSpecSourceSnapshotEncryptionKey)(ptr) == nil
}

func (RegionDiskSpecSourceSnapshotEncryptionKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionDiskSpecSourceSnapshotEncryptionKey)(ptr)
	var objs []RegionDiskSpecSourceSnapshotEncryptionKey
	if obj != nil {
		objs = []RegionDiskSpecSourceSnapshotEncryptionKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskSpecSourceSnapshotEncryptionKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionDiskSpecSourceSnapshotEncryptionKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionDiskSpecSourceSnapshotEncryptionKey)(ptr) = RegionDiskSpecSourceSnapshotEncryptionKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionDiskSpecSourceSnapshotEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskSpecSourceSnapshotEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionDiskSpecSourceSnapshotEncryptionKey)(ptr) = objs[0]
			} else {
				*(*RegionDiskSpecSourceSnapshotEncryptionKey)(ptr) = RegionDiskSpecSourceSnapshotEncryptionKey{}
			}
		} else {
			*(*RegionDiskSpecSourceSnapshotEncryptionKey)(ptr) = RegionDiskSpecSourceSnapshotEncryptionKey{}
		}
	default:
		iter.ReportError("decode RegionDiskSpecSourceSnapshotEncryptionKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionDiskIamBindingSpecConditionCodec struct {
}

func (RegionDiskIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionDiskIamBindingSpecCondition)(ptr) == nil
}

func (RegionDiskIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionDiskIamBindingSpecCondition)(ptr)
	var objs []RegionDiskIamBindingSpecCondition
	if obj != nil {
		objs = []RegionDiskIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionDiskIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionDiskIamBindingSpecCondition)(ptr) = RegionDiskIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionDiskIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionDiskIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*RegionDiskIamBindingSpecCondition)(ptr) = RegionDiskIamBindingSpecCondition{}
			}
		} else {
			*(*RegionDiskIamBindingSpecCondition)(ptr) = RegionDiskIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode RegionDiskIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionDiskIamMemberSpecConditionCodec struct {
}

func (RegionDiskIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionDiskIamMemberSpecCondition)(ptr) == nil
}

func (RegionDiskIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionDiskIamMemberSpecCondition)(ptr)
	var objs []RegionDiskIamMemberSpecCondition
	if obj != nil {
		objs = []RegionDiskIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionDiskIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionDiskIamMemberSpecCondition)(ptr) = RegionDiskIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionDiskIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionDiskIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionDiskIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*RegionDiskIamMemberSpecCondition)(ptr) = RegionDiskIamMemberSpecCondition{}
			}
		} else {
			*(*RegionDiskIamMemberSpecCondition)(ptr) = RegionDiskIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode RegionDiskIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionHealthCheckSpecGrpcHealthCheckCodec struct {
}

func (RegionHealthCheckSpecGrpcHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionHealthCheckSpecGrpcHealthCheck)(ptr) == nil
}

func (RegionHealthCheckSpecGrpcHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionHealthCheckSpecGrpcHealthCheck)(ptr)
	var objs []RegionHealthCheckSpecGrpcHealthCheck
	if obj != nil {
		objs = []RegionHealthCheckSpecGrpcHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecGrpcHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionHealthCheckSpecGrpcHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionHealthCheckSpecGrpcHealthCheck)(ptr) = RegionHealthCheckSpecGrpcHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionHealthCheckSpecGrpcHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecGrpcHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionHealthCheckSpecGrpcHealthCheck)(ptr) = objs[0]
			} else {
				*(*RegionHealthCheckSpecGrpcHealthCheck)(ptr) = RegionHealthCheckSpecGrpcHealthCheck{}
			}
		} else {
			*(*RegionHealthCheckSpecGrpcHealthCheck)(ptr) = RegionHealthCheckSpecGrpcHealthCheck{}
		}
	default:
		iter.ReportError("decode RegionHealthCheckSpecGrpcHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionHealthCheckSpecHttp2HealthCheckCodec struct {
}

func (RegionHealthCheckSpecHttp2HealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionHealthCheckSpecHttp2HealthCheck)(ptr) == nil
}

func (RegionHealthCheckSpecHttp2HealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionHealthCheckSpecHttp2HealthCheck)(ptr)
	var objs []RegionHealthCheckSpecHttp2HealthCheck
	if obj != nil {
		objs = []RegionHealthCheckSpecHttp2HealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttp2HealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionHealthCheckSpecHttp2HealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionHealthCheckSpecHttp2HealthCheck)(ptr) = RegionHealthCheckSpecHttp2HealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionHealthCheckSpecHttp2HealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttp2HealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionHealthCheckSpecHttp2HealthCheck)(ptr) = objs[0]
			} else {
				*(*RegionHealthCheckSpecHttp2HealthCheck)(ptr) = RegionHealthCheckSpecHttp2HealthCheck{}
			}
		} else {
			*(*RegionHealthCheckSpecHttp2HealthCheck)(ptr) = RegionHealthCheckSpecHttp2HealthCheck{}
		}
	default:
		iter.ReportError("decode RegionHealthCheckSpecHttp2HealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionHealthCheckSpecHttpHealthCheckCodec struct {
}

func (RegionHealthCheckSpecHttpHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionHealthCheckSpecHttpHealthCheck)(ptr) == nil
}

func (RegionHealthCheckSpecHttpHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionHealthCheckSpecHttpHealthCheck)(ptr)
	var objs []RegionHealthCheckSpecHttpHealthCheck
	if obj != nil {
		objs = []RegionHealthCheckSpecHttpHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttpHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionHealthCheckSpecHttpHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionHealthCheckSpecHttpHealthCheck)(ptr) = RegionHealthCheckSpecHttpHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionHealthCheckSpecHttpHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttpHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionHealthCheckSpecHttpHealthCheck)(ptr) = objs[0]
			} else {
				*(*RegionHealthCheckSpecHttpHealthCheck)(ptr) = RegionHealthCheckSpecHttpHealthCheck{}
			}
		} else {
			*(*RegionHealthCheckSpecHttpHealthCheck)(ptr) = RegionHealthCheckSpecHttpHealthCheck{}
		}
	default:
		iter.ReportError("decode RegionHealthCheckSpecHttpHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionHealthCheckSpecHttpsHealthCheckCodec struct {
}

func (RegionHealthCheckSpecHttpsHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionHealthCheckSpecHttpsHealthCheck)(ptr) == nil
}

func (RegionHealthCheckSpecHttpsHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionHealthCheckSpecHttpsHealthCheck)(ptr)
	var objs []RegionHealthCheckSpecHttpsHealthCheck
	if obj != nil {
		objs = []RegionHealthCheckSpecHttpsHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttpsHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionHealthCheckSpecHttpsHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionHealthCheckSpecHttpsHealthCheck)(ptr) = RegionHealthCheckSpecHttpsHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionHealthCheckSpecHttpsHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecHttpsHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionHealthCheckSpecHttpsHealthCheck)(ptr) = objs[0]
			} else {
				*(*RegionHealthCheckSpecHttpsHealthCheck)(ptr) = RegionHealthCheckSpecHttpsHealthCheck{}
			}
		} else {
			*(*RegionHealthCheckSpecHttpsHealthCheck)(ptr) = RegionHealthCheckSpecHttpsHealthCheck{}
		}
	default:
		iter.ReportError("decode RegionHealthCheckSpecHttpsHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionHealthCheckSpecSslHealthCheckCodec struct {
}

func (RegionHealthCheckSpecSslHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionHealthCheckSpecSslHealthCheck)(ptr) == nil
}

func (RegionHealthCheckSpecSslHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionHealthCheckSpecSslHealthCheck)(ptr)
	var objs []RegionHealthCheckSpecSslHealthCheck
	if obj != nil {
		objs = []RegionHealthCheckSpecSslHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecSslHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionHealthCheckSpecSslHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionHealthCheckSpecSslHealthCheck)(ptr) = RegionHealthCheckSpecSslHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionHealthCheckSpecSslHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecSslHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionHealthCheckSpecSslHealthCheck)(ptr) = objs[0]
			} else {
				*(*RegionHealthCheckSpecSslHealthCheck)(ptr) = RegionHealthCheckSpecSslHealthCheck{}
			}
		} else {
			*(*RegionHealthCheckSpecSslHealthCheck)(ptr) = RegionHealthCheckSpecSslHealthCheck{}
		}
	default:
		iter.ReportError("decode RegionHealthCheckSpecSslHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionHealthCheckSpecTcpHealthCheckCodec struct {
}

func (RegionHealthCheckSpecTcpHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionHealthCheckSpecTcpHealthCheck)(ptr) == nil
}

func (RegionHealthCheckSpecTcpHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionHealthCheckSpecTcpHealthCheck)(ptr)
	var objs []RegionHealthCheckSpecTcpHealthCheck
	if obj != nil {
		objs = []RegionHealthCheckSpecTcpHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecTcpHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionHealthCheckSpecTcpHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionHealthCheckSpecTcpHealthCheck)(ptr) = RegionHealthCheckSpecTcpHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionHealthCheckSpecTcpHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionHealthCheckSpecTcpHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionHealthCheckSpecTcpHealthCheck)(ptr) = objs[0]
			} else {
				*(*RegionHealthCheckSpecTcpHealthCheck)(ptr) = RegionHealthCheckSpecTcpHealthCheck{}
			}
		} else {
			*(*RegionHealthCheckSpecTcpHealthCheck)(ptr) = RegionHealthCheckSpecTcpHealthCheck{}
		}
	default:
		iter.ReportError("decode RegionHealthCheckSpecTcpHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionInstanceGroupManagerSpecAutoHealingPoliciesCodec struct {
}

func (RegionInstanceGroupManagerSpecAutoHealingPoliciesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionInstanceGroupManagerSpecAutoHealingPolicies)(ptr) == nil
}

func (RegionInstanceGroupManagerSpecAutoHealingPoliciesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionInstanceGroupManagerSpecAutoHealingPolicies)(ptr)
	var objs []RegionInstanceGroupManagerSpecAutoHealingPolicies
	if obj != nil {
		objs = []RegionInstanceGroupManagerSpecAutoHealingPolicies{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecAutoHealingPolicies{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionInstanceGroupManagerSpecAutoHealingPoliciesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionInstanceGroupManagerSpecAutoHealingPolicies)(ptr) = RegionInstanceGroupManagerSpecAutoHealingPolicies{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionInstanceGroupManagerSpecAutoHealingPolicies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecAutoHealingPolicies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionInstanceGroupManagerSpecAutoHealingPolicies)(ptr) = objs[0]
			} else {
				*(*RegionInstanceGroupManagerSpecAutoHealingPolicies)(ptr) = RegionInstanceGroupManagerSpecAutoHealingPolicies{}
			}
		} else {
			*(*RegionInstanceGroupManagerSpecAutoHealingPolicies)(ptr) = RegionInstanceGroupManagerSpecAutoHealingPolicies{}
		}
	default:
		iter.ReportError("decode RegionInstanceGroupManagerSpecAutoHealingPolicies", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionInstanceGroupManagerSpecUpdatePolicyCodec struct {
}

func (RegionInstanceGroupManagerSpecUpdatePolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionInstanceGroupManagerSpecUpdatePolicy)(ptr) == nil
}

func (RegionInstanceGroupManagerSpecUpdatePolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionInstanceGroupManagerSpecUpdatePolicy)(ptr)
	var objs []RegionInstanceGroupManagerSpecUpdatePolicy
	if obj != nil {
		objs = []RegionInstanceGroupManagerSpecUpdatePolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecUpdatePolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionInstanceGroupManagerSpecUpdatePolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionInstanceGroupManagerSpecUpdatePolicy)(ptr) = RegionInstanceGroupManagerSpecUpdatePolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionInstanceGroupManagerSpecUpdatePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecUpdatePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionInstanceGroupManagerSpecUpdatePolicy)(ptr) = objs[0]
			} else {
				*(*RegionInstanceGroupManagerSpecUpdatePolicy)(ptr) = RegionInstanceGroupManagerSpecUpdatePolicy{}
			}
		} else {
			*(*RegionInstanceGroupManagerSpecUpdatePolicy)(ptr) = RegionInstanceGroupManagerSpecUpdatePolicy{}
		}
	default:
		iter.ReportError("decode RegionInstanceGroupManagerSpecUpdatePolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionInstanceGroupManagerSpecVersionTargetSizeCodec struct {
}

func (RegionInstanceGroupManagerSpecVersionTargetSizeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionInstanceGroupManagerSpecVersionTargetSize)(ptr) == nil
}

func (RegionInstanceGroupManagerSpecVersionTargetSizeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionInstanceGroupManagerSpecVersionTargetSize)(ptr)
	var objs []RegionInstanceGroupManagerSpecVersionTargetSize
	if obj != nil {
		objs = []RegionInstanceGroupManagerSpecVersionTargetSize{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecVersionTargetSize{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionInstanceGroupManagerSpecVersionTargetSizeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionInstanceGroupManagerSpecVersionTargetSize)(ptr) = RegionInstanceGroupManagerSpecVersionTargetSize{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionInstanceGroupManagerSpecVersionTargetSize

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionInstanceGroupManagerSpecVersionTargetSize{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionInstanceGroupManagerSpecVersionTargetSize)(ptr) = objs[0]
			} else {
				*(*RegionInstanceGroupManagerSpecVersionTargetSize)(ptr) = RegionInstanceGroupManagerSpecVersionTargetSize{}
			}
		} else {
			*(*RegionInstanceGroupManagerSpecVersionTargetSize)(ptr) = RegionInstanceGroupManagerSpecVersionTargetSize{}
		}
	default:
		iter.ReportError("decode RegionInstanceGroupManagerSpecVersionTargetSize", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionNetworkEndpointGroupSpecAppEngineCodec struct {
}

func (RegionNetworkEndpointGroupSpecAppEngineCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionNetworkEndpointGroupSpecAppEngine)(ptr) == nil
}

func (RegionNetworkEndpointGroupSpecAppEngineCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionNetworkEndpointGroupSpecAppEngine)(ptr)
	var objs []RegionNetworkEndpointGroupSpecAppEngine
	if obj != nil {
		objs = []RegionNetworkEndpointGroupSpecAppEngine{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecAppEngine{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionNetworkEndpointGroupSpecAppEngineCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionNetworkEndpointGroupSpecAppEngine)(ptr) = RegionNetworkEndpointGroupSpecAppEngine{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionNetworkEndpointGroupSpecAppEngine

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecAppEngine{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionNetworkEndpointGroupSpecAppEngine)(ptr) = objs[0]
			} else {
				*(*RegionNetworkEndpointGroupSpecAppEngine)(ptr) = RegionNetworkEndpointGroupSpecAppEngine{}
			}
		} else {
			*(*RegionNetworkEndpointGroupSpecAppEngine)(ptr) = RegionNetworkEndpointGroupSpecAppEngine{}
		}
	default:
		iter.ReportError("decode RegionNetworkEndpointGroupSpecAppEngine", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionNetworkEndpointGroupSpecCloudFunctionCodec struct {
}

func (RegionNetworkEndpointGroupSpecCloudFunctionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionNetworkEndpointGroupSpecCloudFunction)(ptr) == nil
}

func (RegionNetworkEndpointGroupSpecCloudFunctionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionNetworkEndpointGroupSpecCloudFunction)(ptr)
	var objs []RegionNetworkEndpointGroupSpecCloudFunction
	if obj != nil {
		objs = []RegionNetworkEndpointGroupSpecCloudFunction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecCloudFunction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionNetworkEndpointGroupSpecCloudFunctionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionNetworkEndpointGroupSpecCloudFunction)(ptr) = RegionNetworkEndpointGroupSpecCloudFunction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionNetworkEndpointGroupSpecCloudFunction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecCloudFunction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionNetworkEndpointGroupSpecCloudFunction)(ptr) = objs[0]
			} else {
				*(*RegionNetworkEndpointGroupSpecCloudFunction)(ptr) = RegionNetworkEndpointGroupSpecCloudFunction{}
			}
		} else {
			*(*RegionNetworkEndpointGroupSpecCloudFunction)(ptr) = RegionNetworkEndpointGroupSpecCloudFunction{}
		}
	default:
		iter.ReportError("decode RegionNetworkEndpointGroupSpecCloudFunction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionNetworkEndpointGroupSpecCloudRunCodec struct {
}

func (RegionNetworkEndpointGroupSpecCloudRunCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionNetworkEndpointGroupSpecCloudRun)(ptr) == nil
}

func (RegionNetworkEndpointGroupSpecCloudRunCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionNetworkEndpointGroupSpecCloudRun)(ptr)
	var objs []RegionNetworkEndpointGroupSpecCloudRun
	if obj != nil {
		objs = []RegionNetworkEndpointGroupSpecCloudRun{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecCloudRun{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionNetworkEndpointGroupSpecCloudRunCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionNetworkEndpointGroupSpecCloudRun)(ptr) = RegionNetworkEndpointGroupSpecCloudRun{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionNetworkEndpointGroupSpecCloudRun

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionNetworkEndpointGroupSpecCloudRun{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionNetworkEndpointGroupSpecCloudRun)(ptr) = objs[0]
			} else {
				*(*RegionNetworkEndpointGroupSpecCloudRun)(ptr) = RegionNetworkEndpointGroupSpecCloudRun{}
			}
		} else {
			*(*RegionNetworkEndpointGroupSpecCloudRun)(ptr) = RegionNetworkEndpointGroupSpecCloudRun{}
		}
	default:
		iter.ReportError("decode RegionNetworkEndpointGroupSpecCloudRun", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionPerInstanceConfigSpecPreservedStateCodec struct {
}

func (RegionPerInstanceConfigSpecPreservedStateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionPerInstanceConfigSpecPreservedState)(ptr) == nil
}

func (RegionPerInstanceConfigSpecPreservedStateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionPerInstanceConfigSpecPreservedState)(ptr)
	var objs []RegionPerInstanceConfigSpecPreservedState
	if obj != nil {
		objs = []RegionPerInstanceConfigSpecPreservedState{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionPerInstanceConfigSpecPreservedState{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionPerInstanceConfigSpecPreservedStateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionPerInstanceConfigSpecPreservedState)(ptr) = RegionPerInstanceConfigSpecPreservedState{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionPerInstanceConfigSpecPreservedState

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionPerInstanceConfigSpecPreservedState{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionPerInstanceConfigSpecPreservedState)(ptr) = objs[0]
			} else {
				*(*RegionPerInstanceConfigSpecPreservedState)(ptr) = RegionPerInstanceConfigSpecPreservedState{}
			}
		} else {
			*(*RegionPerInstanceConfigSpecPreservedState)(ptr) = RegionPerInstanceConfigSpecPreservedState{}
		}
	default:
		iter.ReportError("decode RegionPerInstanceConfigSpecPreservedState", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecDefaultURLRedirectCodec struct {
}

func (RegionURLMapSpecDefaultURLRedirectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecDefaultURLRedirect)(ptr) == nil
}

func (RegionURLMapSpecDefaultURLRedirectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecDefaultURLRedirect)(ptr)
	var objs []RegionURLMapSpecDefaultURLRedirect
	if obj != nil {
		objs = []RegionURLMapSpecDefaultURLRedirect{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecDefaultURLRedirect{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecDefaultURLRedirectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecDefaultURLRedirect)(ptr) = RegionURLMapSpecDefaultURLRedirect{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecDefaultURLRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecDefaultURLRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecDefaultURLRedirect)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecDefaultURLRedirect)(ptr) = RegionURLMapSpecDefaultURLRedirect{}
			}
		} else {
			*(*RegionURLMapSpecDefaultURLRedirect)(ptr) = RegionURLMapSpecDefaultURLRedirect{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecDefaultURLRedirect", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherDefaultURLRedirectCodec struct {
}

func (RegionURLMapSpecPathMatcherDefaultURLRedirectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherDefaultURLRedirect)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherDefaultURLRedirectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherDefaultURLRedirect)(ptr)
	var objs []RegionURLMapSpecPathMatcherDefaultURLRedirect
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherDefaultURLRedirect{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherDefaultURLRedirect{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherDefaultURLRedirectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherDefaultURLRedirect)(ptr) = RegionURLMapSpecPathMatcherDefaultURLRedirect{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherDefaultURLRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherDefaultURLRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherDefaultURLRedirect)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherDefaultURLRedirect)(ptr) = RegionURLMapSpecPathMatcherDefaultURLRedirect{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherDefaultURLRedirect)(ptr) = RegionURLMapSpecPathMatcherDefaultURLRedirect{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherDefaultURLRedirect", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteAction)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteAction)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteAction
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteAction)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteAction)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteAction)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteAction{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteAction)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteAction{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteActionCorsPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionTimeoutCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteActionTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteActionUrlRewrite", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) = RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherPathRuleUrlRedirectCodec struct {
}

func (RegionURLMapSpecPathMatcherPathRuleUrlRedirectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherPathRuleUrlRedirect)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherPathRuleUrlRedirectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherPathRuleUrlRedirect)(ptr)
	var objs []RegionURLMapSpecPathMatcherPathRuleUrlRedirect
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherPathRuleUrlRedirect{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleUrlRedirect{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherPathRuleUrlRedirectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherPathRuleUrlRedirect)(ptr) = RegionURLMapSpecPathMatcherPathRuleUrlRedirect{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherPathRuleUrlRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherPathRuleUrlRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherPathRuleUrlRedirect)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherPathRuleUrlRedirect)(ptr) = RegionURLMapSpecPathMatcherPathRuleUrlRedirect{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherPathRuleUrlRedirect)(ptr) = RegionURLMapSpecPathMatcherPathRuleUrlRedirect{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherPathRuleUrlRedirect", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesHeaderActionCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesHeaderActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesHeaderAction)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesHeaderActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesHeaderAction)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesHeaderAction
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesHeaderAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesHeaderAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesHeaderActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesHeaderAction)(ptr) = RegionURLMapSpecPathMatcherRouteRulesHeaderAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesHeaderAction)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesHeaderAction)(ptr) = RegionURLMapSpecPathMatcherRouteRulesHeaderAction{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesHeaderAction)(ptr) = RegionURLMapSpecPathMatcherRouteRulesHeaderAction{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesHeaderAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) = RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) = RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) = RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteAction)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteAction)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteAction
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteAction)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteAction)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteAction)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteAction{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteAction)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteAction{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteActionCorsPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteActionTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteActionUrlRewrite", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) = RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegionURLMapSpecPathMatcherRouteRulesUrlRedirectCodec struct {
}

func (RegionURLMapSpecPathMatcherRouteRulesUrlRedirectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegionURLMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) == nil
}

func (RegionURLMapSpecPathMatcherRouteRulesUrlRedirectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegionURLMapSpecPathMatcherRouteRulesUrlRedirect)(ptr)
	var objs []RegionURLMapSpecPathMatcherRouteRulesUrlRedirect
	if obj != nil {
		objs = []RegionURLMapSpecPathMatcherRouteRulesUrlRedirect{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesUrlRedirect{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegionURLMapSpecPathMatcherRouteRulesUrlRedirectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegionURLMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) = RegionURLMapSpecPathMatcherRouteRulesUrlRedirect{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegionURLMapSpecPathMatcherRouteRulesUrlRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegionURLMapSpecPathMatcherRouteRulesUrlRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegionURLMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) = objs[0]
			} else {
				*(*RegionURLMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) = RegionURLMapSpecPathMatcherRouteRulesUrlRedirect{}
			}
		} else {
			*(*RegionURLMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) = RegionURLMapSpecPathMatcherRouteRulesUrlRedirect{}
		}
	default:
		iter.ReportError("decode RegionURLMapSpecPathMatcherRouteRulesUrlRedirect", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ReservationSpecSpecificReservationCodec struct {
}

func (ReservationSpecSpecificReservationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ReservationSpecSpecificReservation)(ptr) == nil
}

func (ReservationSpecSpecificReservationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ReservationSpecSpecificReservation)(ptr)
	var objs []ReservationSpecSpecificReservation
	if obj != nil {
		objs = []ReservationSpecSpecificReservation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ReservationSpecSpecificReservation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ReservationSpecSpecificReservationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ReservationSpecSpecificReservation)(ptr) = ReservationSpecSpecificReservation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ReservationSpecSpecificReservation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ReservationSpecSpecificReservation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ReservationSpecSpecificReservation)(ptr) = objs[0]
			} else {
				*(*ReservationSpecSpecificReservation)(ptr) = ReservationSpecSpecificReservation{}
			}
		} else {
			*(*ReservationSpecSpecificReservation)(ptr) = ReservationSpecSpecificReservation{}
		}
	default:
		iter.ReportError("decode ReservationSpecSpecificReservation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ReservationSpecSpecificReservationInstancePropertiesCodec struct {
}

func (ReservationSpecSpecificReservationInstancePropertiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ReservationSpecSpecificReservationInstanceProperties)(ptr) == nil
}

func (ReservationSpecSpecificReservationInstancePropertiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ReservationSpecSpecificReservationInstanceProperties)(ptr)
	var objs []ReservationSpecSpecificReservationInstanceProperties
	if obj != nil {
		objs = []ReservationSpecSpecificReservationInstanceProperties{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ReservationSpecSpecificReservationInstanceProperties{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ReservationSpecSpecificReservationInstancePropertiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ReservationSpecSpecificReservationInstanceProperties)(ptr) = ReservationSpecSpecificReservationInstanceProperties{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ReservationSpecSpecificReservationInstanceProperties

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ReservationSpecSpecificReservationInstanceProperties{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ReservationSpecSpecificReservationInstanceProperties)(ptr) = objs[0]
			} else {
				*(*ReservationSpecSpecificReservationInstanceProperties)(ptr) = ReservationSpecSpecificReservationInstanceProperties{}
			}
		} else {
			*(*ReservationSpecSpecificReservationInstanceProperties)(ptr) = ReservationSpecSpecificReservationInstanceProperties{}
		}
	default:
		iter.ReportError("decode ReservationSpecSpecificReservationInstanceProperties", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResourcePolicySpecGroupPlacementPolicyCodec struct {
}

func (ResourcePolicySpecGroupPlacementPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResourcePolicySpecGroupPlacementPolicy)(ptr) == nil
}

func (ResourcePolicySpecGroupPlacementPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResourcePolicySpecGroupPlacementPolicy)(ptr)
	var objs []ResourcePolicySpecGroupPlacementPolicy
	if obj != nil {
		objs = []ResourcePolicySpecGroupPlacementPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecGroupPlacementPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResourcePolicySpecGroupPlacementPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResourcePolicySpecGroupPlacementPolicy)(ptr) = ResourcePolicySpecGroupPlacementPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResourcePolicySpecGroupPlacementPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecGroupPlacementPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResourcePolicySpecGroupPlacementPolicy)(ptr) = objs[0]
			} else {
				*(*ResourcePolicySpecGroupPlacementPolicy)(ptr) = ResourcePolicySpecGroupPlacementPolicy{}
			}
		} else {
			*(*ResourcePolicySpecGroupPlacementPolicy)(ptr) = ResourcePolicySpecGroupPlacementPolicy{}
		}
	default:
		iter.ReportError("decode ResourcePolicySpecGroupPlacementPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResourcePolicySpecSnapshotSchedulePolicyCodec struct {
}

func (ResourcePolicySpecSnapshotSchedulePolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResourcePolicySpecSnapshotSchedulePolicy)(ptr) == nil
}

func (ResourcePolicySpecSnapshotSchedulePolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResourcePolicySpecSnapshotSchedulePolicy)(ptr)
	var objs []ResourcePolicySpecSnapshotSchedulePolicy
	if obj != nil {
		objs = []ResourcePolicySpecSnapshotSchedulePolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResourcePolicySpecSnapshotSchedulePolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResourcePolicySpecSnapshotSchedulePolicy)(ptr) = ResourcePolicySpecSnapshotSchedulePolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResourcePolicySpecSnapshotSchedulePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResourcePolicySpecSnapshotSchedulePolicy)(ptr) = objs[0]
			} else {
				*(*ResourcePolicySpecSnapshotSchedulePolicy)(ptr) = ResourcePolicySpecSnapshotSchedulePolicy{}
			}
		} else {
			*(*ResourcePolicySpecSnapshotSchedulePolicy)(ptr) = ResourcePolicySpecSnapshotSchedulePolicy{}
		}
	default:
		iter.ReportError("decode ResourcePolicySpecSnapshotSchedulePolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicyCodec struct {
}

func (ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy)(ptr) == nil
}

func (ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy)(ptr)
	var objs []ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy
	if obj != nil {
		objs = []ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy)(ptr) = objs[0]
			} else {
				*(*ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy{}
			}
		} else {
			*(*ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy{}
		}
	default:
		iter.ReportError("decode ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResourcePolicySpecSnapshotSchedulePolicyScheduleCodec struct {
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResourcePolicySpecSnapshotSchedulePolicySchedule)(ptr) == nil
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResourcePolicySpecSnapshotSchedulePolicySchedule)(ptr)
	var objs []ResourcePolicySpecSnapshotSchedulePolicySchedule
	if obj != nil {
		objs = []ResourcePolicySpecSnapshotSchedulePolicySchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicySchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResourcePolicySpecSnapshotSchedulePolicySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicySchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResourcePolicySpecSnapshotSchedulePolicySchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicySchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResourcePolicySpecSnapshotSchedulePolicySchedule)(ptr) = objs[0]
			} else {
				*(*ResourcePolicySpecSnapshotSchedulePolicySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicySchedule{}
			}
		} else {
			*(*ResourcePolicySpecSnapshotSchedulePolicySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicySchedule{}
		}
	default:
		iter.ReportError("decode ResourcePolicySpecSnapshotSchedulePolicySchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResourcePolicySpecSnapshotSchedulePolicyScheduleDailyScheduleCodec struct {
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleDailyScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule)(ptr) == nil
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleDailyScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule)(ptr)
	var objs []ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule
	if obj != nil {
		objs = []ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleDailyScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule)(ptr) = objs[0]
			} else {
				*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule{}
			}
		} else {
			*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule{}
		}
	default:
		iter.ReportError("decode ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlyScheduleCodec struct {
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlyScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule)(ptr) == nil
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlyScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule)(ptr)
	var objs []ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule
	if obj != nil {
		objs = []ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlyScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule)(ptr) = objs[0]
			} else {
				*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule{}
			}
		} else {
			*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule{}
		}
	default:
		iter.ReportError("decode ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklyScheduleCodec struct {
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklyScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule)(ptr) == nil
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklyScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule)(ptr)
	var objs []ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule
	if obj != nil {
		objs = []ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklyScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule)(ptr) = objs[0]
			} else {
				*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule{}
			}
		} else {
			*(*ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule)(ptr) = ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule{}
		}
	default:
		iter.ReportError("decode ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ResourcePolicySpecSnapshotSchedulePolicySnapshotPropertiesCodec struct {
}

func (ResourcePolicySpecSnapshotSchedulePolicySnapshotPropertiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties)(ptr) == nil
}

func (ResourcePolicySpecSnapshotSchedulePolicySnapshotPropertiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties)(ptr)
	var objs []ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties
	if obj != nil {
		objs = []ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ResourcePolicySpecSnapshotSchedulePolicySnapshotPropertiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties)(ptr) = ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties)(ptr) = objs[0]
			} else {
				*(*ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties)(ptr) = ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties{}
			}
		} else {
			*(*ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties)(ptr) = ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties{}
		}
	default:
		iter.ReportError("decode ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouterSpecBgpCodec struct {
}

func (RouterSpecBgpCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouterSpecBgp)(ptr) == nil
}

func (RouterSpecBgpCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouterSpecBgp)(ptr)
	var objs []RouterSpecBgp
	if obj != nil {
		objs = []RouterSpecBgp{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouterSpecBgp{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouterSpecBgpCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouterSpecBgp)(ptr) = RouterSpecBgp{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouterSpecBgp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouterSpecBgp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouterSpecBgp)(ptr) = objs[0]
			} else {
				*(*RouterSpecBgp)(ptr) = RouterSpecBgp{}
			}
		} else {
			*(*RouterSpecBgp)(ptr) = RouterSpecBgp{}
		}
	default:
		iter.ReportError("decode RouterSpecBgp", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouterNATSpecLogConfigCodec struct {
}

func (RouterNATSpecLogConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouterNATSpecLogConfig)(ptr) == nil
}

func (RouterNATSpecLogConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouterNATSpecLogConfig)(ptr)
	var objs []RouterNATSpecLogConfig
	if obj != nil {
		objs = []RouterNATSpecLogConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouterNATSpecLogConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouterNATSpecLogConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouterNATSpecLogConfig)(ptr) = RouterNATSpecLogConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouterNATSpecLogConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouterNATSpecLogConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouterNATSpecLogConfig)(ptr) = objs[0]
			} else {
				*(*RouterNATSpecLogConfig)(ptr) = RouterNATSpecLogConfig{}
			}
		} else {
			*(*RouterNATSpecLogConfig)(ptr) = RouterNATSpecLogConfig{}
		}
	default:
		iter.ReportError("decode RouterNATSpecLogConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SecurityPolicySpecRuleMatchCodec struct {
}

func (SecurityPolicySpecRuleMatchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SecurityPolicySpecRuleMatch)(ptr) == nil
}

func (SecurityPolicySpecRuleMatchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SecurityPolicySpecRuleMatch)(ptr)
	var objs []SecurityPolicySpecRuleMatch
	if obj != nil {
		objs = []SecurityPolicySpecRuleMatch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SecurityPolicySpecRuleMatchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SecurityPolicySpecRuleMatch)(ptr) = SecurityPolicySpecRuleMatch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SecurityPolicySpecRuleMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SecurityPolicySpecRuleMatch)(ptr) = objs[0]
			} else {
				*(*SecurityPolicySpecRuleMatch)(ptr) = SecurityPolicySpecRuleMatch{}
			}
		} else {
			*(*SecurityPolicySpecRuleMatch)(ptr) = SecurityPolicySpecRuleMatch{}
		}
	default:
		iter.ReportError("decode SecurityPolicySpecRuleMatch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SecurityPolicySpecRuleMatchConfigCodec struct {
}

func (SecurityPolicySpecRuleMatchConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SecurityPolicySpecRuleMatchConfig)(ptr) == nil
}

func (SecurityPolicySpecRuleMatchConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SecurityPolicySpecRuleMatchConfig)(ptr)
	var objs []SecurityPolicySpecRuleMatchConfig
	if obj != nil {
		objs = []SecurityPolicySpecRuleMatchConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatchConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SecurityPolicySpecRuleMatchConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SecurityPolicySpecRuleMatchConfig)(ptr) = SecurityPolicySpecRuleMatchConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SecurityPolicySpecRuleMatchConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatchConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SecurityPolicySpecRuleMatchConfig)(ptr) = objs[0]
			} else {
				*(*SecurityPolicySpecRuleMatchConfig)(ptr) = SecurityPolicySpecRuleMatchConfig{}
			}
		} else {
			*(*SecurityPolicySpecRuleMatchConfig)(ptr) = SecurityPolicySpecRuleMatchConfig{}
		}
	default:
		iter.ReportError("decode SecurityPolicySpecRuleMatchConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SecurityPolicySpecRuleMatchExprCodec struct {
}

func (SecurityPolicySpecRuleMatchExprCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SecurityPolicySpecRuleMatchExpr)(ptr) == nil
}

func (SecurityPolicySpecRuleMatchExprCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SecurityPolicySpecRuleMatchExpr)(ptr)
	var objs []SecurityPolicySpecRuleMatchExpr
	if obj != nil {
		objs = []SecurityPolicySpecRuleMatchExpr{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatchExpr{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SecurityPolicySpecRuleMatchExprCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SecurityPolicySpecRuleMatchExpr)(ptr) = SecurityPolicySpecRuleMatchExpr{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SecurityPolicySpecRuleMatchExpr

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityPolicySpecRuleMatchExpr{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SecurityPolicySpecRuleMatchExpr)(ptr) = objs[0]
			} else {
				*(*SecurityPolicySpecRuleMatchExpr)(ptr) = SecurityPolicySpecRuleMatchExpr{}
			}
		} else {
			*(*SecurityPolicySpecRuleMatchExpr)(ptr) = SecurityPolicySpecRuleMatchExpr{}
		}
	default:
		iter.ReportError("decode SecurityPolicySpecRuleMatchExpr", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SnapshotSpecSnapshotEncryptionKeyCodec struct {
}

func (SnapshotSpecSnapshotEncryptionKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SnapshotSpecSnapshotEncryptionKey)(ptr) == nil
}

func (SnapshotSpecSnapshotEncryptionKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SnapshotSpecSnapshotEncryptionKey)(ptr)
	var objs []SnapshotSpecSnapshotEncryptionKey
	if obj != nil {
		objs = []SnapshotSpecSnapshotEncryptionKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SnapshotSpecSnapshotEncryptionKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SnapshotSpecSnapshotEncryptionKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SnapshotSpecSnapshotEncryptionKey)(ptr) = SnapshotSpecSnapshotEncryptionKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SnapshotSpecSnapshotEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SnapshotSpecSnapshotEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SnapshotSpecSnapshotEncryptionKey)(ptr) = objs[0]
			} else {
				*(*SnapshotSpecSnapshotEncryptionKey)(ptr) = SnapshotSpecSnapshotEncryptionKey{}
			}
		} else {
			*(*SnapshotSpecSnapshotEncryptionKey)(ptr) = SnapshotSpecSnapshotEncryptionKey{}
		}
	default:
		iter.ReportError("decode SnapshotSpecSnapshotEncryptionKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SnapshotSpecSourceDiskEncryptionKeyCodec struct {
}

func (SnapshotSpecSourceDiskEncryptionKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SnapshotSpecSourceDiskEncryptionKey)(ptr) == nil
}

func (SnapshotSpecSourceDiskEncryptionKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SnapshotSpecSourceDiskEncryptionKey)(ptr)
	var objs []SnapshotSpecSourceDiskEncryptionKey
	if obj != nil {
		objs = []SnapshotSpecSourceDiskEncryptionKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SnapshotSpecSourceDiskEncryptionKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SnapshotSpecSourceDiskEncryptionKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SnapshotSpecSourceDiskEncryptionKey)(ptr) = SnapshotSpecSourceDiskEncryptionKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SnapshotSpecSourceDiskEncryptionKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SnapshotSpecSourceDiskEncryptionKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SnapshotSpecSourceDiskEncryptionKey)(ptr) = objs[0]
			} else {
				*(*SnapshotSpecSourceDiskEncryptionKey)(ptr) = SnapshotSpecSourceDiskEncryptionKey{}
			}
		} else {
			*(*SnapshotSpecSourceDiskEncryptionKey)(ptr) = SnapshotSpecSourceDiskEncryptionKey{}
		}
	default:
		iter.ReportError("decode SnapshotSpecSourceDiskEncryptionKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SubnetworkSpecLogConfigCodec struct {
}

func (SubnetworkSpecLogConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SubnetworkSpecLogConfig)(ptr) == nil
}

func (SubnetworkSpecLogConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SubnetworkSpecLogConfig)(ptr)
	var objs []SubnetworkSpecLogConfig
	if obj != nil {
		objs = []SubnetworkSpecLogConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkSpecLogConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SubnetworkSpecLogConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SubnetworkSpecLogConfig)(ptr) = SubnetworkSpecLogConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SubnetworkSpecLogConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkSpecLogConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SubnetworkSpecLogConfig)(ptr) = objs[0]
			} else {
				*(*SubnetworkSpecLogConfig)(ptr) = SubnetworkSpecLogConfig{}
			}
		} else {
			*(*SubnetworkSpecLogConfig)(ptr) = SubnetworkSpecLogConfig{}
		}
	default:
		iter.ReportError("decode SubnetworkSpecLogConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SubnetworkIamBindingSpecConditionCodec struct {
}

func (SubnetworkIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SubnetworkIamBindingSpecCondition)(ptr) == nil
}

func (SubnetworkIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SubnetworkIamBindingSpecCondition)(ptr)
	var objs []SubnetworkIamBindingSpecCondition
	if obj != nil {
		objs = []SubnetworkIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SubnetworkIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SubnetworkIamBindingSpecCondition)(ptr) = SubnetworkIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SubnetworkIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SubnetworkIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*SubnetworkIamBindingSpecCondition)(ptr) = SubnetworkIamBindingSpecCondition{}
			}
		} else {
			*(*SubnetworkIamBindingSpecCondition)(ptr) = SubnetworkIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode SubnetworkIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SubnetworkIamMemberSpecConditionCodec struct {
}

func (SubnetworkIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SubnetworkIamMemberSpecCondition)(ptr) == nil
}

func (SubnetworkIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SubnetworkIamMemberSpecCondition)(ptr)
	var objs []SubnetworkIamMemberSpecCondition
	if obj != nil {
		objs = []SubnetworkIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SubnetworkIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SubnetworkIamMemberSpecCondition)(ptr) = SubnetworkIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SubnetworkIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubnetworkIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SubnetworkIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*SubnetworkIamMemberSpecCondition)(ptr) = SubnetworkIamMemberSpecCondition{}
			}
		} else {
			*(*SubnetworkIamMemberSpecCondition)(ptr) = SubnetworkIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode SubnetworkIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionCodec struct {
}

func (UrlMapSpecDefaultRouteActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteAction)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteAction)(ptr)
	var objs []UrlMapSpecDefaultRouteAction
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteAction)(ptr) = UrlMapSpecDefaultRouteAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteAction)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteAction)(ptr) = UrlMapSpecDefaultRouteAction{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteAction)(ptr) = UrlMapSpecDefaultRouteAction{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionCorsPolicyCodec struct {
}

func (UrlMapSpecDefaultRouteActionCorsPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteActionCorsPolicy)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionCorsPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteActionCorsPolicy)(ptr)
	var objs []UrlMapSpecDefaultRouteActionCorsPolicy
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteActionCorsPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionCorsPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionCorsPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteActionCorsPolicy)(ptr) = UrlMapSpecDefaultRouteActionCorsPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteActionCorsPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionCorsPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteActionCorsPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteActionCorsPolicy)(ptr) = UrlMapSpecDefaultRouteActionCorsPolicy{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteActionCorsPolicy)(ptr) = UrlMapSpecDefaultRouteActionCorsPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteActionCorsPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionFaultInjectionPolicyCodec struct {
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteActionFaultInjectionPolicy)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteActionFaultInjectionPolicy)(ptr)
	var objs []UrlMapSpecDefaultRouteActionFaultInjectionPolicy
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteActionFaultInjectionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteActionFaultInjectionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicy{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteActionFaultInjectionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbortCodec struct {
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbortCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbortCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort)(ptr)
	var objs []UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbortCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteActionFaultInjectionPolicyAbort", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayCodec struct {
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay)(ptr)
	var objs []UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec struct {
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr)
	var objs []UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteActionFaultInjectionPolicyDelayFixedDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionRequestMirrorPolicyCodec struct {
}

func (UrlMapSpecDefaultRouteActionRequestMirrorPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteActionRequestMirrorPolicy)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionRequestMirrorPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteActionRequestMirrorPolicy)(ptr)
	var objs []UrlMapSpecDefaultRouteActionRequestMirrorPolicy
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteActionRequestMirrorPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRequestMirrorPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionRequestMirrorPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecDefaultRouteActionRequestMirrorPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteActionRequestMirrorPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRequestMirrorPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteActionRequestMirrorPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecDefaultRouteActionRequestMirrorPolicy{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecDefaultRouteActionRequestMirrorPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteActionRequestMirrorPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionRetryPolicyCodec struct {
}

func (UrlMapSpecDefaultRouteActionRetryPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteActionRetryPolicy)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionRetryPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteActionRetryPolicy)(ptr)
	var objs []UrlMapSpecDefaultRouteActionRetryPolicy
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteActionRetryPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRetryPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionRetryPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteActionRetryPolicy)(ptr) = UrlMapSpecDefaultRouteActionRetryPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteActionRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteActionRetryPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteActionRetryPolicy)(ptr) = UrlMapSpecDefaultRouteActionRetryPolicy{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteActionRetryPolicy)(ptr) = UrlMapSpecDefaultRouteActionRetryPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteActionRetryPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeoutCodec struct {
}

func (UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout)(ptr)
	var objs []UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteActionRetryPolicyPerTryTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionTimeoutCodec struct {
}

func (UrlMapSpecDefaultRouteActionTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteActionTimeout)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteActionTimeout)(ptr)
	var objs []UrlMapSpecDefaultRouteActionTimeout
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteActionTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteActionTimeout)(ptr) = UrlMapSpecDefaultRouteActionTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteActionTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteActionTimeout)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteActionTimeout)(ptr) = UrlMapSpecDefaultRouteActionTimeout{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteActionTimeout)(ptr) = UrlMapSpecDefaultRouteActionTimeout{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteActionTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionUrlRewriteCodec struct {
}

func (UrlMapSpecDefaultRouteActionUrlRewriteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteActionUrlRewrite)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionUrlRewriteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteActionUrlRewrite)(ptr)
	var objs []UrlMapSpecDefaultRouteActionUrlRewrite
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteActionUrlRewrite{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionUrlRewrite{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionUrlRewriteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteActionUrlRewrite)(ptr) = UrlMapSpecDefaultRouteActionUrlRewrite{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteActionUrlRewrite

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionUrlRewrite{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteActionUrlRewrite)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteActionUrlRewrite)(ptr) = UrlMapSpecDefaultRouteActionUrlRewrite{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteActionUrlRewrite)(ptr) = UrlMapSpecDefaultRouteActionUrlRewrite{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteActionUrlRewrite", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionCodec struct {
}

func (UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) == nil
}

func (UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr)
	var objs []UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction
	if obj != nil {
		objs = []UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction{}
			}
		} else {
			*(*UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultRouteActionWeightedBackendServicesHeaderAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecDefaultURLRedirectCodec struct {
}

func (UrlMapSpecDefaultURLRedirectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecDefaultURLRedirect)(ptr) == nil
}

func (UrlMapSpecDefaultURLRedirectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecDefaultURLRedirect)(ptr)
	var objs []UrlMapSpecDefaultURLRedirect
	if obj != nil {
		objs = []UrlMapSpecDefaultURLRedirect{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultURLRedirect{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecDefaultURLRedirectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecDefaultURLRedirect)(ptr) = UrlMapSpecDefaultURLRedirect{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecDefaultURLRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecDefaultURLRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecDefaultURLRedirect)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecDefaultURLRedirect)(ptr) = UrlMapSpecDefaultURLRedirect{}
			}
		} else {
			*(*UrlMapSpecDefaultURLRedirect)(ptr) = UrlMapSpecDefaultURLRedirect{}
		}
	default:
		iter.ReportError("decode UrlMapSpecDefaultURLRedirect", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecHeaderActionCodec struct {
}

func (UrlMapSpecHeaderActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecHeaderAction)(ptr) == nil
}

func (UrlMapSpecHeaderActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecHeaderAction)(ptr)
	var objs []UrlMapSpecHeaderAction
	if obj != nil {
		objs = []UrlMapSpecHeaderAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecHeaderAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecHeaderActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecHeaderAction)(ptr) = UrlMapSpecHeaderAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecHeaderAction)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecHeaderAction)(ptr) = UrlMapSpecHeaderAction{}
			}
		} else {
			*(*UrlMapSpecHeaderAction)(ptr) = UrlMapSpecHeaderAction{}
		}
	default:
		iter.ReportError("decode UrlMapSpecHeaderAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteAction)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteAction)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteAction
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteAction)(ptr) = UrlMapSpecPathMatcherDefaultRouteAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteAction)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteAction)(ptr) = UrlMapSpecPathMatcherDefaultRouteAction{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteAction)(ptr) = UrlMapSpecPathMatcherDefaultRouteAction{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionCorsPolicyCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionCorsPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionCorsPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionCorsPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteActionCorsPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbortCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbortCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbortCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbortCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyAbort", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteActionFaultInjectionPolicyDelayFixedDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicyCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteActionRequestMirrorPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteActionRetryPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteActionRetryPolicyPerTryTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionTimeoutCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteActionTimeout)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteActionTimeout)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteActionTimeout
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteActionTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteActionTimeout)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteActionTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteActionTimeout)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteActionTimeout)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionTimeout{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionTimeout)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionTimeout{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteActionTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionUrlRewriteCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionUrlRewriteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionUrlRewriteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionUrlRewriteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteActionUrlRewrite", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionCodec struct {
}

func (UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultRouteActionWeightedBackendServicesHeaderAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherDefaultURLRedirectCodec struct {
}

func (UrlMapSpecPathMatcherDefaultURLRedirectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherDefaultURLRedirect)(ptr) == nil
}

func (UrlMapSpecPathMatcherDefaultURLRedirectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherDefaultURLRedirect)(ptr)
	var objs []UrlMapSpecPathMatcherDefaultURLRedirect
	if obj != nil {
		objs = []UrlMapSpecPathMatcherDefaultURLRedirect{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultURLRedirect{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherDefaultURLRedirectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherDefaultURLRedirect)(ptr) = UrlMapSpecPathMatcherDefaultURLRedirect{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherDefaultURLRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherDefaultURLRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherDefaultURLRedirect)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherDefaultURLRedirect)(ptr) = UrlMapSpecPathMatcherDefaultURLRedirect{}
			}
		} else {
			*(*UrlMapSpecPathMatcherDefaultURLRedirect)(ptr) = UrlMapSpecPathMatcherDefaultURLRedirect{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherDefaultURLRedirect", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherHeaderActionCodec struct {
}

func (UrlMapSpecPathMatcherHeaderActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherHeaderAction)(ptr) == nil
}

func (UrlMapSpecPathMatcherHeaderActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherHeaderAction)(ptr)
	var objs []UrlMapSpecPathMatcherHeaderAction
	if obj != nil {
		objs = []UrlMapSpecPathMatcherHeaderAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherHeaderAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherHeaderActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherHeaderAction)(ptr) = UrlMapSpecPathMatcherHeaderAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherHeaderAction)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherHeaderAction)(ptr) = UrlMapSpecPathMatcherHeaderAction{}
			}
		} else {
			*(*UrlMapSpecPathMatcherHeaderAction)(ptr) = UrlMapSpecPathMatcherHeaderAction{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherHeaderAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteAction)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteAction)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteAction
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteAction)(ptr) = UrlMapSpecPathMatcherPathRuleRouteAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteAction)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteAction)(ptr) = UrlMapSpecPathMatcherPathRuleRouteAction{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteAction)(ptr) = UrlMapSpecPathMatcherPathRuleRouteAction{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteActionCorsPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbortCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyAbort", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteActionFaultInjectionPolicyDelayFixedDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteActionRequestMirrorPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteActionRetryPolicyPerTryTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionTimeoutCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteActionTimeout
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteActionTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteActionTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionTimeout{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionTimeout)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionTimeout{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteActionTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionUrlRewriteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteActionUrlRewrite", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleRouteActionWeightedBackendServicesHeaderAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherPathRuleUrlRedirectCodec struct {
}

func (UrlMapSpecPathMatcherPathRuleUrlRedirectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherPathRuleUrlRedirect)(ptr) == nil
}

func (UrlMapSpecPathMatcherPathRuleUrlRedirectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherPathRuleUrlRedirect)(ptr)
	var objs []UrlMapSpecPathMatcherPathRuleUrlRedirect
	if obj != nil {
		objs = []UrlMapSpecPathMatcherPathRuleUrlRedirect{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleUrlRedirect{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherPathRuleUrlRedirectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherPathRuleUrlRedirect)(ptr) = UrlMapSpecPathMatcherPathRuleUrlRedirect{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherPathRuleUrlRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherPathRuleUrlRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherPathRuleUrlRedirect)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherPathRuleUrlRedirect)(ptr) = UrlMapSpecPathMatcherPathRuleUrlRedirect{}
			}
		} else {
			*(*UrlMapSpecPathMatcherPathRuleUrlRedirect)(ptr) = UrlMapSpecPathMatcherPathRuleUrlRedirect{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherPathRuleUrlRedirect", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesHeaderActionCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesHeaderActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesHeaderAction)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesHeaderActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesHeaderAction)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesHeaderAction
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesHeaderAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesHeaderAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesHeaderActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesHeaderAction)(ptr) = UrlMapSpecPathMatcherRouteRulesHeaderAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesHeaderAction)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesHeaderAction)(ptr) = UrlMapSpecPathMatcherRouteRulesHeaderAction{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesHeaderAction)(ptr) = UrlMapSpecPathMatcherRouteRulesHeaderAction{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesHeaderAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) = UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) = UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch)(ptr) = UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesMatchRulesHeaderMatchesRangeMatch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteAction)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteAction)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteAction
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteAction)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteAction)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteAction)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteAction{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteAction)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteAction{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteActionCorsPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbortCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyAbort", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteActionFaultInjectionPolicyDelayFixedDelay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteActionRequestMirrorPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteActionRetryPolicyPerTryTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteActionTimeout
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteActionTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteActionTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionTimeout{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionTimeout)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionTimeout{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteActionTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewriteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteActionUrlRewrite", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction)(ptr) = UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesRouteActionWeightedBackendServicesHeaderAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type UrlMapSpecPathMatcherRouteRulesUrlRedirectCodec struct {
}

func (UrlMapSpecPathMatcherRouteRulesUrlRedirectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*UrlMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) == nil
}

func (UrlMapSpecPathMatcherRouteRulesUrlRedirectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*UrlMapSpecPathMatcherRouteRulesUrlRedirect)(ptr)
	var objs []UrlMapSpecPathMatcherRouteRulesUrlRedirect
	if obj != nil {
		objs = []UrlMapSpecPathMatcherRouteRulesUrlRedirect{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesUrlRedirect{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (UrlMapSpecPathMatcherRouteRulesUrlRedirectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*UrlMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) = UrlMapSpecPathMatcherRouteRulesUrlRedirect{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []UrlMapSpecPathMatcherRouteRulesUrlRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(UrlMapSpecPathMatcherRouteRulesUrlRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*UrlMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) = objs[0]
			} else {
				*(*UrlMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) = UrlMapSpecPathMatcherRouteRulesUrlRedirect{}
			}
		} else {
			*(*UrlMapSpecPathMatcherRouteRulesUrlRedirect)(ptr) = UrlMapSpecPathMatcherRouteRulesUrlRedirect{}
		}
	default:
		iter.ReportError("decode UrlMapSpecPathMatcherRouteRulesUrlRedirect", "unexpected JSON type")
	}
}
