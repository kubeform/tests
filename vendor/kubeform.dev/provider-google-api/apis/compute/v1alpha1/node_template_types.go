/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type NodeTemplate struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              NodeTemplateSpec   `json:"spec,omitempty"`
	Status            NodeTemplateStatus `json:"status,omitempty"`
}

type NodeTemplateSpec struct {
	NodeTemplateSpec2 `json:",inline"`
	// +optional
	KubeformOutput NodeTemplateSpec2 `json:"kubeformOutput,omitempty" tf:"-"`
}

type NodeTemplateSpecNodeTypeFlexibility struct {
	// Number of virtual CPUs to use.
	// +optional
	Cpus *string `json:"cpus,omitempty" tf:"cpus"`
	// Use local SSD
	// +optional
	LocalSsd *string `json:"localSsd,omitempty" tf:"local_ssd"`
	// Physical memory available to the node, defined in MB.
	// +optional
	Memory *string `json:"memory,omitempty" tf:"memory"`
}

type NodeTemplateSpecServerBinding struct {
	// Type of server binding policy. If 'RESTART_NODE_ON_ANY_SERVER',
	// nodes using this template will restart on any physical server
	// following a maintenance event.
	//
	// If 'RESTART_NODE_ON_MINIMAL_SERVER', nodes using this template
	// will restart on the same physical server following a maintenance
	// event, instead of being live migrated to or restarted on a new
	// physical server. This option may be useful if you are using
	// software licenses tied to the underlying server characteristics
	// such as physical sockets or cores, to avoid the need for
	// additional licenses when maintenance occurs. However, VMs on such
	// nodes will experience outages while maintenance is applied. Possible values: ["RESTART_NODE_ON_ANY_SERVER", "RESTART_NODE_ON_MINIMAL_SERVERS"]
	Type *string `json:"type" tf:"type"`
}

type NodeTemplateSpec2 struct {
	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	Timeouts *base.ResourceTimeout `json:"timeouts,omitempty" tf:"timeouts"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// CPU overcommit. Default value: "NONE" Possible values: ["ENABLED", "NONE"]
	// +optional
	CpuOvercommitType *string `json:"cpuOvercommitType,omitempty" tf:"cpu_overcommit_type"`
	// Creation timestamp in RFC3339 text format.
	// +optional
	CreationTimestamp *string `json:"creationTimestamp,omitempty" tf:"creation_timestamp"`
	// An optional textual description of the resource.
	// +optional
	Description *string `json:"description,omitempty" tf:"description"`
	// Name of the resource.
	// +optional
	Name *string `json:"name,omitempty" tf:"name"`
	// Labels to use for node affinity, which will be used in
	// instance scheduling.
	// +optional
	NodeAffinityLabels *map[string]string `json:"nodeAffinityLabels,omitempty" tf:"node_affinity_labels"`
	// Node type to use for nodes group that are created from this template.
	// Only one of nodeTypeFlexibility and nodeType can be specified.
	// +optional
	NodeType *string `json:"nodeType,omitempty" tf:"node_type"`
	// Flexible properties for the desired node type. Node groups that
	// use this node template will create nodes of a type that matches
	// these properties. Only one of nodeTypeFlexibility and nodeType can
	// be specified.
	// +optional
	NodeTypeFlexibility *NodeTemplateSpecNodeTypeFlexibility `json:"nodeTypeFlexibility,omitempty" tf:"node_type_flexibility"`
	// +optional
	Project *string `json:"project,omitempty" tf:"project"`
	// Region where nodes using the node template will be created.
	// If it is not provided, the provider region is used.
	// +optional
	Region *string `json:"region,omitempty" tf:"region"`
	// +optional
	SelfLink *string `json:"selfLink,omitempty" tf:"self_link"`
	// The server binding policy for nodes using this template. Determines
	// where the nodes should restart following a maintenance event.
	// +optional
	ServerBinding *NodeTemplateSpecServerBinding `json:"serverBinding,omitempty" tf:"server_binding"`
}

type NodeTemplateStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase base.Phase `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// NodeTemplateList is a list of NodeTemplates
type NodeTemplateList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of NodeTemplate CRD objects
	Items []NodeTemplate `json:"items,omitempty"`
}
