/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type ResourcePolicy struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ResourcePolicySpec   `json:"spec,omitempty"`
	Status            ResourcePolicyStatus `json:"status,omitempty"`
}

type ResourcePolicySpec struct {
	ResourcePolicySpec2 `json:",inline"`
	// +optional
	KubeformOutput ResourcePolicySpec2 `json:"kubeformOutput,omitempty" tf:"-"`
}

type ResourcePolicySpecGroupPlacementPolicy struct {
	// The number of availability domains instances will be spread across. If two instances are in different
	// availability domain, they will not be put in the same low latency network
	// +optional
	AvailabilityDomainCount *int64 `json:"availabilityDomainCount,omitempty" tf:"availability_domain_count"`
	// Collocation specifies whether to place VMs inside the same availability domain on the same low-latency network.
	// Specify 'COLLOCATED' to enable collocation. Can only be specified with 'vm_count'. If compute instances are created
	// with a COLLOCATED policy, then exactly 'vm_count' instances must be created at the same time with the resource policy
	// attached. Possible values: ["COLLOCATED"]
	// +optional
	Collocation *string `json:"collocation,omitempty" tf:"collocation"`
	// Number of vms in this placement group.
	// +optional
	VmCount *int64 `json:"vmCount,omitempty" tf:"vm_count"`
}

type ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy struct {
	// Maximum age of the snapshot that is allowed to be kept.
	MaxRetentionDays *int64 `json:"maxRetentionDays" tf:"max_retention_days"`
	// Specifies the behavior to apply to scheduled snapshots when
	// the source disk is deleted. Default value: "KEEP_AUTO_SNAPSHOTS" Possible values: ["KEEP_AUTO_SNAPSHOTS", "APPLY_RETENTION_POLICY"]
	// +optional
	OnSourceDiskDelete *string `json:"onSourceDiskDelete,omitempty" tf:"on_source_disk_delete"`
}

type ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule struct {
	// The number of days between snapshots.
	DaysInCycle *int64 `json:"daysInCycle" tf:"days_in_cycle"`
	// This must be in UTC format that resolves to one of
	// 00:00, 04:00, 08:00, 12:00, 16:00, or 20:00. For example,
	// both 13:00-5 and 08:00 are valid.
	StartTime *string `json:"startTime" tf:"start_time"`
}

type ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule struct {
	// The number of hours between snapshots.
	HoursInCycle *int64 `json:"hoursInCycle" tf:"hours_in_cycle"`
	// Time within the window to start the operations.
	// It must be in an hourly format "HH:MM",
	// where HH : [00-23] and MM : [00] GMT.
	// eg: 21:00
	StartTime *string `json:"startTime" tf:"start_time"`
}

type ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeeks struct {
	// The day of the week to create the snapshot. e.g. MONDAY Possible values: ["MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"]
	Day *string `json:"day" tf:"day"`
	// Time within the window to start the operations.
	// It must be in format "HH:MM", where HH : [00-23] and MM : [00-00] GMT.
	StartTime *string `json:"startTime" tf:"start_time"`
}

type ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule struct {
	// May contain up to seven (one for each day of the week) snapshot times.
	// +kubebuilder:validation:MaxItems=7
	// +kubebuilder:validation:MinItems=1
	DayOfWeeks []ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklyScheduleDayOfWeeks `json:"dayOfWeeks" tf:"day_of_weeks"`
}

type ResourcePolicySpecSnapshotSchedulePolicySchedule struct {
	// The policy will execute every nth day at the specified time.
	// +optional
	DailySchedule *ResourcePolicySpecSnapshotSchedulePolicyScheduleDailySchedule `json:"dailySchedule,omitempty" tf:"daily_schedule"`
	// The policy will execute every nth hour starting at the specified time.
	// +optional
	HourlySchedule *ResourcePolicySpecSnapshotSchedulePolicyScheduleHourlySchedule `json:"hourlySchedule,omitempty" tf:"hourly_schedule"`
	// Allows specifying a snapshot time for each day of the week.
	// +optional
	WeeklySchedule *ResourcePolicySpecSnapshotSchedulePolicyScheduleWeeklySchedule `json:"weeklySchedule,omitempty" tf:"weekly_schedule"`
}

type ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties struct {
	// Whether to perform a 'guest aware' snapshot.
	// +optional
	GuestFlush *bool `json:"guestFlush,omitempty" tf:"guest_flush"`
	// A set of key-value pairs.
	// +optional
	Labels *map[string]string `json:"labels,omitempty" tf:"labels"`
	// Cloud Storage bucket location to store the auto snapshot
	// (regional or multi-regional)
	// +optional
	StorageLocations []string `json:"storageLocations,omitempty" tf:"storage_locations"`
}

type ResourcePolicySpecSnapshotSchedulePolicy struct {
	// Retention policy applied to snapshots created by this resource policy.
	// +optional
	RetentionPolicy *ResourcePolicySpecSnapshotSchedulePolicyRetentionPolicy `json:"retentionPolicy,omitempty" tf:"retention_policy"`
	// Contains one of an 'hourlySchedule', 'dailySchedule', or 'weeklySchedule'.
	Schedule *ResourcePolicySpecSnapshotSchedulePolicySchedule `json:"schedule" tf:"schedule"`
	// Properties with which the snapshots are created, such as labels.
	// +optional
	SnapshotProperties *ResourcePolicySpecSnapshotSchedulePolicySnapshotProperties `json:"snapshotProperties,omitempty" tf:"snapshot_properties"`
}

type ResourcePolicySpec2 struct {
	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	Timeouts *base.ResourceTimeout `json:"timeouts,omitempty" tf:"timeouts"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// Resource policy for instances used for placement configuration.
	// +optional
	GroupPlacementPolicy *ResourcePolicySpecGroupPlacementPolicy `json:"groupPlacementPolicy,omitempty" tf:"group_placement_policy"`
	// The name of the resource, provided by the client when initially creating
	// the resource. The resource name must be 1-63 characters long, and comply
	// with RFC1035. Specifically, the name must be 1-63 characters long and
	// match the regular expression '[a-z]([-a-z0-9]*[a-z0-9])'? which means the
	// first character must be a lowercase letter, and all following characters
	// must be a dash, lowercase letter, or digit, except the last character,
	// which cannot be a dash.
	Name *string `json:"name" tf:"name"`
	// +optional
	Project *string `json:"project,omitempty" tf:"project"`
	// Region where resource policy resides.
	// +optional
	Region *string `json:"region,omitempty" tf:"region"`
	// +optional
	SelfLink *string `json:"selfLink,omitempty" tf:"self_link"`
	// Policy for creating snapshots of persistent disks.
	// +optional
	SnapshotSchedulePolicy *ResourcePolicySpecSnapshotSchedulePolicy `json:"snapshotSchedulePolicy,omitempty" tf:"snapshot_schedule_policy"`
}

type ResourcePolicyStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase base.Phase `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// ResourcePolicyList is a list of ResourcePolicys
type ResourcePolicyList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of ResourcePolicy CRD objects
	Items []ResourcePolicy `json:"items,omitempty"`
}
