/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AssetFolderFeedSpecCondition{}).Type1()):                                                AssetFolderFeedSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AssetFolderFeedSpecFeedOutputConfig{}).Type1()):                                         AssetFolderFeedSpecFeedOutputConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AssetFolderFeedSpecFeedOutputConfigPubsubDestination{}).Type1()):                        AssetFolderFeedSpecFeedOutputConfigPubsubDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AssetOrganizationFeedSpecCondition{}).Type1()):                                          AssetOrganizationFeedSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AssetOrganizationFeedSpecFeedOutputConfig{}).Type1()):                                   AssetOrganizationFeedSpecFeedOutputConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AssetOrganizationFeedSpecFeedOutputConfigPubsubDestination{}).Type1()):                  AssetOrganizationFeedSpecFeedOutputConfigPubsubDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AssetProjectFeedSpecCondition{}).Type1()):                                               AssetProjectFeedSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AssetProjectFeedSpecFeedOutputConfig{}).Type1()):                                        AssetProjectFeedSpecFeedOutputConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AssetProjectFeedSpecFeedOutputConfigPubsubDestination{}).Type1()):                       AssetProjectFeedSpecFeedOutputConfigPubsubDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IdentityGroupSpecGroupKey{}).Type1()):                                                   IdentityGroupSpecGroupKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IdentityGroupMembershipSpecPreferredMemberKey{}).Type1()):                               IdentityGroupMembershipSpecPreferredMemberKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunDomainMappingSpecMetadata{}).Type1()):                                                RunDomainMappingSpecMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunDomainMappingSpecSpec{}).Type1()):                                                    RunDomainMappingSpecSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecMetadata{}).Type1()):                                                      RunServiceSpecMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplate{}).Type1()):                                                      RunServiceSpecTemplateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateMetadata{}).Type1()):                                              RunServiceSpecTemplateMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpec{}).Type1()):                                                  RunServiceSpecTemplateSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpecContainersEnvFromConfigMapRef{}).Type1()):                     RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference{}).Type1()): RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReferenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpecContainersEnvFromSecretRef{}).Type1()):                        RunServiceSpecTemplateSpecContainersEnvFromSecretRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReference{}).Type1()):    RunServiceSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReferenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpecContainersResources{}).Type1()):                               RunServiceSpecTemplateSpecContainersResourcesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunServiceIamBindingSpecCondition{}).Type1()):                                           RunServiceIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunServiceIamMemberSpecCondition{}).Type1()):                                            RunServiceIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecAppEngineHTTPTarget{}).Type1()):                                         SchedulerJobSpecAppEngineHTTPTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecAppEngineHTTPTargetAppEngineRouting{}).Type1()):                         SchedulerJobSpecAppEngineHTTPTargetAppEngineRoutingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecHttpTarget{}).Type1()):                                                  SchedulerJobSpecHttpTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecHttpTargetOauthToken{}).Type1()):                                        SchedulerJobSpecHttpTargetOauthTokenCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecHttpTargetOidcToken{}).Type1()):                                         SchedulerJobSpecHttpTargetOidcTokenCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecPubsubTarget{}).Type1()):                                                SchedulerJobSpecPubsubTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecRetryConfig{}).Type1()):                                                 SchedulerJobSpecRetryConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TasksQueueSpecAppEngineRoutingOverride{}).Type1()):                                      TasksQueueSpecAppEngineRoutingOverrideCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TasksQueueSpecRateLimits{}).Type1()):                                                    TasksQueueSpecRateLimitsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TasksQueueSpecRetryConfig{}).Type1()):                                                   TasksQueueSpecRetryConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TasksQueueSpecStackdriverLoggingConfig{}).Type1()):                                      TasksQueueSpecStackdriverLoggingConfigCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AssetFolderFeedSpecCondition{}).Type1()):                                                AssetFolderFeedSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AssetFolderFeedSpecFeedOutputConfig{}).Type1()):                                         AssetFolderFeedSpecFeedOutputConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AssetFolderFeedSpecFeedOutputConfigPubsubDestination{}).Type1()):                        AssetFolderFeedSpecFeedOutputConfigPubsubDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AssetOrganizationFeedSpecCondition{}).Type1()):                                          AssetOrganizationFeedSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AssetOrganizationFeedSpecFeedOutputConfig{}).Type1()):                                   AssetOrganizationFeedSpecFeedOutputConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AssetOrganizationFeedSpecFeedOutputConfigPubsubDestination{}).Type1()):                  AssetOrganizationFeedSpecFeedOutputConfigPubsubDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AssetProjectFeedSpecCondition{}).Type1()):                                               AssetProjectFeedSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AssetProjectFeedSpecFeedOutputConfig{}).Type1()):                                        AssetProjectFeedSpecFeedOutputConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AssetProjectFeedSpecFeedOutputConfigPubsubDestination{}).Type1()):                       AssetProjectFeedSpecFeedOutputConfigPubsubDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IdentityGroupSpecGroupKey{}).Type1()):                                                   IdentityGroupSpecGroupKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IdentityGroupMembershipSpecPreferredMemberKey{}).Type1()):                               IdentityGroupMembershipSpecPreferredMemberKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunDomainMappingSpecMetadata{}).Type1()):                                                RunDomainMappingSpecMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunDomainMappingSpecSpec{}).Type1()):                                                    RunDomainMappingSpecSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecMetadata{}).Type1()):                                                      RunServiceSpecMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplate{}).Type1()):                                                      RunServiceSpecTemplateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateMetadata{}).Type1()):                                              RunServiceSpecTemplateMetadataCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpec{}).Type1()):                                                  RunServiceSpecTemplateSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpecContainersEnvFromConfigMapRef{}).Type1()):                     RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference{}).Type1()): RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReferenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpecContainersEnvFromSecretRef{}).Type1()):                        RunServiceSpecTemplateSpecContainersEnvFromSecretRefCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReference{}).Type1()):    RunServiceSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReferenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpecContainersResources{}).Type1()):                               RunServiceSpecTemplateSpecContainersResourcesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunServiceIamBindingSpecCondition{}).Type1()):                                           RunServiceIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RunServiceIamMemberSpecCondition{}).Type1()):                                            RunServiceIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecAppEngineHTTPTarget{}).Type1()):                                         SchedulerJobSpecAppEngineHTTPTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecAppEngineHTTPTargetAppEngineRouting{}).Type1()):                         SchedulerJobSpecAppEngineHTTPTargetAppEngineRoutingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecHttpTarget{}).Type1()):                                                  SchedulerJobSpecHttpTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecHttpTargetOauthToken{}).Type1()):                                        SchedulerJobSpecHttpTargetOauthTokenCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecHttpTargetOidcToken{}).Type1()):                                         SchedulerJobSpecHttpTargetOidcTokenCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecPubsubTarget{}).Type1()):                                                SchedulerJobSpecPubsubTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecRetryConfig{}).Type1()):                                                 SchedulerJobSpecRetryConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TasksQueueSpecAppEngineRoutingOverride{}).Type1()):                                      TasksQueueSpecAppEngineRoutingOverrideCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TasksQueueSpecRateLimits{}).Type1()):                                                    TasksQueueSpecRateLimitsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TasksQueueSpecRetryConfig{}).Type1()):                                                   TasksQueueSpecRetryConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TasksQueueSpecStackdriverLoggingConfig{}).Type1()):                                      TasksQueueSpecStackdriverLoggingConfigCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AssetFolderFeedSpecConditionCodec struct {
}

func (AssetFolderFeedSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AssetFolderFeedSpecCondition)(ptr) == nil
}

func (AssetFolderFeedSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AssetFolderFeedSpecCondition)(ptr)
	var objs []AssetFolderFeedSpecCondition
	if obj != nil {
		objs = []AssetFolderFeedSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AssetFolderFeedSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AssetFolderFeedSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AssetFolderFeedSpecCondition)(ptr) = AssetFolderFeedSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AssetFolderFeedSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AssetFolderFeedSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AssetFolderFeedSpecCondition)(ptr) = objs[0]
			} else {
				*(*AssetFolderFeedSpecCondition)(ptr) = AssetFolderFeedSpecCondition{}
			}
		} else {
			*(*AssetFolderFeedSpecCondition)(ptr) = AssetFolderFeedSpecCondition{}
		}
	default:
		iter.ReportError("decode AssetFolderFeedSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AssetFolderFeedSpecFeedOutputConfigCodec struct {
}

func (AssetFolderFeedSpecFeedOutputConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AssetFolderFeedSpecFeedOutputConfig)(ptr) == nil
}

func (AssetFolderFeedSpecFeedOutputConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AssetFolderFeedSpecFeedOutputConfig)(ptr)
	var objs []AssetFolderFeedSpecFeedOutputConfig
	if obj != nil {
		objs = []AssetFolderFeedSpecFeedOutputConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AssetFolderFeedSpecFeedOutputConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AssetFolderFeedSpecFeedOutputConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AssetFolderFeedSpecFeedOutputConfig)(ptr) = AssetFolderFeedSpecFeedOutputConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AssetFolderFeedSpecFeedOutputConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AssetFolderFeedSpecFeedOutputConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AssetFolderFeedSpecFeedOutputConfig)(ptr) = objs[0]
			} else {
				*(*AssetFolderFeedSpecFeedOutputConfig)(ptr) = AssetFolderFeedSpecFeedOutputConfig{}
			}
		} else {
			*(*AssetFolderFeedSpecFeedOutputConfig)(ptr) = AssetFolderFeedSpecFeedOutputConfig{}
		}
	default:
		iter.ReportError("decode AssetFolderFeedSpecFeedOutputConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AssetFolderFeedSpecFeedOutputConfigPubsubDestinationCodec struct {
}

func (AssetFolderFeedSpecFeedOutputConfigPubsubDestinationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AssetFolderFeedSpecFeedOutputConfigPubsubDestination)(ptr) == nil
}

func (AssetFolderFeedSpecFeedOutputConfigPubsubDestinationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AssetFolderFeedSpecFeedOutputConfigPubsubDestination)(ptr)
	var objs []AssetFolderFeedSpecFeedOutputConfigPubsubDestination
	if obj != nil {
		objs = []AssetFolderFeedSpecFeedOutputConfigPubsubDestination{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AssetFolderFeedSpecFeedOutputConfigPubsubDestination{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AssetFolderFeedSpecFeedOutputConfigPubsubDestinationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AssetFolderFeedSpecFeedOutputConfigPubsubDestination)(ptr) = AssetFolderFeedSpecFeedOutputConfigPubsubDestination{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AssetFolderFeedSpecFeedOutputConfigPubsubDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AssetFolderFeedSpecFeedOutputConfigPubsubDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AssetFolderFeedSpecFeedOutputConfigPubsubDestination)(ptr) = objs[0]
			} else {
				*(*AssetFolderFeedSpecFeedOutputConfigPubsubDestination)(ptr) = AssetFolderFeedSpecFeedOutputConfigPubsubDestination{}
			}
		} else {
			*(*AssetFolderFeedSpecFeedOutputConfigPubsubDestination)(ptr) = AssetFolderFeedSpecFeedOutputConfigPubsubDestination{}
		}
	default:
		iter.ReportError("decode AssetFolderFeedSpecFeedOutputConfigPubsubDestination", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AssetOrganizationFeedSpecConditionCodec struct {
}

func (AssetOrganizationFeedSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AssetOrganizationFeedSpecCondition)(ptr) == nil
}

func (AssetOrganizationFeedSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AssetOrganizationFeedSpecCondition)(ptr)
	var objs []AssetOrganizationFeedSpecCondition
	if obj != nil {
		objs = []AssetOrganizationFeedSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AssetOrganizationFeedSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AssetOrganizationFeedSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AssetOrganizationFeedSpecCondition)(ptr) = AssetOrganizationFeedSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AssetOrganizationFeedSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AssetOrganizationFeedSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AssetOrganizationFeedSpecCondition)(ptr) = objs[0]
			} else {
				*(*AssetOrganizationFeedSpecCondition)(ptr) = AssetOrganizationFeedSpecCondition{}
			}
		} else {
			*(*AssetOrganizationFeedSpecCondition)(ptr) = AssetOrganizationFeedSpecCondition{}
		}
	default:
		iter.ReportError("decode AssetOrganizationFeedSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AssetOrganizationFeedSpecFeedOutputConfigCodec struct {
}

func (AssetOrganizationFeedSpecFeedOutputConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AssetOrganizationFeedSpecFeedOutputConfig)(ptr) == nil
}

func (AssetOrganizationFeedSpecFeedOutputConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AssetOrganizationFeedSpecFeedOutputConfig)(ptr)
	var objs []AssetOrganizationFeedSpecFeedOutputConfig
	if obj != nil {
		objs = []AssetOrganizationFeedSpecFeedOutputConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AssetOrganizationFeedSpecFeedOutputConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AssetOrganizationFeedSpecFeedOutputConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AssetOrganizationFeedSpecFeedOutputConfig)(ptr) = AssetOrganizationFeedSpecFeedOutputConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AssetOrganizationFeedSpecFeedOutputConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AssetOrganizationFeedSpecFeedOutputConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AssetOrganizationFeedSpecFeedOutputConfig)(ptr) = objs[0]
			} else {
				*(*AssetOrganizationFeedSpecFeedOutputConfig)(ptr) = AssetOrganizationFeedSpecFeedOutputConfig{}
			}
		} else {
			*(*AssetOrganizationFeedSpecFeedOutputConfig)(ptr) = AssetOrganizationFeedSpecFeedOutputConfig{}
		}
	default:
		iter.ReportError("decode AssetOrganizationFeedSpecFeedOutputConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AssetOrganizationFeedSpecFeedOutputConfigPubsubDestinationCodec struct {
}

func (AssetOrganizationFeedSpecFeedOutputConfigPubsubDestinationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AssetOrganizationFeedSpecFeedOutputConfigPubsubDestination)(ptr) == nil
}

func (AssetOrganizationFeedSpecFeedOutputConfigPubsubDestinationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AssetOrganizationFeedSpecFeedOutputConfigPubsubDestination)(ptr)
	var objs []AssetOrganizationFeedSpecFeedOutputConfigPubsubDestination
	if obj != nil {
		objs = []AssetOrganizationFeedSpecFeedOutputConfigPubsubDestination{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AssetOrganizationFeedSpecFeedOutputConfigPubsubDestination{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AssetOrganizationFeedSpecFeedOutputConfigPubsubDestinationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AssetOrganizationFeedSpecFeedOutputConfigPubsubDestination)(ptr) = AssetOrganizationFeedSpecFeedOutputConfigPubsubDestination{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AssetOrganizationFeedSpecFeedOutputConfigPubsubDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AssetOrganizationFeedSpecFeedOutputConfigPubsubDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AssetOrganizationFeedSpecFeedOutputConfigPubsubDestination)(ptr) = objs[0]
			} else {
				*(*AssetOrganizationFeedSpecFeedOutputConfigPubsubDestination)(ptr) = AssetOrganizationFeedSpecFeedOutputConfigPubsubDestination{}
			}
		} else {
			*(*AssetOrganizationFeedSpecFeedOutputConfigPubsubDestination)(ptr) = AssetOrganizationFeedSpecFeedOutputConfigPubsubDestination{}
		}
	default:
		iter.ReportError("decode AssetOrganizationFeedSpecFeedOutputConfigPubsubDestination", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AssetProjectFeedSpecConditionCodec struct {
}

func (AssetProjectFeedSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AssetProjectFeedSpecCondition)(ptr) == nil
}

func (AssetProjectFeedSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AssetProjectFeedSpecCondition)(ptr)
	var objs []AssetProjectFeedSpecCondition
	if obj != nil {
		objs = []AssetProjectFeedSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AssetProjectFeedSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AssetProjectFeedSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AssetProjectFeedSpecCondition)(ptr) = AssetProjectFeedSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AssetProjectFeedSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AssetProjectFeedSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AssetProjectFeedSpecCondition)(ptr) = objs[0]
			} else {
				*(*AssetProjectFeedSpecCondition)(ptr) = AssetProjectFeedSpecCondition{}
			}
		} else {
			*(*AssetProjectFeedSpecCondition)(ptr) = AssetProjectFeedSpecCondition{}
		}
	default:
		iter.ReportError("decode AssetProjectFeedSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AssetProjectFeedSpecFeedOutputConfigCodec struct {
}

func (AssetProjectFeedSpecFeedOutputConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AssetProjectFeedSpecFeedOutputConfig)(ptr) == nil
}

func (AssetProjectFeedSpecFeedOutputConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AssetProjectFeedSpecFeedOutputConfig)(ptr)
	var objs []AssetProjectFeedSpecFeedOutputConfig
	if obj != nil {
		objs = []AssetProjectFeedSpecFeedOutputConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AssetProjectFeedSpecFeedOutputConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AssetProjectFeedSpecFeedOutputConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AssetProjectFeedSpecFeedOutputConfig)(ptr) = AssetProjectFeedSpecFeedOutputConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AssetProjectFeedSpecFeedOutputConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AssetProjectFeedSpecFeedOutputConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AssetProjectFeedSpecFeedOutputConfig)(ptr) = objs[0]
			} else {
				*(*AssetProjectFeedSpecFeedOutputConfig)(ptr) = AssetProjectFeedSpecFeedOutputConfig{}
			}
		} else {
			*(*AssetProjectFeedSpecFeedOutputConfig)(ptr) = AssetProjectFeedSpecFeedOutputConfig{}
		}
	default:
		iter.ReportError("decode AssetProjectFeedSpecFeedOutputConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AssetProjectFeedSpecFeedOutputConfigPubsubDestinationCodec struct {
}

func (AssetProjectFeedSpecFeedOutputConfigPubsubDestinationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AssetProjectFeedSpecFeedOutputConfigPubsubDestination)(ptr) == nil
}

func (AssetProjectFeedSpecFeedOutputConfigPubsubDestinationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AssetProjectFeedSpecFeedOutputConfigPubsubDestination)(ptr)
	var objs []AssetProjectFeedSpecFeedOutputConfigPubsubDestination
	if obj != nil {
		objs = []AssetProjectFeedSpecFeedOutputConfigPubsubDestination{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AssetProjectFeedSpecFeedOutputConfigPubsubDestination{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AssetProjectFeedSpecFeedOutputConfigPubsubDestinationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AssetProjectFeedSpecFeedOutputConfigPubsubDestination)(ptr) = AssetProjectFeedSpecFeedOutputConfigPubsubDestination{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AssetProjectFeedSpecFeedOutputConfigPubsubDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AssetProjectFeedSpecFeedOutputConfigPubsubDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AssetProjectFeedSpecFeedOutputConfigPubsubDestination)(ptr) = objs[0]
			} else {
				*(*AssetProjectFeedSpecFeedOutputConfigPubsubDestination)(ptr) = AssetProjectFeedSpecFeedOutputConfigPubsubDestination{}
			}
		} else {
			*(*AssetProjectFeedSpecFeedOutputConfigPubsubDestination)(ptr) = AssetProjectFeedSpecFeedOutputConfigPubsubDestination{}
		}
	default:
		iter.ReportError("decode AssetProjectFeedSpecFeedOutputConfigPubsubDestination", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type IdentityGroupSpecGroupKeyCodec struct {
}

func (IdentityGroupSpecGroupKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*IdentityGroupSpecGroupKey)(ptr) == nil
}

func (IdentityGroupSpecGroupKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*IdentityGroupSpecGroupKey)(ptr)
	var objs []IdentityGroupSpecGroupKey
	if obj != nil {
		objs = []IdentityGroupSpecGroupKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IdentityGroupSpecGroupKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (IdentityGroupSpecGroupKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*IdentityGroupSpecGroupKey)(ptr) = IdentityGroupSpecGroupKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []IdentityGroupSpecGroupKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IdentityGroupSpecGroupKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*IdentityGroupSpecGroupKey)(ptr) = objs[0]
			} else {
				*(*IdentityGroupSpecGroupKey)(ptr) = IdentityGroupSpecGroupKey{}
			}
		} else {
			*(*IdentityGroupSpecGroupKey)(ptr) = IdentityGroupSpecGroupKey{}
		}
	default:
		iter.ReportError("decode IdentityGroupSpecGroupKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type IdentityGroupMembershipSpecPreferredMemberKeyCodec struct {
}

func (IdentityGroupMembershipSpecPreferredMemberKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*IdentityGroupMembershipSpecPreferredMemberKey)(ptr) == nil
}

func (IdentityGroupMembershipSpecPreferredMemberKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*IdentityGroupMembershipSpecPreferredMemberKey)(ptr)
	var objs []IdentityGroupMembershipSpecPreferredMemberKey
	if obj != nil {
		objs = []IdentityGroupMembershipSpecPreferredMemberKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IdentityGroupMembershipSpecPreferredMemberKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (IdentityGroupMembershipSpecPreferredMemberKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*IdentityGroupMembershipSpecPreferredMemberKey)(ptr) = IdentityGroupMembershipSpecPreferredMemberKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []IdentityGroupMembershipSpecPreferredMemberKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IdentityGroupMembershipSpecPreferredMemberKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*IdentityGroupMembershipSpecPreferredMemberKey)(ptr) = objs[0]
			} else {
				*(*IdentityGroupMembershipSpecPreferredMemberKey)(ptr) = IdentityGroupMembershipSpecPreferredMemberKey{}
			}
		} else {
			*(*IdentityGroupMembershipSpecPreferredMemberKey)(ptr) = IdentityGroupMembershipSpecPreferredMemberKey{}
		}
	default:
		iter.ReportError("decode IdentityGroupMembershipSpecPreferredMemberKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RunDomainMappingSpecMetadataCodec struct {
}

func (RunDomainMappingSpecMetadataCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RunDomainMappingSpecMetadata)(ptr) == nil
}

func (RunDomainMappingSpecMetadataCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RunDomainMappingSpecMetadata)(ptr)
	var objs []RunDomainMappingSpecMetadata
	if obj != nil {
		objs = []RunDomainMappingSpecMetadata{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunDomainMappingSpecMetadata{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RunDomainMappingSpecMetadataCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RunDomainMappingSpecMetadata)(ptr) = RunDomainMappingSpecMetadata{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RunDomainMappingSpecMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunDomainMappingSpecMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RunDomainMappingSpecMetadata)(ptr) = objs[0]
			} else {
				*(*RunDomainMappingSpecMetadata)(ptr) = RunDomainMappingSpecMetadata{}
			}
		} else {
			*(*RunDomainMappingSpecMetadata)(ptr) = RunDomainMappingSpecMetadata{}
		}
	default:
		iter.ReportError("decode RunDomainMappingSpecMetadata", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RunDomainMappingSpecSpecCodec struct {
}

func (RunDomainMappingSpecSpecCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RunDomainMappingSpecSpec)(ptr) == nil
}

func (RunDomainMappingSpecSpecCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RunDomainMappingSpecSpec)(ptr)
	var objs []RunDomainMappingSpecSpec
	if obj != nil {
		objs = []RunDomainMappingSpecSpec{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunDomainMappingSpecSpec{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RunDomainMappingSpecSpecCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RunDomainMappingSpecSpec)(ptr) = RunDomainMappingSpecSpec{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RunDomainMappingSpecSpec

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunDomainMappingSpecSpec{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RunDomainMappingSpecSpec)(ptr) = objs[0]
			} else {
				*(*RunDomainMappingSpecSpec)(ptr) = RunDomainMappingSpecSpec{}
			}
		} else {
			*(*RunDomainMappingSpecSpec)(ptr) = RunDomainMappingSpecSpec{}
		}
	default:
		iter.ReportError("decode RunDomainMappingSpecSpec", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RunServiceSpecMetadataCodec struct {
}

func (RunServiceSpecMetadataCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RunServiceSpecMetadata)(ptr) == nil
}

func (RunServiceSpecMetadataCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RunServiceSpecMetadata)(ptr)
	var objs []RunServiceSpecMetadata
	if obj != nil {
		objs = []RunServiceSpecMetadata{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecMetadata{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RunServiceSpecMetadataCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RunServiceSpecMetadata)(ptr) = RunServiceSpecMetadata{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RunServiceSpecMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RunServiceSpecMetadata)(ptr) = objs[0]
			} else {
				*(*RunServiceSpecMetadata)(ptr) = RunServiceSpecMetadata{}
			}
		} else {
			*(*RunServiceSpecMetadata)(ptr) = RunServiceSpecMetadata{}
		}
	default:
		iter.ReportError("decode RunServiceSpecMetadata", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RunServiceSpecTemplateCodec struct {
}

func (RunServiceSpecTemplateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RunServiceSpecTemplate)(ptr) == nil
}

func (RunServiceSpecTemplateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RunServiceSpecTemplate)(ptr)
	var objs []RunServiceSpecTemplate
	if obj != nil {
		objs = []RunServiceSpecTemplate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RunServiceSpecTemplateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RunServiceSpecTemplate)(ptr) = RunServiceSpecTemplate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RunServiceSpecTemplate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RunServiceSpecTemplate)(ptr) = objs[0]
			} else {
				*(*RunServiceSpecTemplate)(ptr) = RunServiceSpecTemplate{}
			}
		} else {
			*(*RunServiceSpecTemplate)(ptr) = RunServiceSpecTemplate{}
		}
	default:
		iter.ReportError("decode RunServiceSpecTemplate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RunServiceSpecTemplateMetadataCodec struct {
}

func (RunServiceSpecTemplateMetadataCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RunServiceSpecTemplateMetadata)(ptr) == nil
}

func (RunServiceSpecTemplateMetadataCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RunServiceSpecTemplateMetadata)(ptr)
	var objs []RunServiceSpecTemplateMetadata
	if obj != nil {
		objs = []RunServiceSpecTemplateMetadata{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateMetadata{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RunServiceSpecTemplateMetadataCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RunServiceSpecTemplateMetadata)(ptr) = RunServiceSpecTemplateMetadata{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RunServiceSpecTemplateMetadata

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateMetadata{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RunServiceSpecTemplateMetadata)(ptr) = objs[0]
			} else {
				*(*RunServiceSpecTemplateMetadata)(ptr) = RunServiceSpecTemplateMetadata{}
			}
		} else {
			*(*RunServiceSpecTemplateMetadata)(ptr) = RunServiceSpecTemplateMetadata{}
		}
	default:
		iter.ReportError("decode RunServiceSpecTemplateMetadata", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RunServiceSpecTemplateSpecCodec struct {
}

func (RunServiceSpecTemplateSpecCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RunServiceSpecTemplateSpec)(ptr) == nil
}

func (RunServiceSpecTemplateSpecCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RunServiceSpecTemplateSpec)(ptr)
	var objs []RunServiceSpecTemplateSpec
	if obj != nil {
		objs = []RunServiceSpecTemplateSpec{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpec{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RunServiceSpecTemplateSpecCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RunServiceSpecTemplateSpec)(ptr) = RunServiceSpecTemplateSpec{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RunServiceSpecTemplateSpec

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpec{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RunServiceSpecTemplateSpec)(ptr) = objs[0]
			} else {
				*(*RunServiceSpecTemplateSpec)(ptr) = RunServiceSpecTemplateSpec{}
			}
		} else {
			*(*RunServiceSpecTemplateSpec)(ptr) = RunServiceSpecTemplateSpec{}
		}
	default:
		iter.ReportError("decode RunServiceSpecTemplateSpec", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefCodec struct {
}

func (RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RunServiceSpecTemplateSpecContainersEnvFromConfigMapRef)(ptr) == nil
}

func (RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RunServiceSpecTemplateSpecContainersEnvFromConfigMapRef)(ptr)
	var objs []RunServiceSpecTemplateSpecContainersEnvFromConfigMapRef
	if obj != nil {
		objs = []RunServiceSpecTemplateSpecContainersEnvFromConfigMapRef{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpecContainersEnvFromConfigMapRef{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RunServiceSpecTemplateSpecContainersEnvFromConfigMapRef)(ptr) = RunServiceSpecTemplateSpecContainersEnvFromConfigMapRef{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RunServiceSpecTemplateSpecContainersEnvFromConfigMapRef

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpecContainersEnvFromConfigMapRef{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RunServiceSpecTemplateSpecContainersEnvFromConfigMapRef)(ptr) = objs[0]
			} else {
				*(*RunServiceSpecTemplateSpecContainersEnvFromConfigMapRef)(ptr) = RunServiceSpecTemplateSpecContainersEnvFromConfigMapRef{}
			}
		} else {
			*(*RunServiceSpecTemplateSpecContainersEnvFromConfigMapRef)(ptr) = RunServiceSpecTemplateSpecContainersEnvFromConfigMapRef{}
		}
	default:
		iter.ReportError("decode RunServiceSpecTemplateSpecContainersEnvFromConfigMapRef", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReferenceCodec struct {
}

func (RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReferenceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference)(ptr) == nil
}

func (RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReferenceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference)(ptr)
	var objs []RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference
	if obj != nil {
		objs = []RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReferenceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference)(ptr) = RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference)(ptr) = objs[0]
			} else {
				*(*RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference)(ptr) = RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference{}
			}
		} else {
			*(*RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference)(ptr) = RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference{}
		}
	default:
		iter.ReportError("decode RunServiceSpecTemplateSpecContainersEnvFromConfigMapRefLocalObjectReference", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RunServiceSpecTemplateSpecContainersEnvFromSecretRefCodec struct {
}

func (RunServiceSpecTemplateSpecContainersEnvFromSecretRefCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RunServiceSpecTemplateSpecContainersEnvFromSecretRef)(ptr) == nil
}

func (RunServiceSpecTemplateSpecContainersEnvFromSecretRefCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RunServiceSpecTemplateSpecContainersEnvFromSecretRef)(ptr)
	var objs []RunServiceSpecTemplateSpecContainersEnvFromSecretRef
	if obj != nil {
		objs = []RunServiceSpecTemplateSpecContainersEnvFromSecretRef{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpecContainersEnvFromSecretRef{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RunServiceSpecTemplateSpecContainersEnvFromSecretRefCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RunServiceSpecTemplateSpecContainersEnvFromSecretRef)(ptr) = RunServiceSpecTemplateSpecContainersEnvFromSecretRef{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RunServiceSpecTemplateSpecContainersEnvFromSecretRef

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpecContainersEnvFromSecretRef{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RunServiceSpecTemplateSpecContainersEnvFromSecretRef)(ptr) = objs[0]
			} else {
				*(*RunServiceSpecTemplateSpecContainersEnvFromSecretRef)(ptr) = RunServiceSpecTemplateSpecContainersEnvFromSecretRef{}
			}
		} else {
			*(*RunServiceSpecTemplateSpecContainersEnvFromSecretRef)(ptr) = RunServiceSpecTemplateSpecContainersEnvFromSecretRef{}
		}
	default:
		iter.ReportError("decode RunServiceSpecTemplateSpecContainersEnvFromSecretRef", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RunServiceSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReferenceCodec struct {
}

func (RunServiceSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReferenceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RunServiceSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReference)(ptr) == nil
}

func (RunServiceSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReferenceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RunServiceSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReference)(ptr)
	var objs []RunServiceSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReference
	if obj != nil {
		objs = []RunServiceSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReference{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReference{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RunServiceSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReferenceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RunServiceSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReference)(ptr) = RunServiceSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReference{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RunServiceSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReference

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReference{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RunServiceSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReference)(ptr) = objs[0]
			} else {
				*(*RunServiceSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReference)(ptr) = RunServiceSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReference{}
			}
		} else {
			*(*RunServiceSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReference)(ptr) = RunServiceSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReference{}
		}
	default:
		iter.ReportError("decode RunServiceSpecTemplateSpecContainersEnvFromSecretRefLocalObjectReference", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RunServiceSpecTemplateSpecContainersResourcesCodec struct {
}

func (RunServiceSpecTemplateSpecContainersResourcesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RunServiceSpecTemplateSpecContainersResources)(ptr) == nil
}

func (RunServiceSpecTemplateSpecContainersResourcesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RunServiceSpecTemplateSpecContainersResources)(ptr)
	var objs []RunServiceSpecTemplateSpecContainersResources
	if obj != nil {
		objs = []RunServiceSpecTemplateSpecContainersResources{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpecContainersResources{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RunServiceSpecTemplateSpecContainersResourcesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RunServiceSpecTemplateSpecContainersResources)(ptr) = RunServiceSpecTemplateSpecContainersResources{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RunServiceSpecTemplateSpecContainersResources

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunServiceSpecTemplateSpecContainersResources{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RunServiceSpecTemplateSpecContainersResources)(ptr) = objs[0]
			} else {
				*(*RunServiceSpecTemplateSpecContainersResources)(ptr) = RunServiceSpecTemplateSpecContainersResources{}
			}
		} else {
			*(*RunServiceSpecTemplateSpecContainersResources)(ptr) = RunServiceSpecTemplateSpecContainersResources{}
		}
	default:
		iter.ReportError("decode RunServiceSpecTemplateSpecContainersResources", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RunServiceIamBindingSpecConditionCodec struct {
}

func (RunServiceIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RunServiceIamBindingSpecCondition)(ptr) == nil
}

func (RunServiceIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RunServiceIamBindingSpecCondition)(ptr)
	var objs []RunServiceIamBindingSpecCondition
	if obj != nil {
		objs = []RunServiceIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunServiceIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RunServiceIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RunServiceIamBindingSpecCondition)(ptr) = RunServiceIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RunServiceIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunServiceIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RunServiceIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*RunServiceIamBindingSpecCondition)(ptr) = RunServiceIamBindingSpecCondition{}
			}
		} else {
			*(*RunServiceIamBindingSpecCondition)(ptr) = RunServiceIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode RunServiceIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RunServiceIamMemberSpecConditionCodec struct {
}

func (RunServiceIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RunServiceIamMemberSpecCondition)(ptr) == nil
}

func (RunServiceIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RunServiceIamMemberSpecCondition)(ptr)
	var objs []RunServiceIamMemberSpecCondition
	if obj != nil {
		objs = []RunServiceIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunServiceIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RunServiceIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RunServiceIamMemberSpecCondition)(ptr) = RunServiceIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RunServiceIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RunServiceIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RunServiceIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*RunServiceIamMemberSpecCondition)(ptr) = RunServiceIamMemberSpecCondition{}
			}
		} else {
			*(*RunServiceIamMemberSpecCondition)(ptr) = RunServiceIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode RunServiceIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SchedulerJobSpecAppEngineHTTPTargetCodec struct {
}

func (SchedulerJobSpecAppEngineHTTPTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SchedulerJobSpecAppEngineHTTPTarget)(ptr) == nil
}

func (SchedulerJobSpecAppEngineHTTPTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SchedulerJobSpecAppEngineHTTPTarget)(ptr)
	var objs []SchedulerJobSpecAppEngineHTTPTarget
	if obj != nil {
		objs = []SchedulerJobSpecAppEngineHTTPTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecAppEngineHTTPTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SchedulerJobSpecAppEngineHTTPTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SchedulerJobSpecAppEngineHTTPTarget)(ptr) = SchedulerJobSpecAppEngineHTTPTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SchedulerJobSpecAppEngineHTTPTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecAppEngineHTTPTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SchedulerJobSpecAppEngineHTTPTarget)(ptr) = objs[0]
			} else {
				*(*SchedulerJobSpecAppEngineHTTPTarget)(ptr) = SchedulerJobSpecAppEngineHTTPTarget{}
			}
		} else {
			*(*SchedulerJobSpecAppEngineHTTPTarget)(ptr) = SchedulerJobSpecAppEngineHTTPTarget{}
		}
	default:
		iter.ReportError("decode SchedulerJobSpecAppEngineHTTPTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SchedulerJobSpecAppEngineHTTPTargetAppEngineRoutingCodec struct {
}

func (SchedulerJobSpecAppEngineHTTPTargetAppEngineRoutingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SchedulerJobSpecAppEngineHTTPTargetAppEngineRouting)(ptr) == nil
}

func (SchedulerJobSpecAppEngineHTTPTargetAppEngineRoutingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SchedulerJobSpecAppEngineHTTPTargetAppEngineRouting)(ptr)
	var objs []SchedulerJobSpecAppEngineHTTPTargetAppEngineRouting
	if obj != nil {
		objs = []SchedulerJobSpecAppEngineHTTPTargetAppEngineRouting{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecAppEngineHTTPTargetAppEngineRouting{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SchedulerJobSpecAppEngineHTTPTargetAppEngineRoutingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SchedulerJobSpecAppEngineHTTPTargetAppEngineRouting)(ptr) = SchedulerJobSpecAppEngineHTTPTargetAppEngineRouting{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SchedulerJobSpecAppEngineHTTPTargetAppEngineRouting

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecAppEngineHTTPTargetAppEngineRouting{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SchedulerJobSpecAppEngineHTTPTargetAppEngineRouting)(ptr) = objs[0]
			} else {
				*(*SchedulerJobSpecAppEngineHTTPTargetAppEngineRouting)(ptr) = SchedulerJobSpecAppEngineHTTPTargetAppEngineRouting{}
			}
		} else {
			*(*SchedulerJobSpecAppEngineHTTPTargetAppEngineRouting)(ptr) = SchedulerJobSpecAppEngineHTTPTargetAppEngineRouting{}
		}
	default:
		iter.ReportError("decode SchedulerJobSpecAppEngineHTTPTargetAppEngineRouting", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SchedulerJobSpecHttpTargetCodec struct {
}

func (SchedulerJobSpecHttpTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SchedulerJobSpecHttpTarget)(ptr) == nil
}

func (SchedulerJobSpecHttpTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SchedulerJobSpecHttpTarget)(ptr)
	var objs []SchedulerJobSpecHttpTarget
	if obj != nil {
		objs = []SchedulerJobSpecHttpTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecHttpTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SchedulerJobSpecHttpTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SchedulerJobSpecHttpTarget)(ptr) = SchedulerJobSpecHttpTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SchedulerJobSpecHttpTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecHttpTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SchedulerJobSpecHttpTarget)(ptr) = objs[0]
			} else {
				*(*SchedulerJobSpecHttpTarget)(ptr) = SchedulerJobSpecHttpTarget{}
			}
		} else {
			*(*SchedulerJobSpecHttpTarget)(ptr) = SchedulerJobSpecHttpTarget{}
		}
	default:
		iter.ReportError("decode SchedulerJobSpecHttpTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SchedulerJobSpecHttpTargetOauthTokenCodec struct {
}

func (SchedulerJobSpecHttpTargetOauthTokenCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SchedulerJobSpecHttpTargetOauthToken)(ptr) == nil
}

func (SchedulerJobSpecHttpTargetOauthTokenCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SchedulerJobSpecHttpTargetOauthToken)(ptr)
	var objs []SchedulerJobSpecHttpTargetOauthToken
	if obj != nil {
		objs = []SchedulerJobSpecHttpTargetOauthToken{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecHttpTargetOauthToken{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SchedulerJobSpecHttpTargetOauthTokenCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SchedulerJobSpecHttpTargetOauthToken)(ptr) = SchedulerJobSpecHttpTargetOauthToken{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SchedulerJobSpecHttpTargetOauthToken

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecHttpTargetOauthToken{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SchedulerJobSpecHttpTargetOauthToken)(ptr) = objs[0]
			} else {
				*(*SchedulerJobSpecHttpTargetOauthToken)(ptr) = SchedulerJobSpecHttpTargetOauthToken{}
			}
		} else {
			*(*SchedulerJobSpecHttpTargetOauthToken)(ptr) = SchedulerJobSpecHttpTargetOauthToken{}
		}
	default:
		iter.ReportError("decode SchedulerJobSpecHttpTargetOauthToken", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SchedulerJobSpecHttpTargetOidcTokenCodec struct {
}

func (SchedulerJobSpecHttpTargetOidcTokenCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SchedulerJobSpecHttpTargetOidcToken)(ptr) == nil
}

func (SchedulerJobSpecHttpTargetOidcTokenCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SchedulerJobSpecHttpTargetOidcToken)(ptr)
	var objs []SchedulerJobSpecHttpTargetOidcToken
	if obj != nil {
		objs = []SchedulerJobSpecHttpTargetOidcToken{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecHttpTargetOidcToken{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SchedulerJobSpecHttpTargetOidcTokenCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SchedulerJobSpecHttpTargetOidcToken)(ptr) = SchedulerJobSpecHttpTargetOidcToken{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SchedulerJobSpecHttpTargetOidcToken

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecHttpTargetOidcToken{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SchedulerJobSpecHttpTargetOidcToken)(ptr) = objs[0]
			} else {
				*(*SchedulerJobSpecHttpTargetOidcToken)(ptr) = SchedulerJobSpecHttpTargetOidcToken{}
			}
		} else {
			*(*SchedulerJobSpecHttpTargetOidcToken)(ptr) = SchedulerJobSpecHttpTargetOidcToken{}
		}
	default:
		iter.ReportError("decode SchedulerJobSpecHttpTargetOidcToken", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SchedulerJobSpecPubsubTargetCodec struct {
}

func (SchedulerJobSpecPubsubTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SchedulerJobSpecPubsubTarget)(ptr) == nil
}

func (SchedulerJobSpecPubsubTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SchedulerJobSpecPubsubTarget)(ptr)
	var objs []SchedulerJobSpecPubsubTarget
	if obj != nil {
		objs = []SchedulerJobSpecPubsubTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecPubsubTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SchedulerJobSpecPubsubTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SchedulerJobSpecPubsubTarget)(ptr) = SchedulerJobSpecPubsubTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SchedulerJobSpecPubsubTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecPubsubTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SchedulerJobSpecPubsubTarget)(ptr) = objs[0]
			} else {
				*(*SchedulerJobSpecPubsubTarget)(ptr) = SchedulerJobSpecPubsubTarget{}
			}
		} else {
			*(*SchedulerJobSpecPubsubTarget)(ptr) = SchedulerJobSpecPubsubTarget{}
		}
	default:
		iter.ReportError("decode SchedulerJobSpecPubsubTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SchedulerJobSpecRetryConfigCodec struct {
}

func (SchedulerJobSpecRetryConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SchedulerJobSpecRetryConfig)(ptr) == nil
}

func (SchedulerJobSpecRetryConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SchedulerJobSpecRetryConfig)(ptr)
	var objs []SchedulerJobSpecRetryConfig
	if obj != nil {
		objs = []SchedulerJobSpecRetryConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecRetryConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SchedulerJobSpecRetryConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SchedulerJobSpecRetryConfig)(ptr) = SchedulerJobSpecRetryConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SchedulerJobSpecRetryConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SchedulerJobSpecRetryConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SchedulerJobSpecRetryConfig)(ptr) = objs[0]
			} else {
				*(*SchedulerJobSpecRetryConfig)(ptr) = SchedulerJobSpecRetryConfig{}
			}
		} else {
			*(*SchedulerJobSpecRetryConfig)(ptr) = SchedulerJobSpecRetryConfig{}
		}
	default:
		iter.ReportError("decode SchedulerJobSpecRetryConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TasksQueueSpecAppEngineRoutingOverrideCodec struct {
}

func (TasksQueueSpecAppEngineRoutingOverrideCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TasksQueueSpecAppEngineRoutingOverride)(ptr) == nil
}

func (TasksQueueSpecAppEngineRoutingOverrideCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TasksQueueSpecAppEngineRoutingOverride)(ptr)
	var objs []TasksQueueSpecAppEngineRoutingOverride
	if obj != nil {
		objs = []TasksQueueSpecAppEngineRoutingOverride{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TasksQueueSpecAppEngineRoutingOverride{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TasksQueueSpecAppEngineRoutingOverrideCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TasksQueueSpecAppEngineRoutingOverride)(ptr) = TasksQueueSpecAppEngineRoutingOverride{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TasksQueueSpecAppEngineRoutingOverride

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TasksQueueSpecAppEngineRoutingOverride{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TasksQueueSpecAppEngineRoutingOverride)(ptr) = objs[0]
			} else {
				*(*TasksQueueSpecAppEngineRoutingOverride)(ptr) = TasksQueueSpecAppEngineRoutingOverride{}
			}
		} else {
			*(*TasksQueueSpecAppEngineRoutingOverride)(ptr) = TasksQueueSpecAppEngineRoutingOverride{}
		}
	default:
		iter.ReportError("decode TasksQueueSpecAppEngineRoutingOverride", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TasksQueueSpecRateLimitsCodec struct {
}

func (TasksQueueSpecRateLimitsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TasksQueueSpecRateLimits)(ptr) == nil
}

func (TasksQueueSpecRateLimitsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TasksQueueSpecRateLimits)(ptr)
	var objs []TasksQueueSpecRateLimits
	if obj != nil {
		objs = []TasksQueueSpecRateLimits{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TasksQueueSpecRateLimits{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TasksQueueSpecRateLimitsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TasksQueueSpecRateLimits)(ptr) = TasksQueueSpecRateLimits{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TasksQueueSpecRateLimits

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TasksQueueSpecRateLimits{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TasksQueueSpecRateLimits)(ptr) = objs[0]
			} else {
				*(*TasksQueueSpecRateLimits)(ptr) = TasksQueueSpecRateLimits{}
			}
		} else {
			*(*TasksQueueSpecRateLimits)(ptr) = TasksQueueSpecRateLimits{}
		}
	default:
		iter.ReportError("decode TasksQueueSpecRateLimits", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TasksQueueSpecRetryConfigCodec struct {
}

func (TasksQueueSpecRetryConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TasksQueueSpecRetryConfig)(ptr) == nil
}

func (TasksQueueSpecRetryConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TasksQueueSpecRetryConfig)(ptr)
	var objs []TasksQueueSpecRetryConfig
	if obj != nil {
		objs = []TasksQueueSpecRetryConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TasksQueueSpecRetryConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TasksQueueSpecRetryConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TasksQueueSpecRetryConfig)(ptr) = TasksQueueSpecRetryConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TasksQueueSpecRetryConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TasksQueueSpecRetryConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TasksQueueSpecRetryConfig)(ptr) = objs[0]
			} else {
				*(*TasksQueueSpecRetryConfig)(ptr) = TasksQueueSpecRetryConfig{}
			}
		} else {
			*(*TasksQueueSpecRetryConfig)(ptr) = TasksQueueSpecRetryConfig{}
		}
	default:
		iter.ReportError("decode TasksQueueSpecRetryConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TasksQueueSpecStackdriverLoggingConfigCodec struct {
}

func (TasksQueueSpecStackdriverLoggingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TasksQueueSpecStackdriverLoggingConfig)(ptr) == nil
}

func (TasksQueueSpecStackdriverLoggingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TasksQueueSpecStackdriverLoggingConfig)(ptr)
	var objs []TasksQueueSpecStackdriverLoggingConfig
	if obj != nil {
		objs = []TasksQueueSpecStackdriverLoggingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TasksQueueSpecStackdriverLoggingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TasksQueueSpecStackdriverLoggingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TasksQueueSpecStackdriverLoggingConfig)(ptr) = TasksQueueSpecStackdriverLoggingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TasksQueueSpecStackdriverLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TasksQueueSpecStackdriverLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TasksQueueSpecStackdriverLoggingConfig)(ptr) = objs[0]
			} else {
				*(*TasksQueueSpecStackdriverLoggingConfig)(ptr) = TasksQueueSpecStackdriverLoggingConfig{}
			}
		} else {
			*(*TasksQueueSpecStackdriverLoggingConfig)(ptr) = TasksQueueSpecStackdriverLoggingConfig{}
		}
	default:
		iter.ReportError("decode TasksQueueSpecStackdriverLoggingConfig", "unexpected JSON type")
	}
}
