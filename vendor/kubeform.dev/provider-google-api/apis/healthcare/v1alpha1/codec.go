/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ConsentStoreIamBindingSpecCondition{}).Type1()):                       ConsentStoreIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConsentStoreIamMemberSpecCondition{}).Type1()):                        ConsentStoreIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatasetIamBindingSpecCondition{}).Type1()):                            DatasetIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatasetIamMemberSpecCondition{}).Type1()):                             DatasetIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DicomStoreSpecNotificationConfig{}).Type1()):                          DicomStoreSpecNotificationConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DicomStoreIamBindingSpecCondition{}).Type1()):                         DicomStoreIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DicomStoreIamMemberSpecCondition{}).Type1()):                          DicomStoreIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FhirStoreSpecNotificationConfig{}).Type1()):                           FhirStoreSpecNotificationConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FhirStoreSpecStreamConfigsBigqueryDestination{}).Type1()):             FhirStoreSpecStreamConfigsBigqueryDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FhirStoreSpecStreamConfigsBigqueryDestinationSchemaConfig{}).Type1()): FhirStoreSpecStreamConfigsBigqueryDestinationSchemaConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FhirStoreIamBindingSpecCondition{}).Type1()):                          FhirStoreIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FhirStoreIamMemberSpecCondition{}).Type1()):                           FhirStoreIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(Hl7V2StoreSpecNotificationConfig{}).Type1()):                          Hl7V2StoreSpecNotificationConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(Hl7V2StoreSpecParserConfig{}).Type1()):                                Hl7V2StoreSpecParserConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(Hl7V2StoreIamBindingSpecCondition{}).Type1()):                         Hl7V2StoreIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(Hl7V2StoreIamMemberSpecCondition{}).Type1()):                          Hl7V2StoreIamMemberSpecConditionCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ConsentStoreIamBindingSpecCondition{}).Type1()):                       ConsentStoreIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConsentStoreIamMemberSpecCondition{}).Type1()):                        ConsentStoreIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatasetIamBindingSpecCondition{}).Type1()):                            DatasetIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatasetIamMemberSpecCondition{}).Type1()):                             DatasetIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DicomStoreSpecNotificationConfig{}).Type1()):                          DicomStoreSpecNotificationConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DicomStoreIamBindingSpecCondition{}).Type1()):                         DicomStoreIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DicomStoreIamMemberSpecCondition{}).Type1()):                          DicomStoreIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FhirStoreSpecNotificationConfig{}).Type1()):                           FhirStoreSpecNotificationConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FhirStoreSpecStreamConfigsBigqueryDestination{}).Type1()):             FhirStoreSpecStreamConfigsBigqueryDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FhirStoreSpecStreamConfigsBigqueryDestinationSchemaConfig{}).Type1()): FhirStoreSpecStreamConfigsBigqueryDestinationSchemaConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FhirStoreIamBindingSpecCondition{}).Type1()):                          FhirStoreIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FhirStoreIamMemberSpecCondition{}).Type1()):                           FhirStoreIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(Hl7V2StoreSpecNotificationConfig{}).Type1()):                          Hl7V2StoreSpecNotificationConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(Hl7V2StoreSpecParserConfig{}).Type1()):                                Hl7V2StoreSpecParserConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(Hl7V2StoreIamBindingSpecCondition{}).Type1()):                         Hl7V2StoreIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(Hl7V2StoreIamMemberSpecCondition{}).Type1()):                          Hl7V2StoreIamMemberSpecConditionCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type ConsentStoreIamBindingSpecConditionCodec struct {
}

func (ConsentStoreIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConsentStoreIamBindingSpecCondition)(ptr) == nil
}

func (ConsentStoreIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConsentStoreIamBindingSpecCondition)(ptr)
	var objs []ConsentStoreIamBindingSpecCondition
	if obj != nil {
		objs = []ConsentStoreIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConsentStoreIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConsentStoreIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConsentStoreIamBindingSpecCondition)(ptr) = ConsentStoreIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConsentStoreIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConsentStoreIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConsentStoreIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*ConsentStoreIamBindingSpecCondition)(ptr) = ConsentStoreIamBindingSpecCondition{}
			}
		} else {
			*(*ConsentStoreIamBindingSpecCondition)(ptr) = ConsentStoreIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode ConsentStoreIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConsentStoreIamMemberSpecConditionCodec struct {
}

func (ConsentStoreIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConsentStoreIamMemberSpecCondition)(ptr) == nil
}

func (ConsentStoreIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConsentStoreIamMemberSpecCondition)(ptr)
	var objs []ConsentStoreIamMemberSpecCondition
	if obj != nil {
		objs = []ConsentStoreIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConsentStoreIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConsentStoreIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConsentStoreIamMemberSpecCondition)(ptr) = ConsentStoreIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConsentStoreIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConsentStoreIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConsentStoreIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*ConsentStoreIamMemberSpecCondition)(ptr) = ConsentStoreIamMemberSpecCondition{}
			}
		} else {
			*(*ConsentStoreIamMemberSpecCondition)(ptr) = ConsentStoreIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode ConsentStoreIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DatasetIamBindingSpecConditionCodec struct {
}

func (DatasetIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DatasetIamBindingSpecCondition)(ptr) == nil
}

func (DatasetIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DatasetIamBindingSpecCondition)(ptr)
	var objs []DatasetIamBindingSpecCondition
	if obj != nil {
		objs = []DatasetIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatasetIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DatasetIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DatasetIamBindingSpecCondition)(ptr) = DatasetIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DatasetIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatasetIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DatasetIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*DatasetIamBindingSpecCondition)(ptr) = DatasetIamBindingSpecCondition{}
			}
		} else {
			*(*DatasetIamBindingSpecCondition)(ptr) = DatasetIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode DatasetIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DatasetIamMemberSpecConditionCodec struct {
}

func (DatasetIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DatasetIamMemberSpecCondition)(ptr) == nil
}

func (DatasetIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DatasetIamMemberSpecCondition)(ptr)
	var objs []DatasetIamMemberSpecCondition
	if obj != nil {
		objs = []DatasetIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatasetIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DatasetIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DatasetIamMemberSpecCondition)(ptr) = DatasetIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DatasetIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatasetIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DatasetIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*DatasetIamMemberSpecCondition)(ptr) = DatasetIamMemberSpecCondition{}
			}
		} else {
			*(*DatasetIamMemberSpecCondition)(ptr) = DatasetIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode DatasetIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DicomStoreSpecNotificationConfigCodec struct {
}

func (DicomStoreSpecNotificationConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DicomStoreSpecNotificationConfig)(ptr) == nil
}

func (DicomStoreSpecNotificationConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DicomStoreSpecNotificationConfig)(ptr)
	var objs []DicomStoreSpecNotificationConfig
	if obj != nil {
		objs = []DicomStoreSpecNotificationConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DicomStoreSpecNotificationConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DicomStoreSpecNotificationConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DicomStoreSpecNotificationConfig)(ptr) = DicomStoreSpecNotificationConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DicomStoreSpecNotificationConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DicomStoreSpecNotificationConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DicomStoreSpecNotificationConfig)(ptr) = objs[0]
			} else {
				*(*DicomStoreSpecNotificationConfig)(ptr) = DicomStoreSpecNotificationConfig{}
			}
		} else {
			*(*DicomStoreSpecNotificationConfig)(ptr) = DicomStoreSpecNotificationConfig{}
		}
	default:
		iter.ReportError("decode DicomStoreSpecNotificationConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DicomStoreIamBindingSpecConditionCodec struct {
}

func (DicomStoreIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DicomStoreIamBindingSpecCondition)(ptr) == nil
}

func (DicomStoreIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DicomStoreIamBindingSpecCondition)(ptr)
	var objs []DicomStoreIamBindingSpecCondition
	if obj != nil {
		objs = []DicomStoreIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DicomStoreIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DicomStoreIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DicomStoreIamBindingSpecCondition)(ptr) = DicomStoreIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DicomStoreIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DicomStoreIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DicomStoreIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*DicomStoreIamBindingSpecCondition)(ptr) = DicomStoreIamBindingSpecCondition{}
			}
		} else {
			*(*DicomStoreIamBindingSpecCondition)(ptr) = DicomStoreIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode DicomStoreIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DicomStoreIamMemberSpecConditionCodec struct {
}

func (DicomStoreIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DicomStoreIamMemberSpecCondition)(ptr) == nil
}

func (DicomStoreIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DicomStoreIamMemberSpecCondition)(ptr)
	var objs []DicomStoreIamMemberSpecCondition
	if obj != nil {
		objs = []DicomStoreIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DicomStoreIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DicomStoreIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DicomStoreIamMemberSpecCondition)(ptr) = DicomStoreIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DicomStoreIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DicomStoreIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DicomStoreIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*DicomStoreIamMemberSpecCondition)(ptr) = DicomStoreIamMemberSpecCondition{}
			}
		} else {
			*(*DicomStoreIamMemberSpecCondition)(ptr) = DicomStoreIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode DicomStoreIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FhirStoreSpecNotificationConfigCodec struct {
}

func (FhirStoreSpecNotificationConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FhirStoreSpecNotificationConfig)(ptr) == nil
}

func (FhirStoreSpecNotificationConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FhirStoreSpecNotificationConfig)(ptr)
	var objs []FhirStoreSpecNotificationConfig
	if obj != nil {
		objs = []FhirStoreSpecNotificationConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FhirStoreSpecNotificationConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FhirStoreSpecNotificationConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FhirStoreSpecNotificationConfig)(ptr) = FhirStoreSpecNotificationConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FhirStoreSpecNotificationConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FhirStoreSpecNotificationConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FhirStoreSpecNotificationConfig)(ptr) = objs[0]
			} else {
				*(*FhirStoreSpecNotificationConfig)(ptr) = FhirStoreSpecNotificationConfig{}
			}
		} else {
			*(*FhirStoreSpecNotificationConfig)(ptr) = FhirStoreSpecNotificationConfig{}
		}
	default:
		iter.ReportError("decode FhirStoreSpecNotificationConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FhirStoreSpecStreamConfigsBigqueryDestinationCodec struct {
}

func (FhirStoreSpecStreamConfigsBigqueryDestinationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FhirStoreSpecStreamConfigsBigqueryDestination)(ptr) == nil
}

func (FhirStoreSpecStreamConfigsBigqueryDestinationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FhirStoreSpecStreamConfigsBigqueryDestination)(ptr)
	var objs []FhirStoreSpecStreamConfigsBigqueryDestination
	if obj != nil {
		objs = []FhirStoreSpecStreamConfigsBigqueryDestination{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FhirStoreSpecStreamConfigsBigqueryDestination{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FhirStoreSpecStreamConfigsBigqueryDestinationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FhirStoreSpecStreamConfigsBigqueryDestination)(ptr) = FhirStoreSpecStreamConfigsBigqueryDestination{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FhirStoreSpecStreamConfigsBigqueryDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FhirStoreSpecStreamConfigsBigqueryDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FhirStoreSpecStreamConfigsBigqueryDestination)(ptr) = objs[0]
			} else {
				*(*FhirStoreSpecStreamConfigsBigqueryDestination)(ptr) = FhirStoreSpecStreamConfigsBigqueryDestination{}
			}
		} else {
			*(*FhirStoreSpecStreamConfigsBigqueryDestination)(ptr) = FhirStoreSpecStreamConfigsBigqueryDestination{}
		}
	default:
		iter.ReportError("decode FhirStoreSpecStreamConfigsBigqueryDestination", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FhirStoreSpecStreamConfigsBigqueryDestinationSchemaConfigCodec struct {
}

func (FhirStoreSpecStreamConfigsBigqueryDestinationSchemaConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FhirStoreSpecStreamConfigsBigqueryDestinationSchemaConfig)(ptr) == nil
}

func (FhirStoreSpecStreamConfigsBigqueryDestinationSchemaConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FhirStoreSpecStreamConfigsBigqueryDestinationSchemaConfig)(ptr)
	var objs []FhirStoreSpecStreamConfigsBigqueryDestinationSchemaConfig
	if obj != nil {
		objs = []FhirStoreSpecStreamConfigsBigqueryDestinationSchemaConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FhirStoreSpecStreamConfigsBigqueryDestinationSchemaConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FhirStoreSpecStreamConfigsBigqueryDestinationSchemaConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FhirStoreSpecStreamConfigsBigqueryDestinationSchemaConfig)(ptr) = FhirStoreSpecStreamConfigsBigqueryDestinationSchemaConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FhirStoreSpecStreamConfigsBigqueryDestinationSchemaConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FhirStoreSpecStreamConfigsBigqueryDestinationSchemaConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FhirStoreSpecStreamConfigsBigqueryDestinationSchemaConfig)(ptr) = objs[0]
			} else {
				*(*FhirStoreSpecStreamConfigsBigqueryDestinationSchemaConfig)(ptr) = FhirStoreSpecStreamConfigsBigqueryDestinationSchemaConfig{}
			}
		} else {
			*(*FhirStoreSpecStreamConfigsBigqueryDestinationSchemaConfig)(ptr) = FhirStoreSpecStreamConfigsBigqueryDestinationSchemaConfig{}
		}
	default:
		iter.ReportError("decode FhirStoreSpecStreamConfigsBigqueryDestinationSchemaConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FhirStoreIamBindingSpecConditionCodec struct {
}

func (FhirStoreIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FhirStoreIamBindingSpecCondition)(ptr) == nil
}

func (FhirStoreIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FhirStoreIamBindingSpecCondition)(ptr)
	var objs []FhirStoreIamBindingSpecCondition
	if obj != nil {
		objs = []FhirStoreIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FhirStoreIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FhirStoreIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FhirStoreIamBindingSpecCondition)(ptr) = FhirStoreIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FhirStoreIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FhirStoreIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FhirStoreIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*FhirStoreIamBindingSpecCondition)(ptr) = FhirStoreIamBindingSpecCondition{}
			}
		} else {
			*(*FhirStoreIamBindingSpecCondition)(ptr) = FhirStoreIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode FhirStoreIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FhirStoreIamMemberSpecConditionCodec struct {
}

func (FhirStoreIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FhirStoreIamMemberSpecCondition)(ptr) == nil
}

func (FhirStoreIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FhirStoreIamMemberSpecCondition)(ptr)
	var objs []FhirStoreIamMemberSpecCondition
	if obj != nil {
		objs = []FhirStoreIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FhirStoreIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FhirStoreIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FhirStoreIamMemberSpecCondition)(ptr) = FhirStoreIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FhirStoreIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FhirStoreIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FhirStoreIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*FhirStoreIamMemberSpecCondition)(ptr) = FhirStoreIamMemberSpecCondition{}
			}
		} else {
			*(*FhirStoreIamMemberSpecCondition)(ptr) = FhirStoreIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode FhirStoreIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type Hl7V2StoreSpecNotificationConfigCodec struct {
}

func (Hl7V2StoreSpecNotificationConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*Hl7V2StoreSpecNotificationConfig)(ptr) == nil
}

func (Hl7V2StoreSpecNotificationConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*Hl7V2StoreSpecNotificationConfig)(ptr)
	var objs []Hl7V2StoreSpecNotificationConfig
	if obj != nil {
		objs = []Hl7V2StoreSpecNotificationConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(Hl7V2StoreSpecNotificationConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (Hl7V2StoreSpecNotificationConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*Hl7V2StoreSpecNotificationConfig)(ptr) = Hl7V2StoreSpecNotificationConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []Hl7V2StoreSpecNotificationConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(Hl7V2StoreSpecNotificationConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*Hl7V2StoreSpecNotificationConfig)(ptr) = objs[0]
			} else {
				*(*Hl7V2StoreSpecNotificationConfig)(ptr) = Hl7V2StoreSpecNotificationConfig{}
			}
		} else {
			*(*Hl7V2StoreSpecNotificationConfig)(ptr) = Hl7V2StoreSpecNotificationConfig{}
		}
	default:
		iter.ReportError("decode Hl7V2StoreSpecNotificationConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type Hl7V2StoreSpecParserConfigCodec struct {
}

func (Hl7V2StoreSpecParserConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*Hl7V2StoreSpecParserConfig)(ptr) == nil
}

func (Hl7V2StoreSpecParserConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*Hl7V2StoreSpecParserConfig)(ptr)
	var objs []Hl7V2StoreSpecParserConfig
	if obj != nil {
		objs = []Hl7V2StoreSpecParserConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(Hl7V2StoreSpecParserConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (Hl7V2StoreSpecParserConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*Hl7V2StoreSpecParserConfig)(ptr) = Hl7V2StoreSpecParserConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []Hl7V2StoreSpecParserConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(Hl7V2StoreSpecParserConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*Hl7V2StoreSpecParserConfig)(ptr) = objs[0]
			} else {
				*(*Hl7V2StoreSpecParserConfig)(ptr) = Hl7V2StoreSpecParserConfig{}
			}
		} else {
			*(*Hl7V2StoreSpecParserConfig)(ptr) = Hl7V2StoreSpecParserConfig{}
		}
	default:
		iter.ReportError("decode Hl7V2StoreSpecParserConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type Hl7V2StoreIamBindingSpecConditionCodec struct {
}

func (Hl7V2StoreIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*Hl7V2StoreIamBindingSpecCondition)(ptr) == nil
}

func (Hl7V2StoreIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*Hl7V2StoreIamBindingSpecCondition)(ptr)
	var objs []Hl7V2StoreIamBindingSpecCondition
	if obj != nil {
		objs = []Hl7V2StoreIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(Hl7V2StoreIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (Hl7V2StoreIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*Hl7V2StoreIamBindingSpecCondition)(ptr) = Hl7V2StoreIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []Hl7V2StoreIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(Hl7V2StoreIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*Hl7V2StoreIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*Hl7V2StoreIamBindingSpecCondition)(ptr) = Hl7V2StoreIamBindingSpecCondition{}
			}
		} else {
			*(*Hl7V2StoreIamBindingSpecCondition)(ptr) = Hl7V2StoreIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode Hl7V2StoreIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type Hl7V2StoreIamMemberSpecConditionCodec struct {
}

func (Hl7V2StoreIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*Hl7V2StoreIamMemberSpecCondition)(ptr) == nil
}

func (Hl7V2StoreIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*Hl7V2StoreIamMemberSpecCondition)(ptr)
	var objs []Hl7V2StoreIamMemberSpecCondition
	if obj != nil {
		objs = []Hl7V2StoreIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(Hl7V2StoreIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (Hl7V2StoreIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*Hl7V2StoreIamMemberSpecCondition)(ptr) = Hl7V2StoreIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []Hl7V2StoreIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(Hl7V2StoreIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*Hl7V2StoreIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*Hl7V2StoreIamMemberSpecCondition)(ptr) = Hl7V2StoreIamMemberSpecCondition{}
			}
		} else {
			*(*Hl7V2StoreIamMemberSpecCondition)(ptr) = Hl7V2StoreIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode Hl7V2StoreIamMemberSpecCondition", "unexpected JSON type")
	}
}
