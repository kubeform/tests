/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecBasicAlgorithm{}).Type1()):                       AutoscalingPolicySpecBasicAlgorithmCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecBasicAlgorithmYarnConfig{}).Type1()):             AutoscalingPolicySpecBasicAlgorithmYarnConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecSecondaryWorkerConfig{}).Type1()):                AutoscalingPolicySpecSecondaryWorkerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecWorkerConfig{}).Type1()):                         AutoscalingPolicySpecWorkerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfig{}).Type1()):                                  ClusterSpecClusterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigAutoscalingConfig{}).Type1()):                 ClusterSpecClusterConfigAutoscalingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigEncryptionConfig{}).Type1()):                  ClusterSpecClusterConfigEncryptionConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigGceClusterConfig{}).Type1()):                  ClusterSpecClusterConfigGceClusterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigMasterConfig{}).Type1()):                      ClusterSpecClusterConfigMasterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigMasterConfigDiskConfig{}).Type1()):            ClusterSpecClusterConfigMasterConfigDiskConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigPreemptibleWorkerConfig{}).Type1()):           ClusterSpecClusterConfigPreemptibleWorkerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig{}).Type1()): ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSecurityConfig{}).Type1()):                    ClusterSpecClusterConfigSecurityConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSecurityConfigKerberosConfig{}).Type1()):      ClusterSpecClusterConfigSecurityConfigKerberosConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSoftwareConfig{}).Type1()):                    ClusterSpecClusterConfigSoftwareConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigWorkerConfig{}).Type1()):                      ClusterSpecClusterConfigWorkerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigWorkerConfigDiskConfig{}).Type1()):            ClusterSpecClusterConfigWorkerConfigDiskConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterIamBindingSpecCondition{}).Type1()):                            ClusterIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterIamMemberSpecCondition{}).Type1()):                             ClusterIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHadoopConfig{}).Type1()):                                       JobSpecHadoopConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHadoopConfigLoggingConfig{}).Type1()):                          JobSpecHadoopConfigLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHiveConfig{}).Type1()):                                         JobSpecHiveConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPigConfig{}).Type1()):                                          JobSpecPigConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPigConfigLoggingConfig{}).Type1()):                             JobSpecPigConfigLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPlacement{}).Type1()):                                          JobSpecPlacementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPysparkConfig{}).Type1()):                                      JobSpecPysparkConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPysparkConfigLoggingConfig{}).Type1()):                         JobSpecPysparkConfigLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecReference{}).Type1()):                                          JobSpecReferenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecScheduling{}).Type1()):                                         JobSpecSchedulingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparkConfig{}).Type1()):                                        JobSpecSparkConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparkConfigLoggingConfig{}).Type1()):                           JobSpecSparkConfigLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparksqlConfig{}).Type1()):                                     JobSpecSparksqlConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparksqlConfigLoggingConfig{}).Type1()):                        JobSpecSparksqlConfigLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobIamBindingSpecCondition{}).Type1()):                                JobIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobIamMemberSpecCondition{}).Type1()):                                 JobIamMemberSpecConditionCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecBasicAlgorithm{}).Type1()):                       AutoscalingPolicySpecBasicAlgorithmCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecBasicAlgorithmYarnConfig{}).Type1()):             AutoscalingPolicySpecBasicAlgorithmYarnConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecSecondaryWorkerConfig{}).Type1()):                AutoscalingPolicySpecSecondaryWorkerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecWorkerConfig{}).Type1()):                         AutoscalingPolicySpecWorkerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfig{}).Type1()):                                  ClusterSpecClusterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigAutoscalingConfig{}).Type1()):                 ClusterSpecClusterConfigAutoscalingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigEncryptionConfig{}).Type1()):                  ClusterSpecClusterConfigEncryptionConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigGceClusterConfig{}).Type1()):                  ClusterSpecClusterConfigGceClusterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigMasterConfig{}).Type1()):                      ClusterSpecClusterConfigMasterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigMasterConfigDiskConfig{}).Type1()):            ClusterSpecClusterConfigMasterConfigDiskConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigPreemptibleWorkerConfig{}).Type1()):           ClusterSpecClusterConfigPreemptibleWorkerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig{}).Type1()): ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSecurityConfig{}).Type1()):                    ClusterSpecClusterConfigSecurityConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSecurityConfigKerberosConfig{}).Type1()):      ClusterSpecClusterConfigSecurityConfigKerberosConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSoftwareConfig{}).Type1()):                    ClusterSpecClusterConfigSoftwareConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigWorkerConfig{}).Type1()):                      ClusterSpecClusterConfigWorkerConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigWorkerConfigDiskConfig{}).Type1()):            ClusterSpecClusterConfigWorkerConfigDiskConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterIamBindingSpecCondition{}).Type1()):                            ClusterIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterIamMemberSpecCondition{}).Type1()):                             ClusterIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHadoopConfig{}).Type1()):                                       JobSpecHadoopConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHadoopConfigLoggingConfig{}).Type1()):                          JobSpecHadoopConfigLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHiveConfig{}).Type1()):                                         JobSpecHiveConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPigConfig{}).Type1()):                                          JobSpecPigConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPigConfigLoggingConfig{}).Type1()):                             JobSpecPigConfigLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPlacement{}).Type1()):                                          JobSpecPlacementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPysparkConfig{}).Type1()):                                      JobSpecPysparkConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPysparkConfigLoggingConfig{}).Type1()):                         JobSpecPysparkConfigLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecReference{}).Type1()):                                          JobSpecReferenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecScheduling{}).Type1()):                                         JobSpecSchedulingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparkConfig{}).Type1()):                                        JobSpecSparkConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparkConfigLoggingConfig{}).Type1()):                           JobSpecSparkConfigLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparksqlConfig{}).Type1()):                                     JobSpecSparksqlConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparksqlConfigLoggingConfig{}).Type1()):                        JobSpecSparksqlConfigLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobIamBindingSpecCondition{}).Type1()):                                JobIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobIamMemberSpecCondition{}).Type1()):                                 JobIamMemberSpecConditionCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AutoscalingPolicySpecBasicAlgorithmCodec struct {
}

func (AutoscalingPolicySpecBasicAlgorithmCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscalingPolicySpecBasicAlgorithm)(ptr) == nil
}

func (AutoscalingPolicySpecBasicAlgorithmCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscalingPolicySpecBasicAlgorithm)(ptr)
	var objs []AutoscalingPolicySpecBasicAlgorithm
	if obj != nil {
		objs = []AutoscalingPolicySpecBasicAlgorithm{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecBasicAlgorithm{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscalingPolicySpecBasicAlgorithmCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscalingPolicySpecBasicAlgorithm)(ptr) = AutoscalingPolicySpecBasicAlgorithm{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscalingPolicySpecBasicAlgorithm

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecBasicAlgorithm{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscalingPolicySpecBasicAlgorithm)(ptr) = objs[0]
			} else {
				*(*AutoscalingPolicySpecBasicAlgorithm)(ptr) = AutoscalingPolicySpecBasicAlgorithm{}
			}
		} else {
			*(*AutoscalingPolicySpecBasicAlgorithm)(ptr) = AutoscalingPolicySpecBasicAlgorithm{}
		}
	default:
		iter.ReportError("decode AutoscalingPolicySpecBasicAlgorithm", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoscalingPolicySpecBasicAlgorithmYarnConfigCodec struct {
}

func (AutoscalingPolicySpecBasicAlgorithmYarnConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscalingPolicySpecBasicAlgorithmYarnConfig)(ptr) == nil
}

func (AutoscalingPolicySpecBasicAlgorithmYarnConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscalingPolicySpecBasicAlgorithmYarnConfig)(ptr)
	var objs []AutoscalingPolicySpecBasicAlgorithmYarnConfig
	if obj != nil {
		objs = []AutoscalingPolicySpecBasicAlgorithmYarnConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecBasicAlgorithmYarnConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscalingPolicySpecBasicAlgorithmYarnConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscalingPolicySpecBasicAlgorithmYarnConfig)(ptr) = AutoscalingPolicySpecBasicAlgorithmYarnConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscalingPolicySpecBasicAlgorithmYarnConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecBasicAlgorithmYarnConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscalingPolicySpecBasicAlgorithmYarnConfig)(ptr) = objs[0]
			} else {
				*(*AutoscalingPolicySpecBasicAlgorithmYarnConfig)(ptr) = AutoscalingPolicySpecBasicAlgorithmYarnConfig{}
			}
		} else {
			*(*AutoscalingPolicySpecBasicAlgorithmYarnConfig)(ptr) = AutoscalingPolicySpecBasicAlgorithmYarnConfig{}
		}
	default:
		iter.ReportError("decode AutoscalingPolicySpecBasicAlgorithmYarnConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoscalingPolicySpecSecondaryWorkerConfigCodec struct {
}

func (AutoscalingPolicySpecSecondaryWorkerConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscalingPolicySpecSecondaryWorkerConfig)(ptr) == nil
}

func (AutoscalingPolicySpecSecondaryWorkerConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscalingPolicySpecSecondaryWorkerConfig)(ptr)
	var objs []AutoscalingPolicySpecSecondaryWorkerConfig
	if obj != nil {
		objs = []AutoscalingPolicySpecSecondaryWorkerConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecSecondaryWorkerConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscalingPolicySpecSecondaryWorkerConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscalingPolicySpecSecondaryWorkerConfig)(ptr) = AutoscalingPolicySpecSecondaryWorkerConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscalingPolicySpecSecondaryWorkerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecSecondaryWorkerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscalingPolicySpecSecondaryWorkerConfig)(ptr) = objs[0]
			} else {
				*(*AutoscalingPolicySpecSecondaryWorkerConfig)(ptr) = AutoscalingPolicySpecSecondaryWorkerConfig{}
			}
		} else {
			*(*AutoscalingPolicySpecSecondaryWorkerConfig)(ptr) = AutoscalingPolicySpecSecondaryWorkerConfig{}
		}
	default:
		iter.ReportError("decode AutoscalingPolicySpecSecondaryWorkerConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoscalingPolicySpecWorkerConfigCodec struct {
}

func (AutoscalingPolicySpecWorkerConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscalingPolicySpecWorkerConfig)(ptr) == nil
}

func (AutoscalingPolicySpecWorkerConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscalingPolicySpecWorkerConfig)(ptr)
	var objs []AutoscalingPolicySpecWorkerConfig
	if obj != nil {
		objs = []AutoscalingPolicySpecWorkerConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecWorkerConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscalingPolicySpecWorkerConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscalingPolicySpecWorkerConfig)(ptr) = AutoscalingPolicySpecWorkerConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscalingPolicySpecWorkerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscalingPolicySpecWorkerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscalingPolicySpecWorkerConfig)(ptr) = objs[0]
			} else {
				*(*AutoscalingPolicySpecWorkerConfig)(ptr) = AutoscalingPolicySpecWorkerConfig{}
			}
		} else {
			*(*AutoscalingPolicySpecWorkerConfig)(ptr) = AutoscalingPolicySpecWorkerConfig{}
		}
	default:
		iter.ReportError("decode AutoscalingPolicySpecWorkerConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigCodec struct {
}

func (ClusterSpecClusterConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfig)(ptr)
	var objs []ClusterSpecClusterConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfig)(ptr) = ClusterSpecClusterConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfig)(ptr) = ClusterSpecClusterConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfig)(ptr) = ClusterSpecClusterConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigAutoscalingConfigCodec struct {
}

func (ClusterSpecClusterConfigAutoscalingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigAutoscalingConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigAutoscalingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigAutoscalingConfig)(ptr)
	var objs []ClusterSpecClusterConfigAutoscalingConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigAutoscalingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigAutoscalingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigAutoscalingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigAutoscalingConfig)(ptr) = ClusterSpecClusterConfigAutoscalingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigAutoscalingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigAutoscalingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigAutoscalingConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigAutoscalingConfig)(ptr) = ClusterSpecClusterConfigAutoscalingConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigAutoscalingConfig)(ptr) = ClusterSpecClusterConfigAutoscalingConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigAutoscalingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigEncryptionConfigCodec struct {
}

func (ClusterSpecClusterConfigEncryptionConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigEncryptionConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigEncryptionConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigEncryptionConfig)(ptr)
	var objs []ClusterSpecClusterConfigEncryptionConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigEncryptionConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigEncryptionConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigEncryptionConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigEncryptionConfig)(ptr) = ClusterSpecClusterConfigEncryptionConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigEncryptionConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigEncryptionConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigEncryptionConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigEncryptionConfig)(ptr) = ClusterSpecClusterConfigEncryptionConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigEncryptionConfig)(ptr) = ClusterSpecClusterConfigEncryptionConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigEncryptionConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigGceClusterConfigCodec struct {
}

func (ClusterSpecClusterConfigGceClusterConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigGceClusterConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigGceClusterConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigGceClusterConfig)(ptr)
	var objs []ClusterSpecClusterConfigGceClusterConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigGceClusterConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigGceClusterConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigGceClusterConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigGceClusterConfig)(ptr) = ClusterSpecClusterConfigGceClusterConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigGceClusterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigGceClusterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigGceClusterConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigGceClusterConfig)(ptr) = ClusterSpecClusterConfigGceClusterConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigGceClusterConfig)(ptr) = ClusterSpecClusterConfigGceClusterConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigGceClusterConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigMasterConfigCodec struct {
}

func (ClusterSpecClusterConfigMasterConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigMasterConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigMasterConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigMasterConfig)(ptr)
	var objs []ClusterSpecClusterConfigMasterConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigMasterConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigMasterConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigMasterConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigMasterConfig)(ptr) = ClusterSpecClusterConfigMasterConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigMasterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigMasterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigMasterConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigMasterConfig)(ptr) = ClusterSpecClusterConfigMasterConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigMasterConfig)(ptr) = ClusterSpecClusterConfigMasterConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigMasterConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigMasterConfigDiskConfigCodec struct {
}

func (ClusterSpecClusterConfigMasterConfigDiskConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigMasterConfigDiskConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigMasterConfigDiskConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigMasterConfigDiskConfig)(ptr)
	var objs []ClusterSpecClusterConfigMasterConfigDiskConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigMasterConfigDiskConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigMasterConfigDiskConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigMasterConfigDiskConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigMasterConfigDiskConfig)(ptr) = ClusterSpecClusterConfigMasterConfigDiskConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigMasterConfigDiskConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigMasterConfigDiskConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigMasterConfigDiskConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigMasterConfigDiskConfig)(ptr) = ClusterSpecClusterConfigMasterConfigDiskConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigMasterConfigDiskConfig)(ptr) = ClusterSpecClusterConfigMasterConfigDiskConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigMasterConfigDiskConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigPreemptibleWorkerConfigCodec struct {
}

func (ClusterSpecClusterConfigPreemptibleWorkerConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigPreemptibleWorkerConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigPreemptibleWorkerConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigPreemptibleWorkerConfig)(ptr)
	var objs []ClusterSpecClusterConfigPreemptibleWorkerConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigPreemptibleWorkerConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigPreemptibleWorkerConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigPreemptibleWorkerConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigPreemptibleWorkerConfig)(ptr) = ClusterSpecClusterConfigPreemptibleWorkerConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigPreemptibleWorkerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigPreemptibleWorkerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigPreemptibleWorkerConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigPreemptibleWorkerConfig)(ptr) = ClusterSpecClusterConfigPreemptibleWorkerConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigPreemptibleWorkerConfig)(ptr) = ClusterSpecClusterConfigPreemptibleWorkerConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigPreemptibleWorkerConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfigCodec struct {
}

func (ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig)(ptr)
	var objs []ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig)(ptr) = ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig)(ptr) = ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig)(ptr) = ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigPreemptibleWorkerConfigDiskConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigSecurityConfigCodec struct {
}

func (ClusterSpecClusterConfigSecurityConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigSecurityConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigSecurityConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigSecurityConfig)(ptr)
	var objs []ClusterSpecClusterConfigSecurityConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigSecurityConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSecurityConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigSecurityConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigSecurityConfig)(ptr) = ClusterSpecClusterConfigSecurityConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigSecurityConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSecurityConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigSecurityConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigSecurityConfig)(ptr) = ClusterSpecClusterConfigSecurityConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigSecurityConfig)(ptr) = ClusterSpecClusterConfigSecurityConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigSecurityConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigSecurityConfigKerberosConfigCodec struct {
}

func (ClusterSpecClusterConfigSecurityConfigKerberosConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigSecurityConfigKerberosConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigSecurityConfigKerberosConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigSecurityConfigKerberosConfig)(ptr)
	var objs []ClusterSpecClusterConfigSecurityConfigKerberosConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigSecurityConfigKerberosConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSecurityConfigKerberosConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigSecurityConfigKerberosConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigSecurityConfigKerberosConfig)(ptr) = ClusterSpecClusterConfigSecurityConfigKerberosConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigSecurityConfigKerberosConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSecurityConfigKerberosConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigSecurityConfigKerberosConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigSecurityConfigKerberosConfig)(ptr) = ClusterSpecClusterConfigSecurityConfigKerberosConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigSecurityConfigKerberosConfig)(ptr) = ClusterSpecClusterConfigSecurityConfigKerberosConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigSecurityConfigKerberosConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigSoftwareConfigCodec struct {
}

func (ClusterSpecClusterConfigSoftwareConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigSoftwareConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigSoftwareConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigSoftwareConfig)(ptr)
	var objs []ClusterSpecClusterConfigSoftwareConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigSoftwareConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSoftwareConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigSoftwareConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigSoftwareConfig)(ptr) = ClusterSpecClusterConfigSoftwareConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigSoftwareConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigSoftwareConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigSoftwareConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigSoftwareConfig)(ptr) = ClusterSpecClusterConfigSoftwareConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigSoftwareConfig)(ptr) = ClusterSpecClusterConfigSoftwareConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigSoftwareConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigWorkerConfigCodec struct {
}

func (ClusterSpecClusterConfigWorkerConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigWorkerConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigWorkerConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigWorkerConfig)(ptr)
	var objs []ClusterSpecClusterConfigWorkerConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigWorkerConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigWorkerConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigWorkerConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigWorkerConfig)(ptr) = ClusterSpecClusterConfigWorkerConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigWorkerConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigWorkerConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigWorkerConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigWorkerConfig)(ptr) = ClusterSpecClusterConfigWorkerConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigWorkerConfig)(ptr) = ClusterSpecClusterConfigWorkerConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigWorkerConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterConfigWorkerConfigDiskConfigCodec struct {
}

func (ClusterSpecClusterConfigWorkerConfigDiskConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterConfigWorkerConfigDiskConfig)(ptr) == nil
}

func (ClusterSpecClusterConfigWorkerConfigDiskConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterConfigWorkerConfigDiskConfig)(ptr)
	var objs []ClusterSpecClusterConfigWorkerConfigDiskConfig
	if obj != nil {
		objs = []ClusterSpecClusterConfigWorkerConfigDiskConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigWorkerConfigDiskConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterConfigWorkerConfigDiskConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterConfigWorkerConfigDiskConfig)(ptr) = ClusterSpecClusterConfigWorkerConfigDiskConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterConfigWorkerConfigDiskConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterConfigWorkerConfigDiskConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterConfigWorkerConfigDiskConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterConfigWorkerConfigDiskConfig)(ptr) = ClusterSpecClusterConfigWorkerConfigDiskConfig{}
			}
		} else {
			*(*ClusterSpecClusterConfigWorkerConfigDiskConfig)(ptr) = ClusterSpecClusterConfigWorkerConfigDiskConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterConfigWorkerConfigDiskConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterIamBindingSpecConditionCodec struct {
}

func (ClusterIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterIamBindingSpecCondition)(ptr) == nil
}

func (ClusterIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterIamBindingSpecCondition)(ptr)
	var objs []ClusterIamBindingSpecCondition
	if obj != nil {
		objs = []ClusterIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterIamBindingSpecCondition)(ptr) = ClusterIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*ClusterIamBindingSpecCondition)(ptr) = ClusterIamBindingSpecCondition{}
			}
		} else {
			*(*ClusterIamBindingSpecCondition)(ptr) = ClusterIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode ClusterIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterIamMemberSpecConditionCodec struct {
}

func (ClusterIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterIamMemberSpecCondition)(ptr) == nil
}

func (ClusterIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterIamMemberSpecCondition)(ptr)
	var objs []ClusterIamMemberSpecCondition
	if obj != nil {
		objs = []ClusterIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterIamMemberSpecCondition)(ptr) = ClusterIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*ClusterIamMemberSpecCondition)(ptr) = ClusterIamMemberSpecCondition{}
			}
		} else {
			*(*ClusterIamMemberSpecCondition)(ptr) = ClusterIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode ClusterIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecHadoopConfigCodec struct {
}

func (JobSpecHadoopConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecHadoopConfig)(ptr) == nil
}

func (JobSpecHadoopConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecHadoopConfig)(ptr)
	var objs []JobSpecHadoopConfig
	if obj != nil {
		objs = []JobSpecHadoopConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHadoopConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecHadoopConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecHadoopConfig)(ptr) = JobSpecHadoopConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecHadoopConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHadoopConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecHadoopConfig)(ptr) = objs[0]
			} else {
				*(*JobSpecHadoopConfig)(ptr) = JobSpecHadoopConfig{}
			}
		} else {
			*(*JobSpecHadoopConfig)(ptr) = JobSpecHadoopConfig{}
		}
	default:
		iter.ReportError("decode JobSpecHadoopConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecHadoopConfigLoggingConfigCodec struct {
}

func (JobSpecHadoopConfigLoggingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecHadoopConfigLoggingConfig)(ptr) == nil
}

func (JobSpecHadoopConfigLoggingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecHadoopConfigLoggingConfig)(ptr)
	var objs []JobSpecHadoopConfigLoggingConfig
	if obj != nil {
		objs = []JobSpecHadoopConfigLoggingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHadoopConfigLoggingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecHadoopConfigLoggingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecHadoopConfigLoggingConfig)(ptr) = JobSpecHadoopConfigLoggingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecHadoopConfigLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHadoopConfigLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecHadoopConfigLoggingConfig)(ptr) = objs[0]
			} else {
				*(*JobSpecHadoopConfigLoggingConfig)(ptr) = JobSpecHadoopConfigLoggingConfig{}
			}
		} else {
			*(*JobSpecHadoopConfigLoggingConfig)(ptr) = JobSpecHadoopConfigLoggingConfig{}
		}
	default:
		iter.ReportError("decode JobSpecHadoopConfigLoggingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecHiveConfigCodec struct {
}

func (JobSpecHiveConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecHiveConfig)(ptr) == nil
}

func (JobSpecHiveConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecHiveConfig)(ptr)
	var objs []JobSpecHiveConfig
	if obj != nil {
		objs = []JobSpecHiveConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHiveConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecHiveConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecHiveConfig)(ptr) = JobSpecHiveConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecHiveConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecHiveConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecHiveConfig)(ptr) = objs[0]
			} else {
				*(*JobSpecHiveConfig)(ptr) = JobSpecHiveConfig{}
			}
		} else {
			*(*JobSpecHiveConfig)(ptr) = JobSpecHiveConfig{}
		}
	default:
		iter.ReportError("decode JobSpecHiveConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecPigConfigCodec struct {
}

func (JobSpecPigConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecPigConfig)(ptr) == nil
}

func (JobSpecPigConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecPigConfig)(ptr)
	var objs []JobSpecPigConfig
	if obj != nil {
		objs = []JobSpecPigConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPigConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecPigConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecPigConfig)(ptr) = JobSpecPigConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecPigConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPigConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecPigConfig)(ptr) = objs[0]
			} else {
				*(*JobSpecPigConfig)(ptr) = JobSpecPigConfig{}
			}
		} else {
			*(*JobSpecPigConfig)(ptr) = JobSpecPigConfig{}
		}
	default:
		iter.ReportError("decode JobSpecPigConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecPigConfigLoggingConfigCodec struct {
}

func (JobSpecPigConfigLoggingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecPigConfigLoggingConfig)(ptr) == nil
}

func (JobSpecPigConfigLoggingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecPigConfigLoggingConfig)(ptr)
	var objs []JobSpecPigConfigLoggingConfig
	if obj != nil {
		objs = []JobSpecPigConfigLoggingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPigConfigLoggingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecPigConfigLoggingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecPigConfigLoggingConfig)(ptr) = JobSpecPigConfigLoggingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecPigConfigLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPigConfigLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecPigConfigLoggingConfig)(ptr) = objs[0]
			} else {
				*(*JobSpecPigConfigLoggingConfig)(ptr) = JobSpecPigConfigLoggingConfig{}
			}
		} else {
			*(*JobSpecPigConfigLoggingConfig)(ptr) = JobSpecPigConfigLoggingConfig{}
		}
	default:
		iter.ReportError("decode JobSpecPigConfigLoggingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecPlacementCodec struct {
}

func (JobSpecPlacementCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecPlacement)(ptr) == nil
}

func (JobSpecPlacementCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecPlacement)(ptr)
	var objs []JobSpecPlacement
	if obj != nil {
		objs = []JobSpecPlacement{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPlacement{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecPlacementCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecPlacement)(ptr) = JobSpecPlacement{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecPlacement

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPlacement{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecPlacement)(ptr) = objs[0]
			} else {
				*(*JobSpecPlacement)(ptr) = JobSpecPlacement{}
			}
		} else {
			*(*JobSpecPlacement)(ptr) = JobSpecPlacement{}
		}
	default:
		iter.ReportError("decode JobSpecPlacement", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecPysparkConfigCodec struct {
}

func (JobSpecPysparkConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecPysparkConfig)(ptr) == nil
}

func (JobSpecPysparkConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecPysparkConfig)(ptr)
	var objs []JobSpecPysparkConfig
	if obj != nil {
		objs = []JobSpecPysparkConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPysparkConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecPysparkConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecPysparkConfig)(ptr) = JobSpecPysparkConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecPysparkConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPysparkConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecPysparkConfig)(ptr) = objs[0]
			} else {
				*(*JobSpecPysparkConfig)(ptr) = JobSpecPysparkConfig{}
			}
		} else {
			*(*JobSpecPysparkConfig)(ptr) = JobSpecPysparkConfig{}
		}
	default:
		iter.ReportError("decode JobSpecPysparkConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecPysparkConfigLoggingConfigCodec struct {
}

func (JobSpecPysparkConfigLoggingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecPysparkConfigLoggingConfig)(ptr) == nil
}

func (JobSpecPysparkConfigLoggingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecPysparkConfigLoggingConfig)(ptr)
	var objs []JobSpecPysparkConfigLoggingConfig
	if obj != nil {
		objs = []JobSpecPysparkConfigLoggingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPysparkConfigLoggingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecPysparkConfigLoggingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecPysparkConfigLoggingConfig)(ptr) = JobSpecPysparkConfigLoggingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecPysparkConfigLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecPysparkConfigLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecPysparkConfigLoggingConfig)(ptr) = objs[0]
			} else {
				*(*JobSpecPysparkConfigLoggingConfig)(ptr) = JobSpecPysparkConfigLoggingConfig{}
			}
		} else {
			*(*JobSpecPysparkConfigLoggingConfig)(ptr) = JobSpecPysparkConfigLoggingConfig{}
		}
	default:
		iter.ReportError("decode JobSpecPysparkConfigLoggingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecReferenceCodec struct {
}

func (JobSpecReferenceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecReference)(ptr) == nil
}

func (JobSpecReferenceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecReference)(ptr)
	var objs []JobSpecReference
	if obj != nil {
		objs = []JobSpecReference{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecReference{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecReferenceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecReference)(ptr) = JobSpecReference{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecReference

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecReference{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecReference)(ptr) = objs[0]
			} else {
				*(*JobSpecReference)(ptr) = JobSpecReference{}
			}
		} else {
			*(*JobSpecReference)(ptr) = JobSpecReference{}
		}
	default:
		iter.ReportError("decode JobSpecReference", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecSchedulingCodec struct {
}

func (JobSpecSchedulingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecScheduling)(ptr) == nil
}

func (JobSpecSchedulingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecScheduling)(ptr)
	var objs []JobSpecScheduling
	if obj != nil {
		objs = []JobSpecScheduling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecScheduling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecSchedulingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecScheduling)(ptr) = JobSpecScheduling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecScheduling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecScheduling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecScheduling)(ptr) = objs[0]
			} else {
				*(*JobSpecScheduling)(ptr) = JobSpecScheduling{}
			}
		} else {
			*(*JobSpecScheduling)(ptr) = JobSpecScheduling{}
		}
	default:
		iter.ReportError("decode JobSpecScheduling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecSparkConfigCodec struct {
}

func (JobSpecSparkConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecSparkConfig)(ptr) == nil
}

func (JobSpecSparkConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecSparkConfig)(ptr)
	var objs []JobSpecSparkConfig
	if obj != nil {
		objs = []JobSpecSparkConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparkConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecSparkConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecSparkConfig)(ptr) = JobSpecSparkConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecSparkConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparkConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecSparkConfig)(ptr) = objs[0]
			} else {
				*(*JobSpecSparkConfig)(ptr) = JobSpecSparkConfig{}
			}
		} else {
			*(*JobSpecSparkConfig)(ptr) = JobSpecSparkConfig{}
		}
	default:
		iter.ReportError("decode JobSpecSparkConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecSparkConfigLoggingConfigCodec struct {
}

func (JobSpecSparkConfigLoggingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecSparkConfigLoggingConfig)(ptr) == nil
}

func (JobSpecSparkConfigLoggingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecSparkConfigLoggingConfig)(ptr)
	var objs []JobSpecSparkConfigLoggingConfig
	if obj != nil {
		objs = []JobSpecSparkConfigLoggingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparkConfigLoggingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecSparkConfigLoggingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecSparkConfigLoggingConfig)(ptr) = JobSpecSparkConfigLoggingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecSparkConfigLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparkConfigLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecSparkConfigLoggingConfig)(ptr) = objs[0]
			} else {
				*(*JobSpecSparkConfigLoggingConfig)(ptr) = JobSpecSparkConfigLoggingConfig{}
			}
		} else {
			*(*JobSpecSparkConfigLoggingConfig)(ptr) = JobSpecSparkConfigLoggingConfig{}
		}
	default:
		iter.ReportError("decode JobSpecSparkConfigLoggingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecSparksqlConfigCodec struct {
}

func (JobSpecSparksqlConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecSparksqlConfig)(ptr) == nil
}

func (JobSpecSparksqlConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecSparksqlConfig)(ptr)
	var objs []JobSpecSparksqlConfig
	if obj != nil {
		objs = []JobSpecSparksqlConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparksqlConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecSparksqlConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecSparksqlConfig)(ptr) = JobSpecSparksqlConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecSparksqlConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparksqlConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecSparksqlConfig)(ptr) = objs[0]
			} else {
				*(*JobSpecSparksqlConfig)(ptr) = JobSpecSparksqlConfig{}
			}
		} else {
			*(*JobSpecSparksqlConfig)(ptr) = JobSpecSparksqlConfig{}
		}
	default:
		iter.ReportError("decode JobSpecSparksqlConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecSparksqlConfigLoggingConfigCodec struct {
}

func (JobSpecSparksqlConfigLoggingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecSparksqlConfigLoggingConfig)(ptr) == nil
}

func (JobSpecSparksqlConfigLoggingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecSparksqlConfigLoggingConfig)(ptr)
	var objs []JobSpecSparksqlConfigLoggingConfig
	if obj != nil {
		objs = []JobSpecSparksqlConfigLoggingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparksqlConfigLoggingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecSparksqlConfigLoggingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecSparksqlConfigLoggingConfig)(ptr) = JobSpecSparksqlConfigLoggingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecSparksqlConfigLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecSparksqlConfigLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecSparksqlConfigLoggingConfig)(ptr) = objs[0]
			} else {
				*(*JobSpecSparksqlConfigLoggingConfig)(ptr) = JobSpecSparksqlConfigLoggingConfig{}
			}
		} else {
			*(*JobSpecSparksqlConfigLoggingConfig)(ptr) = JobSpecSparksqlConfigLoggingConfig{}
		}
	default:
		iter.ReportError("decode JobSpecSparksqlConfigLoggingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobIamBindingSpecConditionCodec struct {
}

func (JobIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobIamBindingSpecCondition)(ptr) == nil
}

func (JobIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobIamBindingSpecCondition)(ptr)
	var objs []JobIamBindingSpecCondition
	if obj != nil {
		objs = []JobIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobIamBindingSpecCondition)(ptr) = JobIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*JobIamBindingSpecCondition)(ptr) = JobIamBindingSpecCondition{}
			}
		} else {
			*(*JobIamBindingSpecCondition)(ptr) = JobIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode JobIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobIamMemberSpecConditionCodec struct {
}

func (JobIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobIamMemberSpecCondition)(ptr) == nil
}

func (JobIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobIamMemberSpecCondition)(ptr)
	var objs []JobIamMemberSpecCondition
	if obj != nil {
		objs = []JobIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobIamMemberSpecCondition)(ptr) = JobIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*JobIamMemberSpecCondition)(ptr) = JobIamMemberSpecCondition{}
			}
		} else {
			*(*JobIamMemberSpecCondition)(ptr) = JobIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode JobIamMemberSpecCondition", "unexpected JSON type")
	}
}
