/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(DataTransferConfigSpecEmailPreferences{}).Type1()):                    DataTransferConfigSpecEmailPreferencesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DataTransferConfigSpecScheduleOptions{}).Type1()):                     DataTransferConfigSpecScheduleOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DataTransferConfigSpecSensitiveParams{}).Type1()):                     DataTransferConfigSpecSensitiveParamsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatasetSpecAccessView{}).Type1()):                                     DatasetSpecAccessViewCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatasetSpecDefaultEncryptionConfiguration{}).Type1()):                 DatasetSpecDefaultEncryptionConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatasetAccessSpecView{}).Type1()):                                     DatasetAccessSpecViewCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatasetIamBindingSpecCondition{}).Type1()):                            DatasetIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatasetIamMemberSpecCondition{}).Type1()):                             DatasetIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecCopy{}).Type1()):                                               JobSpecCopyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecCopyDestinationEncryptionConfiguration{}).Type1()):             JobSpecCopyDestinationEncryptionConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecCopyDestinationTable{}).Type1()):                               JobSpecCopyDestinationTableCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecExtract{}).Type1()):                                            JobSpecExtractCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecExtractSourceModel{}).Type1()):                                 JobSpecExtractSourceModelCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecExtractSourceTable{}).Type1()):                                 JobSpecExtractSourceTableCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecLoad{}).Type1()):                                               JobSpecLoadCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecLoadDestinationEncryptionConfiguration{}).Type1()):             JobSpecLoadDestinationEncryptionConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecLoadDestinationTable{}).Type1()):                               JobSpecLoadDestinationTableCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecLoadTimePartitioning{}).Type1()):                               JobSpecLoadTimePartitioningCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecQuery{}).Type1()):                                              JobSpecQueryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecQueryDefaultDataset{}).Type1()):                                JobSpecQueryDefaultDatasetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecQueryDestinationEncryptionConfiguration{}).Type1()):            JobSpecQueryDestinationEncryptionConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecQueryDestinationTable{}).Type1()):                              JobSpecQueryDestinationTableCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecQueryScriptOptions{}).Type1()):                                 JobSpecQueryScriptOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableSpecEncryptionConfiguration{}).Type1()):                          TableSpecEncryptionConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableSpecExternalDataConfiguration{}).Type1()):                        TableSpecExternalDataConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableSpecExternalDataConfigurationCsvOptions{}).Type1()):              TableSpecExternalDataConfigurationCsvOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableSpecExternalDataConfigurationGoogleSheetsOptions{}).Type1()):     TableSpecExternalDataConfigurationGoogleSheetsOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableSpecExternalDataConfigurationHivePartitioningOptions{}).Type1()): TableSpecExternalDataConfigurationHivePartitioningOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableSpecMaterializedView{}).Type1()):                                 TableSpecMaterializedViewCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableSpecRangePartitioning{}).Type1()):                                TableSpecRangePartitioningCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableSpecRangePartitioningRange{}).Type1()):                           TableSpecRangePartitioningRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableSpecTimePartitioning{}).Type1()):                                 TableSpecTimePartitioningCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableSpecView{}).Type1()):                                             TableSpecViewCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableIamBindingSpecCondition{}).Type1()):                              TableIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableIamMemberSpecCondition{}).Type1()):                               TableIamMemberSpecConditionCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(DataTransferConfigSpecEmailPreferences{}).Type1()):                    DataTransferConfigSpecEmailPreferencesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DataTransferConfigSpecScheduleOptions{}).Type1()):                     DataTransferConfigSpecScheduleOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DataTransferConfigSpecSensitiveParams{}).Type1()):                     DataTransferConfigSpecSensitiveParamsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatasetSpecAccessView{}).Type1()):                                     DatasetSpecAccessViewCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatasetSpecDefaultEncryptionConfiguration{}).Type1()):                 DatasetSpecDefaultEncryptionConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatasetAccessSpecView{}).Type1()):                                     DatasetAccessSpecViewCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatasetIamBindingSpecCondition{}).Type1()):                            DatasetIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatasetIamMemberSpecCondition{}).Type1()):                             DatasetIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecCopy{}).Type1()):                                               JobSpecCopyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecCopyDestinationEncryptionConfiguration{}).Type1()):             JobSpecCopyDestinationEncryptionConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecCopyDestinationTable{}).Type1()):                               JobSpecCopyDestinationTableCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecExtract{}).Type1()):                                            JobSpecExtractCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecExtractSourceModel{}).Type1()):                                 JobSpecExtractSourceModelCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecExtractSourceTable{}).Type1()):                                 JobSpecExtractSourceTableCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecLoad{}).Type1()):                                               JobSpecLoadCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecLoadDestinationEncryptionConfiguration{}).Type1()):             JobSpecLoadDestinationEncryptionConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecLoadDestinationTable{}).Type1()):                               JobSpecLoadDestinationTableCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecLoadTimePartitioning{}).Type1()):                               JobSpecLoadTimePartitioningCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecQuery{}).Type1()):                                              JobSpecQueryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecQueryDefaultDataset{}).Type1()):                                JobSpecQueryDefaultDatasetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecQueryDestinationEncryptionConfiguration{}).Type1()):            JobSpecQueryDestinationEncryptionConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecQueryDestinationTable{}).Type1()):                              JobSpecQueryDestinationTableCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecQueryScriptOptions{}).Type1()):                                 JobSpecQueryScriptOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableSpecEncryptionConfiguration{}).Type1()):                          TableSpecEncryptionConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableSpecExternalDataConfiguration{}).Type1()):                        TableSpecExternalDataConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableSpecExternalDataConfigurationCsvOptions{}).Type1()):              TableSpecExternalDataConfigurationCsvOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableSpecExternalDataConfigurationGoogleSheetsOptions{}).Type1()):     TableSpecExternalDataConfigurationGoogleSheetsOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableSpecExternalDataConfigurationHivePartitioningOptions{}).Type1()): TableSpecExternalDataConfigurationHivePartitioningOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableSpecMaterializedView{}).Type1()):                                 TableSpecMaterializedViewCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableSpecRangePartitioning{}).Type1()):                                TableSpecRangePartitioningCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableSpecRangePartitioningRange{}).Type1()):                           TableSpecRangePartitioningRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableSpecTimePartitioning{}).Type1()):                                 TableSpecTimePartitioningCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableSpecView{}).Type1()):                                             TableSpecViewCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableIamBindingSpecCondition{}).Type1()):                              TableIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TableIamMemberSpecCondition{}).Type1()):                               TableIamMemberSpecConditionCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type DataTransferConfigSpecEmailPreferencesCodec struct {
}

func (DataTransferConfigSpecEmailPreferencesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DataTransferConfigSpecEmailPreferences)(ptr) == nil
}

func (DataTransferConfigSpecEmailPreferencesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DataTransferConfigSpecEmailPreferences)(ptr)
	var objs []DataTransferConfigSpecEmailPreferences
	if obj != nil {
		objs = []DataTransferConfigSpecEmailPreferences{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DataTransferConfigSpecEmailPreferences{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DataTransferConfigSpecEmailPreferencesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DataTransferConfigSpecEmailPreferences)(ptr) = DataTransferConfigSpecEmailPreferences{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DataTransferConfigSpecEmailPreferences

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DataTransferConfigSpecEmailPreferences{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DataTransferConfigSpecEmailPreferences)(ptr) = objs[0]
			} else {
				*(*DataTransferConfigSpecEmailPreferences)(ptr) = DataTransferConfigSpecEmailPreferences{}
			}
		} else {
			*(*DataTransferConfigSpecEmailPreferences)(ptr) = DataTransferConfigSpecEmailPreferences{}
		}
	default:
		iter.ReportError("decode DataTransferConfigSpecEmailPreferences", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DataTransferConfigSpecScheduleOptionsCodec struct {
}

func (DataTransferConfigSpecScheduleOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DataTransferConfigSpecScheduleOptions)(ptr) == nil
}

func (DataTransferConfigSpecScheduleOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DataTransferConfigSpecScheduleOptions)(ptr)
	var objs []DataTransferConfigSpecScheduleOptions
	if obj != nil {
		objs = []DataTransferConfigSpecScheduleOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DataTransferConfigSpecScheduleOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DataTransferConfigSpecScheduleOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DataTransferConfigSpecScheduleOptions)(ptr) = DataTransferConfigSpecScheduleOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DataTransferConfigSpecScheduleOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DataTransferConfigSpecScheduleOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DataTransferConfigSpecScheduleOptions)(ptr) = objs[0]
			} else {
				*(*DataTransferConfigSpecScheduleOptions)(ptr) = DataTransferConfigSpecScheduleOptions{}
			}
		} else {
			*(*DataTransferConfigSpecScheduleOptions)(ptr) = DataTransferConfigSpecScheduleOptions{}
		}
	default:
		iter.ReportError("decode DataTransferConfigSpecScheduleOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DataTransferConfigSpecSensitiveParamsCodec struct {
}

func (DataTransferConfigSpecSensitiveParamsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DataTransferConfigSpecSensitiveParams)(ptr) == nil
}

func (DataTransferConfigSpecSensitiveParamsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DataTransferConfigSpecSensitiveParams)(ptr)
	var objs []DataTransferConfigSpecSensitiveParams
	if obj != nil {
		objs = []DataTransferConfigSpecSensitiveParams{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DataTransferConfigSpecSensitiveParams{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DataTransferConfigSpecSensitiveParamsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DataTransferConfigSpecSensitiveParams)(ptr) = DataTransferConfigSpecSensitiveParams{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DataTransferConfigSpecSensitiveParams

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DataTransferConfigSpecSensitiveParams{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DataTransferConfigSpecSensitiveParams)(ptr) = objs[0]
			} else {
				*(*DataTransferConfigSpecSensitiveParams)(ptr) = DataTransferConfigSpecSensitiveParams{}
			}
		} else {
			*(*DataTransferConfigSpecSensitiveParams)(ptr) = DataTransferConfigSpecSensitiveParams{}
		}
	default:
		iter.ReportError("decode DataTransferConfigSpecSensitiveParams", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DatasetSpecAccessViewCodec struct {
}

func (DatasetSpecAccessViewCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DatasetSpecAccessView)(ptr) == nil
}

func (DatasetSpecAccessViewCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DatasetSpecAccessView)(ptr)
	var objs []DatasetSpecAccessView
	if obj != nil {
		objs = []DatasetSpecAccessView{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatasetSpecAccessView{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DatasetSpecAccessViewCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DatasetSpecAccessView)(ptr) = DatasetSpecAccessView{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DatasetSpecAccessView

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatasetSpecAccessView{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DatasetSpecAccessView)(ptr) = objs[0]
			} else {
				*(*DatasetSpecAccessView)(ptr) = DatasetSpecAccessView{}
			}
		} else {
			*(*DatasetSpecAccessView)(ptr) = DatasetSpecAccessView{}
		}
	default:
		iter.ReportError("decode DatasetSpecAccessView", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DatasetSpecDefaultEncryptionConfigurationCodec struct {
}

func (DatasetSpecDefaultEncryptionConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DatasetSpecDefaultEncryptionConfiguration)(ptr) == nil
}

func (DatasetSpecDefaultEncryptionConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DatasetSpecDefaultEncryptionConfiguration)(ptr)
	var objs []DatasetSpecDefaultEncryptionConfiguration
	if obj != nil {
		objs = []DatasetSpecDefaultEncryptionConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatasetSpecDefaultEncryptionConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DatasetSpecDefaultEncryptionConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DatasetSpecDefaultEncryptionConfiguration)(ptr) = DatasetSpecDefaultEncryptionConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DatasetSpecDefaultEncryptionConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatasetSpecDefaultEncryptionConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DatasetSpecDefaultEncryptionConfiguration)(ptr) = objs[0]
			} else {
				*(*DatasetSpecDefaultEncryptionConfiguration)(ptr) = DatasetSpecDefaultEncryptionConfiguration{}
			}
		} else {
			*(*DatasetSpecDefaultEncryptionConfiguration)(ptr) = DatasetSpecDefaultEncryptionConfiguration{}
		}
	default:
		iter.ReportError("decode DatasetSpecDefaultEncryptionConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DatasetAccessSpecViewCodec struct {
}

func (DatasetAccessSpecViewCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DatasetAccessSpecView)(ptr) == nil
}

func (DatasetAccessSpecViewCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DatasetAccessSpecView)(ptr)
	var objs []DatasetAccessSpecView
	if obj != nil {
		objs = []DatasetAccessSpecView{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatasetAccessSpecView{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DatasetAccessSpecViewCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DatasetAccessSpecView)(ptr) = DatasetAccessSpecView{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DatasetAccessSpecView

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatasetAccessSpecView{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DatasetAccessSpecView)(ptr) = objs[0]
			} else {
				*(*DatasetAccessSpecView)(ptr) = DatasetAccessSpecView{}
			}
		} else {
			*(*DatasetAccessSpecView)(ptr) = DatasetAccessSpecView{}
		}
	default:
		iter.ReportError("decode DatasetAccessSpecView", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DatasetIamBindingSpecConditionCodec struct {
}

func (DatasetIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DatasetIamBindingSpecCondition)(ptr) == nil
}

func (DatasetIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DatasetIamBindingSpecCondition)(ptr)
	var objs []DatasetIamBindingSpecCondition
	if obj != nil {
		objs = []DatasetIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatasetIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DatasetIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DatasetIamBindingSpecCondition)(ptr) = DatasetIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DatasetIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatasetIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DatasetIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*DatasetIamBindingSpecCondition)(ptr) = DatasetIamBindingSpecCondition{}
			}
		} else {
			*(*DatasetIamBindingSpecCondition)(ptr) = DatasetIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode DatasetIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DatasetIamMemberSpecConditionCodec struct {
}

func (DatasetIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DatasetIamMemberSpecCondition)(ptr) == nil
}

func (DatasetIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DatasetIamMemberSpecCondition)(ptr)
	var objs []DatasetIamMemberSpecCondition
	if obj != nil {
		objs = []DatasetIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatasetIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DatasetIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DatasetIamMemberSpecCondition)(ptr) = DatasetIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DatasetIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatasetIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DatasetIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*DatasetIamMemberSpecCondition)(ptr) = DatasetIamMemberSpecCondition{}
			}
		} else {
			*(*DatasetIamMemberSpecCondition)(ptr) = DatasetIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode DatasetIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecCopyCodec struct {
}

func (JobSpecCopyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecCopy)(ptr) == nil
}

func (JobSpecCopyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecCopy)(ptr)
	var objs []JobSpecCopy
	if obj != nil {
		objs = []JobSpecCopy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecCopy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecCopyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecCopy)(ptr) = JobSpecCopy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecCopy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecCopy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecCopy)(ptr) = objs[0]
			} else {
				*(*JobSpecCopy)(ptr) = JobSpecCopy{}
			}
		} else {
			*(*JobSpecCopy)(ptr) = JobSpecCopy{}
		}
	default:
		iter.ReportError("decode JobSpecCopy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecCopyDestinationEncryptionConfigurationCodec struct {
}

func (JobSpecCopyDestinationEncryptionConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecCopyDestinationEncryptionConfiguration)(ptr) == nil
}

func (JobSpecCopyDestinationEncryptionConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecCopyDestinationEncryptionConfiguration)(ptr)
	var objs []JobSpecCopyDestinationEncryptionConfiguration
	if obj != nil {
		objs = []JobSpecCopyDestinationEncryptionConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecCopyDestinationEncryptionConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecCopyDestinationEncryptionConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecCopyDestinationEncryptionConfiguration)(ptr) = JobSpecCopyDestinationEncryptionConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecCopyDestinationEncryptionConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecCopyDestinationEncryptionConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecCopyDestinationEncryptionConfiguration)(ptr) = objs[0]
			} else {
				*(*JobSpecCopyDestinationEncryptionConfiguration)(ptr) = JobSpecCopyDestinationEncryptionConfiguration{}
			}
		} else {
			*(*JobSpecCopyDestinationEncryptionConfiguration)(ptr) = JobSpecCopyDestinationEncryptionConfiguration{}
		}
	default:
		iter.ReportError("decode JobSpecCopyDestinationEncryptionConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecCopyDestinationTableCodec struct {
}

func (JobSpecCopyDestinationTableCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecCopyDestinationTable)(ptr) == nil
}

func (JobSpecCopyDestinationTableCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecCopyDestinationTable)(ptr)
	var objs []JobSpecCopyDestinationTable
	if obj != nil {
		objs = []JobSpecCopyDestinationTable{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecCopyDestinationTable{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecCopyDestinationTableCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecCopyDestinationTable)(ptr) = JobSpecCopyDestinationTable{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecCopyDestinationTable

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecCopyDestinationTable{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecCopyDestinationTable)(ptr) = objs[0]
			} else {
				*(*JobSpecCopyDestinationTable)(ptr) = JobSpecCopyDestinationTable{}
			}
		} else {
			*(*JobSpecCopyDestinationTable)(ptr) = JobSpecCopyDestinationTable{}
		}
	default:
		iter.ReportError("decode JobSpecCopyDestinationTable", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecExtractCodec struct {
}

func (JobSpecExtractCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecExtract)(ptr) == nil
}

func (JobSpecExtractCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecExtract)(ptr)
	var objs []JobSpecExtract
	if obj != nil {
		objs = []JobSpecExtract{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecExtract{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecExtractCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecExtract)(ptr) = JobSpecExtract{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecExtract

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecExtract{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecExtract)(ptr) = objs[0]
			} else {
				*(*JobSpecExtract)(ptr) = JobSpecExtract{}
			}
		} else {
			*(*JobSpecExtract)(ptr) = JobSpecExtract{}
		}
	default:
		iter.ReportError("decode JobSpecExtract", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecExtractSourceModelCodec struct {
}

func (JobSpecExtractSourceModelCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecExtractSourceModel)(ptr) == nil
}

func (JobSpecExtractSourceModelCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecExtractSourceModel)(ptr)
	var objs []JobSpecExtractSourceModel
	if obj != nil {
		objs = []JobSpecExtractSourceModel{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecExtractSourceModel{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecExtractSourceModelCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecExtractSourceModel)(ptr) = JobSpecExtractSourceModel{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecExtractSourceModel

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecExtractSourceModel{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecExtractSourceModel)(ptr) = objs[0]
			} else {
				*(*JobSpecExtractSourceModel)(ptr) = JobSpecExtractSourceModel{}
			}
		} else {
			*(*JobSpecExtractSourceModel)(ptr) = JobSpecExtractSourceModel{}
		}
	default:
		iter.ReportError("decode JobSpecExtractSourceModel", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecExtractSourceTableCodec struct {
}

func (JobSpecExtractSourceTableCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecExtractSourceTable)(ptr) == nil
}

func (JobSpecExtractSourceTableCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecExtractSourceTable)(ptr)
	var objs []JobSpecExtractSourceTable
	if obj != nil {
		objs = []JobSpecExtractSourceTable{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecExtractSourceTable{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecExtractSourceTableCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecExtractSourceTable)(ptr) = JobSpecExtractSourceTable{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecExtractSourceTable

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecExtractSourceTable{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecExtractSourceTable)(ptr) = objs[0]
			} else {
				*(*JobSpecExtractSourceTable)(ptr) = JobSpecExtractSourceTable{}
			}
		} else {
			*(*JobSpecExtractSourceTable)(ptr) = JobSpecExtractSourceTable{}
		}
	default:
		iter.ReportError("decode JobSpecExtractSourceTable", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecLoadCodec struct {
}

func (JobSpecLoadCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecLoad)(ptr) == nil
}

func (JobSpecLoadCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecLoad)(ptr)
	var objs []JobSpecLoad
	if obj != nil {
		objs = []JobSpecLoad{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecLoad{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecLoadCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecLoad)(ptr) = JobSpecLoad{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecLoad

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecLoad{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecLoad)(ptr) = objs[0]
			} else {
				*(*JobSpecLoad)(ptr) = JobSpecLoad{}
			}
		} else {
			*(*JobSpecLoad)(ptr) = JobSpecLoad{}
		}
	default:
		iter.ReportError("decode JobSpecLoad", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecLoadDestinationEncryptionConfigurationCodec struct {
}

func (JobSpecLoadDestinationEncryptionConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecLoadDestinationEncryptionConfiguration)(ptr) == nil
}

func (JobSpecLoadDestinationEncryptionConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecLoadDestinationEncryptionConfiguration)(ptr)
	var objs []JobSpecLoadDestinationEncryptionConfiguration
	if obj != nil {
		objs = []JobSpecLoadDestinationEncryptionConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecLoadDestinationEncryptionConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecLoadDestinationEncryptionConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecLoadDestinationEncryptionConfiguration)(ptr) = JobSpecLoadDestinationEncryptionConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecLoadDestinationEncryptionConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecLoadDestinationEncryptionConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecLoadDestinationEncryptionConfiguration)(ptr) = objs[0]
			} else {
				*(*JobSpecLoadDestinationEncryptionConfiguration)(ptr) = JobSpecLoadDestinationEncryptionConfiguration{}
			}
		} else {
			*(*JobSpecLoadDestinationEncryptionConfiguration)(ptr) = JobSpecLoadDestinationEncryptionConfiguration{}
		}
	default:
		iter.ReportError("decode JobSpecLoadDestinationEncryptionConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecLoadDestinationTableCodec struct {
}

func (JobSpecLoadDestinationTableCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecLoadDestinationTable)(ptr) == nil
}

func (JobSpecLoadDestinationTableCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecLoadDestinationTable)(ptr)
	var objs []JobSpecLoadDestinationTable
	if obj != nil {
		objs = []JobSpecLoadDestinationTable{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecLoadDestinationTable{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecLoadDestinationTableCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecLoadDestinationTable)(ptr) = JobSpecLoadDestinationTable{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecLoadDestinationTable

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecLoadDestinationTable{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecLoadDestinationTable)(ptr) = objs[0]
			} else {
				*(*JobSpecLoadDestinationTable)(ptr) = JobSpecLoadDestinationTable{}
			}
		} else {
			*(*JobSpecLoadDestinationTable)(ptr) = JobSpecLoadDestinationTable{}
		}
	default:
		iter.ReportError("decode JobSpecLoadDestinationTable", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecLoadTimePartitioningCodec struct {
}

func (JobSpecLoadTimePartitioningCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecLoadTimePartitioning)(ptr) == nil
}

func (JobSpecLoadTimePartitioningCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecLoadTimePartitioning)(ptr)
	var objs []JobSpecLoadTimePartitioning
	if obj != nil {
		objs = []JobSpecLoadTimePartitioning{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecLoadTimePartitioning{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecLoadTimePartitioningCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecLoadTimePartitioning)(ptr) = JobSpecLoadTimePartitioning{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecLoadTimePartitioning

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecLoadTimePartitioning{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecLoadTimePartitioning)(ptr) = objs[0]
			} else {
				*(*JobSpecLoadTimePartitioning)(ptr) = JobSpecLoadTimePartitioning{}
			}
		} else {
			*(*JobSpecLoadTimePartitioning)(ptr) = JobSpecLoadTimePartitioning{}
		}
	default:
		iter.ReportError("decode JobSpecLoadTimePartitioning", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecQueryCodec struct {
}

func (JobSpecQueryCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecQuery)(ptr) == nil
}

func (JobSpecQueryCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecQuery)(ptr)
	var objs []JobSpecQuery
	if obj != nil {
		objs = []JobSpecQuery{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecQuery{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecQueryCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecQuery)(ptr) = JobSpecQuery{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecQuery

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecQuery{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecQuery)(ptr) = objs[0]
			} else {
				*(*JobSpecQuery)(ptr) = JobSpecQuery{}
			}
		} else {
			*(*JobSpecQuery)(ptr) = JobSpecQuery{}
		}
	default:
		iter.ReportError("decode JobSpecQuery", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecQueryDefaultDatasetCodec struct {
}

func (JobSpecQueryDefaultDatasetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecQueryDefaultDataset)(ptr) == nil
}

func (JobSpecQueryDefaultDatasetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecQueryDefaultDataset)(ptr)
	var objs []JobSpecQueryDefaultDataset
	if obj != nil {
		objs = []JobSpecQueryDefaultDataset{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecQueryDefaultDataset{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecQueryDefaultDatasetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecQueryDefaultDataset)(ptr) = JobSpecQueryDefaultDataset{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecQueryDefaultDataset

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecQueryDefaultDataset{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecQueryDefaultDataset)(ptr) = objs[0]
			} else {
				*(*JobSpecQueryDefaultDataset)(ptr) = JobSpecQueryDefaultDataset{}
			}
		} else {
			*(*JobSpecQueryDefaultDataset)(ptr) = JobSpecQueryDefaultDataset{}
		}
	default:
		iter.ReportError("decode JobSpecQueryDefaultDataset", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecQueryDestinationEncryptionConfigurationCodec struct {
}

func (JobSpecQueryDestinationEncryptionConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecQueryDestinationEncryptionConfiguration)(ptr) == nil
}

func (JobSpecQueryDestinationEncryptionConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecQueryDestinationEncryptionConfiguration)(ptr)
	var objs []JobSpecQueryDestinationEncryptionConfiguration
	if obj != nil {
		objs = []JobSpecQueryDestinationEncryptionConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecQueryDestinationEncryptionConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecQueryDestinationEncryptionConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecQueryDestinationEncryptionConfiguration)(ptr) = JobSpecQueryDestinationEncryptionConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecQueryDestinationEncryptionConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecQueryDestinationEncryptionConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecQueryDestinationEncryptionConfiguration)(ptr) = objs[0]
			} else {
				*(*JobSpecQueryDestinationEncryptionConfiguration)(ptr) = JobSpecQueryDestinationEncryptionConfiguration{}
			}
		} else {
			*(*JobSpecQueryDestinationEncryptionConfiguration)(ptr) = JobSpecQueryDestinationEncryptionConfiguration{}
		}
	default:
		iter.ReportError("decode JobSpecQueryDestinationEncryptionConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecQueryDestinationTableCodec struct {
}

func (JobSpecQueryDestinationTableCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecQueryDestinationTable)(ptr) == nil
}

func (JobSpecQueryDestinationTableCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecQueryDestinationTable)(ptr)
	var objs []JobSpecQueryDestinationTable
	if obj != nil {
		objs = []JobSpecQueryDestinationTable{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecQueryDestinationTable{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecQueryDestinationTableCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecQueryDestinationTable)(ptr) = JobSpecQueryDestinationTable{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecQueryDestinationTable

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecQueryDestinationTable{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecQueryDestinationTable)(ptr) = objs[0]
			} else {
				*(*JobSpecQueryDestinationTable)(ptr) = JobSpecQueryDestinationTable{}
			}
		} else {
			*(*JobSpecQueryDestinationTable)(ptr) = JobSpecQueryDestinationTable{}
		}
	default:
		iter.ReportError("decode JobSpecQueryDestinationTable", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecQueryScriptOptionsCodec struct {
}

func (JobSpecQueryScriptOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecQueryScriptOptions)(ptr) == nil
}

func (JobSpecQueryScriptOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecQueryScriptOptions)(ptr)
	var objs []JobSpecQueryScriptOptions
	if obj != nil {
		objs = []JobSpecQueryScriptOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecQueryScriptOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecQueryScriptOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecQueryScriptOptions)(ptr) = JobSpecQueryScriptOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecQueryScriptOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecQueryScriptOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecQueryScriptOptions)(ptr) = objs[0]
			} else {
				*(*JobSpecQueryScriptOptions)(ptr) = JobSpecQueryScriptOptions{}
			}
		} else {
			*(*JobSpecQueryScriptOptions)(ptr) = JobSpecQueryScriptOptions{}
		}
	default:
		iter.ReportError("decode JobSpecQueryScriptOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TableSpecEncryptionConfigurationCodec struct {
}

func (TableSpecEncryptionConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TableSpecEncryptionConfiguration)(ptr) == nil
}

func (TableSpecEncryptionConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TableSpecEncryptionConfiguration)(ptr)
	var objs []TableSpecEncryptionConfiguration
	if obj != nil {
		objs = []TableSpecEncryptionConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableSpecEncryptionConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TableSpecEncryptionConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TableSpecEncryptionConfiguration)(ptr) = TableSpecEncryptionConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TableSpecEncryptionConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableSpecEncryptionConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TableSpecEncryptionConfiguration)(ptr) = objs[0]
			} else {
				*(*TableSpecEncryptionConfiguration)(ptr) = TableSpecEncryptionConfiguration{}
			}
		} else {
			*(*TableSpecEncryptionConfiguration)(ptr) = TableSpecEncryptionConfiguration{}
		}
	default:
		iter.ReportError("decode TableSpecEncryptionConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TableSpecExternalDataConfigurationCodec struct {
}

func (TableSpecExternalDataConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TableSpecExternalDataConfiguration)(ptr) == nil
}

func (TableSpecExternalDataConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TableSpecExternalDataConfiguration)(ptr)
	var objs []TableSpecExternalDataConfiguration
	if obj != nil {
		objs = []TableSpecExternalDataConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableSpecExternalDataConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TableSpecExternalDataConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TableSpecExternalDataConfiguration)(ptr) = TableSpecExternalDataConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TableSpecExternalDataConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableSpecExternalDataConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TableSpecExternalDataConfiguration)(ptr) = objs[0]
			} else {
				*(*TableSpecExternalDataConfiguration)(ptr) = TableSpecExternalDataConfiguration{}
			}
		} else {
			*(*TableSpecExternalDataConfiguration)(ptr) = TableSpecExternalDataConfiguration{}
		}
	default:
		iter.ReportError("decode TableSpecExternalDataConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TableSpecExternalDataConfigurationCsvOptionsCodec struct {
}

func (TableSpecExternalDataConfigurationCsvOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TableSpecExternalDataConfigurationCsvOptions)(ptr) == nil
}

func (TableSpecExternalDataConfigurationCsvOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TableSpecExternalDataConfigurationCsvOptions)(ptr)
	var objs []TableSpecExternalDataConfigurationCsvOptions
	if obj != nil {
		objs = []TableSpecExternalDataConfigurationCsvOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableSpecExternalDataConfigurationCsvOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TableSpecExternalDataConfigurationCsvOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TableSpecExternalDataConfigurationCsvOptions)(ptr) = TableSpecExternalDataConfigurationCsvOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TableSpecExternalDataConfigurationCsvOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableSpecExternalDataConfigurationCsvOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TableSpecExternalDataConfigurationCsvOptions)(ptr) = objs[0]
			} else {
				*(*TableSpecExternalDataConfigurationCsvOptions)(ptr) = TableSpecExternalDataConfigurationCsvOptions{}
			}
		} else {
			*(*TableSpecExternalDataConfigurationCsvOptions)(ptr) = TableSpecExternalDataConfigurationCsvOptions{}
		}
	default:
		iter.ReportError("decode TableSpecExternalDataConfigurationCsvOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TableSpecExternalDataConfigurationGoogleSheetsOptionsCodec struct {
}

func (TableSpecExternalDataConfigurationGoogleSheetsOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TableSpecExternalDataConfigurationGoogleSheetsOptions)(ptr) == nil
}

func (TableSpecExternalDataConfigurationGoogleSheetsOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TableSpecExternalDataConfigurationGoogleSheetsOptions)(ptr)
	var objs []TableSpecExternalDataConfigurationGoogleSheetsOptions
	if obj != nil {
		objs = []TableSpecExternalDataConfigurationGoogleSheetsOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableSpecExternalDataConfigurationGoogleSheetsOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TableSpecExternalDataConfigurationGoogleSheetsOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TableSpecExternalDataConfigurationGoogleSheetsOptions)(ptr) = TableSpecExternalDataConfigurationGoogleSheetsOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TableSpecExternalDataConfigurationGoogleSheetsOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableSpecExternalDataConfigurationGoogleSheetsOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TableSpecExternalDataConfigurationGoogleSheetsOptions)(ptr) = objs[0]
			} else {
				*(*TableSpecExternalDataConfigurationGoogleSheetsOptions)(ptr) = TableSpecExternalDataConfigurationGoogleSheetsOptions{}
			}
		} else {
			*(*TableSpecExternalDataConfigurationGoogleSheetsOptions)(ptr) = TableSpecExternalDataConfigurationGoogleSheetsOptions{}
		}
	default:
		iter.ReportError("decode TableSpecExternalDataConfigurationGoogleSheetsOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TableSpecExternalDataConfigurationHivePartitioningOptionsCodec struct {
}

func (TableSpecExternalDataConfigurationHivePartitioningOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TableSpecExternalDataConfigurationHivePartitioningOptions)(ptr) == nil
}

func (TableSpecExternalDataConfigurationHivePartitioningOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TableSpecExternalDataConfigurationHivePartitioningOptions)(ptr)
	var objs []TableSpecExternalDataConfigurationHivePartitioningOptions
	if obj != nil {
		objs = []TableSpecExternalDataConfigurationHivePartitioningOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableSpecExternalDataConfigurationHivePartitioningOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TableSpecExternalDataConfigurationHivePartitioningOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TableSpecExternalDataConfigurationHivePartitioningOptions)(ptr) = TableSpecExternalDataConfigurationHivePartitioningOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TableSpecExternalDataConfigurationHivePartitioningOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableSpecExternalDataConfigurationHivePartitioningOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TableSpecExternalDataConfigurationHivePartitioningOptions)(ptr) = objs[0]
			} else {
				*(*TableSpecExternalDataConfigurationHivePartitioningOptions)(ptr) = TableSpecExternalDataConfigurationHivePartitioningOptions{}
			}
		} else {
			*(*TableSpecExternalDataConfigurationHivePartitioningOptions)(ptr) = TableSpecExternalDataConfigurationHivePartitioningOptions{}
		}
	default:
		iter.ReportError("decode TableSpecExternalDataConfigurationHivePartitioningOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TableSpecMaterializedViewCodec struct {
}

func (TableSpecMaterializedViewCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TableSpecMaterializedView)(ptr) == nil
}

func (TableSpecMaterializedViewCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TableSpecMaterializedView)(ptr)
	var objs []TableSpecMaterializedView
	if obj != nil {
		objs = []TableSpecMaterializedView{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableSpecMaterializedView{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TableSpecMaterializedViewCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TableSpecMaterializedView)(ptr) = TableSpecMaterializedView{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TableSpecMaterializedView

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableSpecMaterializedView{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TableSpecMaterializedView)(ptr) = objs[0]
			} else {
				*(*TableSpecMaterializedView)(ptr) = TableSpecMaterializedView{}
			}
		} else {
			*(*TableSpecMaterializedView)(ptr) = TableSpecMaterializedView{}
		}
	default:
		iter.ReportError("decode TableSpecMaterializedView", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TableSpecRangePartitioningCodec struct {
}

func (TableSpecRangePartitioningCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TableSpecRangePartitioning)(ptr) == nil
}

func (TableSpecRangePartitioningCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TableSpecRangePartitioning)(ptr)
	var objs []TableSpecRangePartitioning
	if obj != nil {
		objs = []TableSpecRangePartitioning{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableSpecRangePartitioning{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TableSpecRangePartitioningCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TableSpecRangePartitioning)(ptr) = TableSpecRangePartitioning{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TableSpecRangePartitioning

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableSpecRangePartitioning{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TableSpecRangePartitioning)(ptr) = objs[0]
			} else {
				*(*TableSpecRangePartitioning)(ptr) = TableSpecRangePartitioning{}
			}
		} else {
			*(*TableSpecRangePartitioning)(ptr) = TableSpecRangePartitioning{}
		}
	default:
		iter.ReportError("decode TableSpecRangePartitioning", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TableSpecRangePartitioningRangeCodec struct {
}

func (TableSpecRangePartitioningRangeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TableSpecRangePartitioningRange)(ptr) == nil
}

func (TableSpecRangePartitioningRangeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TableSpecRangePartitioningRange)(ptr)
	var objs []TableSpecRangePartitioningRange
	if obj != nil {
		objs = []TableSpecRangePartitioningRange{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableSpecRangePartitioningRange{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TableSpecRangePartitioningRangeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TableSpecRangePartitioningRange)(ptr) = TableSpecRangePartitioningRange{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TableSpecRangePartitioningRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableSpecRangePartitioningRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TableSpecRangePartitioningRange)(ptr) = objs[0]
			} else {
				*(*TableSpecRangePartitioningRange)(ptr) = TableSpecRangePartitioningRange{}
			}
		} else {
			*(*TableSpecRangePartitioningRange)(ptr) = TableSpecRangePartitioningRange{}
		}
	default:
		iter.ReportError("decode TableSpecRangePartitioningRange", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TableSpecTimePartitioningCodec struct {
}

func (TableSpecTimePartitioningCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TableSpecTimePartitioning)(ptr) == nil
}

func (TableSpecTimePartitioningCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TableSpecTimePartitioning)(ptr)
	var objs []TableSpecTimePartitioning
	if obj != nil {
		objs = []TableSpecTimePartitioning{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableSpecTimePartitioning{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TableSpecTimePartitioningCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TableSpecTimePartitioning)(ptr) = TableSpecTimePartitioning{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TableSpecTimePartitioning

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableSpecTimePartitioning{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TableSpecTimePartitioning)(ptr) = objs[0]
			} else {
				*(*TableSpecTimePartitioning)(ptr) = TableSpecTimePartitioning{}
			}
		} else {
			*(*TableSpecTimePartitioning)(ptr) = TableSpecTimePartitioning{}
		}
	default:
		iter.ReportError("decode TableSpecTimePartitioning", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TableSpecViewCodec struct {
}

func (TableSpecViewCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TableSpecView)(ptr) == nil
}

func (TableSpecViewCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TableSpecView)(ptr)
	var objs []TableSpecView
	if obj != nil {
		objs = []TableSpecView{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableSpecView{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TableSpecViewCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TableSpecView)(ptr) = TableSpecView{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TableSpecView

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableSpecView{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TableSpecView)(ptr) = objs[0]
			} else {
				*(*TableSpecView)(ptr) = TableSpecView{}
			}
		} else {
			*(*TableSpecView)(ptr) = TableSpecView{}
		}
	default:
		iter.ReportError("decode TableSpecView", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TableIamBindingSpecConditionCodec struct {
}

func (TableIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TableIamBindingSpecCondition)(ptr) == nil
}

func (TableIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TableIamBindingSpecCondition)(ptr)
	var objs []TableIamBindingSpecCondition
	if obj != nil {
		objs = []TableIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TableIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TableIamBindingSpecCondition)(ptr) = TableIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TableIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TableIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*TableIamBindingSpecCondition)(ptr) = TableIamBindingSpecCondition{}
			}
		} else {
			*(*TableIamBindingSpecCondition)(ptr) = TableIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode TableIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TableIamMemberSpecConditionCodec struct {
}

func (TableIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TableIamMemberSpecCondition)(ptr) == nil
}

func (TableIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TableIamMemberSpecCondition)(ptr)
	var objs []TableIamMemberSpecCondition
	if obj != nil {
		objs = []TableIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TableIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TableIamMemberSpecCondition)(ptr) = TableIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TableIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TableIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TableIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*TableIamMemberSpecCondition)(ptr) = TableIamMemberSpecCondition{}
			}
		} else {
			*(*TableIamMemberSpecCondition)(ptr) = TableIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode TableIamMemberSpecCondition", "unexpected JSON type")
	}
}
