/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecFeatureSettings{}).Type1()):                                  ApplicationSpecFeatureSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecIap{}).Type1()):                                              ApplicationSpecIapCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DomainMappingSpecSslSettings{}).Type1()):                                    DomainMappingSpecSslSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecApiConfig{}).Type1()):                                 FlexibleAppVersionSpecApiConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecAutomaticScaling{}).Type1()):                          FlexibleAppVersionSpecAutomaticScalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecAutomaticScalingCpuUtilization{}).Type1()):            FlexibleAppVersionSpecAutomaticScalingCpuUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecAutomaticScalingDiskUtilization{}).Type1()):           FlexibleAppVersionSpecAutomaticScalingDiskUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecAutomaticScalingNetworkUtilization{}).Type1()):        FlexibleAppVersionSpecAutomaticScalingNetworkUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecAutomaticScalingRequestUtilization{}).Type1()):        FlexibleAppVersionSpecAutomaticScalingRequestUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecDeployment{}).Type1()):                                FlexibleAppVersionSpecDeploymentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecDeploymentCloudBuildOptions{}).Type1()):               FlexibleAppVersionSpecDeploymentCloudBuildOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecDeploymentContainer{}).Type1()):                       FlexibleAppVersionSpecDeploymentContainerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecDeploymentZip{}).Type1()):                             FlexibleAppVersionSpecDeploymentZipCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecEndpointsAPIService{}).Type1()):                       FlexibleAppVersionSpecEndpointsAPIServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecEntrypoint{}).Type1()):                                FlexibleAppVersionSpecEntrypointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecHandlersScript{}).Type1()):                            FlexibleAppVersionSpecHandlersScriptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecHandlersStaticFiles{}).Type1()):                       FlexibleAppVersionSpecHandlersStaticFilesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecLivenessCheck{}).Type1()):                             FlexibleAppVersionSpecLivenessCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecManualScaling{}).Type1()):                             FlexibleAppVersionSpecManualScalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecNetwork{}).Type1()):                                   FlexibleAppVersionSpecNetworkCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecReadinessCheck{}).Type1()):                            FlexibleAppVersionSpecReadinessCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecResources{}).Type1()):                                 FlexibleAppVersionSpecResourcesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecVpcAccessConnector{}).Type1()):                        FlexibleAppVersionSpecVpcAccessConnectorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSplitTrafficSpecSplit{}).Type1()):                                    ServiceSplitTrafficSpecSplitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecAutomaticScaling{}).Type1()):                          StandardAppVersionSpecAutomaticScalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecAutomaticScalingStandardSchedulerSettings{}).Type1()): StandardAppVersionSpecAutomaticScalingStandardSchedulerSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecBasicScaling{}).Type1()):                              StandardAppVersionSpecBasicScalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecDeployment{}).Type1()):                                StandardAppVersionSpecDeploymentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecDeploymentZip{}).Type1()):                             StandardAppVersionSpecDeploymentZipCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecEntrypoint{}).Type1()):                                StandardAppVersionSpecEntrypointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecHandlersScript{}).Type1()):                            StandardAppVersionSpecHandlersScriptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecHandlersStaticFiles{}).Type1()):                       StandardAppVersionSpecHandlersStaticFilesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecManualScaling{}).Type1()):                             StandardAppVersionSpecManualScalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecVpcAccessConnector{}).Type1()):                        StandardAppVersionSpecVpcAccessConnectorCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecFeatureSettings{}).Type1()):                                  ApplicationSpecFeatureSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecIap{}).Type1()):                                              ApplicationSpecIapCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DomainMappingSpecSslSettings{}).Type1()):                                    DomainMappingSpecSslSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecApiConfig{}).Type1()):                                 FlexibleAppVersionSpecApiConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecAutomaticScaling{}).Type1()):                          FlexibleAppVersionSpecAutomaticScalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecAutomaticScalingCpuUtilization{}).Type1()):            FlexibleAppVersionSpecAutomaticScalingCpuUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecAutomaticScalingDiskUtilization{}).Type1()):           FlexibleAppVersionSpecAutomaticScalingDiskUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecAutomaticScalingNetworkUtilization{}).Type1()):        FlexibleAppVersionSpecAutomaticScalingNetworkUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecAutomaticScalingRequestUtilization{}).Type1()):        FlexibleAppVersionSpecAutomaticScalingRequestUtilizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecDeployment{}).Type1()):                                FlexibleAppVersionSpecDeploymentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecDeploymentCloudBuildOptions{}).Type1()):               FlexibleAppVersionSpecDeploymentCloudBuildOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecDeploymentContainer{}).Type1()):                       FlexibleAppVersionSpecDeploymentContainerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecDeploymentZip{}).Type1()):                             FlexibleAppVersionSpecDeploymentZipCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecEndpointsAPIService{}).Type1()):                       FlexibleAppVersionSpecEndpointsAPIServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecEntrypoint{}).Type1()):                                FlexibleAppVersionSpecEntrypointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecHandlersScript{}).Type1()):                            FlexibleAppVersionSpecHandlersScriptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecHandlersStaticFiles{}).Type1()):                       FlexibleAppVersionSpecHandlersStaticFilesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecLivenessCheck{}).Type1()):                             FlexibleAppVersionSpecLivenessCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecManualScaling{}).Type1()):                             FlexibleAppVersionSpecManualScalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecNetwork{}).Type1()):                                   FlexibleAppVersionSpecNetworkCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecReadinessCheck{}).Type1()):                            FlexibleAppVersionSpecReadinessCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecResources{}).Type1()):                                 FlexibleAppVersionSpecResourcesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecVpcAccessConnector{}).Type1()):                        FlexibleAppVersionSpecVpcAccessConnectorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSplitTrafficSpecSplit{}).Type1()):                                    ServiceSplitTrafficSpecSplitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecAutomaticScaling{}).Type1()):                          StandardAppVersionSpecAutomaticScalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecAutomaticScalingStandardSchedulerSettings{}).Type1()): StandardAppVersionSpecAutomaticScalingStandardSchedulerSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecBasicScaling{}).Type1()):                              StandardAppVersionSpecBasicScalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecDeployment{}).Type1()):                                StandardAppVersionSpecDeploymentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecDeploymentZip{}).Type1()):                             StandardAppVersionSpecDeploymentZipCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecEntrypoint{}).Type1()):                                StandardAppVersionSpecEntrypointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecHandlersScript{}).Type1()):                            StandardAppVersionSpecHandlersScriptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecHandlersStaticFiles{}).Type1()):                       StandardAppVersionSpecHandlersStaticFilesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecManualScaling{}).Type1()):                             StandardAppVersionSpecManualScalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecVpcAccessConnector{}).Type1()):                        StandardAppVersionSpecVpcAccessConnectorCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type ApplicationSpecFeatureSettingsCodec struct {
}

func (ApplicationSpecFeatureSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecFeatureSettings)(ptr) == nil
}

func (ApplicationSpecFeatureSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecFeatureSettings)(ptr)
	var objs []ApplicationSpecFeatureSettings
	if obj != nil {
		objs = []ApplicationSpecFeatureSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecFeatureSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecFeatureSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecFeatureSettings)(ptr) = ApplicationSpecFeatureSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecFeatureSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecFeatureSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecFeatureSettings)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecFeatureSettings)(ptr) = ApplicationSpecFeatureSettings{}
			}
		} else {
			*(*ApplicationSpecFeatureSettings)(ptr) = ApplicationSpecFeatureSettings{}
		}
	default:
		iter.ReportError("decode ApplicationSpecFeatureSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecIapCodec struct {
}

func (ApplicationSpecIapCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecIap)(ptr) == nil
}

func (ApplicationSpecIapCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecIap)(ptr)
	var objs []ApplicationSpecIap
	if obj != nil {
		objs = []ApplicationSpecIap{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecIap{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecIapCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecIap)(ptr) = ApplicationSpecIap{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecIap

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecIap{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecIap)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecIap)(ptr) = ApplicationSpecIap{}
			}
		} else {
			*(*ApplicationSpecIap)(ptr) = ApplicationSpecIap{}
		}
	default:
		iter.ReportError("decode ApplicationSpecIap", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DomainMappingSpecSslSettingsCodec struct {
}

func (DomainMappingSpecSslSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DomainMappingSpecSslSettings)(ptr) == nil
}

func (DomainMappingSpecSslSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DomainMappingSpecSslSettings)(ptr)
	var objs []DomainMappingSpecSslSettings
	if obj != nil {
		objs = []DomainMappingSpecSslSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainMappingSpecSslSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DomainMappingSpecSslSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DomainMappingSpecSslSettings)(ptr) = DomainMappingSpecSslSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DomainMappingSpecSslSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainMappingSpecSslSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DomainMappingSpecSslSettings)(ptr) = objs[0]
			} else {
				*(*DomainMappingSpecSslSettings)(ptr) = DomainMappingSpecSslSettings{}
			}
		} else {
			*(*DomainMappingSpecSslSettings)(ptr) = DomainMappingSpecSslSettings{}
		}
	default:
		iter.ReportError("decode DomainMappingSpecSslSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FlexibleAppVersionSpecApiConfigCodec struct {
}

func (FlexibleAppVersionSpecApiConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FlexibleAppVersionSpecApiConfig)(ptr) == nil
}

func (FlexibleAppVersionSpecApiConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FlexibleAppVersionSpecApiConfig)(ptr)
	var objs []FlexibleAppVersionSpecApiConfig
	if obj != nil {
		objs = []FlexibleAppVersionSpecApiConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecApiConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FlexibleAppVersionSpecApiConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FlexibleAppVersionSpecApiConfig)(ptr) = FlexibleAppVersionSpecApiConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FlexibleAppVersionSpecApiConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecApiConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FlexibleAppVersionSpecApiConfig)(ptr) = objs[0]
			} else {
				*(*FlexibleAppVersionSpecApiConfig)(ptr) = FlexibleAppVersionSpecApiConfig{}
			}
		} else {
			*(*FlexibleAppVersionSpecApiConfig)(ptr) = FlexibleAppVersionSpecApiConfig{}
		}
	default:
		iter.ReportError("decode FlexibleAppVersionSpecApiConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FlexibleAppVersionSpecAutomaticScalingCodec struct {
}

func (FlexibleAppVersionSpecAutomaticScalingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FlexibleAppVersionSpecAutomaticScaling)(ptr) == nil
}

func (FlexibleAppVersionSpecAutomaticScalingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FlexibleAppVersionSpecAutomaticScaling)(ptr)
	var objs []FlexibleAppVersionSpecAutomaticScaling
	if obj != nil {
		objs = []FlexibleAppVersionSpecAutomaticScaling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecAutomaticScaling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FlexibleAppVersionSpecAutomaticScalingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FlexibleAppVersionSpecAutomaticScaling)(ptr) = FlexibleAppVersionSpecAutomaticScaling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FlexibleAppVersionSpecAutomaticScaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecAutomaticScaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FlexibleAppVersionSpecAutomaticScaling)(ptr) = objs[0]
			} else {
				*(*FlexibleAppVersionSpecAutomaticScaling)(ptr) = FlexibleAppVersionSpecAutomaticScaling{}
			}
		} else {
			*(*FlexibleAppVersionSpecAutomaticScaling)(ptr) = FlexibleAppVersionSpecAutomaticScaling{}
		}
	default:
		iter.ReportError("decode FlexibleAppVersionSpecAutomaticScaling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FlexibleAppVersionSpecAutomaticScalingCpuUtilizationCodec struct {
}

func (FlexibleAppVersionSpecAutomaticScalingCpuUtilizationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FlexibleAppVersionSpecAutomaticScalingCpuUtilization)(ptr) == nil
}

func (FlexibleAppVersionSpecAutomaticScalingCpuUtilizationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FlexibleAppVersionSpecAutomaticScalingCpuUtilization)(ptr)
	var objs []FlexibleAppVersionSpecAutomaticScalingCpuUtilization
	if obj != nil {
		objs = []FlexibleAppVersionSpecAutomaticScalingCpuUtilization{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecAutomaticScalingCpuUtilization{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FlexibleAppVersionSpecAutomaticScalingCpuUtilizationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FlexibleAppVersionSpecAutomaticScalingCpuUtilization)(ptr) = FlexibleAppVersionSpecAutomaticScalingCpuUtilization{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FlexibleAppVersionSpecAutomaticScalingCpuUtilization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecAutomaticScalingCpuUtilization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FlexibleAppVersionSpecAutomaticScalingCpuUtilization)(ptr) = objs[0]
			} else {
				*(*FlexibleAppVersionSpecAutomaticScalingCpuUtilization)(ptr) = FlexibleAppVersionSpecAutomaticScalingCpuUtilization{}
			}
		} else {
			*(*FlexibleAppVersionSpecAutomaticScalingCpuUtilization)(ptr) = FlexibleAppVersionSpecAutomaticScalingCpuUtilization{}
		}
	default:
		iter.ReportError("decode FlexibleAppVersionSpecAutomaticScalingCpuUtilization", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FlexibleAppVersionSpecAutomaticScalingDiskUtilizationCodec struct {
}

func (FlexibleAppVersionSpecAutomaticScalingDiskUtilizationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FlexibleAppVersionSpecAutomaticScalingDiskUtilization)(ptr) == nil
}

func (FlexibleAppVersionSpecAutomaticScalingDiskUtilizationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FlexibleAppVersionSpecAutomaticScalingDiskUtilization)(ptr)
	var objs []FlexibleAppVersionSpecAutomaticScalingDiskUtilization
	if obj != nil {
		objs = []FlexibleAppVersionSpecAutomaticScalingDiskUtilization{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecAutomaticScalingDiskUtilization{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FlexibleAppVersionSpecAutomaticScalingDiskUtilizationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FlexibleAppVersionSpecAutomaticScalingDiskUtilization)(ptr) = FlexibleAppVersionSpecAutomaticScalingDiskUtilization{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FlexibleAppVersionSpecAutomaticScalingDiskUtilization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecAutomaticScalingDiskUtilization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FlexibleAppVersionSpecAutomaticScalingDiskUtilization)(ptr) = objs[0]
			} else {
				*(*FlexibleAppVersionSpecAutomaticScalingDiskUtilization)(ptr) = FlexibleAppVersionSpecAutomaticScalingDiskUtilization{}
			}
		} else {
			*(*FlexibleAppVersionSpecAutomaticScalingDiskUtilization)(ptr) = FlexibleAppVersionSpecAutomaticScalingDiskUtilization{}
		}
	default:
		iter.ReportError("decode FlexibleAppVersionSpecAutomaticScalingDiskUtilization", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FlexibleAppVersionSpecAutomaticScalingNetworkUtilizationCodec struct {
}

func (FlexibleAppVersionSpecAutomaticScalingNetworkUtilizationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FlexibleAppVersionSpecAutomaticScalingNetworkUtilization)(ptr) == nil
}

func (FlexibleAppVersionSpecAutomaticScalingNetworkUtilizationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FlexibleAppVersionSpecAutomaticScalingNetworkUtilization)(ptr)
	var objs []FlexibleAppVersionSpecAutomaticScalingNetworkUtilization
	if obj != nil {
		objs = []FlexibleAppVersionSpecAutomaticScalingNetworkUtilization{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecAutomaticScalingNetworkUtilization{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FlexibleAppVersionSpecAutomaticScalingNetworkUtilizationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FlexibleAppVersionSpecAutomaticScalingNetworkUtilization)(ptr) = FlexibleAppVersionSpecAutomaticScalingNetworkUtilization{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FlexibleAppVersionSpecAutomaticScalingNetworkUtilization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecAutomaticScalingNetworkUtilization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FlexibleAppVersionSpecAutomaticScalingNetworkUtilization)(ptr) = objs[0]
			} else {
				*(*FlexibleAppVersionSpecAutomaticScalingNetworkUtilization)(ptr) = FlexibleAppVersionSpecAutomaticScalingNetworkUtilization{}
			}
		} else {
			*(*FlexibleAppVersionSpecAutomaticScalingNetworkUtilization)(ptr) = FlexibleAppVersionSpecAutomaticScalingNetworkUtilization{}
		}
	default:
		iter.ReportError("decode FlexibleAppVersionSpecAutomaticScalingNetworkUtilization", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FlexibleAppVersionSpecAutomaticScalingRequestUtilizationCodec struct {
}

func (FlexibleAppVersionSpecAutomaticScalingRequestUtilizationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FlexibleAppVersionSpecAutomaticScalingRequestUtilization)(ptr) == nil
}

func (FlexibleAppVersionSpecAutomaticScalingRequestUtilizationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FlexibleAppVersionSpecAutomaticScalingRequestUtilization)(ptr)
	var objs []FlexibleAppVersionSpecAutomaticScalingRequestUtilization
	if obj != nil {
		objs = []FlexibleAppVersionSpecAutomaticScalingRequestUtilization{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecAutomaticScalingRequestUtilization{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FlexibleAppVersionSpecAutomaticScalingRequestUtilizationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FlexibleAppVersionSpecAutomaticScalingRequestUtilization)(ptr) = FlexibleAppVersionSpecAutomaticScalingRequestUtilization{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FlexibleAppVersionSpecAutomaticScalingRequestUtilization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecAutomaticScalingRequestUtilization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FlexibleAppVersionSpecAutomaticScalingRequestUtilization)(ptr) = objs[0]
			} else {
				*(*FlexibleAppVersionSpecAutomaticScalingRequestUtilization)(ptr) = FlexibleAppVersionSpecAutomaticScalingRequestUtilization{}
			}
		} else {
			*(*FlexibleAppVersionSpecAutomaticScalingRequestUtilization)(ptr) = FlexibleAppVersionSpecAutomaticScalingRequestUtilization{}
		}
	default:
		iter.ReportError("decode FlexibleAppVersionSpecAutomaticScalingRequestUtilization", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FlexibleAppVersionSpecDeploymentCodec struct {
}

func (FlexibleAppVersionSpecDeploymentCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FlexibleAppVersionSpecDeployment)(ptr) == nil
}

func (FlexibleAppVersionSpecDeploymentCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FlexibleAppVersionSpecDeployment)(ptr)
	var objs []FlexibleAppVersionSpecDeployment
	if obj != nil {
		objs = []FlexibleAppVersionSpecDeployment{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecDeployment{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FlexibleAppVersionSpecDeploymentCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FlexibleAppVersionSpecDeployment)(ptr) = FlexibleAppVersionSpecDeployment{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FlexibleAppVersionSpecDeployment

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecDeployment{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FlexibleAppVersionSpecDeployment)(ptr) = objs[0]
			} else {
				*(*FlexibleAppVersionSpecDeployment)(ptr) = FlexibleAppVersionSpecDeployment{}
			}
		} else {
			*(*FlexibleAppVersionSpecDeployment)(ptr) = FlexibleAppVersionSpecDeployment{}
		}
	default:
		iter.ReportError("decode FlexibleAppVersionSpecDeployment", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FlexibleAppVersionSpecDeploymentCloudBuildOptionsCodec struct {
}

func (FlexibleAppVersionSpecDeploymentCloudBuildOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FlexibleAppVersionSpecDeploymentCloudBuildOptions)(ptr) == nil
}

func (FlexibleAppVersionSpecDeploymentCloudBuildOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FlexibleAppVersionSpecDeploymentCloudBuildOptions)(ptr)
	var objs []FlexibleAppVersionSpecDeploymentCloudBuildOptions
	if obj != nil {
		objs = []FlexibleAppVersionSpecDeploymentCloudBuildOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecDeploymentCloudBuildOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FlexibleAppVersionSpecDeploymentCloudBuildOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FlexibleAppVersionSpecDeploymentCloudBuildOptions)(ptr) = FlexibleAppVersionSpecDeploymentCloudBuildOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FlexibleAppVersionSpecDeploymentCloudBuildOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecDeploymentCloudBuildOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FlexibleAppVersionSpecDeploymentCloudBuildOptions)(ptr) = objs[0]
			} else {
				*(*FlexibleAppVersionSpecDeploymentCloudBuildOptions)(ptr) = FlexibleAppVersionSpecDeploymentCloudBuildOptions{}
			}
		} else {
			*(*FlexibleAppVersionSpecDeploymentCloudBuildOptions)(ptr) = FlexibleAppVersionSpecDeploymentCloudBuildOptions{}
		}
	default:
		iter.ReportError("decode FlexibleAppVersionSpecDeploymentCloudBuildOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FlexibleAppVersionSpecDeploymentContainerCodec struct {
}

func (FlexibleAppVersionSpecDeploymentContainerCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FlexibleAppVersionSpecDeploymentContainer)(ptr) == nil
}

func (FlexibleAppVersionSpecDeploymentContainerCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FlexibleAppVersionSpecDeploymentContainer)(ptr)
	var objs []FlexibleAppVersionSpecDeploymentContainer
	if obj != nil {
		objs = []FlexibleAppVersionSpecDeploymentContainer{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecDeploymentContainer{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FlexibleAppVersionSpecDeploymentContainerCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FlexibleAppVersionSpecDeploymentContainer)(ptr) = FlexibleAppVersionSpecDeploymentContainer{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FlexibleAppVersionSpecDeploymentContainer

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecDeploymentContainer{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FlexibleAppVersionSpecDeploymentContainer)(ptr) = objs[0]
			} else {
				*(*FlexibleAppVersionSpecDeploymentContainer)(ptr) = FlexibleAppVersionSpecDeploymentContainer{}
			}
		} else {
			*(*FlexibleAppVersionSpecDeploymentContainer)(ptr) = FlexibleAppVersionSpecDeploymentContainer{}
		}
	default:
		iter.ReportError("decode FlexibleAppVersionSpecDeploymentContainer", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FlexibleAppVersionSpecDeploymentZipCodec struct {
}

func (FlexibleAppVersionSpecDeploymentZipCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FlexibleAppVersionSpecDeploymentZip)(ptr) == nil
}

func (FlexibleAppVersionSpecDeploymentZipCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FlexibleAppVersionSpecDeploymentZip)(ptr)
	var objs []FlexibleAppVersionSpecDeploymentZip
	if obj != nil {
		objs = []FlexibleAppVersionSpecDeploymentZip{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecDeploymentZip{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FlexibleAppVersionSpecDeploymentZipCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FlexibleAppVersionSpecDeploymentZip)(ptr) = FlexibleAppVersionSpecDeploymentZip{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FlexibleAppVersionSpecDeploymentZip

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecDeploymentZip{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FlexibleAppVersionSpecDeploymentZip)(ptr) = objs[0]
			} else {
				*(*FlexibleAppVersionSpecDeploymentZip)(ptr) = FlexibleAppVersionSpecDeploymentZip{}
			}
		} else {
			*(*FlexibleAppVersionSpecDeploymentZip)(ptr) = FlexibleAppVersionSpecDeploymentZip{}
		}
	default:
		iter.ReportError("decode FlexibleAppVersionSpecDeploymentZip", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FlexibleAppVersionSpecEndpointsAPIServiceCodec struct {
}

func (FlexibleAppVersionSpecEndpointsAPIServiceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FlexibleAppVersionSpecEndpointsAPIService)(ptr) == nil
}

func (FlexibleAppVersionSpecEndpointsAPIServiceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FlexibleAppVersionSpecEndpointsAPIService)(ptr)
	var objs []FlexibleAppVersionSpecEndpointsAPIService
	if obj != nil {
		objs = []FlexibleAppVersionSpecEndpointsAPIService{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecEndpointsAPIService{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FlexibleAppVersionSpecEndpointsAPIServiceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FlexibleAppVersionSpecEndpointsAPIService)(ptr) = FlexibleAppVersionSpecEndpointsAPIService{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FlexibleAppVersionSpecEndpointsAPIService

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecEndpointsAPIService{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FlexibleAppVersionSpecEndpointsAPIService)(ptr) = objs[0]
			} else {
				*(*FlexibleAppVersionSpecEndpointsAPIService)(ptr) = FlexibleAppVersionSpecEndpointsAPIService{}
			}
		} else {
			*(*FlexibleAppVersionSpecEndpointsAPIService)(ptr) = FlexibleAppVersionSpecEndpointsAPIService{}
		}
	default:
		iter.ReportError("decode FlexibleAppVersionSpecEndpointsAPIService", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FlexibleAppVersionSpecEntrypointCodec struct {
}

func (FlexibleAppVersionSpecEntrypointCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FlexibleAppVersionSpecEntrypoint)(ptr) == nil
}

func (FlexibleAppVersionSpecEntrypointCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FlexibleAppVersionSpecEntrypoint)(ptr)
	var objs []FlexibleAppVersionSpecEntrypoint
	if obj != nil {
		objs = []FlexibleAppVersionSpecEntrypoint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecEntrypoint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FlexibleAppVersionSpecEntrypointCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FlexibleAppVersionSpecEntrypoint)(ptr) = FlexibleAppVersionSpecEntrypoint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FlexibleAppVersionSpecEntrypoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecEntrypoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FlexibleAppVersionSpecEntrypoint)(ptr) = objs[0]
			} else {
				*(*FlexibleAppVersionSpecEntrypoint)(ptr) = FlexibleAppVersionSpecEntrypoint{}
			}
		} else {
			*(*FlexibleAppVersionSpecEntrypoint)(ptr) = FlexibleAppVersionSpecEntrypoint{}
		}
	default:
		iter.ReportError("decode FlexibleAppVersionSpecEntrypoint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FlexibleAppVersionSpecHandlersScriptCodec struct {
}

func (FlexibleAppVersionSpecHandlersScriptCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FlexibleAppVersionSpecHandlersScript)(ptr) == nil
}

func (FlexibleAppVersionSpecHandlersScriptCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FlexibleAppVersionSpecHandlersScript)(ptr)
	var objs []FlexibleAppVersionSpecHandlersScript
	if obj != nil {
		objs = []FlexibleAppVersionSpecHandlersScript{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecHandlersScript{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FlexibleAppVersionSpecHandlersScriptCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FlexibleAppVersionSpecHandlersScript)(ptr) = FlexibleAppVersionSpecHandlersScript{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FlexibleAppVersionSpecHandlersScript

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecHandlersScript{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FlexibleAppVersionSpecHandlersScript)(ptr) = objs[0]
			} else {
				*(*FlexibleAppVersionSpecHandlersScript)(ptr) = FlexibleAppVersionSpecHandlersScript{}
			}
		} else {
			*(*FlexibleAppVersionSpecHandlersScript)(ptr) = FlexibleAppVersionSpecHandlersScript{}
		}
	default:
		iter.ReportError("decode FlexibleAppVersionSpecHandlersScript", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FlexibleAppVersionSpecHandlersStaticFilesCodec struct {
}

func (FlexibleAppVersionSpecHandlersStaticFilesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FlexibleAppVersionSpecHandlersStaticFiles)(ptr) == nil
}

func (FlexibleAppVersionSpecHandlersStaticFilesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FlexibleAppVersionSpecHandlersStaticFiles)(ptr)
	var objs []FlexibleAppVersionSpecHandlersStaticFiles
	if obj != nil {
		objs = []FlexibleAppVersionSpecHandlersStaticFiles{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecHandlersStaticFiles{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FlexibleAppVersionSpecHandlersStaticFilesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FlexibleAppVersionSpecHandlersStaticFiles)(ptr) = FlexibleAppVersionSpecHandlersStaticFiles{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FlexibleAppVersionSpecHandlersStaticFiles

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecHandlersStaticFiles{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FlexibleAppVersionSpecHandlersStaticFiles)(ptr) = objs[0]
			} else {
				*(*FlexibleAppVersionSpecHandlersStaticFiles)(ptr) = FlexibleAppVersionSpecHandlersStaticFiles{}
			}
		} else {
			*(*FlexibleAppVersionSpecHandlersStaticFiles)(ptr) = FlexibleAppVersionSpecHandlersStaticFiles{}
		}
	default:
		iter.ReportError("decode FlexibleAppVersionSpecHandlersStaticFiles", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FlexibleAppVersionSpecLivenessCheckCodec struct {
}

func (FlexibleAppVersionSpecLivenessCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FlexibleAppVersionSpecLivenessCheck)(ptr) == nil
}

func (FlexibleAppVersionSpecLivenessCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FlexibleAppVersionSpecLivenessCheck)(ptr)
	var objs []FlexibleAppVersionSpecLivenessCheck
	if obj != nil {
		objs = []FlexibleAppVersionSpecLivenessCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecLivenessCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FlexibleAppVersionSpecLivenessCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FlexibleAppVersionSpecLivenessCheck)(ptr) = FlexibleAppVersionSpecLivenessCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FlexibleAppVersionSpecLivenessCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecLivenessCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FlexibleAppVersionSpecLivenessCheck)(ptr) = objs[0]
			} else {
				*(*FlexibleAppVersionSpecLivenessCheck)(ptr) = FlexibleAppVersionSpecLivenessCheck{}
			}
		} else {
			*(*FlexibleAppVersionSpecLivenessCheck)(ptr) = FlexibleAppVersionSpecLivenessCheck{}
		}
	default:
		iter.ReportError("decode FlexibleAppVersionSpecLivenessCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FlexibleAppVersionSpecManualScalingCodec struct {
}

func (FlexibleAppVersionSpecManualScalingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FlexibleAppVersionSpecManualScaling)(ptr) == nil
}

func (FlexibleAppVersionSpecManualScalingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FlexibleAppVersionSpecManualScaling)(ptr)
	var objs []FlexibleAppVersionSpecManualScaling
	if obj != nil {
		objs = []FlexibleAppVersionSpecManualScaling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecManualScaling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FlexibleAppVersionSpecManualScalingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FlexibleAppVersionSpecManualScaling)(ptr) = FlexibleAppVersionSpecManualScaling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FlexibleAppVersionSpecManualScaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecManualScaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FlexibleAppVersionSpecManualScaling)(ptr) = objs[0]
			} else {
				*(*FlexibleAppVersionSpecManualScaling)(ptr) = FlexibleAppVersionSpecManualScaling{}
			}
		} else {
			*(*FlexibleAppVersionSpecManualScaling)(ptr) = FlexibleAppVersionSpecManualScaling{}
		}
	default:
		iter.ReportError("decode FlexibleAppVersionSpecManualScaling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FlexibleAppVersionSpecNetworkCodec struct {
}

func (FlexibleAppVersionSpecNetworkCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FlexibleAppVersionSpecNetwork)(ptr) == nil
}

func (FlexibleAppVersionSpecNetworkCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FlexibleAppVersionSpecNetwork)(ptr)
	var objs []FlexibleAppVersionSpecNetwork
	if obj != nil {
		objs = []FlexibleAppVersionSpecNetwork{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecNetwork{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FlexibleAppVersionSpecNetworkCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FlexibleAppVersionSpecNetwork)(ptr) = FlexibleAppVersionSpecNetwork{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FlexibleAppVersionSpecNetwork

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecNetwork{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FlexibleAppVersionSpecNetwork)(ptr) = objs[0]
			} else {
				*(*FlexibleAppVersionSpecNetwork)(ptr) = FlexibleAppVersionSpecNetwork{}
			}
		} else {
			*(*FlexibleAppVersionSpecNetwork)(ptr) = FlexibleAppVersionSpecNetwork{}
		}
	default:
		iter.ReportError("decode FlexibleAppVersionSpecNetwork", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FlexibleAppVersionSpecReadinessCheckCodec struct {
}

func (FlexibleAppVersionSpecReadinessCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FlexibleAppVersionSpecReadinessCheck)(ptr) == nil
}

func (FlexibleAppVersionSpecReadinessCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FlexibleAppVersionSpecReadinessCheck)(ptr)
	var objs []FlexibleAppVersionSpecReadinessCheck
	if obj != nil {
		objs = []FlexibleAppVersionSpecReadinessCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecReadinessCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FlexibleAppVersionSpecReadinessCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FlexibleAppVersionSpecReadinessCheck)(ptr) = FlexibleAppVersionSpecReadinessCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FlexibleAppVersionSpecReadinessCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecReadinessCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FlexibleAppVersionSpecReadinessCheck)(ptr) = objs[0]
			} else {
				*(*FlexibleAppVersionSpecReadinessCheck)(ptr) = FlexibleAppVersionSpecReadinessCheck{}
			}
		} else {
			*(*FlexibleAppVersionSpecReadinessCheck)(ptr) = FlexibleAppVersionSpecReadinessCheck{}
		}
	default:
		iter.ReportError("decode FlexibleAppVersionSpecReadinessCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FlexibleAppVersionSpecResourcesCodec struct {
}

func (FlexibleAppVersionSpecResourcesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FlexibleAppVersionSpecResources)(ptr) == nil
}

func (FlexibleAppVersionSpecResourcesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FlexibleAppVersionSpecResources)(ptr)
	var objs []FlexibleAppVersionSpecResources
	if obj != nil {
		objs = []FlexibleAppVersionSpecResources{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecResources{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FlexibleAppVersionSpecResourcesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FlexibleAppVersionSpecResources)(ptr) = FlexibleAppVersionSpecResources{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FlexibleAppVersionSpecResources

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecResources{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FlexibleAppVersionSpecResources)(ptr) = objs[0]
			} else {
				*(*FlexibleAppVersionSpecResources)(ptr) = FlexibleAppVersionSpecResources{}
			}
		} else {
			*(*FlexibleAppVersionSpecResources)(ptr) = FlexibleAppVersionSpecResources{}
		}
	default:
		iter.ReportError("decode FlexibleAppVersionSpecResources", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FlexibleAppVersionSpecVpcAccessConnectorCodec struct {
}

func (FlexibleAppVersionSpecVpcAccessConnectorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FlexibleAppVersionSpecVpcAccessConnector)(ptr) == nil
}

func (FlexibleAppVersionSpecVpcAccessConnectorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FlexibleAppVersionSpecVpcAccessConnector)(ptr)
	var objs []FlexibleAppVersionSpecVpcAccessConnector
	if obj != nil {
		objs = []FlexibleAppVersionSpecVpcAccessConnector{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecVpcAccessConnector{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FlexibleAppVersionSpecVpcAccessConnectorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FlexibleAppVersionSpecVpcAccessConnector)(ptr) = FlexibleAppVersionSpecVpcAccessConnector{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FlexibleAppVersionSpecVpcAccessConnector

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FlexibleAppVersionSpecVpcAccessConnector{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FlexibleAppVersionSpecVpcAccessConnector)(ptr) = objs[0]
			} else {
				*(*FlexibleAppVersionSpecVpcAccessConnector)(ptr) = FlexibleAppVersionSpecVpcAccessConnector{}
			}
		} else {
			*(*FlexibleAppVersionSpecVpcAccessConnector)(ptr) = FlexibleAppVersionSpecVpcAccessConnector{}
		}
	default:
		iter.ReportError("decode FlexibleAppVersionSpecVpcAccessConnector", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSplitTrafficSpecSplitCodec struct {
}

func (ServiceSplitTrafficSpecSplitCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSplitTrafficSpecSplit)(ptr) == nil
}

func (ServiceSplitTrafficSpecSplitCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSplitTrafficSpecSplit)(ptr)
	var objs []ServiceSplitTrafficSpecSplit
	if obj != nil {
		objs = []ServiceSplitTrafficSpecSplit{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSplitTrafficSpecSplit{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSplitTrafficSpecSplitCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSplitTrafficSpecSplit)(ptr) = ServiceSplitTrafficSpecSplit{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSplitTrafficSpecSplit

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSplitTrafficSpecSplit{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSplitTrafficSpecSplit)(ptr) = objs[0]
			} else {
				*(*ServiceSplitTrafficSpecSplit)(ptr) = ServiceSplitTrafficSpecSplit{}
			}
		} else {
			*(*ServiceSplitTrafficSpecSplit)(ptr) = ServiceSplitTrafficSpecSplit{}
		}
	default:
		iter.ReportError("decode ServiceSplitTrafficSpecSplit", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StandardAppVersionSpecAutomaticScalingCodec struct {
}

func (StandardAppVersionSpecAutomaticScalingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StandardAppVersionSpecAutomaticScaling)(ptr) == nil
}

func (StandardAppVersionSpecAutomaticScalingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StandardAppVersionSpecAutomaticScaling)(ptr)
	var objs []StandardAppVersionSpecAutomaticScaling
	if obj != nil {
		objs = []StandardAppVersionSpecAutomaticScaling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecAutomaticScaling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StandardAppVersionSpecAutomaticScalingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StandardAppVersionSpecAutomaticScaling)(ptr) = StandardAppVersionSpecAutomaticScaling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StandardAppVersionSpecAutomaticScaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecAutomaticScaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StandardAppVersionSpecAutomaticScaling)(ptr) = objs[0]
			} else {
				*(*StandardAppVersionSpecAutomaticScaling)(ptr) = StandardAppVersionSpecAutomaticScaling{}
			}
		} else {
			*(*StandardAppVersionSpecAutomaticScaling)(ptr) = StandardAppVersionSpecAutomaticScaling{}
		}
	default:
		iter.ReportError("decode StandardAppVersionSpecAutomaticScaling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StandardAppVersionSpecAutomaticScalingStandardSchedulerSettingsCodec struct {
}

func (StandardAppVersionSpecAutomaticScalingStandardSchedulerSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StandardAppVersionSpecAutomaticScalingStandardSchedulerSettings)(ptr) == nil
}

func (StandardAppVersionSpecAutomaticScalingStandardSchedulerSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StandardAppVersionSpecAutomaticScalingStandardSchedulerSettings)(ptr)
	var objs []StandardAppVersionSpecAutomaticScalingStandardSchedulerSettings
	if obj != nil {
		objs = []StandardAppVersionSpecAutomaticScalingStandardSchedulerSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecAutomaticScalingStandardSchedulerSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StandardAppVersionSpecAutomaticScalingStandardSchedulerSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StandardAppVersionSpecAutomaticScalingStandardSchedulerSettings)(ptr) = StandardAppVersionSpecAutomaticScalingStandardSchedulerSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StandardAppVersionSpecAutomaticScalingStandardSchedulerSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecAutomaticScalingStandardSchedulerSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StandardAppVersionSpecAutomaticScalingStandardSchedulerSettings)(ptr) = objs[0]
			} else {
				*(*StandardAppVersionSpecAutomaticScalingStandardSchedulerSettings)(ptr) = StandardAppVersionSpecAutomaticScalingStandardSchedulerSettings{}
			}
		} else {
			*(*StandardAppVersionSpecAutomaticScalingStandardSchedulerSettings)(ptr) = StandardAppVersionSpecAutomaticScalingStandardSchedulerSettings{}
		}
	default:
		iter.ReportError("decode StandardAppVersionSpecAutomaticScalingStandardSchedulerSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StandardAppVersionSpecBasicScalingCodec struct {
}

func (StandardAppVersionSpecBasicScalingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StandardAppVersionSpecBasicScaling)(ptr) == nil
}

func (StandardAppVersionSpecBasicScalingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StandardAppVersionSpecBasicScaling)(ptr)
	var objs []StandardAppVersionSpecBasicScaling
	if obj != nil {
		objs = []StandardAppVersionSpecBasicScaling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecBasicScaling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StandardAppVersionSpecBasicScalingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StandardAppVersionSpecBasicScaling)(ptr) = StandardAppVersionSpecBasicScaling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StandardAppVersionSpecBasicScaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecBasicScaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StandardAppVersionSpecBasicScaling)(ptr) = objs[0]
			} else {
				*(*StandardAppVersionSpecBasicScaling)(ptr) = StandardAppVersionSpecBasicScaling{}
			}
		} else {
			*(*StandardAppVersionSpecBasicScaling)(ptr) = StandardAppVersionSpecBasicScaling{}
		}
	default:
		iter.ReportError("decode StandardAppVersionSpecBasicScaling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StandardAppVersionSpecDeploymentCodec struct {
}

func (StandardAppVersionSpecDeploymentCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StandardAppVersionSpecDeployment)(ptr) == nil
}

func (StandardAppVersionSpecDeploymentCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StandardAppVersionSpecDeployment)(ptr)
	var objs []StandardAppVersionSpecDeployment
	if obj != nil {
		objs = []StandardAppVersionSpecDeployment{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecDeployment{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StandardAppVersionSpecDeploymentCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StandardAppVersionSpecDeployment)(ptr) = StandardAppVersionSpecDeployment{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StandardAppVersionSpecDeployment

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecDeployment{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StandardAppVersionSpecDeployment)(ptr) = objs[0]
			} else {
				*(*StandardAppVersionSpecDeployment)(ptr) = StandardAppVersionSpecDeployment{}
			}
		} else {
			*(*StandardAppVersionSpecDeployment)(ptr) = StandardAppVersionSpecDeployment{}
		}
	default:
		iter.ReportError("decode StandardAppVersionSpecDeployment", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StandardAppVersionSpecDeploymentZipCodec struct {
}

func (StandardAppVersionSpecDeploymentZipCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StandardAppVersionSpecDeploymentZip)(ptr) == nil
}

func (StandardAppVersionSpecDeploymentZipCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StandardAppVersionSpecDeploymentZip)(ptr)
	var objs []StandardAppVersionSpecDeploymentZip
	if obj != nil {
		objs = []StandardAppVersionSpecDeploymentZip{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecDeploymentZip{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StandardAppVersionSpecDeploymentZipCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StandardAppVersionSpecDeploymentZip)(ptr) = StandardAppVersionSpecDeploymentZip{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StandardAppVersionSpecDeploymentZip

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecDeploymentZip{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StandardAppVersionSpecDeploymentZip)(ptr) = objs[0]
			} else {
				*(*StandardAppVersionSpecDeploymentZip)(ptr) = StandardAppVersionSpecDeploymentZip{}
			}
		} else {
			*(*StandardAppVersionSpecDeploymentZip)(ptr) = StandardAppVersionSpecDeploymentZip{}
		}
	default:
		iter.ReportError("decode StandardAppVersionSpecDeploymentZip", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StandardAppVersionSpecEntrypointCodec struct {
}

func (StandardAppVersionSpecEntrypointCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StandardAppVersionSpecEntrypoint)(ptr) == nil
}

func (StandardAppVersionSpecEntrypointCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StandardAppVersionSpecEntrypoint)(ptr)
	var objs []StandardAppVersionSpecEntrypoint
	if obj != nil {
		objs = []StandardAppVersionSpecEntrypoint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecEntrypoint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StandardAppVersionSpecEntrypointCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StandardAppVersionSpecEntrypoint)(ptr) = StandardAppVersionSpecEntrypoint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StandardAppVersionSpecEntrypoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecEntrypoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StandardAppVersionSpecEntrypoint)(ptr) = objs[0]
			} else {
				*(*StandardAppVersionSpecEntrypoint)(ptr) = StandardAppVersionSpecEntrypoint{}
			}
		} else {
			*(*StandardAppVersionSpecEntrypoint)(ptr) = StandardAppVersionSpecEntrypoint{}
		}
	default:
		iter.ReportError("decode StandardAppVersionSpecEntrypoint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StandardAppVersionSpecHandlersScriptCodec struct {
}

func (StandardAppVersionSpecHandlersScriptCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StandardAppVersionSpecHandlersScript)(ptr) == nil
}

func (StandardAppVersionSpecHandlersScriptCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StandardAppVersionSpecHandlersScript)(ptr)
	var objs []StandardAppVersionSpecHandlersScript
	if obj != nil {
		objs = []StandardAppVersionSpecHandlersScript{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecHandlersScript{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StandardAppVersionSpecHandlersScriptCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StandardAppVersionSpecHandlersScript)(ptr) = StandardAppVersionSpecHandlersScript{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StandardAppVersionSpecHandlersScript

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecHandlersScript{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StandardAppVersionSpecHandlersScript)(ptr) = objs[0]
			} else {
				*(*StandardAppVersionSpecHandlersScript)(ptr) = StandardAppVersionSpecHandlersScript{}
			}
		} else {
			*(*StandardAppVersionSpecHandlersScript)(ptr) = StandardAppVersionSpecHandlersScript{}
		}
	default:
		iter.ReportError("decode StandardAppVersionSpecHandlersScript", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StandardAppVersionSpecHandlersStaticFilesCodec struct {
}

func (StandardAppVersionSpecHandlersStaticFilesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StandardAppVersionSpecHandlersStaticFiles)(ptr) == nil
}

func (StandardAppVersionSpecHandlersStaticFilesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StandardAppVersionSpecHandlersStaticFiles)(ptr)
	var objs []StandardAppVersionSpecHandlersStaticFiles
	if obj != nil {
		objs = []StandardAppVersionSpecHandlersStaticFiles{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecHandlersStaticFiles{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StandardAppVersionSpecHandlersStaticFilesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StandardAppVersionSpecHandlersStaticFiles)(ptr) = StandardAppVersionSpecHandlersStaticFiles{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StandardAppVersionSpecHandlersStaticFiles

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecHandlersStaticFiles{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StandardAppVersionSpecHandlersStaticFiles)(ptr) = objs[0]
			} else {
				*(*StandardAppVersionSpecHandlersStaticFiles)(ptr) = StandardAppVersionSpecHandlersStaticFiles{}
			}
		} else {
			*(*StandardAppVersionSpecHandlersStaticFiles)(ptr) = StandardAppVersionSpecHandlersStaticFiles{}
		}
	default:
		iter.ReportError("decode StandardAppVersionSpecHandlersStaticFiles", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StandardAppVersionSpecManualScalingCodec struct {
}

func (StandardAppVersionSpecManualScalingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StandardAppVersionSpecManualScaling)(ptr) == nil
}

func (StandardAppVersionSpecManualScalingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StandardAppVersionSpecManualScaling)(ptr)
	var objs []StandardAppVersionSpecManualScaling
	if obj != nil {
		objs = []StandardAppVersionSpecManualScaling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecManualScaling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StandardAppVersionSpecManualScalingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StandardAppVersionSpecManualScaling)(ptr) = StandardAppVersionSpecManualScaling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StandardAppVersionSpecManualScaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecManualScaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StandardAppVersionSpecManualScaling)(ptr) = objs[0]
			} else {
				*(*StandardAppVersionSpecManualScaling)(ptr) = StandardAppVersionSpecManualScaling{}
			}
		} else {
			*(*StandardAppVersionSpecManualScaling)(ptr) = StandardAppVersionSpecManualScaling{}
		}
	default:
		iter.ReportError("decode StandardAppVersionSpecManualScaling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StandardAppVersionSpecVpcAccessConnectorCodec struct {
}

func (StandardAppVersionSpecVpcAccessConnectorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StandardAppVersionSpecVpcAccessConnector)(ptr) == nil
}

func (StandardAppVersionSpecVpcAccessConnectorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StandardAppVersionSpecVpcAccessConnector)(ptr)
	var objs []StandardAppVersionSpecVpcAccessConnector
	if obj != nil {
		objs = []StandardAppVersionSpecVpcAccessConnector{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecVpcAccessConnector{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StandardAppVersionSpecVpcAccessConnectorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StandardAppVersionSpecVpcAccessConnector)(ptr) = StandardAppVersionSpecVpcAccessConnector{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StandardAppVersionSpecVpcAccessConnector

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StandardAppVersionSpecVpcAccessConnector{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StandardAppVersionSpecVpcAccessConnector)(ptr) = objs[0]
			} else {
				*(*StandardAppVersionSpecVpcAccessConnector)(ptr) = StandardAppVersionSpecVpcAccessConnector{}
			}
		} else {
			*(*StandardAppVersionSpecVpcAccessConnector)(ptr) = StandardAppVersionSpecVpcAccessConnector{}
		}
	default:
		iter.ReportError("decode StandardAppVersionSpecVpcAccessConnector", "unexpected JSON type")
	}
}
