/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(LiteSubscriptionSpecDeliveryConfig{}).Type1()):   LiteSubscriptionSpecDeliveryConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LiteTopicSpecPartitionConfig{}).Type1()):         LiteTopicSpecPartitionConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LiteTopicSpecPartitionConfigCapacity{}).Type1()): LiteTopicSpecPartitionConfigCapacityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LiteTopicSpecRetentionConfig{}).Type1()):         LiteTopicSpecRetentionConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionSpecDeadLetterPolicy{}).Type1()):     SubscriptionSpecDeadLetterPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionSpecExpirationPolicy{}).Type1()):     SubscriptionSpecExpirationPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionSpecPushConfig{}).Type1()):           SubscriptionSpecPushConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionSpecPushConfigOidcToken{}).Type1()):  SubscriptionSpecPushConfigOidcTokenCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionSpecRetryPolicy{}).Type1()):          SubscriptionSpecRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionIamBindingSpecCondition{}).Type1()):  SubscriptionIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionIamMemberSpecCondition{}).Type1()):   SubscriptionIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecMessageStoragePolicy{}).Type1()):        TopicSpecMessageStoragePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicIamBindingSpecCondition{}).Type1()):         TopicIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicIamMemberSpecCondition{}).Type1()):          TopicIamMemberSpecConditionCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(LiteSubscriptionSpecDeliveryConfig{}).Type1()):   LiteSubscriptionSpecDeliveryConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LiteTopicSpecPartitionConfig{}).Type1()):         LiteTopicSpecPartitionConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LiteTopicSpecPartitionConfigCapacity{}).Type1()): LiteTopicSpecPartitionConfigCapacityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LiteTopicSpecRetentionConfig{}).Type1()):         LiteTopicSpecRetentionConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionSpecDeadLetterPolicy{}).Type1()):     SubscriptionSpecDeadLetterPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionSpecExpirationPolicy{}).Type1()):     SubscriptionSpecExpirationPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionSpecPushConfig{}).Type1()):           SubscriptionSpecPushConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionSpecPushConfigOidcToken{}).Type1()):  SubscriptionSpecPushConfigOidcTokenCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionSpecRetryPolicy{}).Type1()):          SubscriptionSpecRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionIamBindingSpecCondition{}).Type1()):  SubscriptionIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionIamMemberSpecCondition{}).Type1()):   SubscriptionIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecMessageStoragePolicy{}).Type1()):        TopicSpecMessageStoragePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicIamBindingSpecCondition{}).Type1()):         TopicIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicIamMemberSpecCondition{}).Type1()):          TopicIamMemberSpecConditionCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type LiteSubscriptionSpecDeliveryConfigCodec struct {
}

func (LiteSubscriptionSpecDeliveryConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LiteSubscriptionSpecDeliveryConfig)(ptr) == nil
}

func (LiteSubscriptionSpecDeliveryConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LiteSubscriptionSpecDeliveryConfig)(ptr)
	var objs []LiteSubscriptionSpecDeliveryConfig
	if obj != nil {
		objs = []LiteSubscriptionSpecDeliveryConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LiteSubscriptionSpecDeliveryConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LiteSubscriptionSpecDeliveryConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LiteSubscriptionSpecDeliveryConfig)(ptr) = LiteSubscriptionSpecDeliveryConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LiteSubscriptionSpecDeliveryConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LiteSubscriptionSpecDeliveryConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LiteSubscriptionSpecDeliveryConfig)(ptr) = objs[0]
			} else {
				*(*LiteSubscriptionSpecDeliveryConfig)(ptr) = LiteSubscriptionSpecDeliveryConfig{}
			}
		} else {
			*(*LiteSubscriptionSpecDeliveryConfig)(ptr) = LiteSubscriptionSpecDeliveryConfig{}
		}
	default:
		iter.ReportError("decode LiteSubscriptionSpecDeliveryConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LiteTopicSpecPartitionConfigCodec struct {
}

func (LiteTopicSpecPartitionConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LiteTopicSpecPartitionConfig)(ptr) == nil
}

func (LiteTopicSpecPartitionConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LiteTopicSpecPartitionConfig)(ptr)
	var objs []LiteTopicSpecPartitionConfig
	if obj != nil {
		objs = []LiteTopicSpecPartitionConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LiteTopicSpecPartitionConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LiteTopicSpecPartitionConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LiteTopicSpecPartitionConfig)(ptr) = LiteTopicSpecPartitionConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LiteTopicSpecPartitionConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LiteTopicSpecPartitionConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LiteTopicSpecPartitionConfig)(ptr) = objs[0]
			} else {
				*(*LiteTopicSpecPartitionConfig)(ptr) = LiteTopicSpecPartitionConfig{}
			}
		} else {
			*(*LiteTopicSpecPartitionConfig)(ptr) = LiteTopicSpecPartitionConfig{}
		}
	default:
		iter.ReportError("decode LiteTopicSpecPartitionConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LiteTopicSpecPartitionConfigCapacityCodec struct {
}

func (LiteTopicSpecPartitionConfigCapacityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LiteTopicSpecPartitionConfigCapacity)(ptr) == nil
}

func (LiteTopicSpecPartitionConfigCapacityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LiteTopicSpecPartitionConfigCapacity)(ptr)
	var objs []LiteTopicSpecPartitionConfigCapacity
	if obj != nil {
		objs = []LiteTopicSpecPartitionConfigCapacity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LiteTopicSpecPartitionConfigCapacity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LiteTopicSpecPartitionConfigCapacityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LiteTopicSpecPartitionConfigCapacity)(ptr) = LiteTopicSpecPartitionConfigCapacity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LiteTopicSpecPartitionConfigCapacity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LiteTopicSpecPartitionConfigCapacity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LiteTopicSpecPartitionConfigCapacity)(ptr) = objs[0]
			} else {
				*(*LiteTopicSpecPartitionConfigCapacity)(ptr) = LiteTopicSpecPartitionConfigCapacity{}
			}
		} else {
			*(*LiteTopicSpecPartitionConfigCapacity)(ptr) = LiteTopicSpecPartitionConfigCapacity{}
		}
	default:
		iter.ReportError("decode LiteTopicSpecPartitionConfigCapacity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LiteTopicSpecRetentionConfigCodec struct {
}

func (LiteTopicSpecRetentionConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LiteTopicSpecRetentionConfig)(ptr) == nil
}

func (LiteTopicSpecRetentionConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LiteTopicSpecRetentionConfig)(ptr)
	var objs []LiteTopicSpecRetentionConfig
	if obj != nil {
		objs = []LiteTopicSpecRetentionConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LiteTopicSpecRetentionConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LiteTopicSpecRetentionConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LiteTopicSpecRetentionConfig)(ptr) = LiteTopicSpecRetentionConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LiteTopicSpecRetentionConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LiteTopicSpecRetentionConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LiteTopicSpecRetentionConfig)(ptr) = objs[0]
			} else {
				*(*LiteTopicSpecRetentionConfig)(ptr) = LiteTopicSpecRetentionConfig{}
			}
		} else {
			*(*LiteTopicSpecRetentionConfig)(ptr) = LiteTopicSpecRetentionConfig{}
		}
	default:
		iter.ReportError("decode LiteTopicSpecRetentionConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SubscriptionSpecDeadLetterPolicyCodec struct {
}

func (SubscriptionSpecDeadLetterPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SubscriptionSpecDeadLetterPolicy)(ptr) == nil
}

func (SubscriptionSpecDeadLetterPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SubscriptionSpecDeadLetterPolicy)(ptr)
	var objs []SubscriptionSpecDeadLetterPolicy
	if obj != nil {
		objs = []SubscriptionSpecDeadLetterPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionSpecDeadLetterPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SubscriptionSpecDeadLetterPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SubscriptionSpecDeadLetterPolicy)(ptr) = SubscriptionSpecDeadLetterPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SubscriptionSpecDeadLetterPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionSpecDeadLetterPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SubscriptionSpecDeadLetterPolicy)(ptr) = objs[0]
			} else {
				*(*SubscriptionSpecDeadLetterPolicy)(ptr) = SubscriptionSpecDeadLetterPolicy{}
			}
		} else {
			*(*SubscriptionSpecDeadLetterPolicy)(ptr) = SubscriptionSpecDeadLetterPolicy{}
		}
	default:
		iter.ReportError("decode SubscriptionSpecDeadLetterPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SubscriptionSpecExpirationPolicyCodec struct {
}

func (SubscriptionSpecExpirationPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SubscriptionSpecExpirationPolicy)(ptr) == nil
}

func (SubscriptionSpecExpirationPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SubscriptionSpecExpirationPolicy)(ptr)
	var objs []SubscriptionSpecExpirationPolicy
	if obj != nil {
		objs = []SubscriptionSpecExpirationPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionSpecExpirationPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SubscriptionSpecExpirationPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SubscriptionSpecExpirationPolicy)(ptr) = SubscriptionSpecExpirationPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SubscriptionSpecExpirationPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionSpecExpirationPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SubscriptionSpecExpirationPolicy)(ptr) = objs[0]
			} else {
				*(*SubscriptionSpecExpirationPolicy)(ptr) = SubscriptionSpecExpirationPolicy{}
			}
		} else {
			*(*SubscriptionSpecExpirationPolicy)(ptr) = SubscriptionSpecExpirationPolicy{}
		}
	default:
		iter.ReportError("decode SubscriptionSpecExpirationPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SubscriptionSpecPushConfigCodec struct {
}

func (SubscriptionSpecPushConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SubscriptionSpecPushConfig)(ptr) == nil
}

func (SubscriptionSpecPushConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SubscriptionSpecPushConfig)(ptr)
	var objs []SubscriptionSpecPushConfig
	if obj != nil {
		objs = []SubscriptionSpecPushConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionSpecPushConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SubscriptionSpecPushConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SubscriptionSpecPushConfig)(ptr) = SubscriptionSpecPushConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SubscriptionSpecPushConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionSpecPushConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SubscriptionSpecPushConfig)(ptr) = objs[0]
			} else {
				*(*SubscriptionSpecPushConfig)(ptr) = SubscriptionSpecPushConfig{}
			}
		} else {
			*(*SubscriptionSpecPushConfig)(ptr) = SubscriptionSpecPushConfig{}
		}
	default:
		iter.ReportError("decode SubscriptionSpecPushConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SubscriptionSpecPushConfigOidcTokenCodec struct {
}

func (SubscriptionSpecPushConfigOidcTokenCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SubscriptionSpecPushConfigOidcToken)(ptr) == nil
}

func (SubscriptionSpecPushConfigOidcTokenCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SubscriptionSpecPushConfigOidcToken)(ptr)
	var objs []SubscriptionSpecPushConfigOidcToken
	if obj != nil {
		objs = []SubscriptionSpecPushConfigOidcToken{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionSpecPushConfigOidcToken{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SubscriptionSpecPushConfigOidcTokenCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SubscriptionSpecPushConfigOidcToken)(ptr) = SubscriptionSpecPushConfigOidcToken{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SubscriptionSpecPushConfigOidcToken

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionSpecPushConfigOidcToken{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SubscriptionSpecPushConfigOidcToken)(ptr) = objs[0]
			} else {
				*(*SubscriptionSpecPushConfigOidcToken)(ptr) = SubscriptionSpecPushConfigOidcToken{}
			}
		} else {
			*(*SubscriptionSpecPushConfigOidcToken)(ptr) = SubscriptionSpecPushConfigOidcToken{}
		}
	default:
		iter.ReportError("decode SubscriptionSpecPushConfigOidcToken", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SubscriptionSpecRetryPolicyCodec struct {
}

func (SubscriptionSpecRetryPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SubscriptionSpecRetryPolicy)(ptr) == nil
}

func (SubscriptionSpecRetryPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SubscriptionSpecRetryPolicy)(ptr)
	var objs []SubscriptionSpecRetryPolicy
	if obj != nil {
		objs = []SubscriptionSpecRetryPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionSpecRetryPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SubscriptionSpecRetryPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SubscriptionSpecRetryPolicy)(ptr) = SubscriptionSpecRetryPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SubscriptionSpecRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionSpecRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SubscriptionSpecRetryPolicy)(ptr) = objs[0]
			} else {
				*(*SubscriptionSpecRetryPolicy)(ptr) = SubscriptionSpecRetryPolicy{}
			}
		} else {
			*(*SubscriptionSpecRetryPolicy)(ptr) = SubscriptionSpecRetryPolicy{}
		}
	default:
		iter.ReportError("decode SubscriptionSpecRetryPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SubscriptionIamBindingSpecConditionCodec struct {
}

func (SubscriptionIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SubscriptionIamBindingSpecCondition)(ptr) == nil
}

func (SubscriptionIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SubscriptionIamBindingSpecCondition)(ptr)
	var objs []SubscriptionIamBindingSpecCondition
	if obj != nil {
		objs = []SubscriptionIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SubscriptionIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SubscriptionIamBindingSpecCondition)(ptr) = SubscriptionIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SubscriptionIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SubscriptionIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*SubscriptionIamBindingSpecCondition)(ptr) = SubscriptionIamBindingSpecCondition{}
			}
		} else {
			*(*SubscriptionIamBindingSpecCondition)(ptr) = SubscriptionIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode SubscriptionIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SubscriptionIamMemberSpecConditionCodec struct {
}

func (SubscriptionIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SubscriptionIamMemberSpecCondition)(ptr) == nil
}

func (SubscriptionIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SubscriptionIamMemberSpecCondition)(ptr)
	var objs []SubscriptionIamMemberSpecCondition
	if obj != nil {
		objs = []SubscriptionIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SubscriptionIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SubscriptionIamMemberSpecCondition)(ptr) = SubscriptionIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SubscriptionIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SubscriptionIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SubscriptionIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*SubscriptionIamMemberSpecCondition)(ptr) = SubscriptionIamMemberSpecCondition{}
			}
		} else {
			*(*SubscriptionIamMemberSpecCondition)(ptr) = SubscriptionIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode SubscriptionIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicSpecMessageStoragePolicyCodec struct {
}

func (TopicSpecMessageStoragePolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicSpecMessageStoragePolicy)(ptr) == nil
}

func (TopicSpecMessageStoragePolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicSpecMessageStoragePolicy)(ptr)
	var objs []TopicSpecMessageStoragePolicy
	if obj != nil {
		objs = []TopicSpecMessageStoragePolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecMessageStoragePolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicSpecMessageStoragePolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicSpecMessageStoragePolicy)(ptr) = TopicSpecMessageStoragePolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicSpecMessageStoragePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecMessageStoragePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicSpecMessageStoragePolicy)(ptr) = objs[0]
			} else {
				*(*TopicSpecMessageStoragePolicy)(ptr) = TopicSpecMessageStoragePolicy{}
			}
		} else {
			*(*TopicSpecMessageStoragePolicy)(ptr) = TopicSpecMessageStoragePolicy{}
		}
	default:
		iter.ReportError("decode TopicSpecMessageStoragePolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicIamBindingSpecConditionCodec struct {
}

func (TopicIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicIamBindingSpecCondition)(ptr) == nil
}

func (TopicIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicIamBindingSpecCondition)(ptr)
	var objs []TopicIamBindingSpecCondition
	if obj != nil {
		objs = []TopicIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicIamBindingSpecCondition)(ptr) = TopicIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*TopicIamBindingSpecCondition)(ptr) = TopicIamBindingSpecCondition{}
			}
		} else {
			*(*TopicIamBindingSpecCondition)(ptr) = TopicIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode TopicIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicIamMemberSpecConditionCodec struct {
}

func (TopicIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicIamMemberSpecCondition)(ptr) == nil
}

func (TopicIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicIamMemberSpecCondition)(ptr)
	var objs []TopicIamMemberSpecCondition
	if obj != nil {
		objs = []TopicIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicIamMemberSpecCondition)(ptr) = TopicIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*TopicIamMemberSpecCondition)(ptr) = TopicIamMemberSpecCondition{}
			}
		} else {
			*(*TopicIamMemberSpecCondition)(ptr) = TopicIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode TopicIamMemberSpecCondition", "unexpected JSON type")
	}
}
