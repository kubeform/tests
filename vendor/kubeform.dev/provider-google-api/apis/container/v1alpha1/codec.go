/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AnalysisNoteSpecAttestationAuthority{}).Type1()):                    AnalysisNoteSpecAttestationAuthorityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalysisNoteSpecAttestationAuthorityHint{}).Type1()):                AnalysisNoteSpecAttestationAuthorityHintCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalysisOccurrenceSpecAttestation{}).Type1()):                       AnalysisOccurrenceSpecAttestationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfig{}).Type1()):                                 ClusterSpecAddonsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigCloudrunConfig{}).Type1()):                   ClusterSpecAddonsConfigCloudrunConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigHorizontalPodAutoscaling{}).Type1()):         ClusterSpecAddonsConfigHorizontalPodAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigHttpLoadBalancing{}).Type1()):                ClusterSpecAddonsConfigHttpLoadBalancingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigNetworkPolicyConfig{}).Type1()):              ClusterSpecAddonsConfigNetworkPolicyConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAuthenticatorGroupsConfig{}).Type1()):                    ClusterSpecAuthenticatorGroupsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterAutoscaling{}).Type1()):                           ClusterSpecClusterAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterAutoscalingAutoProvisioningDefaults{}).Type1()):   ClusterSpecClusterAutoscalingAutoProvisioningDefaultsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecDatabaseEncryption{}).Type1()):                           ClusterSpecDatabaseEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecDefaultSnatStatus{}).Type1()):                            ClusterSpecDefaultSnatStatusCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecIpAllocationPolicy{}).Type1()):                           ClusterSpecIpAllocationPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicy{}).Type1()):                            ClusterSpecMaintenancePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicyDailyMaintenanceWindow{}).Type1()):      ClusterSpecMaintenancePolicyDailyMaintenanceWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicyRecurringWindow{}).Type1()):             ClusterSpecMaintenancePolicyRecurringWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuth{}).Type1()):                                   ClusterSpecMasterAuthCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuthClientCertificateConfig{}).Type1()):            ClusterSpecMasterAuthClientCertificateConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuthorizedNetworksConfig{}).Type1()):               ClusterSpecMasterAuthorizedNetworksConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNetworkPolicy{}).Type1()):                                ClusterSpecNetworkPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfig{}).Type1()):                                   ClusterSpecNodeConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfigShieldedInstanceConfig{}).Type1()):             ClusterSpecNodeConfigShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfigWorkloadMetadataConfig{}).Type1()):             ClusterSpecNodeConfigWorkloadMetadataConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolAutoscaling{}).Type1()):                          ClusterSpecNodePoolAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolManagement{}).Type1()):                           ClusterSpecNodePoolManagementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfig{}).Type1()):                           ClusterSpecNodePoolNodeConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfigShieldedInstanceConfig{}).Type1()):     ClusterSpecNodePoolNodeConfigShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig{}).Type1()):     ClusterSpecNodePoolNodeConfigWorkloadMetadataConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolUpgradeSettings{}).Type1()):                      ClusterSpecNodePoolUpgradeSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecPodSecurityPolicyConfig{}).Type1()):                      ClusterSpecPodSecurityPolicyConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecPrivateClusterConfig{}).Type1()):                         ClusterSpecPrivateClusterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig{}).Type1()): ClusterSpecPrivateClusterConfigMasterGlobalAccessConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReleaseChannel{}).Type1()):                               ClusterSpecReleaseChannelCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecResourceUsageExportConfig{}).Type1()):                    ClusterSpecResourceUsageExportConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecResourceUsageExportConfigBigqueryDestination{}).Type1()): ClusterSpecResourceUsageExportConfigBigqueryDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecVerticalPodAutoscaling{}).Type1()):                       ClusterSpecVerticalPodAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecWorkloadIdentityConfig{}).Type1()):                       ClusterSpecWorkloadIdentityConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecAutoscaling{}).Type1()):                                 NodePoolSpecAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecManagement{}).Type1()):                                  NodePoolSpecManagementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfig{}).Type1()):                                  NodePoolSpecNodeConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigShieldedInstanceConfig{}).Type1()):            NodePoolSpecNodeConfigShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigWorkloadMetadataConfig{}).Type1()):            NodePoolSpecNodeConfigWorkloadMetadataConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecUpgradeSettings{}).Type1()):                             NodePoolSpecUpgradeSettingsCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AnalysisNoteSpecAttestationAuthority{}).Type1()):                    AnalysisNoteSpecAttestationAuthorityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalysisNoteSpecAttestationAuthorityHint{}).Type1()):                AnalysisNoteSpecAttestationAuthorityHintCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalysisOccurrenceSpecAttestation{}).Type1()):                       AnalysisOccurrenceSpecAttestationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfig{}).Type1()):                                 ClusterSpecAddonsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigCloudrunConfig{}).Type1()):                   ClusterSpecAddonsConfigCloudrunConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigHorizontalPodAutoscaling{}).Type1()):         ClusterSpecAddonsConfigHorizontalPodAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigHttpLoadBalancing{}).Type1()):                ClusterSpecAddonsConfigHttpLoadBalancingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigNetworkPolicyConfig{}).Type1()):              ClusterSpecAddonsConfigNetworkPolicyConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAuthenticatorGroupsConfig{}).Type1()):                    ClusterSpecAuthenticatorGroupsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterAutoscaling{}).Type1()):                           ClusterSpecClusterAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterAutoscalingAutoProvisioningDefaults{}).Type1()):   ClusterSpecClusterAutoscalingAutoProvisioningDefaultsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecDatabaseEncryption{}).Type1()):                           ClusterSpecDatabaseEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecDefaultSnatStatus{}).Type1()):                            ClusterSpecDefaultSnatStatusCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecIpAllocationPolicy{}).Type1()):                           ClusterSpecIpAllocationPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicy{}).Type1()):                            ClusterSpecMaintenancePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicyDailyMaintenanceWindow{}).Type1()):      ClusterSpecMaintenancePolicyDailyMaintenanceWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicyRecurringWindow{}).Type1()):             ClusterSpecMaintenancePolicyRecurringWindowCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuth{}).Type1()):                                   ClusterSpecMasterAuthCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuthClientCertificateConfig{}).Type1()):            ClusterSpecMasterAuthClientCertificateConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuthorizedNetworksConfig{}).Type1()):               ClusterSpecMasterAuthorizedNetworksConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNetworkPolicy{}).Type1()):                                ClusterSpecNetworkPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfig{}).Type1()):                                   ClusterSpecNodeConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfigShieldedInstanceConfig{}).Type1()):             ClusterSpecNodeConfigShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfigWorkloadMetadataConfig{}).Type1()):             ClusterSpecNodeConfigWorkloadMetadataConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolAutoscaling{}).Type1()):                          ClusterSpecNodePoolAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolManagement{}).Type1()):                           ClusterSpecNodePoolManagementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfig{}).Type1()):                           ClusterSpecNodePoolNodeConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfigShieldedInstanceConfig{}).Type1()):     ClusterSpecNodePoolNodeConfigShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig{}).Type1()):     ClusterSpecNodePoolNodeConfigWorkloadMetadataConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolUpgradeSettings{}).Type1()):                      ClusterSpecNodePoolUpgradeSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecPodSecurityPolicyConfig{}).Type1()):                      ClusterSpecPodSecurityPolicyConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecPrivateClusterConfig{}).Type1()):                         ClusterSpecPrivateClusterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig{}).Type1()): ClusterSpecPrivateClusterConfigMasterGlobalAccessConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReleaseChannel{}).Type1()):                               ClusterSpecReleaseChannelCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecResourceUsageExportConfig{}).Type1()):                    ClusterSpecResourceUsageExportConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecResourceUsageExportConfigBigqueryDestination{}).Type1()): ClusterSpecResourceUsageExportConfigBigqueryDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecVerticalPodAutoscaling{}).Type1()):                       ClusterSpecVerticalPodAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecWorkloadIdentityConfig{}).Type1()):                       ClusterSpecWorkloadIdentityConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecAutoscaling{}).Type1()):                                 NodePoolSpecAutoscalingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecManagement{}).Type1()):                                  NodePoolSpecManagementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfig{}).Type1()):                                  NodePoolSpecNodeConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigShieldedInstanceConfig{}).Type1()):            NodePoolSpecNodeConfigShieldedInstanceConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigWorkloadMetadataConfig{}).Type1()):            NodePoolSpecNodeConfigWorkloadMetadataConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecUpgradeSettings{}).Type1()):                             NodePoolSpecUpgradeSettingsCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AnalysisNoteSpecAttestationAuthorityCodec struct {
}

func (AnalysisNoteSpecAttestationAuthorityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalysisNoteSpecAttestationAuthority)(ptr) == nil
}

func (AnalysisNoteSpecAttestationAuthorityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalysisNoteSpecAttestationAuthority)(ptr)
	var objs []AnalysisNoteSpecAttestationAuthority
	if obj != nil {
		objs = []AnalysisNoteSpecAttestationAuthority{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalysisNoteSpecAttestationAuthority{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalysisNoteSpecAttestationAuthorityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalysisNoteSpecAttestationAuthority)(ptr) = AnalysisNoteSpecAttestationAuthority{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalysisNoteSpecAttestationAuthority

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalysisNoteSpecAttestationAuthority{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalysisNoteSpecAttestationAuthority)(ptr) = objs[0]
			} else {
				*(*AnalysisNoteSpecAttestationAuthority)(ptr) = AnalysisNoteSpecAttestationAuthority{}
			}
		} else {
			*(*AnalysisNoteSpecAttestationAuthority)(ptr) = AnalysisNoteSpecAttestationAuthority{}
		}
	default:
		iter.ReportError("decode AnalysisNoteSpecAttestationAuthority", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalysisNoteSpecAttestationAuthorityHintCodec struct {
}

func (AnalysisNoteSpecAttestationAuthorityHintCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalysisNoteSpecAttestationAuthorityHint)(ptr) == nil
}

func (AnalysisNoteSpecAttestationAuthorityHintCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalysisNoteSpecAttestationAuthorityHint)(ptr)
	var objs []AnalysisNoteSpecAttestationAuthorityHint
	if obj != nil {
		objs = []AnalysisNoteSpecAttestationAuthorityHint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalysisNoteSpecAttestationAuthorityHint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalysisNoteSpecAttestationAuthorityHintCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalysisNoteSpecAttestationAuthorityHint)(ptr) = AnalysisNoteSpecAttestationAuthorityHint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalysisNoteSpecAttestationAuthorityHint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalysisNoteSpecAttestationAuthorityHint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalysisNoteSpecAttestationAuthorityHint)(ptr) = objs[0]
			} else {
				*(*AnalysisNoteSpecAttestationAuthorityHint)(ptr) = AnalysisNoteSpecAttestationAuthorityHint{}
			}
		} else {
			*(*AnalysisNoteSpecAttestationAuthorityHint)(ptr) = AnalysisNoteSpecAttestationAuthorityHint{}
		}
	default:
		iter.ReportError("decode AnalysisNoteSpecAttestationAuthorityHint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalysisOccurrenceSpecAttestationCodec struct {
}

func (AnalysisOccurrenceSpecAttestationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalysisOccurrenceSpecAttestation)(ptr) == nil
}

func (AnalysisOccurrenceSpecAttestationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalysisOccurrenceSpecAttestation)(ptr)
	var objs []AnalysisOccurrenceSpecAttestation
	if obj != nil {
		objs = []AnalysisOccurrenceSpecAttestation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalysisOccurrenceSpecAttestation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalysisOccurrenceSpecAttestationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalysisOccurrenceSpecAttestation)(ptr) = AnalysisOccurrenceSpecAttestation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalysisOccurrenceSpecAttestation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalysisOccurrenceSpecAttestation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalysisOccurrenceSpecAttestation)(ptr) = objs[0]
			} else {
				*(*AnalysisOccurrenceSpecAttestation)(ptr) = AnalysisOccurrenceSpecAttestation{}
			}
		} else {
			*(*AnalysisOccurrenceSpecAttestation)(ptr) = AnalysisOccurrenceSpecAttestation{}
		}
	default:
		iter.ReportError("decode AnalysisOccurrenceSpecAttestation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecAddonsConfigCodec struct {
}

func (ClusterSpecAddonsConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecAddonsConfig)(ptr) == nil
}

func (ClusterSpecAddonsConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecAddonsConfig)(ptr)
	var objs []ClusterSpecAddonsConfig
	if obj != nil {
		objs = []ClusterSpecAddonsConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecAddonsConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecAddonsConfig)(ptr) = ClusterSpecAddonsConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecAddonsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecAddonsConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecAddonsConfig)(ptr) = ClusterSpecAddonsConfig{}
			}
		} else {
			*(*ClusterSpecAddonsConfig)(ptr) = ClusterSpecAddonsConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecAddonsConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecAddonsConfigCloudrunConfigCodec struct {
}

func (ClusterSpecAddonsConfigCloudrunConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecAddonsConfigCloudrunConfig)(ptr) == nil
}

func (ClusterSpecAddonsConfigCloudrunConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecAddonsConfigCloudrunConfig)(ptr)
	var objs []ClusterSpecAddonsConfigCloudrunConfig
	if obj != nil {
		objs = []ClusterSpecAddonsConfigCloudrunConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigCloudrunConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecAddonsConfigCloudrunConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecAddonsConfigCloudrunConfig)(ptr) = ClusterSpecAddonsConfigCloudrunConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecAddonsConfigCloudrunConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigCloudrunConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecAddonsConfigCloudrunConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecAddonsConfigCloudrunConfig)(ptr) = ClusterSpecAddonsConfigCloudrunConfig{}
			}
		} else {
			*(*ClusterSpecAddonsConfigCloudrunConfig)(ptr) = ClusterSpecAddonsConfigCloudrunConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecAddonsConfigCloudrunConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecAddonsConfigHorizontalPodAutoscalingCodec struct {
}

func (ClusterSpecAddonsConfigHorizontalPodAutoscalingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecAddonsConfigHorizontalPodAutoscaling)(ptr) == nil
}

func (ClusterSpecAddonsConfigHorizontalPodAutoscalingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecAddonsConfigHorizontalPodAutoscaling)(ptr)
	var objs []ClusterSpecAddonsConfigHorizontalPodAutoscaling
	if obj != nil {
		objs = []ClusterSpecAddonsConfigHorizontalPodAutoscaling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigHorizontalPodAutoscaling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecAddonsConfigHorizontalPodAutoscalingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecAddonsConfigHorizontalPodAutoscaling)(ptr) = ClusterSpecAddonsConfigHorizontalPodAutoscaling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecAddonsConfigHorizontalPodAutoscaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigHorizontalPodAutoscaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecAddonsConfigHorizontalPodAutoscaling)(ptr) = objs[0]
			} else {
				*(*ClusterSpecAddonsConfigHorizontalPodAutoscaling)(ptr) = ClusterSpecAddonsConfigHorizontalPodAutoscaling{}
			}
		} else {
			*(*ClusterSpecAddonsConfigHorizontalPodAutoscaling)(ptr) = ClusterSpecAddonsConfigHorizontalPodAutoscaling{}
		}
	default:
		iter.ReportError("decode ClusterSpecAddonsConfigHorizontalPodAutoscaling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecAddonsConfigHttpLoadBalancingCodec struct {
}

func (ClusterSpecAddonsConfigHttpLoadBalancingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecAddonsConfigHttpLoadBalancing)(ptr) == nil
}

func (ClusterSpecAddonsConfigHttpLoadBalancingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecAddonsConfigHttpLoadBalancing)(ptr)
	var objs []ClusterSpecAddonsConfigHttpLoadBalancing
	if obj != nil {
		objs = []ClusterSpecAddonsConfigHttpLoadBalancing{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigHttpLoadBalancing{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecAddonsConfigHttpLoadBalancingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecAddonsConfigHttpLoadBalancing)(ptr) = ClusterSpecAddonsConfigHttpLoadBalancing{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecAddonsConfigHttpLoadBalancing

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigHttpLoadBalancing{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecAddonsConfigHttpLoadBalancing)(ptr) = objs[0]
			} else {
				*(*ClusterSpecAddonsConfigHttpLoadBalancing)(ptr) = ClusterSpecAddonsConfigHttpLoadBalancing{}
			}
		} else {
			*(*ClusterSpecAddonsConfigHttpLoadBalancing)(ptr) = ClusterSpecAddonsConfigHttpLoadBalancing{}
		}
	default:
		iter.ReportError("decode ClusterSpecAddonsConfigHttpLoadBalancing", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecAddonsConfigNetworkPolicyConfigCodec struct {
}

func (ClusterSpecAddonsConfigNetworkPolicyConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecAddonsConfigNetworkPolicyConfig)(ptr) == nil
}

func (ClusterSpecAddonsConfigNetworkPolicyConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecAddonsConfigNetworkPolicyConfig)(ptr)
	var objs []ClusterSpecAddonsConfigNetworkPolicyConfig
	if obj != nil {
		objs = []ClusterSpecAddonsConfigNetworkPolicyConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigNetworkPolicyConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecAddonsConfigNetworkPolicyConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecAddonsConfigNetworkPolicyConfig)(ptr) = ClusterSpecAddonsConfigNetworkPolicyConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecAddonsConfigNetworkPolicyConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAddonsConfigNetworkPolicyConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecAddonsConfigNetworkPolicyConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecAddonsConfigNetworkPolicyConfig)(ptr) = ClusterSpecAddonsConfigNetworkPolicyConfig{}
			}
		} else {
			*(*ClusterSpecAddonsConfigNetworkPolicyConfig)(ptr) = ClusterSpecAddonsConfigNetworkPolicyConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecAddonsConfigNetworkPolicyConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecAuthenticatorGroupsConfigCodec struct {
}

func (ClusterSpecAuthenticatorGroupsConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecAuthenticatorGroupsConfig)(ptr) == nil
}

func (ClusterSpecAuthenticatorGroupsConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecAuthenticatorGroupsConfig)(ptr)
	var objs []ClusterSpecAuthenticatorGroupsConfig
	if obj != nil {
		objs = []ClusterSpecAuthenticatorGroupsConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAuthenticatorGroupsConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecAuthenticatorGroupsConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecAuthenticatorGroupsConfig)(ptr) = ClusterSpecAuthenticatorGroupsConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecAuthenticatorGroupsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecAuthenticatorGroupsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecAuthenticatorGroupsConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecAuthenticatorGroupsConfig)(ptr) = ClusterSpecAuthenticatorGroupsConfig{}
			}
		} else {
			*(*ClusterSpecAuthenticatorGroupsConfig)(ptr) = ClusterSpecAuthenticatorGroupsConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecAuthenticatorGroupsConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterAutoscalingCodec struct {
}

func (ClusterSpecClusterAutoscalingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterAutoscaling)(ptr) == nil
}

func (ClusterSpecClusterAutoscalingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterAutoscaling)(ptr)
	var objs []ClusterSpecClusterAutoscaling
	if obj != nil {
		objs = []ClusterSpecClusterAutoscaling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterAutoscaling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterAutoscalingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterAutoscaling)(ptr) = ClusterSpecClusterAutoscaling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterAutoscaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterAutoscaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterAutoscaling)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterAutoscaling)(ptr) = ClusterSpecClusterAutoscaling{}
			}
		} else {
			*(*ClusterSpecClusterAutoscaling)(ptr) = ClusterSpecClusterAutoscaling{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterAutoscaling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClusterAutoscalingAutoProvisioningDefaultsCodec struct {
}

func (ClusterSpecClusterAutoscalingAutoProvisioningDefaultsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClusterAutoscalingAutoProvisioningDefaults)(ptr) == nil
}

func (ClusterSpecClusterAutoscalingAutoProvisioningDefaultsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClusterAutoscalingAutoProvisioningDefaults)(ptr)
	var objs []ClusterSpecClusterAutoscalingAutoProvisioningDefaults
	if obj != nil {
		objs = []ClusterSpecClusterAutoscalingAutoProvisioningDefaults{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterAutoscalingAutoProvisioningDefaults{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClusterAutoscalingAutoProvisioningDefaultsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClusterAutoscalingAutoProvisioningDefaults)(ptr) = ClusterSpecClusterAutoscalingAutoProvisioningDefaults{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClusterAutoscalingAutoProvisioningDefaults

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClusterAutoscalingAutoProvisioningDefaults{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClusterAutoscalingAutoProvisioningDefaults)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClusterAutoscalingAutoProvisioningDefaults)(ptr) = ClusterSpecClusterAutoscalingAutoProvisioningDefaults{}
			}
		} else {
			*(*ClusterSpecClusterAutoscalingAutoProvisioningDefaults)(ptr) = ClusterSpecClusterAutoscalingAutoProvisioningDefaults{}
		}
	default:
		iter.ReportError("decode ClusterSpecClusterAutoscalingAutoProvisioningDefaults", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecDatabaseEncryptionCodec struct {
}

func (ClusterSpecDatabaseEncryptionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecDatabaseEncryption)(ptr) == nil
}

func (ClusterSpecDatabaseEncryptionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecDatabaseEncryption)(ptr)
	var objs []ClusterSpecDatabaseEncryption
	if obj != nil {
		objs = []ClusterSpecDatabaseEncryption{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecDatabaseEncryption{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecDatabaseEncryptionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecDatabaseEncryption)(ptr) = ClusterSpecDatabaseEncryption{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecDatabaseEncryption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecDatabaseEncryption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecDatabaseEncryption)(ptr) = objs[0]
			} else {
				*(*ClusterSpecDatabaseEncryption)(ptr) = ClusterSpecDatabaseEncryption{}
			}
		} else {
			*(*ClusterSpecDatabaseEncryption)(ptr) = ClusterSpecDatabaseEncryption{}
		}
	default:
		iter.ReportError("decode ClusterSpecDatabaseEncryption", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecDefaultSnatStatusCodec struct {
}

func (ClusterSpecDefaultSnatStatusCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecDefaultSnatStatus)(ptr) == nil
}

func (ClusterSpecDefaultSnatStatusCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecDefaultSnatStatus)(ptr)
	var objs []ClusterSpecDefaultSnatStatus
	if obj != nil {
		objs = []ClusterSpecDefaultSnatStatus{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecDefaultSnatStatus{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecDefaultSnatStatusCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecDefaultSnatStatus)(ptr) = ClusterSpecDefaultSnatStatus{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecDefaultSnatStatus

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecDefaultSnatStatus{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecDefaultSnatStatus)(ptr) = objs[0]
			} else {
				*(*ClusterSpecDefaultSnatStatus)(ptr) = ClusterSpecDefaultSnatStatus{}
			}
		} else {
			*(*ClusterSpecDefaultSnatStatus)(ptr) = ClusterSpecDefaultSnatStatus{}
		}
	default:
		iter.ReportError("decode ClusterSpecDefaultSnatStatus", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecIpAllocationPolicyCodec struct {
}

func (ClusterSpecIpAllocationPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecIpAllocationPolicy)(ptr) == nil
}

func (ClusterSpecIpAllocationPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecIpAllocationPolicy)(ptr)
	var objs []ClusterSpecIpAllocationPolicy
	if obj != nil {
		objs = []ClusterSpecIpAllocationPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecIpAllocationPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecIpAllocationPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecIpAllocationPolicy)(ptr) = ClusterSpecIpAllocationPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecIpAllocationPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecIpAllocationPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecIpAllocationPolicy)(ptr) = objs[0]
			} else {
				*(*ClusterSpecIpAllocationPolicy)(ptr) = ClusterSpecIpAllocationPolicy{}
			}
		} else {
			*(*ClusterSpecIpAllocationPolicy)(ptr) = ClusterSpecIpAllocationPolicy{}
		}
	default:
		iter.ReportError("decode ClusterSpecIpAllocationPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecMaintenancePolicyCodec struct {
}

func (ClusterSpecMaintenancePolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecMaintenancePolicy)(ptr) == nil
}

func (ClusterSpecMaintenancePolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecMaintenancePolicy)(ptr)
	var objs []ClusterSpecMaintenancePolicy
	if obj != nil {
		objs = []ClusterSpecMaintenancePolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecMaintenancePolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecMaintenancePolicy)(ptr) = ClusterSpecMaintenancePolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecMaintenancePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecMaintenancePolicy)(ptr) = objs[0]
			} else {
				*(*ClusterSpecMaintenancePolicy)(ptr) = ClusterSpecMaintenancePolicy{}
			}
		} else {
			*(*ClusterSpecMaintenancePolicy)(ptr) = ClusterSpecMaintenancePolicy{}
		}
	default:
		iter.ReportError("decode ClusterSpecMaintenancePolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecMaintenancePolicyDailyMaintenanceWindowCodec struct {
}

func (ClusterSpecMaintenancePolicyDailyMaintenanceWindowCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecMaintenancePolicyDailyMaintenanceWindow)(ptr) == nil
}

func (ClusterSpecMaintenancePolicyDailyMaintenanceWindowCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecMaintenancePolicyDailyMaintenanceWindow)(ptr)
	var objs []ClusterSpecMaintenancePolicyDailyMaintenanceWindow
	if obj != nil {
		objs = []ClusterSpecMaintenancePolicyDailyMaintenanceWindow{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicyDailyMaintenanceWindow{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecMaintenancePolicyDailyMaintenanceWindowCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecMaintenancePolicyDailyMaintenanceWindow)(ptr) = ClusterSpecMaintenancePolicyDailyMaintenanceWindow{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecMaintenancePolicyDailyMaintenanceWindow

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicyDailyMaintenanceWindow{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecMaintenancePolicyDailyMaintenanceWindow)(ptr) = objs[0]
			} else {
				*(*ClusterSpecMaintenancePolicyDailyMaintenanceWindow)(ptr) = ClusterSpecMaintenancePolicyDailyMaintenanceWindow{}
			}
		} else {
			*(*ClusterSpecMaintenancePolicyDailyMaintenanceWindow)(ptr) = ClusterSpecMaintenancePolicyDailyMaintenanceWindow{}
		}
	default:
		iter.ReportError("decode ClusterSpecMaintenancePolicyDailyMaintenanceWindow", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecMaintenancePolicyRecurringWindowCodec struct {
}

func (ClusterSpecMaintenancePolicyRecurringWindowCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecMaintenancePolicyRecurringWindow)(ptr) == nil
}

func (ClusterSpecMaintenancePolicyRecurringWindowCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecMaintenancePolicyRecurringWindow)(ptr)
	var objs []ClusterSpecMaintenancePolicyRecurringWindow
	if obj != nil {
		objs = []ClusterSpecMaintenancePolicyRecurringWindow{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicyRecurringWindow{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecMaintenancePolicyRecurringWindowCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecMaintenancePolicyRecurringWindow)(ptr) = ClusterSpecMaintenancePolicyRecurringWindow{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecMaintenancePolicyRecurringWindow

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMaintenancePolicyRecurringWindow{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecMaintenancePolicyRecurringWindow)(ptr) = objs[0]
			} else {
				*(*ClusterSpecMaintenancePolicyRecurringWindow)(ptr) = ClusterSpecMaintenancePolicyRecurringWindow{}
			}
		} else {
			*(*ClusterSpecMaintenancePolicyRecurringWindow)(ptr) = ClusterSpecMaintenancePolicyRecurringWindow{}
		}
	default:
		iter.ReportError("decode ClusterSpecMaintenancePolicyRecurringWindow", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecMasterAuthCodec struct {
}

func (ClusterSpecMasterAuthCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecMasterAuth)(ptr) == nil
}

func (ClusterSpecMasterAuthCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecMasterAuth)(ptr)
	var objs []ClusterSpecMasterAuth
	if obj != nil {
		objs = []ClusterSpecMasterAuth{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuth{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecMasterAuthCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecMasterAuth)(ptr) = ClusterSpecMasterAuth{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecMasterAuth

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuth{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecMasterAuth)(ptr) = objs[0]
			} else {
				*(*ClusterSpecMasterAuth)(ptr) = ClusterSpecMasterAuth{}
			}
		} else {
			*(*ClusterSpecMasterAuth)(ptr) = ClusterSpecMasterAuth{}
		}
	default:
		iter.ReportError("decode ClusterSpecMasterAuth", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecMasterAuthClientCertificateConfigCodec struct {
}

func (ClusterSpecMasterAuthClientCertificateConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecMasterAuthClientCertificateConfig)(ptr) == nil
}

func (ClusterSpecMasterAuthClientCertificateConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecMasterAuthClientCertificateConfig)(ptr)
	var objs []ClusterSpecMasterAuthClientCertificateConfig
	if obj != nil {
		objs = []ClusterSpecMasterAuthClientCertificateConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuthClientCertificateConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecMasterAuthClientCertificateConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecMasterAuthClientCertificateConfig)(ptr) = ClusterSpecMasterAuthClientCertificateConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecMasterAuthClientCertificateConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuthClientCertificateConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecMasterAuthClientCertificateConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecMasterAuthClientCertificateConfig)(ptr) = ClusterSpecMasterAuthClientCertificateConfig{}
			}
		} else {
			*(*ClusterSpecMasterAuthClientCertificateConfig)(ptr) = ClusterSpecMasterAuthClientCertificateConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecMasterAuthClientCertificateConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecMasterAuthorizedNetworksConfigCodec struct {
}

func (ClusterSpecMasterAuthorizedNetworksConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecMasterAuthorizedNetworksConfig)(ptr) == nil
}

func (ClusterSpecMasterAuthorizedNetworksConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecMasterAuthorizedNetworksConfig)(ptr)
	var objs []ClusterSpecMasterAuthorizedNetworksConfig
	if obj != nil {
		objs = []ClusterSpecMasterAuthorizedNetworksConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuthorizedNetworksConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecMasterAuthorizedNetworksConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecMasterAuthorizedNetworksConfig)(ptr) = ClusterSpecMasterAuthorizedNetworksConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecMasterAuthorizedNetworksConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecMasterAuthorizedNetworksConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecMasterAuthorizedNetworksConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecMasterAuthorizedNetworksConfig)(ptr) = ClusterSpecMasterAuthorizedNetworksConfig{}
			}
		} else {
			*(*ClusterSpecMasterAuthorizedNetworksConfig)(ptr) = ClusterSpecMasterAuthorizedNetworksConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecMasterAuthorizedNetworksConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecNetworkPolicyCodec struct {
}

func (ClusterSpecNetworkPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecNetworkPolicy)(ptr) == nil
}

func (ClusterSpecNetworkPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecNetworkPolicy)(ptr)
	var objs []ClusterSpecNetworkPolicy
	if obj != nil {
		objs = []ClusterSpecNetworkPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNetworkPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecNetworkPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecNetworkPolicy)(ptr) = ClusterSpecNetworkPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecNetworkPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNetworkPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecNetworkPolicy)(ptr) = objs[0]
			} else {
				*(*ClusterSpecNetworkPolicy)(ptr) = ClusterSpecNetworkPolicy{}
			}
		} else {
			*(*ClusterSpecNetworkPolicy)(ptr) = ClusterSpecNetworkPolicy{}
		}
	default:
		iter.ReportError("decode ClusterSpecNetworkPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecNodeConfigCodec struct {
}

func (ClusterSpecNodeConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecNodeConfig)(ptr) == nil
}

func (ClusterSpecNodeConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecNodeConfig)(ptr)
	var objs []ClusterSpecNodeConfig
	if obj != nil {
		objs = []ClusterSpecNodeConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecNodeConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecNodeConfig)(ptr) = ClusterSpecNodeConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecNodeConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecNodeConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecNodeConfig)(ptr) = ClusterSpecNodeConfig{}
			}
		} else {
			*(*ClusterSpecNodeConfig)(ptr) = ClusterSpecNodeConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecNodeConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecNodeConfigShieldedInstanceConfigCodec struct {
}

func (ClusterSpecNodeConfigShieldedInstanceConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecNodeConfigShieldedInstanceConfig)(ptr) == nil
}

func (ClusterSpecNodeConfigShieldedInstanceConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecNodeConfigShieldedInstanceConfig)(ptr)
	var objs []ClusterSpecNodeConfigShieldedInstanceConfig
	if obj != nil {
		objs = []ClusterSpecNodeConfigShieldedInstanceConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfigShieldedInstanceConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecNodeConfigShieldedInstanceConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecNodeConfigShieldedInstanceConfig)(ptr) = ClusterSpecNodeConfigShieldedInstanceConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecNodeConfigShieldedInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfigShieldedInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecNodeConfigShieldedInstanceConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecNodeConfigShieldedInstanceConfig)(ptr) = ClusterSpecNodeConfigShieldedInstanceConfig{}
			}
		} else {
			*(*ClusterSpecNodeConfigShieldedInstanceConfig)(ptr) = ClusterSpecNodeConfigShieldedInstanceConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecNodeConfigShieldedInstanceConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecNodeConfigWorkloadMetadataConfigCodec struct {
}

func (ClusterSpecNodeConfigWorkloadMetadataConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecNodeConfigWorkloadMetadataConfig)(ptr) == nil
}

func (ClusterSpecNodeConfigWorkloadMetadataConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecNodeConfigWorkloadMetadataConfig)(ptr)
	var objs []ClusterSpecNodeConfigWorkloadMetadataConfig
	if obj != nil {
		objs = []ClusterSpecNodeConfigWorkloadMetadataConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfigWorkloadMetadataConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecNodeConfigWorkloadMetadataConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecNodeConfigWorkloadMetadataConfig)(ptr) = ClusterSpecNodeConfigWorkloadMetadataConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecNodeConfigWorkloadMetadataConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodeConfigWorkloadMetadataConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecNodeConfigWorkloadMetadataConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecNodeConfigWorkloadMetadataConfig)(ptr) = ClusterSpecNodeConfigWorkloadMetadataConfig{}
			}
		} else {
			*(*ClusterSpecNodeConfigWorkloadMetadataConfig)(ptr) = ClusterSpecNodeConfigWorkloadMetadataConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecNodeConfigWorkloadMetadataConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecNodePoolAutoscalingCodec struct {
}

func (ClusterSpecNodePoolAutoscalingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecNodePoolAutoscaling)(ptr) == nil
}

func (ClusterSpecNodePoolAutoscalingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecNodePoolAutoscaling)(ptr)
	var objs []ClusterSpecNodePoolAutoscaling
	if obj != nil {
		objs = []ClusterSpecNodePoolAutoscaling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolAutoscaling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecNodePoolAutoscalingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecNodePoolAutoscaling)(ptr) = ClusterSpecNodePoolAutoscaling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecNodePoolAutoscaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolAutoscaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecNodePoolAutoscaling)(ptr) = objs[0]
			} else {
				*(*ClusterSpecNodePoolAutoscaling)(ptr) = ClusterSpecNodePoolAutoscaling{}
			}
		} else {
			*(*ClusterSpecNodePoolAutoscaling)(ptr) = ClusterSpecNodePoolAutoscaling{}
		}
	default:
		iter.ReportError("decode ClusterSpecNodePoolAutoscaling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecNodePoolManagementCodec struct {
}

func (ClusterSpecNodePoolManagementCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecNodePoolManagement)(ptr) == nil
}

func (ClusterSpecNodePoolManagementCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecNodePoolManagement)(ptr)
	var objs []ClusterSpecNodePoolManagement
	if obj != nil {
		objs = []ClusterSpecNodePoolManagement{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolManagement{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecNodePoolManagementCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecNodePoolManagement)(ptr) = ClusterSpecNodePoolManagement{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecNodePoolManagement

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolManagement{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecNodePoolManagement)(ptr) = objs[0]
			} else {
				*(*ClusterSpecNodePoolManagement)(ptr) = ClusterSpecNodePoolManagement{}
			}
		} else {
			*(*ClusterSpecNodePoolManagement)(ptr) = ClusterSpecNodePoolManagement{}
		}
	default:
		iter.ReportError("decode ClusterSpecNodePoolManagement", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecNodePoolNodeConfigCodec struct {
}

func (ClusterSpecNodePoolNodeConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecNodePoolNodeConfig)(ptr) == nil
}

func (ClusterSpecNodePoolNodeConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecNodePoolNodeConfig)(ptr)
	var objs []ClusterSpecNodePoolNodeConfig
	if obj != nil {
		objs = []ClusterSpecNodePoolNodeConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecNodePoolNodeConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecNodePoolNodeConfig)(ptr) = ClusterSpecNodePoolNodeConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecNodePoolNodeConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecNodePoolNodeConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecNodePoolNodeConfig)(ptr) = ClusterSpecNodePoolNodeConfig{}
			}
		} else {
			*(*ClusterSpecNodePoolNodeConfig)(ptr) = ClusterSpecNodePoolNodeConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecNodePoolNodeConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecNodePoolNodeConfigShieldedInstanceConfigCodec struct {
}

func (ClusterSpecNodePoolNodeConfigShieldedInstanceConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecNodePoolNodeConfigShieldedInstanceConfig)(ptr) == nil
}

func (ClusterSpecNodePoolNodeConfigShieldedInstanceConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecNodePoolNodeConfigShieldedInstanceConfig)(ptr)
	var objs []ClusterSpecNodePoolNodeConfigShieldedInstanceConfig
	if obj != nil {
		objs = []ClusterSpecNodePoolNodeConfigShieldedInstanceConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfigShieldedInstanceConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecNodePoolNodeConfigShieldedInstanceConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecNodePoolNodeConfigShieldedInstanceConfig)(ptr) = ClusterSpecNodePoolNodeConfigShieldedInstanceConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecNodePoolNodeConfigShieldedInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfigShieldedInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecNodePoolNodeConfigShieldedInstanceConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecNodePoolNodeConfigShieldedInstanceConfig)(ptr) = ClusterSpecNodePoolNodeConfigShieldedInstanceConfig{}
			}
		} else {
			*(*ClusterSpecNodePoolNodeConfigShieldedInstanceConfig)(ptr) = ClusterSpecNodePoolNodeConfigShieldedInstanceConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecNodePoolNodeConfigShieldedInstanceConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecNodePoolNodeConfigWorkloadMetadataConfigCodec struct {
}

func (ClusterSpecNodePoolNodeConfigWorkloadMetadataConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig)(ptr) == nil
}

func (ClusterSpecNodePoolNodeConfigWorkloadMetadataConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig)(ptr)
	var objs []ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig
	if obj != nil {
		objs = []ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecNodePoolNodeConfigWorkloadMetadataConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig)(ptr) = ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig)(ptr) = ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig{}
			}
		} else {
			*(*ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig)(ptr) = ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecNodePoolNodeConfigWorkloadMetadataConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecNodePoolUpgradeSettingsCodec struct {
}

func (ClusterSpecNodePoolUpgradeSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecNodePoolUpgradeSettings)(ptr) == nil
}

func (ClusterSpecNodePoolUpgradeSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecNodePoolUpgradeSettings)(ptr)
	var objs []ClusterSpecNodePoolUpgradeSettings
	if obj != nil {
		objs = []ClusterSpecNodePoolUpgradeSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolUpgradeSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecNodePoolUpgradeSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecNodePoolUpgradeSettings)(ptr) = ClusterSpecNodePoolUpgradeSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecNodePoolUpgradeSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecNodePoolUpgradeSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecNodePoolUpgradeSettings)(ptr) = objs[0]
			} else {
				*(*ClusterSpecNodePoolUpgradeSettings)(ptr) = ClusterSpecNodePoolUpgradeSettings{}
			}
		} else {
			*(*ClusterSpecNodePoolUpgradeSettings)(ptr) = ClusterSpecNodePoolUpgradeSettings{}
		}
	default:
		iter.ReportError("decode ClusterSpecNodePoolUpgradeSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecPodSecurityPolicyConfigCodec struct {
}

func (ClusterSpecPodSecurityPolicyConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecPodSecurityPolicyConfig)(ptr) == nil
}

func (ClusterSpecPodSecurityPolicyConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecPodSecurityPolicyConfig)(ptr)
	var objs []ClusterSpecPodSecurityPolicyConfig
	if obj != nil {
		objs = []ClusterSpecPodSecurityPolicyConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecPodSecurityPolicyConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecPodSecurityPolicyConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecPodSecurityPolicyConfig)(ptr) = ClusterSpecPodSecurityPolicyConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecPodSecurityPolicyConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecPodSecurityPolicyConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecPodSecurityPolicyConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecPodSecurityPolicyConfig)(ptr) = ClusterSpecPodSecurityPolicyConfig{}
			}
		} else {
			*(*ClusterSpecPodSecurityPolicyConfig)(ptr) = ClusterSpecPodSecurityPolicyConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecPodSecurityPolicyConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecPrivateClusterConfigCodec struct {
}

func (ClusterSpecPrivateClusterConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecPrivateClusterConfig)(ptr) == nil
}

func (ClusterSpecPrivateClusterConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecPrivateClusterConfig)(ptr)
	var objs []ClusterSpecPrivateClusterConfig
	if obj != nil {
		objs = []ClusterSpecPrivateClusterConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecPrivateClusterConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecPrivateClusterConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecPrivateClusterConfig)(ptr) = ClusterSpecPrivateClusterConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecPrivateClusterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecPrivateClusterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecPrivateClusterConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecPrivateClusterConfig)(ptr) = ClusterSpecPrivateClusterConfig{}
			}
		} else {
			*(*ClusterSpecPrivateClusterConfig)(ptr) = ClusterSpecPrivateClusterConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecPrivateClusterConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecPrivateClusterConfigMasterGlobalAccessConfigCodec struct {
}

func (ClusterSpecPrivateClusterConfigMasterGlobalAccessConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig)(ptr) == nil
}

func (ClusterSpecPrivateClusterConfigMasterGlobalAccessConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig)(ptr)
	var objs []ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig
	if obj != nil {
		objs = []ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecPrivateClusterConfigMasterGlobalAccessConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig)(ptr) = ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig)(ptr) = ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig{}
			}
		} else {
			*(*ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig)(ptr) = ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecPrivateClusterConfigMasterGlobalAccessConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecReleaseChannelCodec struct {
}

func (ClusterSpecReleaseChannelCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecReleaseChannel)(ptr) == nil
}

func (ClusterSpecReleaseChannelCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecReleaseChannel)(ptr)
	var objs []ClusterSpecReleaseChannel
	if obj != nil {
		objs = []ClusterSpecReleaseChannel{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReleaseChannel{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecReleaseChannelCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecReleaseChannel)(ptr) = ClusterSpecReleaseChannel{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecReleaseChannel

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecReleaseChannel{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecReleaseChannel)(ptr) = objs[0]
			} else {
				*(*ClusterSpecReleaseChannel)(ptr) = ClusterSpecReleaseChannel{}
			}
		} else {
			*(*ClusterSpecReleaseChannel)(ptr) = ClusterSpecReleaseChannel{}
		}
	default:
		iter.ReportError("decode ClusterSpecReleaseChannel", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecResourceUsageExportConfigCodec struct {
}

func (ClusterSpecResourceUsageExportConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecResourceUsageExportConfig)(ptr) == nil
}

func (ClusterSpecResourceUsageExportConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecResourceUsageExportConfig)(ptr)
	var objs []ClusterSpecResourceUsageExportConfig
	if obj != nil {
		objs = []ClusterSpecResourceUsageExportConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecResourceUsageExportConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecResourceUsageExportConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecResourceUsageExportConfig)(ptr) = ClusterSpecResourceUsageExportConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecResourceUsageExportConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecResourceUsageExportConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecResourceUsageExportConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecResourceUsageExportConfig)(ptr) = ClusterSpecResourceUsageExportConfig{}
			}
		} else {
			*(*ClusterSpecResourceUsageExportConfig)(ptr) = ClusterSpecResourceUsageExportConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecResourceUsageExportConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecResourceUsageExportConfigBigqueryDestinationCodec struct {
}

func (ClusterSpecResourceUsageExportConfigBigqueryDestinationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecResourceUsageExportConfigBigqueryDestination)(ptr) == nil
}

func (ClusterSpecResourceUsageExportConfigBigqueryDestinationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecResourceUsageExportConfigBigqueryDestination)(ptr)
	var objs []ClusterSpecResourceUsageExportConfigBigqueryDestination
	if obj != nil {
		objs = []ClusterSpecResourceUsageExportConfigBigqueryDestination{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecResourceUsageExportConfigBigqueryDestination{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecResourceUsageExportConfigBigqueryDestinationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecResourceUsageExportConfigBigqueryDestination)(ptr) = ClusterSpecResourceUsageExportConfigBigqueryDestination{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecResourceUsageExportConfigBigqueryDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecResourceUsageExportConfigBigqueryDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecResourceUsageExportConfigBigqueryDestination)(ptr) = objs[0]
			} else {
				*(*ClusterSpecResourceUsageExportConfigBigqueryDestination)(ptr) = ClusterSpecResourceUsageExportConfigBigqueryDestination{}
			}
		} else {
			*(*ClusterSpecResourceUsageExportConfigBigqueryDestination)(ptr) = ClusterSpecResourceUsageExportConfigBigqueryDestination{}
		}
	default:
		iter.ReportError("decode ClusterSpecResourceUsageExportConfigBigqueryDestination", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecVerticalPodAutoscalingCodec struct {
}

func (ClusterSpecVerticalPodAutoscalingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecVerticalPodAutoscaling)(ptr) == nil
}

func (ClusterSpecVerticalPodAutoscalingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecVerticalPodAutoscaling)(ptr)
	var objs []ClusterSpecVerticalPodAutoscaling
	if obj != nil {
		objs = []ClusterSpecVerticalPodAutoscaling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecVerticalPodAutoscaling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecVerticalPodAutoscalingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecVerticalPodAutoscaling)(ptr) = ClusterSpecVerticalPodAutoscaling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecVerticalPodAutoscaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecVerticalPodAutoscaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecVerticalPodAutoscaling)(ptr) = objs[0]
			} else {
				*(*ClusterSpecVerticalPodAutoscaling)(ptr) = ClusterSpecVerticalPodAutoscaling{}
			}
		} else {
			*(*ClusterSpecVerticalPodAutoscaling)(ptr) = ClusterSpecVerticalPodAutoscaling{}
		}
	default:
		iter.ReportError("decode ClusterSpecVerticalPodAutoscaling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecWorkloadIdentityConfigCodec struct {
}

func (ClusterSpecWorkloadIdentityConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecWorkloadIdentityConfig)(ptr) == nil
}

func (ClusterSpecWorkloadIdentityConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecWorkloadIdentityConfig)(ptr)
	var objs []ClusterSpecWorkloadIdentityConfig
	if obj != nil {
		objs = []ClusterSpecWorkloadIdentityConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecWorkloadIdentityConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecWorkloadIdentityConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecWorkloadIdentityConfig)(ptr) = ClusterSpecWorkloadIdentityConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecWorkloadIdentityConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecWorkloadIdentityConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecWorkloadIdentityConfig)(ptr) = objs[0]
			} else {
				*(*ClusterSpecWorkloadIdentityConfig)(ptr) = ClusterSpecWorkloadIdentityConfig{}
			}
		} else {
			*(*ClusterSpecWorkloadIdentityConfig)(ptr) = ClusterSpecWorkloadIdentityConfig{}
		}
	default:
		iter.ReportError("decode ClusterSpecWorkloadIdentityConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodePoolSpecAutoscalingCodec struct {
}

func (NodePoolSpecAutoscalingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodePoolSpecAutoscaling)(ptr) == nil
}

func (NodePoolSpecAutoscalingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodePoolSpecAutoscaling)(ptr)
	var objs []NodePoolSpecAutoscaling
	if obj != nil {
		objs = []NodePoolSpecAutoscaling{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecAutoscaling{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodePoolSpecAutoscalingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodePoolSpecAutoscaling)(ptr) = NodePoolSpecAutoscaling{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodePoolSpecAutoscaling

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecAutoscaling{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodePoolSpecAutoscaling)(ptr) = objs[0]
			} else {
				*(*NodePoolSpecAutoscaling)(ptr) = NodePoolSpecAutoscaling{}
			}
		} else {
			*(*NodePoolSpecAutoscaling)(ptr) = NodePoolSpecAutoscaling{}
		}
	default:
		iter.ReportError("decode NodePoolSpecAutoscaling", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodePoolSpecManagementCodec struct {
}

func (NodePoolSpecManagementCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodePoolSpecManagement)(ptr) == nil
}

func (NodePoolSpecManagementCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodePoolSpecManagement)(ptr)
	var objs []NodePoolSpecManagement
	if obj != nil {
		objs = []NodePoolSpecManagement{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecManagement{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodePoolSpecManagementCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodePoolSpecManagement)(ptr) = NodePoolSpecManagement{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodePoolSpecManagement

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecManagement{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodePoolSpecManagement)(ptr) = objs[0]
			} else {
				*(*NodePoolSpecManagement)(ptr) = NodePoolSpecManagement{}
			}
		} else {
			*(*NodePoolSpecManagement)(ptr) = NodePoolSpecManagement{}
		}
	default:
		iter.ReportError("decode NodePoolSpecManagement", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodePoolSpecNodeConfigCodec struct {
}

func (NodePoolSpecNodeConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodePoolSpecNodeConfig)(ptr) == nil
}

func (NodePoolSpecNodeConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodePoolSpecNodeConfig)(ptr)
	var objs []NodePoolSpecNodeConfig
	if obj != nil {
		objs = []NodePoolSpecNodeConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodePoolSpecNodeConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodePoolSpecNodeConfig)(ptr) = NodePoolSpecNodeConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodePoolSpecNodeConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodePoolSpecNodeConfig)(ptr) = objs[0]
			} else {
				*(*NodePoolSpecNodeConfig)(ptr) = NodePoolSpecNodeConfig{}
			}
		} else {
			*(*NodePoolSpecNodeConfig)(ptr) = NodePoolSpecNodeConfig{}
		}
	default:
		iter.ReportError("decode NodePoolSpecNodeConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodePoolSpecNodeConfigShieldedInstanceConfigCodec struct {
}

func (NodePoolSpecNodeConfigShieldedInstanceConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodePoolSpecNodeConfigShieldedInstanceConfig)(ptr) == nil
}

func (NodePoolSpecNodeConfigShieldedInstanceConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodePoolSpecNodeConfigShieldedInstanceConfig)(ptr)
	var objs []NodePoolSpecNodeConfigShieldedInstanceConfig
	if obj != nil {
		objs = []NodePoolSpecNodeConfigShieldedInstanceConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigShieldedInstanceConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodePoolSpecNodeConfigShieldedInstanceConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodePoolSpecNodeConfigShieldedInstanceConfig)(ptr) = NodePoolSpecNodeConfigShieldedInstanceConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodePoolSpecNodeConfigShieldedInstanceConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigShieldedInstanceConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodePoolSpecNodeConfigShieldedInstanceConfig)(ptr) = objs[0]
			} else {
				*(*NodePoolSpecNodeConfigShieldedInstanceConfig)(ptr) = NodePoolSpecNodeConfigShieldedInstanceConfig{}
			}
		} else {
			*(*NodePoolSpecNodeConfigShieldedInstanceConfig)(ptr) = NodePoolSpecNodeConfigShieldedInstanceConfig{}
		}
	default:
		iter.ReportError("decode NodePoolSpecNodeConfigShieldedInstanceConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodePoolSpecNodeConfigWorkloadMetadataConfigCodec struct {
}

func (NodePoolSpecNodeConfigWorkloadMetadataConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodePoolSpecNodeConfigWorkloadMetadataConfig)(ptr) == nil
}

func (NodePoolSpecNodeConfigWorkloadMetadataConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodePoolSpecNodeConfigWorkloadMetadataConfig)(ptr)
	var objs []NodePoolSpecNodeConfigWorkloadMetadataConfig
	if obj != nil {
		objs = []NodePoolSpecNodeConfigWorkloadMetadataConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigWorkloadMetadataConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodePoolSpecNodeConfigWorkloadMetadataConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodePoolSpecNodeConfigWorkloadMetadataConfig)(ptr) = NodePoolSpecNodeConfigWorkloadMetadataConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodePoolSpecNodeConfigWorkloadMetadataConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecNodeConfigWorkloadMetadataConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodePoolSpecNodeConfigWorkloadMetadataConfig)(ptr) = objs[0]
			} else {
				*(*NodePoolSpecNodeConfigWorkloadMetadataConfig)(ptr) = NodePoolSpecNodeConfigWorkloadMetadataConfig{}
			}
		} else {
			*(*NodePoolSpecNodeConfigWorkloadMetadataConfig)(ptr) = NodePoolSpecNodeConfigWorkloadMetadataConfig{}
		}
	default:
		iter.ReportError("decode NodePoolSpecNodeConfigWorkloadMetadataConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodePoolSpecUpgradeSettingsCodec struct {
}

func (NodePoolSpecUpgradeSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodePoolSpecUpgradeSettings)(ptr) == nil
}

func (NodePoolSpecUpgradeSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodePoolSpecUpgradeSettings)(ptr)
	var objs []NodePoolSpecUpgradeSettings
	if obj != nil {
		objs = []NodePoolSpecUpgradeSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecUpgradeSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodePoolSpecUpgradeSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodePoolSpecUpgradeSettings)(ptr) = NodePoolSpecUpgradeSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodePoolSpecUpgradeSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecUpgradeSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodePoolSpecUpgradeSettings)(ptr) = objs[0]
			} else {
				*(*NodePoolSpecUpgradeSettings)(ptr) = NodePoolSpecUpgradeSettings{}
			}
		} else {
			*(*NodePoolSpecUpgradeSettings)(ptr) = NodePoolSpecUpgradeSettings{}
		}
	default:
		iter.ReportError("decode NodePoolSpecUpgradeSettings", "unexpected JSON type")
	}
}
