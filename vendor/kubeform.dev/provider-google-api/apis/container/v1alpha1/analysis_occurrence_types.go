/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type AnalysisOccurrence struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              AnalysisOccurrenceSpec   `json:"spec,omitempty"`
	Status            AnalysisOccurrenceStatus `json:"status,omitempty"`
}

type AnalysisOccurrenceSpec struct {
	AnalysisOccurrenceSpec2 `json:",inline"`
	// +optional
	KubeformOutput AnalysisOccurrenceSpec2 `json:"kubeformOutput,omitempty" tf:"-"`
}

type AnalysisOccurrenceSpecAttestationSignatures struct {
	// The identifier for the public key that verifies this
	// signature. MUST be an RFC3986 conformant
	// URI. * When possible, the key id should be an
	// immutable reference, such as a cryptographic digest.
	// Examples of valid values:
	//
	// * OpenPGP V4 public key fingerprint. See https://www.iana.org/assignments/uri-schemes/prov/openpgp4fpr
	//   for more details on this scheme.
	//     * 'openpgp4fpr:74FAF3B861BDA0870C7B6DEF607E48D2A663AEEA'
	// * RFC6920 digest-named SubjectPublicKeyInfo (digest of the DER serialization):
	//     * "ni:///sha-256;cD9o9Cq6LG3jD0iKXqEi_vdjJGecm_iXkbqVoScViaU"
	PublicKeyID *string `json:"publicKeyID" tf:"public_key_id"`
	// The content of the signature, an opaque bytestring.
	// The payload that this signature verifies MUST be
	// unambiguously provided with the Signature during
	// verification. A wrapper message might provide the
	// payload explicitly. Alternatively, a message might
	// have a canonical serialization that can always be
	// unambiguously computed to derive the payload.
	// +optional
	Signature *string `json:"signature,omitempty" tf:"signature"`
}

type AnalysisOccurrenceSpecAttestation struct {
	// The serialized payload that is verified by one or
	// more signatures. A base64-encoded string.
	SerializedPayload *string `json:"serializedPayload" tf:"serialized_payload"`
	// One or more signatures over serializedPayload.
	// Verifier implementations should consider this attestation
	// message verified if at least one signature verifies
	// serializedPayload. See Signature in common.proto for more
	// details on signature structure and verification.
	Signatures []AnalysisOccurrenceSpecAttestationSignatures `json:"signatures" tf:"signatures"`
}

type AnalysisOccurrenceSpec2 struct {
	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	Timeouts *base.ResourceTimeout `json:"timeouts,omitempty" tf:"timeouts"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// Occurrence that represents a single "attestation". The authenticity
	// of an attestation can be verified using the attached signature.
	// If the verifier trusts the public key of the signer, then verifying
	// the signature is sufficient to establish trust. In this circumstance,
	// the authority to which this attestation is attached is primarily
	// useful for lookup (how to find this attestation if you already
	// know the authority and artifact to be verified) and intent (for
	// which authority this attestation was intended to sign.
	Attestation *AnalysisOccurrenceSpecAttestation `json:"attestation" tf:"attestation"`
	// The time when the repository was created.
	// +optional
	CreateTime *string `json:"createTime,omitempty" tf:"create_time"`
	// The note kind which explicitly denotes which of the occurrence
	// details are specified. This field can be used as a filter in list
	// requests.
	// +optional
	Kind *string `json:"kind,omitempty" tf:"kind"`
	// The name of the occurrence.
	// +optional
	Name *string `json:"name,omitempty" tf:"name"`
	// The analysis note associated with this occurrence, in the form of
	// projects/[PROJECT]/notes/[NOTE_ID]. This field can be used as a
	// filter in list requests.
	NoteName *string `json:"noteName" tf:"note_name"`
	// +optional
	Project *string `json:"project,omitempty" tf:"project"`
	// A description of actions that can be taken to remedy the note.
	// +optional
	Remediation *string `json:"remediation,omitempty" tf:"remediation"`
	// Required. Immutable. A URI that represents the resource for which
	// the occurrence applies. For example,
	// https://gcr.io/project/image@sha256:123abc for a Docker image.
	ResourceURI *string `json:"resourceURI" tf:"resource_uri"`
	// The time when the repository was last updated.
	// +optional
	UpdateTime *string `json:"updateTime,omitempty" tf:"update_time"`
}

type AnalysisOccurrenceStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase base.Phase `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// AnalysisOccurrenceList is a list of AnalysisOccurrences
type AnalysisOccurrenceList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of AnalysisOccurrence CRD objects
	Items []AnalysisOccurrence `json:"items,omitempty"`
}
