/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AppEngineServiceIamBindingSpecCondition{}).Type1()):  AppEngineServiceIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppEngineServiceIamMemberSpecCondition{}).Type1()):   AppEngineServiceIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppEngineVersionIamBindingSpecCondition{}).Type1()):  AppEngineVersionIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppEngineVersionIamMemberSpecCondition{}).Type1()):   AppEngineVersionIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TunnelIamBindingSpecCondition{}).Type1()):            TunnelIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TunnelIamMemberSpecCondition{}).Type1()):             TunnelIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TunnelInstanceIamBindingSpecCondition{}).Type1()):    TunnelInstanceIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TunnelInstanceIamMemberSpecCondition{}).Type1()):     TunnelInstanceIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebBackendServiceIamBindingSpecCondition{}).Type1()): WebBackendServiceIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebBackendServiceIamMemberSpecCondition{}).Type1()):  WebBackendServiceIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebIamBindingSpecCondition{}).Type1()):               WebIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebIamMemberSpecCondition{}).Type1()):                WebIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebTypeAppEngineIamBindingSpecCondition{}).Type1()):  WebTypeAppEngineIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebTypeAppEngineIamMemberSpecCondition{}).Type1()):   WebTypeAppEngineIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebTypeComputeIamBindingSpecCondition{}).Type1()):    WebTypeComputeIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebTypeComputeIamMemberSpecCondition{}).Type1()):     WebTypeComputeIamMemberSpecConditionCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AppEngineServiceIamBindingSpecCondition{}).Type1()):  AppEngineServiceIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppEngineServiceIamMemberSpecCondition{}).Type1()):   AppEngineServiceIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppEngineVersionIamBindingSpecCondition{}).Type1()):  AppEngineVersionIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AppEngineVersionIamMemberSpecCondition{}).Type1()):   AppEngineVersionIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TunnelIamBindingSpecCondition{}).Type1()):            TunnelIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TunnelIamMemberSpecCondition{}).Type1()):             TunnelIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TunnelInstanceIamBindingSpecCondition{}).Type1()):    TunnelInstanceIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TunnelInstanceIamMemberSpecCondition{}).Type1()):     TunnelInstanceIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebBackendServiceIamBindingSpecCondition{}).Type1()): WebBackendServiceIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebBackendServiceIamMemberSpecCondition{}).Type1()):  WebBackendServiceIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebIamBindingSpecCondition{}).Type1()):               WebIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebIamMemberSpecCondition{}).Type1()):                WebIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebTypeAppEngineIamBindingSpecCondition{}).Type1()):  WebTypeAppEngineIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebTypeAppEngineIamMemberSpecCondition{}).Type1()):   WebTypeAppEngineIamMemberSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebTypeComputeIamBindingSpecCondition{}).Type1()):    WebTypeComputeIamBindingSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WebTypeComputeIamMemberSpecCondition{}).Type1()):     WebTypeComputeIamMemberSpecConditionCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AppEngineServiceIamBindingSpecConditionCodec struct {
}

func (AppEngineServiceIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AppEngineServiceIamBindingSpecCondition)(ptr) == nil
}

func (AppEngineServiceIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AppEngineServiceIamBindingSpecCondition)(ptr)
	var objs []AppEngineServiceIamBindingSpecCondition
	if obj != nil {
		objs = []AppEngineServiceIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppEngineServiceIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AppEngineServiceIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AppEngineServiceIamBindingSpecCondition)(ptr) = AppEngineServiceIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AppEngineServiceIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppEngineServiceIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AppEngineServiceIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*AppEngineServiceIamBindingSpecCondition)(ptr) = AppEngineServiceIamBindingSpecCondition{}
			}
		} else {
			*(*AppEngineServiceIamBindingSpecCondition)(ptr) = AppEngineServiceIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode AppEngineServiceIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AppEngineServiceIamMemberSpecConditionCodec struct {
}

func (AppEngineServiceIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AppEngineServiceIamMemberSpecCondition)(ptr) == nil
}

func (AppEngineServiceIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AppEngineServiceIamMemberSpecCondition)(ptr)
	var objs []AppEngineServiceIamMemberSpecCondition
	if obj != nil {
		objs = []AppEngineServiceIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppEngineServiceIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AppEngineServiceIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AppEngineServiceIamMemberSpecCondition)(ptr) = AppEngineServiceIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AppEngineServiceIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppEngineServiceIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AppEngineServiceIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*AppEngineServiceIamMemberSpecCondition)(ptr) = AppEngineServiceIamMemberSpecCondition{}
			}
		} else {
			*(*AppEngineServiceIamMemberSpecCondition)(ptr) = AppEngineServiceIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode AppEngineServiceIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AppEngineVersionIamBindingSpecConditionCodec struct {
}

func (AppEngineVersionIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AppEngineVersionIamBindingSpecCondition)(ptr) == nil
}

func (AppEngineVersionIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AppEngineVersionIamBindingSpecCondition)(ptr)
	var objs []AppEngineVersionIamBindingSpecCondition
	if obj != nil {
		objs = []AppEngineVersionIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppEngineVersionIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AppEngineVersionIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AppEngineVersionIamBindingSpecCondition)(ptr) = AppEngineVersionIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AppEngineVersionIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppEngineVersionIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AppEngineVersionIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*AppEngineVersionIamBindingSpecCondition)(ptr) = AppEngineVersionIamBindingSpecCondition{}
			}
		} else {
			*(*AppEngineVersionIamBindingSpecCondition)(ptr) = AppEngineVersionIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode AppEngineVersionIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AppEngineVersionIamMemberSpecConditionCodec struct {
}

func (AppEngineVersionIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AppEngineVersionIamMemberSpecCondition)(ptr) == nil
}

func (AppEngineVersionIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AppEngineVersionIamMemberSpecCondition)(ptr)
	var objs []AppEngineVersionIamMemberSpecCondition
	if obj != nil {
		objs = []AppEngineVersionIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppEngineVersionIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AppEngineVersionIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AppEngineVersionIamMemberSpecCondition)(ptr) = AppEngineVersionIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AppEngineVersionIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AppEngineVersionIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AppEngineVersionIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*AppEngineVersionIamMemberSpecCondition)(ptr) = AppEngineVersionIamMemberSpecCondition{}
			}
		} else {
			*(*AppEngineVersionIamMemberSpecCondition)(ptr) = AppEngineVersionIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode AppEngineVersionIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TunnelIamBindingSpecConditionCodec struct {
}

func (TunnelIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TunnelIamBindingSpecCondition)(ptr) == nil
}

func (TunnelIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TunnelIamBindingSpecCondition)(ptr)
	var objs []TunnelIamBindingSpecCondition
	if obj != nil {
		objs = []TunnelIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TunnelIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TunnelIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TunnelIamBindingSpecCondition)(ptr) = TunnelIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TunnelIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TunnelIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TunnelIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*TunnelIamBindingSpecCondition)(ptr) = TunnelIamBindingSpecCondition{}
			}
		} else {
			*(*TunnelIamBindingSpecCondition)(ptr) = TunnelIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode TunnelIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TunnelIamMemberSpecConditionCodec struct {
}

func (TunnelIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TunnelIamMemberSpecCondition)(ptr) == nil
}

func (TunnelIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TunnelIamMemberSpecCondition)(ptr)
	var objs []TunnelIamMemberSpecCondition
	if obj != nil {
		objs = []TunnelIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TunnelIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TunnelIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TunnelIamMemberSpecCondition)(ptr) = TunnelIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TunnelIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TunnelIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TunnelIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*TunnelIamMemberSpecCondition)(ptr) = TunnelIamMemberSpecCondition{}
			}
		} else {
			*(*TunnelIamMemberSpecCondition)(ptr) = TunnelIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode TunnelIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TunnelInstanceIamBindingSpecConditionCodec struct {
}

func (TunnelInstanceIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TunnelInstanceIamBindingSpecCondition)(ptr) == nil
}

func (TunnelInstanceIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TunnelInstanceIamBindingSpecCondition)(ptr)
	var objs []TunnelInstanceIamBindingSpecCondition
	if obj != nil {
		objs = []TunnelInstanceIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TunnelInstanceIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TunnelInstanceIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TunnelInstanceIamBindingSpecCondition)(ptr) = TunnelInstanceIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TunnelInstanceIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TunnelInstanceIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TunnelInstanceIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*TunnelInstanceIamBindingSpecCondition)(ptr) = TunnelInstanceIamBindingSpecCondition{}
			}
		} else {
			*(*TunnelInstanceIamBindingSpecCondition)(ptr) = TunnelInstanceIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode TunnelInstanceIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TunnelInstanceIamMemberSpecConditionCodec struct {
}

func (TunnelInstanceIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TunnelInstanceIamMemberSpecCondition)(ptr) == nil
}

func (TunnelInstanceIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TunnelInstanceIamMemberSpecCondition)(ptr)
	var objs []TunnelInstanceIamMemberSpecCondition
	if obj != nil {
		objs = []TunnelInstanceIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TunnelInstanceIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TunnelInstanceIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TunnelInstanceIamMemberSpecCondition)(ptr) = TunnelInstanceIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TunnelInstanceIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TunnelInstanceIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TunnelInstanceIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*TunnelInstanceIamMemberSpecCondition)(ptr) = TunnelInstanceIamMemberSpecCondition{}
			}
		} else {
			*(*TunnelInstanceIamMemberSpecCondition)(ptr) = TunnelInstanceIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode TunnelInstanceIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WebBackendServiceIamBindingSpecConditionCodec struct {
}

func (WebBackendServiceIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WebBackendServiceIamBindingSpecCondition)(ptr) == nil
}

func (WebBackendServiceIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WebBackendServiceIamBindingSpecCondition)(ptr)
	var objs []WebBackendServiceIamBindingSpecCondition
	if obj != nil {
		objs = []WebBackendServiceIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebBackendServiceIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WebBackendServiceIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WebBackendServiceIamBindingSpecCondition)(ptr) = WebBackendServiceIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WebBackendServiceIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebBackendServiceIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WebBackendServiceIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*WebBackendServiceIamBindingSpecCondition)(ptr) = WebBackendServiceIamBindingSpecCondition{}
			}
		} else {
			*(*WebBackendServiceIamBindingSpecCondition)(ptr) = WebBackendServiceIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode WebBackendServiceIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WebBackendServiceIamMemberSpecConditionCodec struct {
}

func (WebBackendServiceIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WebBackendServiceIamMemberSpecCondition)(ptr) == nil
}

func (WebBackendServiceIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WebBackendServiceIamMemberSpecCondition)(ptr)
	var objs []WebBackendServiceIamMemberSpecCondition
	if obj != nil {
		objs = []WebBackendServiceIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebBackendServiceIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WebBackendServiceIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WebBackendServiceIamMemberSpecCondition)(ptr) = WebBackendServiceIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WebBackendServiceIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebBackendServiceIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WebBackendServiceIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*WebBackendServiceIamMemberSpecCondition)(ptr) = WebBackendServiceIamMemberSpecCondition{}
			}
		} else {
			*(*WebBackendServiceIamMemberSpecCondition)(ptr) = WebBackendServiceIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode WebBackendServiceIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WebIamBindingSpecConditionCodec struct {
}

func (WebIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WebIamBindingSpecCondition)(ptr) == nil
}

func (WebIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WebIamBindingSpecCondition)(ptr)
	var objs []WebIamBindingSpecCondition
	if obj != nil {
		objs = []WebIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WebIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WebIamBindingSpecCondition)(ptr) = WebIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WebIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WebIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*WebIamBindingSpecCondition)(ptr) = WebIamBindingSpecCondition{}
			}
		} else {
			*(*WebIamBindingSpecCondition)(ptr) = WebIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode WebIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WebIamMemberSpecConditionCodec struct {
}

func (WebIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WebIamMemberSpecCondition)(ptr) == nil
}

func (WebIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WebIamMemberSpecCondition)(ptr)
	var objs []WebIamMemberSpecCondition
	if obj != nil {
		objs = []WebIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WebIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WebIamMemberSpecCondition)(ptr) = WebIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WebIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WebIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*WebIamMemberSpecCondition)(ptr) = WebIamMemberSpecCondition{}
			}
		} else {
			*(*WebIamMemberSpecCondition)(ptr) = WebIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode WebIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WebTypeAppEngineIamBindingSpecConditionCodec struct {
}

func (WebTypeAppEngineIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WebTypeAppEngineIamBindingSpecCondition)(ptr) == nil
}

func (WebTypeAppEngineIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WebTypeAppEngineIamBindingSpecCondition)(ptr)
	var objs []WebTypeAppEngineIamBindingSpecCondition
	if obj != nil {
		objs = []WebTypeAppEngineIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebTypeAppEngineIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WebTypeAppEngineIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WebTypeAppEngineIamBindingSpecCondition)(ptr) = WebTypeAppEngineIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WebTypeAppEngineIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebTypeAppEngineIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WebTypeAppEngineIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*WebTypeAppEngineIamBindingSpecCondition)(ptr) = WebTypeAppEngineIamBindingSpecCondition{}
			}
		} else {
			*(*WebTypeAppEngineIamBindingSpecCondition)(ptr) = WebTypeAppEngineIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode WebTypeAppEngineIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WebTypeAppEngineIamMemberSpecConditionCodec struct {
}

func (WebTypeAppEngineIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WebTypeAppEngineIamMemberSpecCondition)(ptr) == nil
}

func (WebTypeAppEngineIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WebTypeAppEngineIamMemberSpecCondition)(ptr)
	var objs []WebTypeAppEngineIamMemberSpecCondition
	if obj != nil {
		objs = []WebTypeAppEngineIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebTypeAppEngineIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WebTypeAppEngineIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WebTypeAppEngineIamMemberSpecCondition)(ptr) = WebTypeAppEngineIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WebTypeAppEngineIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebTypeAppEngineIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WebTypeAppEngineIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*WebTypeAppEngineIamMemberSpecCondition)(ptr) = WebTypeAppEngineIamMemberSpecCondition{}
			}
		} else {
			*(*WebTypeAppEngineIamMemberSpecCondition)(ptr) = WebTypeAppEngineIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode WebTypeAppEngineIamMemberSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WebTypeComputeIamBindingSpecConditionCodec struct {
}

func (WebTypeComputeIamBindingSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WebTypeComputeIamBindingSpecCondition)(ptr) == nil
}

func (WebTypeComputeIamBindingSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WebTypeComputeIamBindingSpecCondition)(ptr)
	var objs []WebTypeComputeIamBindingSpecCondition
	if obj != nil {
		objs = []WebTypeComputeIamBindingSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebTypeComputeIamBindingSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WebTypeComputeIamBindingSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WebTypeComputeIamBindingSpecCondition)(ptr) = WebTypeComputeIamBindingSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WebTypeComputeIamBindingSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebTypeComputeIamBindingSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WebTypeComputeIamBindingSpecCondition)(ptr) = objs[0]
			} else {
				*(*WebTypeComputeIamBindingSpecCondition)(ptr) = WebTypeComputeIamBindingSpecCondition{}
			}
		} else {
			*(*WebTypeComputeIamBindingSpecCondition)(ptr) = WebTypeComputeIamBindingSpecCondition{}
		}
	default:
		iter.ReportError("decode WebTypeComputeIamBindingSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WebTypeComputeIamMemberSpecConditionCodec struct {
}

func (WebTypeComputeIamMemberSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WebTypeComputeIamMemberSpecCondition)(ptr) == nil
}

func (WebTypeComputeIamMemberSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WebTypeComputeIamMemberSpecCondition)(ptr)
	var objs []WebTypeComputeIamMemberSpecCondition
	if obj != nil {
		objs = []WebTypeComputeIamMemberSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebTypeComputeIamMemberSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WebTypeComputeIamMemberSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WebTypeComputeIamMemberSpecCondition)(ptr) = WebTypeComputeIamMemberSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WebTypeComputeIamMemberSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WebTypeComputeIamMemberSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WebTypeComputeIamMemberSpecCondition)(ptr) = objs[0]
			} else {
				*(*WebTypeComputeIamMemberSpecCondition)(ptr) = WebTypeComputeIamMemberSpecCondition{}
			}
		} else {
			*(*WebTypeComputeIamMemberSpecCondition)(ptr) = WebTypeComputeIamMemberSpecCondition{}
		}
	default:
		iter.ReportError("decode WebTypeComputeIamMemberSpecCondition", "unexpected JSON type")
	}
}
