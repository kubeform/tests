/*
Copyright The Kubeform Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/kubeform/apis/base/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type ContainerCluster struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ContainerClusterSpec   `json:"spec,omitempty"`
	Status            ContainerClusterStatus `json:"status,omitempty"`
}

type ContainerClusterSpecAddonsConfigHorizontalPodAutoscaling struct {
	// +optional
	Disabled bool `json:"disabled,omitempty" tf:"disabled,omitempty"`
}

type ContainerClusterSpecAddonsConfigHttpLoadBalancing struct {
	// +optional
	Disabled bool `json:"disabled,omitempty" tf:"disabled,omitempty"`
}

type ContainerClusterSpecAddonsConfigKubernetesDashboard struct {
	// +optional
	Disabled bool `json:"disabled,omitempty" tf:"disabled,omitempty"`
}

type ContainerClusterSpecAddonsConfigNetworkPolicyConfig struct {
	// +optional
	Disabled bool `json:"disabled,omitempty" tf:"disabled,omitempty"`
}

type ContainerClusterSpecAddonsConfig struct {
	// +optional
	// +kubebuilder:validation:MaxItems=1
	HorizontalPodAutoscaling []ContainerClusterSpecAddonsConfigHorizontalPodAutoscaling `json:"horizontalPodAutoscaling,omitempty" tf:"horizontal_pod_autoscaling,omitempty"`
	// +optional
	// +kubebuilder:validation:MaxItems=1
	HttpLoadBalancing []ContainerClusterSpecAddonsConfigHttpLoadBalancing `json:"httpLoadBalancing,omitempty" tf:"http_load_balancing,omitempty"`
	// +optional
	// +kubebuilder:validation:MaxItems=1
	KubernetesDashboard []ContainerClusterSpecAddonsConfigKubernetesDashboard `json:"kubernetesDashboard,omitempty" tf:"kubernetes_dashboard,omitempty"`
	// +optional
	// +kubebuilder:validation:MaxItems=1
	NetworkPolicyConfig []ContainerClusterSpecAddonsConfigNetworkPolicyConfig `json:"networkPolicyConfig,omitempty" tf:"network_policy_config,omitempty"`
}

type ContainerClusterSpecIpAllocationPolicy struct {
	// +optional
	ClusterIpv4CIDRBlock string `json:"clusterIpv4CIDRBlock,omitempty" tf:"cluster_ipv4_cidr_block,omitempty"`
	// +optional
	ClusterSecondaryRangeName string `json:"clusterSecondaryRangeName,omitempty" tf:"cluster_secondary_range_name,omitempty"`
	// +optional
	CreateSubnetwork bool `json:"createSubnetwork,omitempty" tf:"create_subnetwork,omitempty"`
	// +optional
	NodeIpv4CIDRBlock string `json:"nodeIpv4CIDRBlock,omitempty" tf:"node_ipv4_cidr_block,omitempty"`
	// +optional
	ServicesIpv4CIDRBlock string `json:"servicesIpv4CIDRBlock,omitempty" tf:"services_ipv4_cidr_block,omitempty"`
	// +optional
	ServicesSecondaryRangeName string `json:"servicesSecondaryRangeName,omitempty" tf:"services_secondary_range_name,omitempty"`
	// +optional
	SubnetworkName string `json:"subnetworkName,omitempty" tf:"subnetwork_name,omitempty"`
	// +optional
	UseIPAliases bool `json:"useIPAliases,omitempty" tf:"use_ip_aliases,omitempty"`
}

type ContainerClusterSpecMaintenancePolicyDailyMaintenanceWindow struct {
	// +optional
	Duration  string `json:"duration,omitempty" tf:"duration,omitempty"`
	StartTime string `json:"startTime" tf:"start_time"`
}

type ContainerClusterSpecMaintenancePolicy struct {
	// +kubebuilder:validation:MaxItems=1
	DailyMaintenanceWindow []ContainerClusterSpecMaintenancePolicyDailyMaintenanceWindow `json:"dailyMaintenanceWindow" tf:"daily_maintenance_window"`
}

type ContainerClusterSpecMasterAuthClientCertificateConfig struct {
	IssueClientCertificate bool `json:"issueClientCertificate" tf:"issue_client_certificate"`
}

type ContainerClusterSpecMasterAuth struct {
	// +optional
	ClientCertificate string `json:"clientCertificate,omitempty" tf:"client_certificate,omitempty"`
	// +optional
	// +kubebuilder:validation:MaxItems=1
	ClientCertificateConfig []ContainerClusterSpecMasterAuthClientCertificateConfig `json:"clientCertificateConfig,omitempty" tf:"client_certificate_config,omitempty"`
	// +optional
	ClientKey string `json:"-" sensitive:"true" tf:"client_key,omitempty"`
	// +optional
	ClusterCaCertificate string `json:"clusterCaCertificate,omitempty" tf:"cluster_ca_certificate,omitempty"`
	// +optional
	Password string `json:"-" sensitive:"true" tf:"password,omitempty"`
	// +optional
	Username string `json:"username,omitempty" tf:"username,omitempty"`
}

type ContainerClusterSpecMasterAuthorizedNetworksConfigCidrBlocks struct {
	CidrBlock string `json:"cidrBlock" tf:"cidr_block"`
	// +optional
	DisplayName string `json:"displayName,omitempty" tf:"display_name,omitempty"`
}

type ContainerClusterSpecMasterAuthorizedNetworksConfig struct {
	// +optional
	CidrBlocks []ContainerClusterSpecMasterAuthorizedNetworksConfigCidrBlocks `json:"cidrBlocks,omitempty" tf:"cidr_blocks,omitempty"`
}

type ContainerClusterSpecNetworkPolicy struct {
	// +optional
	Enabled bool `json:"enabled,omitempty" tf:"enabled,omitempty"`
	// +optional
	Provider string `json:"provider,omitempty" tf:"provider,omitempty"`
}

type ContainerClusterSpecNodeConfigGuestAccelerator struct {
	Count int64  `json:"count" tf:"count"`
	Type  string `json:"type" tf:"type"`
}

type ContainerClusterSpecNodeConfig struct {
	// +optional
	DiskSizeGb int64 `json:"diskSizeGb,omitempty" tf:"disk_size_gb,omitempty"`
	// +optional
	DiskType string `json:"diskType,omitempty" tf:"disk_type,omitempty"`
	// +optional
	GuestAccelerator []ContainerClusterSpecNodeConfigGuestAccelerator `json:"guestAccelerator,omitempty" tf:"guest_accelerator,omitempty"`
	// +optional
	ImageType string `json:"imageType,omitempty" tf:"image_type,omitempty"`
	// +optional
	Labels map[string]string `json:"labels,omitempty" tf:"labels,omitempty"`
	// +optional
	LocalSsdCount int64 `json:"localSsdCount,omitempty" tf:"local_ssd_count,omitempty"`
	// +optional
	MachineType string `json:"machineType,omitempty" tf:"machine_type,omitempty"`
	// +optional
	Metadata map[string]string `json:"metadata,omitempty" tf:"metadata,omitempty"`
	// +optional
	MinCPUPlatform string `json:"minCPUPlatform,omitempty" tf:"min_cpu_platform,omitempty"`
	// +optional
	OauthScopes []string `json:"oauthScopes,omitempty" tf:"oauth_scopes,omitempty"`
	// +optional
	Preemptible bool `json:"preemptible,omitempty" tf:"preemptible,omitempty"`
	// +optional
	ServiceAccount string `json:"serviceAccount,omitempty" tf:"service_account,omitempty"`
	// +optional
	Tags []string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type ContainerClusterSpecNodePoolAutoscaling struct {
	MaxNodeCount int64 `json:"maxNodeCount" tf:"max_node_count"`
	MinNodeCount int64 `json:"minNodeCount" tf:"min_node_count"`
}

type ContainerClusterSpecNodePoolManagement struct {
	// +optional
	AutoRepair bool `json:"autoRepair,omitempty" tf:"auto_repair,omitempty"`
	// +optional
	AutoUpgrade bool `json:"autoUpgrade,omitempty" tf:"auto_upgrade,omitempty"`
}

type ContainerClusterSpecNodePoolNodeConfigGuestAccelerator struct {
	Count int64  `json:"count" tf:"count"`
	Type  string `json:"type" tf:"type"`
}

type ContainerClusterSpecNodePoolNodeConfig struct {
	// +optional
	DiskSizeGb int64 `json:"diskSizeGb,omitempty" tf:"disk_size_gb,omitempty"`
	// +optional
	DiskType string `json:"diskType,omitempty" tf:"disk_type,omitempty"`
	// +optional
	GuestAccelerator []ContainerClusterSpecNodePoolNodeConfigGuestAccelerator `json:"guestAccelerator,omitempty" tf:"guest_accelerator,omitempty"`
	// +optional
	ImageType string `json:"imageType,omitempty" tf:"image_type,omitempty"`
	// +optional
	Labels map[string]string `json:"labels,omitempty" tf:"labels,omitempty"`
	// +optional
	LocalSsdCount int64 `json:"localSsdCount,omitempty" tf:"local_ssd_count,omitempty"`
	// +optional
	MachineType string `json:"machineType,omitempty" tf:"machine_type,omitempty"`
	// +optional
	Metadata map[string]string `json:"metadata,omitempty" tf:"metadata,omitempty"`
	// +optional
	MinCPUPlatform string `json:"minCPUPlatform,omitempty" tf:"min_cpu_platform,omitempty"`
	// +optional
	OauthScopes []string `json:"oauthScopes,omitempty" tf:"oauth_scopes,omitempty"`
	// +optional
	Preemptible bool `json:"preemptible,omitempty" tf:"preemptible,omitempty"`
	// +optional
	ServiceAccount string `json:"serviceAccount,omitempty" tf:"service_account,omitempty"`
	// +optional
	Tags []string `json:"tags,omitempty" tf:"tags,omitempty"`
}

type ContainerClusterSpecNodePool struct {
	// +optional
	// +kubebuilder:validation:MaxItems=1
	Autoscaling []ContainerClusterSpecNodePoolAutoscaling `json:"autoscaling,omitempty" tf:"autoscaling,omitempty"`
	// +optional
	InitialNodeCount int64 `json:"initialNodeCount,omitempty" tf:"initial_node_count,omitempty"`
	// +optional
	InstanceGroupUrls []string `json:"instanceGroupUrls,omitempty" tf:"instance_group_urls,omitempty"`
	// +optional
	// +kubebuilder:validation:MaxItems=1
	Management []ContainerClusterSpecNodePoolManagement `json:"management,omitempty" tf:"management,omitempty"`
	// +optional
	MaxPodsPerNode int64 `json:"maxPodsPerNode,omitempty" tf:"max_pods_per_node,omitempty"`
	// +optional
	Name string `json:"name,omitempty" tf:"name,omitempty"`
	// +optional
	NamePrefix string `json:"namePrefix,omitempty" tf:"name_prefix,omitempty"`
	// +optional
	// +kubebuilder:validation:MaxItems=1
	NodeConfig []ContainerClusterSpecNodePoolNodeConfig `json:"nodeConfig,omitempty" tf:"node_config,omitempty"`
	// +optional
	NodeCount int64 `json:"nodeCount,omitempty" tf:"node_count,omitempty"`
	// +optional
	Version string `json:"version,omitempty" tf:"version,omitempty"`
}

type ContainerClusterSpecPrivateClusterConfig struct {
	// +optional
	EnablePrivateEndpoint bool `json:"enablePrivateEndpoint,omitempty" tf:"enable_private_endpoint,omitempty"`
	// +optional
	EnablePrivateNodes bool `json:"enablePrivateNodes,omitempty" tf:"enable_private_nodes,omitempty"`
	// +optional
	MasterIpv4CIDRBlock string `json:"masterIpv4CIDRBlock,omitempty" tf:"master_ipv4_cidr_block,omitempty"`
	// +optional
	PrivateEndpoint string `json:"privateEndpoint,omitempty" tf:"private_endpoint,omitempty"`
	// +optional
	PublicEndpoint string `json:"publicEndpoint,omitempty" tf:"public_endpoint,omitempty"`
}

type ContainerClusterSpec struct {
	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	ID string `json:"id,omitempty" tf:"id,omitempty"`

	SecretRef *core.LocalObjectReference `json:"secretRef,omitempty" tf:"-"`

	// +optional
	// Deprecated
	AdditionalZones []string `json:"additionalZones,omitempty" tf:"additional_zones,omitempty"`
	// +optional
	// +kubebuilder:validation:MaxItems=1
	AddonsConfig []ContainerClusterSpecAddonsConfig `json:"addonsConfig,omitempty" tf:"addons_config,omitempty"`
	// +optional
	ClusterIpv4CIDR string `json:"clusterIpv4CIDR,omitempty" tf:"cluster_ipv4_cidr,omitempty"`
	// +optional
	DefaultMaxPodsPerNode int64 `json:"defaultMaxPodsPerNode,omitempty" tf:"default_max_pods_per_node,omitempty"`
	// +optional
	Description string `json:"description,omitempty" tf:"description,omitempty"`
	// +optional
	EnableKubernetesAlpha bool `json:"enableKubernetesAlpha,omitempty" tf:"enable_kubernetes_alpha,omitempty"`
	// +optional
	EnableLegacyAbac bool `json:"enableLegacyAbac,omitempty" tf:"enable_legacy_abac,omitempty"`
	// +optional
	Endpoint string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`
	// +optional
	InitialNodeCount int64 `json:"initialNodeCount,omitempty" tf:"initial_node_count,omitempty"`
	// +optional
	InstanceGroupUrls []string `json:"instanceGroupUrls,omitempty" tf:"instance_group_urls,omitempty"`
	// +optional
	// +kubebuilder:validation:MaxItems=1
	IpAllocationPolicy []ContainerClusterSpecIpAllocationPolicy `json:"ipAllocationPolicy,omitempty" tf:"ip_allocation_policy,omitempty"`
	// +optional
	Location string `json:"location,omitempty" tf:"location,omitempty"`
	// +optional
	LoggingService string `json:"loggingService,omitempty" tf:"logging_service,omitempty"`
	// +optional
	// +kubebuilder:validation:MaxItems=1
	MaintenancePolicy []ContainerClusterSpecMaintenancePolicy `json:"maintenancePolicy,omitempty" tf:"maintenance_policy,omitempty"`
	// +optional
	// +kubebuilder:validation:MaxItems=1
	MasterAuth []ContainerClusterSpecMasterAuth `json:"masterAuth,omitempty" tf:"master_auth,omitempty"`
	// +optional
	// +kubebuilder:validation:MaxItems=1
	MasterAuthorizedNetworksConfig []ContainerClusterSpecMasterAuthorizedNetworksConfig `json:"masterAuthorizedNetworksConfig,omitempty" tf:"master_authorized_networks_config,omitempty"`
	// +optional
	MasterVersion string `json:"masterVersion,omitempty" tf:"master_version,omitempty"`
	// +optional
	MinMasterVersion string `json:"minMasterVersion,omitempty" tf:"min_master_version,omitempty"`
	// +optional
	MonitoringService string `json:"monitoringService,omitempty" tf:"monitoring_service,omitempty"`
	Name              string `json:"name" tf:"name"`
	// +optional
	Network string `json:"network,omitempty" tf:"network,omitempty"`
	// +optional
	// +kubebuilder:validation:MaxItems=1
	NetworkPolicy []ContainerClusterSpecNetworkPolicy `json:"networkPolicy,omitempty" tf:"network_policy,omitempty"`
	// +optional
	// +kubebuilder:validation:MaxItems=1
	NodeConfig []ContainerClusterSpecNodeConfig `json:"nodeConfig,omitempty" tf:"node_config,omitempty"`
	// +optional
	NodeLocations []string `json:"nodeLocations,omitempty" tf:"node_locations,omitempty"`
	// +optional
	NodePool []ContainerClusterSpecNodePool `json:"nodePool,omitempty" tf:"node_pool,omitempty"`
	// +optional
	NodeVersion string `json:"nodeVersion,omitempty" tf:"node_version,omitempty"`
	// +optional
	// +kubebuilder:validation:MaxItems=1
	PrivateClusterConfig []ContainerClusterSpecPrivateClusterConfig `json:"privateClusterConfig,omitempty" tf:"private_cluster_config,omitempty"`
	// +optional
	Project string `json:"project,omitempty" tf:"project,omitempty"`
	// +optional
	// Deprecated
	Region string `json:"region,omitempty" tf:"region,omitempty"`
	// +optional
	RemoveDefaultNodePool bool `json:"removeDefaultNodePool,omitempty" tf:"remove_default_node_pool,omitempty"`
	// +optional
	ResourceLabels map[string]string `json:"resourceLabels,omitempty" tf:"resource_labels,omitempty"`
	// +optional
	ServicesIpv4CIDR string `json:"servicesIpv4CIDR,omitempty" tf:"services_ipv4_cidr,omitempty"`
	// +optional
	Subnetwork string `json:"subnetwork,omitempty" tf:"subnetwork,omitempty"`
	// +optional
	// Deprecated
	Zone string `json:"zone,omitempty" tf:"zone,omitempty"`
}

type ContainerClusterStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Output *ContainerClusterSpec `json:"output,omitempty"`
	// +optional
	State *base.State `json:"state,omitempty"`
	// +optional
	Phase base.Phase `json:"phase,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// ContainerClusterList is a list of ContainerClusters
type ContainerClusterList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of ContainerCluster CRD objects
	Items []ContainerCluster `json:"items,omitempty"`
}
