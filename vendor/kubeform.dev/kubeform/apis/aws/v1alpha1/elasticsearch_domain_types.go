/*
Copyright The Kubeform Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/kubeform/apis/base/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type ElasticsearchDomain struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ElasticsearchDomainSpec   `json:"spec,omitempty"`
	Status            ElasticsearchDomainStatus `json:"status,omitempty"`
}

type ElasticsearchDomainSpecClusterConfigZoneAwarenessConfig struct {
	// +optional
	AvailabilityZoneCount int64 `json:"availabilityZoneCount,omitempty" tf:"availability_zone_count,omitempty"`
}

type ElasticsearchDomainSpecClusterConfig struct {
	// +optional
	DedicatedMasterCount int64 `json:"dedicatedMasterCount,omitempty" tf:"dedicated_master_count,omitempty"`
	// +optional
	DedicatedMasterEnabled bool `json:"dedicatedMasterEnabled,omitempty" tf:"dedicated_master_enabled,omitempty"`
	// +optional
	DedicatedMasterType string `json:"dedicatedMasterType,omitempty" tf:"dedicated_master_type,omitempty"`
	// +optional
	InstanceCount int64 `json:"instanceCount,omitempty" tf:"instance_count,omitempty"`
	// +optional
	InstanceType string `json:"instanceType,omitempty" tf:"instance_type,omitempty"`
	// +optional
	// +kubebuilder:validation:MaxItems=1
	ZoneAwarenessConfig []ElasticsearchDomainSpecClusterConfigZoneAwarenessConfig `json:"zoneAwarenessConfig,omitempty" tf:"zone_awareness_config,omitempty"`
	// +optional
	ZoneAwarenessEnabled bool `json:"zoneAwarenessEnabled,omitempty" tf:"zone_awareness_enabled,omitempty"`
}

type ElasticsearchDomainSpecCognitoOptions struct {
	// +optional
	Enabled        bool   `json:"enabled,omitempty" tf:"enabled,omitempty"`
	IdentityPoolID string `json:"identityPoolID" tf:"identity_pool_id"`
	RoleArn        string `json:"roleArn" tf:"role_arn"`
	UserPoolID     string `json:"userPoolID" tf:"user_pool_id"`
}

type ElasticsearchDomainSpecEbsOptions struct {
	EbsEnabled bool `json:"ebsEnabled" tf:"ebs_enabled"`
	// +optional
	Iops int64 `json:"iops,omitempty" tf:"iops,omitempty"`
	// +optional
	VolumeSize int64 `json:"volumeSize,omitempty" tf:"volume_size,omitempty"`
	// +optional
	VolumeType string `json:"volumeType,omitempty" tf:"volume_type,omitempty"`
}

type ElasticsearchDomainSpecEncryptAtRest struct {
	Enabled bool `json:"enabled" tf:"enabled"`
	// +optional
	KmsKeyID string `json:"kmsKeyID,omitempty" tf:"kms_key_id,omitempty"`
}

type ElasticsearchDomainSpecLogPublishingOptions struct {
	CloudwatchLogGroupArn string `json:"cloudwatchLogGroupArn" tf:"cloudwatch_log_group_arn"`
	// +optional
	Enabled bool   `json:"enabled,omitempty" tf:"enabled,omitempty"`
	LogType string `json:"logType" tf:"log_type"`
}

type ElasticsearchDomainSpecNodeToNodeEncryption struct {
	Enabled bool `json:"enabled" tf:"enabled"`
}

type ElasticsearchDomainSpecSnapshotOptions struct {
	AutomatedSnapshotStartHour int64 `json:"automatedSnapshotStartHour" tf:"automated_snapshot_start_hour"`
}

type ElasticsearchDomainSpecVpcOptions struct {
	// +optional
	AvailabilityZones []string `json:"availabilityZones,omitempty" tf:"availability_zones,omitempty"`
	// +optional
	SecurityGroupIDS []string `json:"securityGroupIDS,omitempty" tf:"security_group_ids,omitempty"`
	// +optional
	SubnetIDS []string `json:"subnetIDS,omitempty" tf:"subnet_ids,omitempty"`
	// +optional
	VpcID string `json:"vpcID,omitempty" tf:"vpc_id,omitempty"`
}

type ElasticsearchDomainSpec struct {
	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	ID string `json:"id,omitempty" tf:"id,omitempty"`

	// +optional
	AccessPolicies string `json:"accessPolicies,omitempty" tf:"access_policies,omitempty"`
	// +optional
	AdvancedOptions map[string]string `json:"advancedOptions,omitempty" tf:"advanced_options,omitempty"`
	// +optional
	Arn string `json:"arn,omitempty" tf:"arn,omitempty"`
	// +optional
	// +kubebuilder:validation:MaxItems=1
	ClusterConfig []ElasticsearchDomainSpecClusterConfig `json:"clusterConfig,omitempty" tf:"cluster_config,omitempty"`
	// +optional
	// +kubebuilder:validation:MaxItems=1
	CognitoOptions []ElasticsearchDomainSpecCognitoOptions `json:"cognitoOptions,omitempty" tf:"cognito_options,omitempty"`
	// +optional
	DomainID   string `json:"domainID,omitempty" tf:"domain_id,omitempty"`
	DomainName string `json:"domainName" tf:"domain_name"`
	// +optional
	// +kubebuilder:validation:MaxItems=1
	EbsOptions []ElasticsearchDomainSpecEbsOptions `json:"ebsOptions,omitempty" tf:"ebs_options,omitempty"`
	// +optional
	ElasticsearchVersion string `json:"elasticsearchVersion,omitempty" tf:"elasticsearch_version,omitempty"`
	// +optional
	// +kubebuilder:validation:MaxItems=1
	EncryptAtRest []ElasticsearchDomainSpecEncryptAtRest `json:"encryptAtRest,omitempty" tf:"encrypt_at_rest,omitempty"`
	// +optional
	Endpoint string `json:"endpoint,omitempty" tf:"endpoint,omitempty"`
	// +optional
	KibanaEndpoint string `json:"kibanaEndpoint,omitempty" tf:"kibana_endpoint,omitempty"`
	// +optional
	LogPublishingOptions []ElasticsearchDomainSpecLogPublishingOptions `json:"logPublishingOptions,omitempty" tf:"log_publishing_options,omitempty"`
	// +optional
	// +kubebuilder:validation:MaxItems=1
	NodeToNodeEncryption []ElasticsearchDomainSpecNodeToNodeEncryption `json:"nodeToNodeEncryption,omitempty" tf:"node_to_node_encryption,omitempty"`
	// +optional
	// +kubebuilder:validation:MaxItems=1
	SnapshotOptions []ElasticsearchDomainSpecSnapshotOptions `json:"snapshotOptions,omitempty" tf:"snapshot_options,omitempty"`
	// +optional
	Tags map[string]string `json:"tags,omitempty" tf:"tags,omitempty"`
	// +optional
	// +kubebuilder:validation:MaxItems=1
	VpcOptions []ElasticsearchDomainSpecVpcOptions `json:"vpcOptions,omitempty" tf:"vpc_options,omitempty"`
}

type ElasticsearchDomainStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Output *ElasticsearchDomainSpec `json:"output,omitempty"`
	// +optional
	State *base.State `json:"state,omitempty"`
	// +optional
	Phase base.Phase `json:"phase,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// ElasticsearchDomainList is a list of ElasticsearchDomains
type ElasticsearchDomainList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of ElasticsearchDomain CRD objects
	Items []ElasticsearchDomain `json:"items,omitempty"`
}
