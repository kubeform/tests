/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecAlerts{}).Type1()):           InstanceSpecAlertsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevices{}).Type1()):    InstanceSpecConfigDevicesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSda{}).Type1()): InstanceSpecConfigDevicesSdaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdb{}).Type1()): InstanceSpecConfigDevicesSdbCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdc{}).Type1()): InstanceSpecConfigDevicesSdcCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdd{}).Type1()): InstanceSpecConfigDevicesSddCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSde{}).Type1()): InstanceSpecConfigDevicesSdeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdf{}).Type1()): InstanceSpecConfigDevicesSdfCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdg{}).Type1()): InstanceSpecConfigDevicesSdgCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdh{}).Type1()): InstanceSpecConfigDevicesSdhCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigHelpers{}).Type1()):    InstanceSpecConfigHelpersCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecAlerts{}).Type1()):           InstanceSpecAlertsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevices{}).Type1()):    InstanceSpecConfigDevicesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSda{}).Type1()): InstanceSpecConfigDevicesSdaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdb{}).Type1()): InstanceSpecConfigDevicesSdbCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdc{}).Type1()): InstanceSpecConfigDevicesSdcCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdd{}).Type1()): InstanceSpecConfigDevicesSddCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSde{}).Type1()): InstanceSpecConfigDevicesSdeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdf{}).Type1()): InstanceSpecConfigDevicesSdfCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdg{}).Type1()): InstanceSpecConfigDevicesSdgCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdh{}).Type1()): InstanceSpecConfigDevicesSdhCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigHelpers{}).Type1()):    InstanceSpecConfigHelpersCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type InstanceSpecAlertsCodec struct {
}

func (InstanceSpecAlertsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecAlerts)(ptr) == nil
}

func (InstanceSpecAlertsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecAlerts)(ptr)
	var objs []InstanceSpecAlerts
	if obj != nil {
		objs = []InstanceSpecAlerts{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecAlerts{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecAlertsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecAlerts)(ptr) = InstanceSpecAlerts{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecAlerts

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecAlerts{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecAlerts)(ptr) = objs[0]
			} else {
				*(*InstanceSpecAlerts)(ptr) = InstanceSpecAlerts{}
			}
		} else {
			*(*InstanceSpecAlerts)(ptr) = InstanceSpecAlerts{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecAlerts

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecAlerts{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecAlerts)(ptr) = obj
		} else {
			*(*InstanceSpecAlerts)(ptr) = InstanceSpecAlerts{}
		}
	default:
		iter.ReportError("decode InstanceSpecAlerts", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecConfigDevicesCodec struct {
}

func (InstanceSpecConfigDevicesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecConfigDevices)(ptr) == nil
}

func (InstanceSpecConfigDevicesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecConfigDevices)(ptr)
	var objs []InstanceSpecConfigDevices
	if obj != nil {
		objs = []InstanceSpecConfigDevices{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevices{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecConfigDevicesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecConfigDevices)(ptr) = InstanceSpecConfigDevices{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecConfigDevices

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevices{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecConfigDevices)(ptr) = objs[0]
			} else {
				*(*InstanceSpecConfigDevices)(ptr) = InstanceSpecConfigDevices{}
			}
		} else {
			*(*InstanceSpecConfigDevices)(ptr) = InstanceSpecConfigDevices{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecConfigDevices

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevices{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecConfigDevices)(ptr) = obj
		} else {
			*(*InstanceSpecConfigDevices)(ptr) = InstanceSpecConfigDevices{}
		}
	default:
		iter.ReportError("decode InstanceSpecConfigDevices", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecConfigDevicesSdaCodec struct {
}

func (InstanceSpecConfigDevicesSdaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecConfigDevicesSda)(ptr) == nil
}

func (InstanceSpecConfigDevicesSdaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecConfigDevicesSda)(ptr)
	var objs []InstanceSpecConfigDevicesSda
	if obj != nil {
		objs = []InstanceSpecConfigDevicesSda{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSda{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecConfigDevicesSdaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecConfigDevicesSda)(ptr) = InstanceSpecConfigDevicesSda{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecConfigDevicesSda

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSda{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecConfigDevicesSda)(ptr) = objs[0]
			} else {
				*(*InstanceSpecConfigDevicesSda)(ptr) = InstanceSpecConfigDevicesSda{}
			}
		} else {
			*(*InstanceSpecConfigDevicesSda)(ptr) = InstanceSpecConfigDevicesSda{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecConfigDevicesSda

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSda{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecConfigDevicesSda)(ptr) = obj
		} else {
			*(*InstanceSpecConfigDevicesSda)(ptr) = InstanceSpecConfigDevicesSda{}
		}
	default:
		iter.ReportError("decode InstanceSpecConfigDevicesSda", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecConfigDevicesSdbCodec struct {
}

func (InstanceSpecConfigDevicesSdbCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecConfigDevicesSdb)(ptr) == nil
}

func (InstanceSpecConfigDevicesSdbCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecConfigDevicesSdb)(ptr)
	var objs []InstanceSpecConfigDevicesSdb
	if obj != nil {
		objs = []InstanceSpecConfigDevicesSdb{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdb{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecConfigDevicesSdbCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecConfigDevicesSdb)(ptr) = InstanceSpecConfigDevicesSdb{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecConfigDevicesSdb

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdb{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecConfigDevicesSdb)(ptr) = objs[0]
			} else {
				*(*InstanceSpecConfigDevicesSdb)(ptr) = InstanceSpecConfigDevicesSdb{}
			}
		} else {
			*(*InstanceSpecConfigDevicesSdb)(ptr) = InstanceSpecConfigDevicesSdb{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecConfigDevicesSdb

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdb{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecConfigDevicesSdb)(ptr) = obj
		} else {
			*(*InstanceSpecConfigDevicesSdb)(ptr) = InstanceSpecConfigDevicesSdb{}
		}
	default:
		iter.ReportError("decode InstanceSpecConfigDevicesSdb", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecConfigDevicesSdcCodec struct {
}

func (InstanceSpecConfigDevicesSdcCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecConfigDevicesSdc)(ptr) == nil
}

func (InstanceSpecConfigDevicesSdcCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecConfigDevicesSdc)(ptr)
	var objs []InstanceSpecConfigDevicesSdc
	if obj != nil {
		objs = []InstanceSpecConfigDevicesSdc{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdc{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecConfigDevicesSdcCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecConfigDevicesSdc)(ptr) = InstanceSpecConfigDevicesSdc{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecConfigDevicesSdc

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdc{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecConfigDevicesSdc)(ptr) = objs[0]
			} else {
				*(*InstanceSpecConfigDevicesSdc)(ptr) = InstanceSpecConfigDevicesSdc{}
			}
		} else {
			*(*InstanceSpecConfigDevicesSdc)(ptr) = InstanceSpecConfigDevicesSdc{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecConfigDevicesSdc

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdc{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecConfigDevicesSdc)(ptr) = obj
		} else {
			*(*InstanceSpecConfigDevicesSdc)(ptr) = InstanceSpecConfigDevicesSdc{}
		}
	default:
		iter.ReportError("decode InstanceSpecConfigDevicesSdc", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecConfigDevicesSddCodec struct {
}

func (InstanceSpecConfigDevicesSddCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecConfigDevicesSdd)(ptr) == nil
}

func (InstanceSpecConfigDevicesSddCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecConfigDevicesSdd)(ptr)
	var objs []InstanceSpecConfigDevicesSdd
	if obj != nil {
		objs = []InstanceSpecConfigDevicesSdd{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdd{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecConfigDevicesSddCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecConfigDevicesSdd)(ptr) = InstanceSpecConfigDevicesSdd{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecConfigDevicesSdd

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdd{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecConfigDevicesSdd)(ptr) = objs[0]
			} else {
				*(*InstanceSpecConfigDevicesSdd)(ptr) = InstanceSpecConfigDevicesSdd{}
			}
		} else {
			*(*InstanceSpecConfigDevicesSdd)(ptr) = InstanceSpecConfigDevicesSdd{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecConfigDevicesSdd

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdd{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecConfigDevicesSdd)(ptr) = obj
		} else {
			*(*InstanceSpecConfigDevicesSdd)(ptr) = InstanceSpecConfigDevicesSdd{}
		}
	default:
		iter.ReportError("decode InstanceSpecConfigDevicesSdd", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecConfigDevicesSdeCodec struct {
}

func (InstanceSpecConfigDevicesSdeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecConfigDevicesSde)(ptr) == nil
}

func (InstanceSpecConfigDevicesSdeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecConfigDevicesSde)(ptr)
	var objs []InstanceSpecConfigDevicesSde
	if obj != nil {
		objs = []InstanceSpecConfigDevicesSde{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSde{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecConfigDevicesSdeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecConfigDevicesSde)(ptr) = InstanceSpecConfigDevicesSde{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecConfigDevicesSde

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSde{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecConfigDevicesSde)(ptr) = objs[0]
			} else {
				*(*InstanceSpecConfigDevicesSde)(ptr) = InstanceSpecConfigDevicesSde{}
			}
		} else {
			*(*InstanceSpecConfigDevicesSde)(ptr) = InstanceSpecConfigDevicesSde{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecConfigDevicesSde

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSde{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecConfigDevicesSde)(ptr) = obj
		} else {
			*(*InstanceSpecConfigDevicesSde)(ptr) = InstanceSpecConfigDevicesSde{}
		}
	default:
		iter.ReportError("decode InstanceSpecConfigDevicesSde", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecConfigDevicesSdfCodec struct {
}

func (InstanceSpecConfigDevicesSdfCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecConfigDevicesSdf)(ptr) == nil
}

func (InstanceSpecConfigDevicesSdfCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecConfigDevicesSdf)(ptr)
	var objs []InstanceSpecConfigDevicesSdf
	if obj != nil {
		objs = []InstanceSpecConfigDevicesSdf{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdf{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecConfigDevicesSdfCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecConfigDevicesSdf)(ptr) = InstanceSpecConfigDevicesSdf{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecConfigDevicesSdf

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdf{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecConfigDevicesSdf)(ptr) = objs[0]
			} else {
				*(*InstanceSpecConfigDevicesSdf)(ptr) = InstanceSpecConfigDevicesSdf{}
			}
		} else {
			*(*InstanceSpecConfigDevicesSdf)(ptr) = InstanceSpecConfigDevicesSdf{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecConfigDevicesSdf

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdf{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecConfigDevicesSdf)(ptr) = obj
		} else {
			*(*InstanceSpecConfigDevicesSdf)(ptr) = InstanceSpecConfigDevicesSdf{}
		}
	default:
		iter.ReportError("decode InstanceSpecConfigDevicesSdf", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecConfigDevicesSdgCodec struct {
}

func (InstanceSpecConfigDevicesSdgCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecConfigDevicesSdg)(ptr) == nil
}

func (InstanceSpecConfigDevicesSdgCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecConfigDevicesSdg)(ptr)
	var objs []InstanceSpecConfigDevicesSdg
	if obj != nil {
		objs = []InstanceSpecConfigDevicesSdg{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdg{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecConfigDevicesSdgCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecConfigDevicesSdg)(ptr) = InstanceSpecConfigDevicesSdg{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecConfigDevicesSdg

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdg{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecConfigDevicesSdg)(ptr) = objs[0]
			} else {
				*(*InstanceSpecConfigDevicesSdg)(ptr) = InstanceSpecConfigDevicesSdg{}
			}
		} else {
			*(*InstanceSpecConfigDevicesSdg)(ptr) = InstanceSpecConfigDevicesSdg{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecConfigDevicesSdg

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdg{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecConfigDevicesSdg)(ptr) = obj
		} else {
			*(*InstanceSpecConfigDevicesSdg)(ptr) = InstanceSpecConfigDevicesSdg{}
		}
	default:
		iter.ReportError("decode InstanceSpecConfigDevicesSdg", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecConfigDevicesSdhCodec struct {
}

func (InstanceSpecConfigDevicesSdhCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecConfigDevicesSdh)(ptr) == nil
}

func (InstanceSpecConfigDevicesSdhCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecConfigDevicesSdh)(ptr)
	var objs []InstanceSpecConfigDevicesSdh
	if obj != nil {
		objs = []InstanceSpecConfigDevicesSdh{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdh{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecConfigDevicesSdhCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecConfigDevicesSdh)(ptr) = InstanceSpecConfigDevicesSdh{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecConfigDevicesSdh

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdh{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecConfigDevicesSdh)(ptr) = objs[0]
			} else {
				*(*InstanceSpecConfigDevicesSdh)(ptr) = InstanceSpecConfigDevicesSdh{}
			}
		} else {
			*(*InstanceSpecConfigDevicesSdh)(ptr) = InstanceSpecConfigDevicesSdh{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecConfigDevicesSdh

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigDevicesSdh{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecConfigDevicesSdh)(ptr) = obj
		} else {
			*(*InstanceSpecConfigDevicesSdh)(ptr) = InstanceSpecConfigDevicesSdh{}
		}
	default:
		iter.ReportError("decode InstanceSpecConfigDevicesSdh", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceSpecConfigHelpersCodec struct {
}

func (InstanceSpecConfigHelpersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceSpecConfigHelpers)(ptr) == nil
}

func (InstanceSpecConfigHelpersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceSpecConfigHelpers)(ptr)
	var objs []InstanceSpecConfigHelpers
	if obj != nil {
		objs = []InstanceSpecConfigHelpers{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigHelpers{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceSpecConfigHelpersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceSpecConfigHelpers)(ptr) = InstanceSpecConfigHelpers{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceSpecConfigHelpers

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigHelpers{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceSpecConfigHelpers)(ptr) = objs[0]
			} else {
				*(*InstanceSpecConfigHelpers)(ptr) = InstanceSpecConfigHelpers{}
			}
		} else {
			*(*InstanceSpecConfigHelpers)(ptr) = InstanceSpecConfigHelpers{}
		}
	case jsoniter.ObjectValue:
		objByte := iter.SkipAndReturnBytes()
		if len(objByte) > 0 {
			var obj InstanceSpecConfigHelpers

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceSpecConfigHelpers{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objByte, &obj)

			*(*InstanceSpecConfigHelpers)(ptr) = obj
		} else {
			*(*InstanceSpecConfigHelpers)(ptr) = InstanceSpecConfigHelpers{}
		}
	default:
		iter.ReportError("decode InstanceSpecConfigHelpers", "unexpected JSON type")
	}
}
