/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(EventPermissionSpecCondition{}).Type1()):                 EventPermissionSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecBatchTarget{}).Type1()):                   EventTargetSpecBatchTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecDeadLetterConfig{}).Type1()):              EventTargetSpecDeadLetterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecEcsTarget{}).Type1()):                     EventTargetSpecEcsTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecEcsTargetNetworkConfiguration{}).Type1()): EventTargetSpecEcsTargetNetworkConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecInputTransformer{}).Type1()):              EventTargetSpecInputTransformerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecKinesisTarget{}).Type1()):                 EventTargetSpecKinesisTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecRetryPolicy{}).Type1()):                   EventTargetSpecRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecSqsTarget{}).Type1()):                     EventTargetSpecSqsTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LogMetricFilterSpecMetricTransformation{}).Type1()):      LogMetricFilterSpecMetricTransformationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MetricAlarmSpecMetricQueryMetric{}).Type1()):             MetricAlarmSpecMetricQueryMetricCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(EventPermissionSpecCondition{}).Type1()):                 EventPermissionSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecBatchTarget{}).Type1()):                   EventTargetSpecBatchTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecDeadLetterConfig{}).Type1()):              EventTargetSpecDeadLetterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecEcsTarget{}).Type1()):                     EventTargetSpecEcsTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecEcsTargetNetworkConfiguration{}).Type1()): EventTargetSpecEcsTargetNetworkConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecInputTransformer{}).Type1()):              EventTargetSpecInputTransformerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecKinesisTarget{}).Type1()):                 EventTargetSpecKinesisTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecRetryPolicy{}).Type1()):                   EventTargetSpecRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecSqsTarget{}).Type1()):                     EventTargetSpecSqsTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LogMetricFilterSpecMetricTransformation{}).Type1()):      LogMetricFilterSpecMetricTransformationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MetricAlarmSpecMetricQueryMetric{}).Type1()):             MetricAlarmSpecMetricQueryMetricCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type EventPermissionSpecConditionCodec struct {
}

func (EventPermissionSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventPermissionSpecCondition)(ptr) == nil
}

func (EventPermissionSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventPermissionSpecCondition)(ptr)
	var objs []EventPermissionSpecCondition
	if obj != nil {
		objs = []EventPermissionSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventPermissionSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventPermissionSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventPermissionSpecCondition)(ptr) = EventPermissionSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventPermissionSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventPermissionSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventPermissionSpecCondition)(ptr) = objs[0]
			} else {
				*(*EventPermissionSpecCondition)(ptr) = EventPermissionSpecCondition{}
			}
		} else {
			*(*EventPermissionSpecCondition)(ptr) = EventPermissionSpecCondition{}
		}
	default:
		iter.ReportError("decode EventPermissionSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventTargetSpecBatchTargetCodec struct {
}

func (EventTargetSpecBatchTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventTargetSpecBatchTarget)(ptr) == nil
}

func (EventTargetSpecBatchTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventTargetSpecBatchTarget)(ptr)
	var objs []EventTargetSpecBatchTarget
	if obj != nil {
		objs = []EventTargetSpecBatchTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecBatchTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventTargetSpecBatchTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventTargetSpecBatchTarget)(ptr) = EventTargetSpecBatchTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventTargetSpecBatchTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecBatchTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventTargetSpecBatchTarget)(ptr) = objs[0]
			} else {
				*(*EventTargetSpecBatchTarget)(ptr) = EventTargetSpecBatchTarget{}
			}
		} else {
			*(*EventTargetSpecBatchTarget)(ptr) = EventTargetSpecBatchTarget{}
		}
	default:
		iter.ReportError("decode EventTargetSpecBatchTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventTargetSpecDeadLetterConfigCodec struct {
}

func (EventTargetSpecDeadLetterConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventTargetSpecDeadLetterConfig)(ptr) == nil
}

func (EventTargetSpecDeadLetterConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventTargetSpecDeadLetterConfig)(ptr)
	var objs []EventTargetSpecDeadLetterConfig
	if obj != nil {
		objs = []EventTargetSpecDeadLetterConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecDeadLetterConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventTargetSpecDeadLetterConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventTargetSpecDeadLetterConfig)(ptr) = EventTargetSpecDeadLetterConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventTargetSpecDeadLetterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecDeadLetterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventTargetSpecDeadLetterConfig)(ptr) = objs[0]
			} else {
				*(*EventTargetSpecDeadLetterConfig)(ptr) = EventTargetSpecDeadLetterConfig{}
			}
		} else {
			*(*EventTargetSpecDeadLetterConfig)(ptr) = EventTargetSpecDeadLetterConfig{}
		}
	default:
		iter.ReportError("decode EventTargetSpecDeadLetterConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventTargetSpecEcsTargetCodec struct {
}

func (EventTargetSpecEcsTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventTargetSpecEcsTarget)(ptr) == nil
}

func (EventTargetSpecEcsTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventTargetSpecEcsTarget)(ptr)
	var objs []EventTargetSpecEcsTarget
	if obj != nil {
		objs = []EventTargetSpecEcsTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecEcsTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventTargetSpecEcsTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventTargetSpecEcsTarget)(ptr) = EventTargetSpecEcsTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventTargetSpecEcsTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecEcsTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventTargetSpecEcsTarget)(ptr) = objs[0]
			} else {
				*(*EventTargetSpecEcsTarget)(ptr) = EventTargetSpecEcsTarget{}
			}
		} else {
			*(*EventTargetSpecEcsTarget)(ptr) = EventTargetSpecEcsTarget{}
		}
	default:
		iter.ReportError("decode EventTargetSpecEcsTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventTargetSpecEcsTargetNetworkConfigurationCodec struct {
}

func (EventTargetSpecEcsTargetNetworkConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventTargetSpecEcsTargetNetworkConfiguration)(ptr) == nil
}

func (EventTargetSpecEcsTargetNetworkConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventTargetSpecEcsTargetNetworkConfiguration)(ptr)
	var objs []EventTargetSpecEcsTargetNetworkConfiguration
	if obj != nil {
		objs = []EventTargetSpecEcsTargetNetworkConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecEcsTargetNetworkConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventTargetSpecEcsTargetNetworkConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventTargetSpecEcsTargetNetworkConfiguration)(ptr) = EventTargetSpecEcsTargetNetworkConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventTargetSpecEcsTargetNetworkConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecEcsTargetNetworkConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventTargetSpecEcsTargetNetworkConfiguration)(ptr) = objs[0]
			} else {
				*(*EventTargetSpecEcsTargetNetworkConfiguration)(ptr) = EventTargetSpecEcsTargetNetworkConfiguration{}
			}
		} else {
			*(*EventTargetSpecEcsTargetNetworkConfiguration)(ptr) = EventTargetSpecEcsTargetNetworkConfiguration{}
		}
	default:
		iter.ReportError("decode EventTargetSpecEcsTargetNetworkConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventTargetSpecInputTransformerCodec struct {
}

func (EventTargetSpecInputTransformerCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventTargetSpecInputTransformer)(ptr) == nil
}

func (EventTargetSpecInputTransformerCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventTargetSpecInputTransformer)(ptr)
	var objs []EventTargetSpecInputTransformer
	if obj != nil {
		objs = []EventTargetSpecInputTransformer{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecInputTransformer{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventTargetSpecInputTransformerCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventTargetSpecInputTransformer)(ptr) = EventTargetSpecInputTransformer{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventTargetSpecInputTransformer

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecInputTransformer{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventTargetSpecInputTransformer)(ptr) = objs[0]
			} else {
				*(*EventTargetSpecInputTransformer)(ptr) = EventTargetSpecInputTransformer{}
			}
		} else {
			*(*EventTargetSpecInputTransformer)(ptr) = EventTargetSpecInputTransformer{}
		}
	default:
		iter.ReportError("decode EventTargetSpecInputTransformer", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventTargetSpecKinesisTargetCodec struct {
}

func (EventTargetSpecKinesisTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventTargetSpecKinesisTarget)(ptr) == nil
}

func (EventTargetSpecKinesisTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventTargetSpecKinesisTarget)(ptr)
	var objs []EventTargetSpecKinesisTarget
	if obj != nil {
		objs = []EventTargetSpecKinesisTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecKinesisTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventTargetSpecKinesisTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventTargetSpecKinesisTarget)(ptr) = EventTargetSpecKinesisTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventTargetSpecKinesisTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecKinesisTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventTargetSpecKinesisTarget)(ptr) = objs[0]
			} else {
				*(*EventTargetSpecKinesisTarget)(ptr) = EventTargetSpecKinesisTarget{}
			}
		} else {
			*(*EventTargetSpecKinesisTarget)(ptr) = EventTargetSpecKinesisTarget{}
		}
	default:
		iter.ReportError("decode EventTargetSpecKinesisTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventTargetSpecRetryPolicyCodec struct {
}

func (EventTargetSpecRetryPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventTargetSpecRetryPolicy)(ptr) == nil
}

func (EventTargetSpecRetryPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventTargetSpecRetryPolicy)(ptr)
	var objs []EventTargetSpecRetryPolicy
	if obj != nil {
		objs = []EventTargetSpecRetryPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecRetryPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventTargetSpecRetryPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventTargetSpecRetryPolicy)(ptr) = EventTargetSpecRetryPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventTargetSpecRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventTargetSpecRetryPolicy)(ptr) = objs[0]
			} else {
				*(*EventTargetSpecRetryPolicy)(ptr) = EventTargetSpecRetryPolicy{}
			}
		} else {
			*(*EventTargetSpecRetryPolicy)(ptr) = EventTargetSpecRetryPolicy{}
		}
	default:
		iter.ReportError("decode EventTargetSpecRetryPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventTargetSpecSqsTargetCodec struct {
}

func (EventTargetSpecSqsTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventTargetSpecSqsTarget)(ptr) == nil
}

func (EventTargetSpecSqsTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventTargetSpecSqsTarget)(ptr)
	var objs []EventTargetSpecSqsTarget
	if obj != nil {
		objs = []EventTargetSpecSqsTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecSqsTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventTargetSpecSqsTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventTargetSpecSqsTarget)(ptr) = EventTargetSpecSqsTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventTargetSpecSqsTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventTargetSpecSqsTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventTargetSpecSqsTarget)(ptr) = objs[0]
			} else {
				*(*EventTargetSpecSqsTarget)(ptr) = EventTargetSpecSqsTarget{}
			}
		} else {
			*(*EventTargetSpecSqsTarget)(ptr) = EventTargetSpecSqsTarget{}
		}
	default:
		iter.ReportError("decode EventTargetSpecSqsTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LogMetricFilterSpecMetricTransformationCodec struct {
}

func (LogMetricFilterSpecMetricTransformationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LogMetricFilterSpecMetricTransformation)(ptr) == nil
}

func (LogMetricFilterSpecMetricTransformationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LogMetricFilterSpecMetricTransformation)(ptr)
	var objs []LogMetricFilterSpecMetricTransformation
	if obj != nil {
		objs = []LogMetricFilterSpecMetricTransformation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LogMetricFilterSpecMetricTransformation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LogMetricFilterSpecMetricTransformationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LogMetricFilterSpecMetricTransformation)(ptr) = LogMetricFilterSpecMetricTransformation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LogMetricFilterSpecMetricTransformation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LogMetricFilterSpecMetricTransformation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LogMetricFilterSpecMetricTransformation)(ptr) = objs[0]
			} else {
				*(*LogMetricFilterSpecMetricTransformation)(ptr) = LogMetricFilterSpecMetricTransformation{}
			}
		} else {
			*(*LogMetricFilterSpecMetricTransformation)(ptr) = LogMetricFilterSpecMetricTransformation{}
		}
	default:
		iter.ReportError("decode LogMetricFilterSpecMetricTransformation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MetricAlarmSpecMetricQueryMetricCodec struct {
}

func (MetricAlarmSpecMetricQueryMetricCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MetricAlarmSpecMetricQueryMetric)(ptr) == nil
}

func (MetricAlarmSpecMetricQueryMetricCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MetricAlarmSpecMetricQueryMetric)(ptr)
	var objs []MetricAlarmSpecMetricQueryMetric
	if obj != nil {
		objs = []MetricAlarmSpecMetricQueryMetric{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricAlarmSpecMetricQueryMetric{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MetricAlarmSpecMetricQueryMetricCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MetricAlarmSpecMetricQueryMetric)(ptr) = MetricAlarmSpecMetricQueryMetric{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MetricAlarmSpecMetricQueryMetric

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricAlarmSpecMetricQueryMetric{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MetricAlarmSpecMetricQueryMetric)(ptr) = objs[0]
			} else {
				*(*MetricAlarmSpecMetricQueryMetric)(ptr) = MetricAlarmSpecMetricQueryMetric{}
			}
		} else {
			*(*MetricAlarmSpecMetricQueryMetric)(ptr) = MetricAlarmSpecMetricQueryMetric{}
		}
	default:
		iter.ReportError("decode MetricAlarmSpecMetricQueryMetric", "unexpected JSON type")
	}
}
