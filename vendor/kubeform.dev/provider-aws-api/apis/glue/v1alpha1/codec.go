/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogTableSpecStorageDescriptor{}).Type1()):                                                          CatalogTableSpecStorageDescriptorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogTableSpecStorageDescriptorSchemaReference{}).Type1()):                                           CatalogTableSpecStorageDescriptorSchemaReferenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogTableSpecStorageDescriptorSchemaReferenceSchemaID{}).Type1()):                                   CatalogTableSpecStorageDescriptorSchemaReferenceSchemaIDCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogTableSpecStorageDescriptorSerDeInfo{}).Type1()):                                                 CatalogTableSpecStorageDescriptorSerDeInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogTableSpecStorageDescriptorSkewedInfo{}).Type1()):                                                CatalogTableSpecStorageDescriptorSkewedInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClassifierSpecCsvClassifier{}).Type1()):                                                                ClassifierSpecCsvClassifierCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClassifierSpecGrokClassifier{}).Type1()):                                                               ClassifierSpecGrokClassifierCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClassifierSpecJsonClassifier{}).Type1()):                                                               ClassifierSpecJsonClassifierCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClassifierSpecXmlClassifier{}).Type1()):                                                                ClassifierSpecXmlClassifierCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectionSpecPhysicalConnectionRequirements{}).Type1()):                                               ConnectionSpecPhysicalConnectionRequirementsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CrawlerSpecLineageConfiguration{}).Type1()):                                                            CrawlerSpecLineageConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CrawlerSpecRecrawlPolicy{}).Type1()):                                                                   CrawlerSpecRecrawlPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CrawlerSpecSchemaChangePolicy{}).Type1()):                                                              CrawlerSpecSchemaChangePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettings{}).Type1()):                             DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsConnectionPasswordEncryption{}).Type1()): DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsConnectionPasswordEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsEncryptionAtRest{}).Type1()):             DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsEncryptionAtRestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecCommand{}).Type1()):                                                                             JobSpecCommandCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecExecutionProperty{}).Type1()):                                                                   JobSpecExecutionPropertyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecNotificationProperty{}).Type1()):                                                                JobSpecNotificationPropertyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MlTransformSpecParameters{}).Type1()):                                                                  MlTransformSpecParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MlTransformSpecParametersFindMatchesParameters{}).Type1()):                                             MlTransformSpecParametersFindMatchesParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PartitionSpecStorageDescriptor{}).Type1()):                                                             PartitionSpecStorageDescriptorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PartitionSpecStorageDescriptorSerDeInfo{}).Type1()):                                                    PartitionSpecStorageDescriptorSerDeInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PartitionSpecStorageDescriptorSkewedInfo{}).Type1()):                                                   PartitionSpecStorageDescriptorSkewedInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityConfigurationSpecEncryptionConfiguration{}).Type1()):                                           SecurityConfigurationSpecEncryptionConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityConfigurationSpecEncryptionConfigurationCloudwatchEncryption{}).Type1()):                       SecurityConfigurationSpecEncryptionConfigurationCloudwatchEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityConfigurationSpecEncryptionConfigurationJobBookmarksEncryption{}).Type1()):                     SecurityConfigurationSpecEncryptionConfigurationJobBookmarksEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityConfigurationSpecEncryptionConfigurationS3Encryption{}).Type1()):                               SecurityConfigurationSpecEncryptionConfigurationS3EncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecActionsNotificationProperty{}).Type1()):                                                     TriggerSpecActionsNotificationPropertyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecPredicate{}).Type1()):                                                                       TriggerSpecPredicateCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogTableSpecStorageDescriptor{}).Type1()):                                                          CatalogTableSpecStorageDescriptorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogTableSpecStorageDescriptorSchemaReference{}).Type1()):                                           CatalogTableSpecStorageDescriptorSchemaReferenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogTableSpecStorageDescriptorSchemaReferenceSchemaID{}).Type1()):                                   CatalogTableSpecStorageDescriptorSchemaReferenceSchemaIDCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogTableSpecStorageDescriptorSerDeInfo{}).Type1()):                                                 CatalogTableSpecStorageDescriptorSerDeInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CatalogTableSpecStorageDescriptorSkewedInfo{}).Type1()):                                                CatalogTableSpecStorageDescriptorSkewedInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClassifierSpecCsvClassifier{}).Type1()):                                                                ClassifierSpecCsvClassifierCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClassifierSpecGrokClassifier{}).Type1()):                                                               ClassifierSpecGrokClassifierCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClassifierSpecJsonClassifier{}).Type1()):                                                               ClassifierSpecJsonClassifierCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClassifierSpecXmlClassifier{}).Type1()):                                                                ClassifierSpecXmlClassifierCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConnectionSpecPhysicalConnectionRequirements{}).Type1()):                                               ConnectionSpecPhysicalConnectionRequirementsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CrawlerSpecLineageConfiguration{}).Type1()):                                                            CrawlerSpecLineageConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CrawlerSpecRecrawlPolicy{}).Type1()):                                                                   CrawlerSpecRecrawlPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CrawlerSpecSchemaChangePolicy{}).Type1()):                                                              CrawlerSpecSchemaChangePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettings{}).Type1()):                             DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsConnectionPasswordEncryption{}).Type1()): DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsConnectionPasswordEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsEncryptionAtRest{}).Type1()):             DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsEncryptionAtRestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecCommand{}).Type1()):                                                                             JobSpecCommandCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecExecutionProperty{}).Type1()):                                                                   JobSpecExecutionPropertyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecNotificationProperty{}).Type1()):                                                                JobSpecNotificationPropertyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MlTransformSpecParameters{}).Type1()):                                                                  MlTransformSpecParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MlTransformSpecParametersFindMatchesParameters{}).Type1()):                                             MlTransformSpecParametersFindMatchesParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PartitionSpecStorageDescriptor{}).Type1()):                                                             PartitionSpecStorageDescriptorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PartitionSpecStorageDescriptorSerDeInfo{}).Type1()):                                                    PartitionSpecStorageDescriptorSerDeInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PartitionSpecStorageDescriptorSkewedInfo{}).Type1()):                                                   PartitionSpecStorageDescriptorSkewedInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityConfigurationSpecEncryptionConfiguration{}).Type1()):                                           SecurityConfigurationSpecEncryptionConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityConfigurationSpecEncryptionConfigurationCloudwatchEncryption{}).Type1()):                       SecurityConfigurationSpecEncryptionConfigurationCloudwatchEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityConfigurationSpecEncryptionConfigurationJobBookmarksEncryption{}).Type1()):                     SecurityConfigurationSpecEncryptionConfigurationJobBookmarksEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SecurityConfigurationSpecEncryptionConfigurationS3Encryption{}).Type1()):                               SecurityConfigurationSpecEncryptionConfigurationS3EncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecActionsNotificationProperty{}).Type1()):                                                     TriggerSpecActionsNotificationPropertyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecPredicate{}).Type1()):                                                                       TriggerSpecPredicateCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type CatalogTableSpecStorageDescriptorCodec struct {
}

func (CatalogTableSpecStorageDescriptorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CatalogTableSpecStorageDescriptor)(ptr) == nil
}

func (CatalogTableSpecStorageDescriptorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CatalogTableSpecStorageDescriptor)(ptr)
	var objs []CatalogTableSpecStorageDescriptor
	if obj != nil {
		objs = []CatalogTableSpecStorageDescriptor{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogTableSpecStorageDescriptor{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CatalogTableSpecStorageDescriptorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CatalogTableSpecStorageDescriptor)(ptr) = CatalogTableSpecStorageDescriptor{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CatalogTableSpecStorageDescriptor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogTableSpecStorageDescriptor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CatalogTableSpecStorageDescriptor)(ptr) = objs[0]
			} else {
				*(*CatalogTableSpecStorageDescriptor)(ptr) = CatalogTableSpecStorageDescriptor{}
			}
		} else {
			*(*CatalogTableSpecStorageDescriptor)(ptr) = CatalogTableSpecStorageDescriptor{}
		}
	default:
		iter.ReportError("decode CatalogTableSpecStorageDescriptor", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CatalogTableSpecStorageDescriptorSchemaReferenceCodec struct {
}

func (CatalogTableSpecStorageDescriptorSchemaReferenceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CatalogTableSpecStorageDescriptorSchemaReference)(ptr) == nil
}

func (CatalogTableSpecStorageDescriptorSchemaReferenceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CatalogTableSpecStorageDescriptorSchemaReference)(ptr)
	var objs []CatalogTableSpecStorageDescriptorSchemaReference
	if obj != nil {
		objs = []CatalogTableSpecStorageDescriptorSchemaReference{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogTableSpecStorageDescriptorSchemaReference{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CatalogTableSpecStorageDescriptorSchemaReferenceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CatalogTableSpecStorageDescriptorSchemaReference)(ptr) = CatalogTableSpecStorageDescriptorSchemaReference{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CatalogTableSpecStorageDescriptorSchemaReference

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogTableSpecStorageDescriptorSchemaReference{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CatalogTableSpecStorageDescriptorSchemaReference)(ptr) = objs[0]
			} else {
				*(*CatalogTableSpecStorageDescriptorSchemaReference)(ptr) = CatalogTableSpecStorageDescriptorSchemaReference{}
			}
		} else {
			*(*CatalogTableSpecStorageDescriptorSchemaReference)(ptr) = CatalogTableSpecStorageDescriptorSchemaReference{}
		}
	default:
		iter.ReportError("decode CatalogTableSpecStorageDescriptorSchemaReference", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CatalogTableSpecStorageDescriptorSchemaReferenceSchemaIDCodec struct {
}

func (CatalogTableSpecStorageDescriptorSchemaReferenceSchemaIDCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CatalogTableSpecStorageDescriptorSchemaReferenceSchemaID)(ptr) == nil
}

func (CatalogTableSpecStorageDescriptorSchemaReferenceSchemaIDCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CatalogTableSpecStorageDescriptorSchemaReferenceSchemaID)(ptr)
	var objs []CatalogTableSpecStorageDescriptorSchemaReferenceSchemaID
	if obj != nil {
		objs = []CatalogTableSpecStorageDescriptorSchemaReferenceSchemaID{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogTableSpecStorageDescriptorSchemaReferenceSchemaID{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CatalogTableSpecStorageDescriptorSchemaReferenceSchemaIDCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CatalogTableSpecStorageDescriptorSchemaReferenceSchemaID)(ptr) = CatalogTableSpecStorageDescriptorSchemaReferenceSchemaID{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CatalogTableSpecStorageDescriptorSchemaReferenceSchemaID

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogTableSpecStorageDescriptorSchemaReferenceSchemaID{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CatalogTableSpecStorageDescriptorSchemaReferenceSchemaID)(ptr) = objs[0]
			} else {
				*(*CatalogTableSpecStorageDescriptorSchemaReferenceSchemaID)(ptr) = CatalogTableSpecStorageDescriptorSchemaReferenceSchemaID{}
			}
		} else {
			*(*CatalogTableSpecStorageDescriptorSchemaReferenceSchemaID)(ptr) = CatalogTableSpecStorageDescriptorSchemaReferenceSchemaID{}
		}
	default:
		iter.ReportError("decode CatalogTableSpecStorageDescriptorSchemaReferenceSchemaID", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CatalogTableSpecStorageDescriptorSerDeInfoCodec struct {
}

func (CatalogTableSpecStorageDescriptorSerDeInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CatalogTableSpecStorageDescriptorSerDeInfo)(ptr) == nil
}

func (CatalogTableSpecStorageDescriptorSerDeInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CatalogTableSpecStorageDescriptorSerDeInfo)(ptr)
	var objs []CatalogTableSpecStorageDescriptorSerDeInfo
	if obj != nil {
		objs = []CatalogTableSpecStorageDescriptorSerDeInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogTableSpecStorageDescriptorSerDeInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CatalogTableSpecStorageDescriptorSerDeInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CatalogTableSpecStorageDescriptorSerDeInfo)(ptr) = CatalogTableSpecStorageDescriptorSerDeInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CatalogTableSpecStorageDescriptorSerDeInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogTableSpecStorageDescriptorSerDeInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CatalogTableSpecStorageDescriptorSerDeInfo)(ptr) = objs[0]
			} else {
				*(*CatalogTableSpecStorageDescriptorSerDeInfo)(ptr) = CatalogTableSpecStorageDescriptorSerDeInfo{}
			}
		} else {
			*(*CatalogTableSpecStorageDescriptorSerDeInfo)(ptr) = CatalogTableSpecStorageDescriptorSerDeInfo{}
		}
	default:
		iter.ReportError("decode CatalogTableSpecStorageDescriptorSerDeInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CatalogTableSpecStorageDescriptorSkewedInfoCodec struct {
}

func (CatalogTableSpecStorageDescriptorSkewedInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CatalogTableSpecStorageDescriptorSkewedInfo)(ptr) == nil
}

func (CatalogTableSpecStorageDescriptorSkewedInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CatalogTableSpecStorageDescriptorSkewedInfo)(ptr)
	var objs []CatalogTableSpecStorageDescriptorSkewedInfo
	if obj != nil {
		objs = []CatalogTableSpecStorageDescriptorSkewedInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogTableSpecStorageDescriptorSkewedInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CatalogTableSpecStorageDescriptorSkewedInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CatalogTableSpecStorageDescriptorSkewedInfo)(ptr) = CatalogTableSpecStorageDescriptorSkewedInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CatalogTableSpecStorageDescriptorSkewedInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CatalogTableSpecStorageDescriptorSkewedInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CatalogTableSpecStorageDescriptorSkewedInfo)(ptr) = objs[0]
			} else {
				*(*CatalogTableSpecStorageDescriptorSkewedInfo)(ptr) = CatalogTableSpecStorageDescriptorSkewedInfo{}
			}
		} else {
			*(*CatalogTableSpecStorageDescriptorSkewedInfo)(ptr) = CatalogTableSpecStorageDescriptorSkewedInfo{}
		}
	default:
		iter.ReportError("decode CatalogTableSpecStorageDescriptorSkewedInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClassifierSpecCsvClassifierCodec struct {
}

func (ClassifierSpecCsvClassifierCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClassifierSpecCsvClassifier)(ptr) == nil
}

func (ClassifierSpecCsvClassifierCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClassifierSpecCsvClassifier)(ptr)
	var objs []ClassifierSpecCsvClassifier
	if obj != nil {
		objs = []ClassifierSpecCsvClassifier{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClassifierSpecCsvClassifier{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClassifierSpecCsvClassifierCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClassifierSpecCsvClassifier)(ptr) = ClassifierSpecCsvClassifier{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClassifierSpecCsvClassifier

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClassifierSpecCsvClassifier{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClassifierSpecCsvClassifier)(ptr) = objs[0]
			} else {
				*(*ClassifierSpecCsvClassifier)(ptr) = ClassifierSpecCsvClassifier{}
			}
		} else {
			*(*ClassifierSpecCsvClassifier)(ptr) = ClassifierSpecCsvClassifier{}
		}
	default:
		iter.ReportError("decode ClassifierSpecCsvClassifier", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClassifierSpecGrokClassifierCodec struct {
}

func (ClassifierSpecGrokClassifierCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClassifierSpecGrokClassifier)(ptr) == nil
}

func (ClassifierSpecGrokClassifierCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClassifierSpecGrokClassifier)(ptr)
	var objs []ClassifierSpecGrokClassifier
	if obj != nil {
		objs = []ClassifierSpecGrokClassifier{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClassifierSpecGrokClassifier{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClassifierSpecGrokClassifierCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClassifierSpecGrokClassifier)(ptr) = ClassifierSpecGrokClassifier{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClassifierSpecGrokClassifier

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClassifierSpecGrokClassifier{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClassifierSpecGrokClassifier)(ptr) = objs[0]
			} else {
				*(*ClassifierSpecGrokClassifier)(ptr) = ClassifierSpecGrokClassifier{}
			}
		} else {
			*(*ClassifierSpecGrokClassifier)(ptr) = ClassifierSpecGrokClassifier{}
		}
	default:
		iter.ReportError("decode ClassifierSpecGrokClassifier", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClassifierSpecJsonClassifierCodec struct {
}

func (ClassifierSpecJsonClassifierCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClassifierSpecJsonClassifier)(ptr) == nil
}

func (ClassifierSpecJsonClassifierCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClassifierSpecJsonClassifier)(ptr)
	var objs []ClassifierSpecJsonClassifier
	if obj != nil {
		objs = []ClassifierSpecJsonClassifier{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClassifierSpecJsonClassifier{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClassifierSpecJsonClassifierCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClassifierSpecJsonClassifier)(ptr) = ClassifierSpecJsonClassifier{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClassifierSpecJsonClassifier

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClassifierSpecJsonClassifier{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClassifierSpecJsonClassifier)(ptr) = objs[0]
			} else {
				*(*ClassifierSpecJsonClassifier)(ptr) = ClassifierSpecJsonClassifier{}
			}
		} else {
			*(*ClassifierSpecJsonClassifier)(ptr) = ClassifierSpecJsonClassifier{}
		}
	default:
		iter.ReportError("decode ClassifierSpecJsonClassifier", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClassifierSpecXmlClassifierCodec struct {
}

func (ClassifierSpecXmlClassifierCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClassifierSpecXmlClassifier)(ptr) == nil
}

func (ClassifierSpecXmlClassifierCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClassifierSpecXmlClassifier)(ptr)
	var objs []ClassifierSpecXmlClassifier
	if obj != nil {
		objs = []ClassifierSpecXmlClassifier{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClassifierSpecXmlClassifier{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClassifierSpecXmlClassifierCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClassifierSpecXmlClassifier)(ptr) = ClassifierSpecXmlClassifier{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClassifierSpecXmlClassifier

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClassifierSpecXmlClassifier{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClassifierSpecXmlClassifier)(ptr) = objs[0]
			} else {
				*(*ClassifierSpecXmlClassifier)(ptr) = ClassifierSpecXmlClassifier{}
			}
		} else {
			*(*ClassifierSpecXmlClassifier)(ptr) = ClassifierSpecXmlClassifier{}
		}
	default:
		iter.ReportError("decode ClassifierSpecXmlClassifier", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConnectionSpecPhysicalConnectionRequirementsCodec struct {
}

func (ConnectionSpecPhysicalConnectionRequirementsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConnectionSpecPhysicalConnectionRequirements)(ptr) == nil
}

func (ConnectionSpecPhysicalConnectionRequirementsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConnectionSpecPhysicalConnectionRequirements)(ptr)
	var objs []ConnectionSpecPhysicalConnectionRequirements
	if obj != nil {
		objs = []ConnectionSpecPhysicalConnectionRequirements{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectionSpecPhysicalConnectionRequirements{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConnectionSpecPhysicalConnectionRequirementsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConnectionSpecPhysicalConnectionRequirements)(ptr) = ConnectionSpecPhysicalConnectionRequirements{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConnectionSpecPhysicalConnectionRequirements

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConnectionSpecPhysicalConnectionRequirements{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConnectionSpecPhysicalConnectionRequirements)(ptr) = objs[0]
			} else {
				*(*ConnectionSpecPhysicalConnectionRequirements)(ptr) = ConnectionSpecPhysicalConnectionRequirements{}
			}
		} else {
			*(*ConnectionSpecPhysicalConnectionRequirements)(ptr) = ConnectionSpecPhysicalConnectionRequirements{}
		}
	default:
		iter.ReportError("decode ConnectionSpecPhysicalConnectionRequirements", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CrawlerSpecLineageConfigurationCodec struct {
}

func (CrawlerSpecLineageConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CrawlerSpecLineageConfiguration)(ptr) == nil
}

func (CrawlerSpecLineageConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CrawlerSpecLineageConfiguration)(ptr)
	var objs []CrawlerSpecLineageConfiguration
	if obj != nil {
		objs = []CrawlerSpecLineageConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CrawlerSpecLineageConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CrawlerSpecLineageConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CrawlerSpecLineageConfiguration)(ptr) = CrawlerSpecLineageConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CrawlerSpecLineageConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CrawlerSpecLineageConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CrawlerSpecLineageConfiguration)(ptr) = objs[0]
			} else {
				*(*CrawlerSpecLineageConfiguration)(ptr) = CrawlerSpecLineageConfiguration{}
			}
		} else {
			*(*CrawlerSpecLineageConfiguration)(ptr) = CrawlerSpecLineageConfiguration{}
		}
	default:
		iter.ReportError("decode CrawlerSpecLineageConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CrawlerSpecRecrawlPolicyCodec struct {
}

func (CrawlerSpecRecrawlPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CrawlerSpecRecrawlPolicy)(ptr) == nil
}

func (CrawlerSpecRecrawlPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CrawlerSpecRecrawlPolicy)(ptr)
	var objs []CrawlerSpecRecrawlPolicy
	if obj != nil {
		objs = []CrawlerSpecRecrawlPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CrawlerSpecRecrawlPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CrawlerSpecRecrawlPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CrawlerSpecRecrawlPolicy)(ptr) = CrawlerSpecRecrawlPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CrawlerSpecRecrawlPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CrawlerSpecRecrawlPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CrawlerSpecRecrawlPolicy)(ptr) = objs[0]
			} else {
				*(*CrawlerSpecRecrawlPolicy)(ptr) = CrawlerSpecRecrawlPolicy{}
			}
		} else {
			*(*CrawlerSpecRecrawlPolicy)(ptr) = CrawlerSpecRecrawlPolicy{}
		}
	default:
		iter.ReportError("decode CrawlerSpecRecrawlPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CrawlerSpecSchemaChangePolicyCodec struct {
}

func (CrawlerSpecSchemaChangePolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CrawlerSpecSchemaChangePolicy)(ptr) == nil
}

func (CrawlerSpecSchemaChangePolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CrawlerSpecSchemaChangePolicy)(ptr)
	var objs []CrawlerSpecSchemaChangePolicy
	if obj != nil {
		objs = []CrawlerSpecSchemaChangePolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CrawlerSpecSchemaChangePolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CrawlerSpecSchemaChangePolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CrawlerSpecSchemaChangePolicy)(ptr) = CrawlerSpecSchemaChangePolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CrawlerSpecSchemaChangePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CrawlerSpecSchemaChangePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CrawlerSpecSchemaChangePolicy)(ptr) = objs[0]
			} else {
				*(*CrawlerSpecSchemaChangePolicy)(ptr) = CrawlerSpecSchemaChangePolicy{}
			}
		} else {
			*(*CrawlerSpecSchemaChangePolicy)(ptr) = CrawlerSpecSchemaChangePolicy{}
		}
	default:
		iter.ReportError("decode CrawlerSpecSchemaChangePolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsCodec struct {
}

func (DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettings)(ptr) == nil
}

func (DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettings)(ptr)
	var objs []DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettings
	if obj != nil {
		objs = []DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettings)(ptr) = DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettings)(ptr) = objs[0]
			} else {
				*(*DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettings)(ptr) = DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettings{}
			}
		} else {
			*(*DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettings)(ptr) = DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettings{}
		}
	default:
		iter.ReportError("decode DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsConnectionPasswordEncryptionCodec struct {
}

func (DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsConnectionPasswordEncryptionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsConnectionPasswordEncryption)(ptr) == nil
}

func (DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsConnectionPasswordEncryptionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsConnectionPasswordEncryption)(ptr)
	var objs []DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsConnectionPasswordEncryption
	if obj != nil {
		objs = []DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsConnectionPasswordEncryption{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsConnectionPasswordEncryption{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsConnectionPasswordEncryptionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsConnectionPasswordEncryption)(ptr) = DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsConnectionPasswordEncryption{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsConnectionPasswordEncryption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsConnectionPasswordEncryption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsConnectionPasswordEncryption)(ptr) = objs[0]
			} else {
				*(*DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsConnectionPasswordEncryption)(ptr) = DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsConnectionPasswordEncryption{}
			}
		} else {
			*(*DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsConnectionPasswordEncryption)(ptr) = DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsConnectionPasswordEncryption{}
		}
	default:
		iter.ReportError("decode DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsConnectionPasswordEncryption", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsEncryptionAtRestCodec struct {
}

func (DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsEncryptionAtRestCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsEncryptionAtRest)(ptr) == nil
}

func (DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsEncryptionAtRestCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsEncryptionAtRest)(ptr)
	var objs []DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsEncryptionAtRest
	if obj != nil {
		objs = []DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsEncryptionAtRest{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsEncryptionAtRest{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsEncryptionAtRestCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsEncryptionAtRest)(ptr) = DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsEncryptionAtRest{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsEncryptionAtRest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsEncryptionAtRest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsEncryptionAtRest)(ptr) = objs[0]
			} else {
				*(*DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsEncryptionAtRest)(ptr) = DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsEncryptionAtRest{}
			}
		} else {
			*(*DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsEncryptionAtRest)(ptr) = DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsEncryptionAtRest{}
		}
	default:
		iter.ReportError("decode DataCatalogEncryptionSettingsSpecDataCatalogEncryptionSettingsEncryptionAtRest", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecCommandCodec struct {
}

func (JobSpecCommandCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecCommand)(ptr) == nil
}

func (JobSpecCommandCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecCommand)(ptr)
	var objs []JobSpecCommand
	if obj != nil {
		objs = []JobSpecCommand{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecCommand{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecCommandCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecCommand)(ptr) = JobSpecCommand{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecCommand

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecCommand{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecCommand)(ptr) = objs[0]
			} else {
				*(*JobSpecCommand)(ptr) = JobSpecCommand{}
			}
		} else {
			*(*JobSpecCommand)(ptr) = JobSpecCommand{}
		}
	default:
		iter.ReportError("decode JobSpecCommand", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecExecutionPropertyCodec struct {
}

func (JobSpecExecutionPropertyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecExecutionProperty)(ptr) == nil
}

func (JobSpecExecutionPropertyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecExecutionProperty)(ptr)
	var objs []JobSpecExecutionProperty
	if obj != nil {
		objs = []JobSpecExecutionProperty{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecExecutionProperty{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecExecutionPropertyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecExecutionProperty)(ptr) = JobSpecExecutionProperty{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecExecutionProperty

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecExecutionProperty{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecExecutionProperty)(ptr) = objs[0]
			} else {
				*(*JobSpecExecutionProperty)(ptr) = JobSpecExecutionProperty{}
			}
		} else {
			*(*JobSpecExecutionProperty)(ptr) = JobSpecExecutionProperty{}
		}
	default:
		iter.ReportError("decode JobSpecExecutionProperty", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecNotificationPropertyCodec struct {
}

func (JobSpecNotificationPropertyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecNotificationProperty)(ptr) == nil
}

func (JobSpecNotificationPropertyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecNotificationProperty)(ptr)
	var objs []JobSpecNotificationProperty
	if obj != nil {
		objs = []JobSpecNotificationProperty{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecNotificationProperty{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecNotificationPropertyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecNotificationProperty)(ptr) = JobSpecNotificationProperty{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecNotificationProperty

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecNotificationProperty{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecNotificationProperty)(ptr) = objs[0]
			} else {
				*(*JobSpecNotificationProperty)(ptr) = JobSpecNotificationProperty{}
			}
		} else {
			*(*JobSpecNotificationProperty)(ptr) = JobSpecNotificationProperty{}
		}
	default:
		iter.ReportError("decode JobSpecNotificationProperty", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MlTransformSpecParametersCodec struct {
}

func (MlTransformSpecParametersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MlTransformSpecParameters)(ptr) == nil
}

func (MlTransformSpecParametersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MlTransformSpecParameters)(ptr)
	var objs []MlTransformSpecParameters
	if obj != nil {
		objs = []MlTransformSpecParameters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MlTransformSpecParameters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MlTransformSpecParametersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MlTransformSpecParameters)(ptr) = MlTransformSpecParameters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MlTransformSpecParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MlTransformSpecParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MlTransformSpecParameters)(ptr) = objs[0]
			} else {
				*(*MlTransformSpecParameters)(ptr) = MlTransformSpecParameters{}
			}
		} else {
			*(*MlTransformSpecParameters)(ptr) = MlTransformSpecParameters{}
		}
	default:
		iter.ReportError("decode MlTransformSpecParameters", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MlTransformSpecParametersFindMatchesParametersCodec struct {
}

func (MlTransformSpecParametersFindMatchesParametersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MlTransformSpecParametersFindMatchesParameters)(ptr) == nil
}

func (MlTransformSpecParametersFindMatchesParametersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MlTransformSpecParametersFindMatchesParameters)(ptr)
	var objs []MlTransformSpecParametersFindMatchesParameters
	if obj != nil {
		objs = []MlTransformSpecParametersFindMatchesParameters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MlTransformSpecParametersFindMatchesParameters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MlTransformSpecParametersFindMatchesParametersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MlTransformSpecParametersFindMatchesParameters)(ptr) = MlTransformSpecParametersFindMatchesParameters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MlTransformSpecParametersFindMatchesParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MlTransformSpecParametersFindMatchesParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MlTransformSpecParametersFindMatchesParameters)(ptr) = objs[0]
			} else {
				*(*MlTransformSpecParametersFindMatchesParameters)(ptr) = MlTransformSpecParametersFindMatchesParameters{}
			}
		} else {
			*(*MlTransformSpecParametersFindMatchesParameters)(ptr) = MlTransformSpecParametersFindMatchesParameters{}
		}
	default:
		iter.ReportError("decode MlTransformSpecParametersFindMatchesParameters", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PartitionSpecStorageDescriptorCodec struct {
}

func (PartitionSpecStorageDescriptorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PartitionSpecStorageDescriptor)(ptr) == nil
}

func (PartitionSpecStorageDescriptorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PartitionSpecStorageDescriptor)(ptr)
	var objs []PartitionSpecStorageDescriptor
	if obj != nil {
		objs = []PartitionSpecStorageDescriptor{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PartitionSpecStorageDescriptor{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PartitionSpecStorageDescriptorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PartitionSpecStorageDescriptor)(ptr) = PartitionSpecStorageDescriptor{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PartitionSpecStorageDescriptor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PartitionSpecStorageDescriptor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PartitionSpecStorageDescriptor)(ptr) = objs[0]
			} else {
				*(*PartitionSpecStorageDescriptor)(ptr) = PartitionSpecStorageDescriptor{}
			}
		} else {
			*(*PartitionSpecStorageDescriptor)(ptr) = PartitionSpecStorageDescriptor{}
		}
	default:
		iter.ReportError("decode PartitionSpecStorageDescriptor", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PartitionSpecStorageDescriptorSerDeInfoCodec struct {
}

func (PartitionSpecStorageDescriptorSerDeInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PartitionSpecStorageDescriptorSerDeInfo)(ptr) == nil
}

func (PartitionSpecStorageDescriptorSerDeInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PartitionSpecStorageDescriptorSerDeInfo)(ptr)
	var objs []PartitionSpecStorageDescriptorSerDeInfo
	if obj != nil {
		objs = []PartitionSpecStorageDescriptorSerDeInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PartitionSpecStorageDescriptorSerDeInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PartitionSpecStorageDescriptorSerDeInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PartitionSpecStorageDescriptorSerDeInfo)(ptr) = PartitionSpecStorageDescriptorSerDeInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PartitionSpecStorageDescriptorSerDeInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PartitionSpecStorageDescriptorSerDeInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PartitionSpecStorageDescriptorSerDeInfo)(ptr) = objs[0]
			} else {
				*(*PartitionSpecStorageDescriptorSerDeInfo)(ptr) = PartitionSpecStorageDescriptorSerDeInfo{}
			}
		} else {
			*(*PartitionSpecStorageDescriptorSerDeInfo)(ptr) = PartitionSpecStorageDescriptorSerDeInfo{}
		}
	default:
		iter.ReportError("decode PartitionSpecStorageDescriptorSerDeInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PartitionSpecStorageDescriptorSkewedInfoCodec struct {
}

func (PartitionSpecStorageDescriptorSkewedInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PartitionSpecStorageDescriptorSkewedInfo)(ptr) == nil
}

func (PartitionSpecStorageDescriptorSkewedInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PartitionSpecStorageDescriptorSkewedInfo)(ptr)
	var objs []PartitionSpecStorageDescriptorSkewedInfo
	if obj != nil {
		objs = []PartitionSpecStorageDescriptorSkewedInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PartitionSpecStorageDescriptorSkewedInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PartitionSpecStorageDescriptorSkewedInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PartitionSpecStorageDescriptorSkewedInfo)(ptr) = PartitionSpecStorageDescriptorSkewedInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PartitionSpecStorageDescriptorSkewedInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PartitionSpecStorageDescriptorSkewedInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PartitionSpecStorageDescriptorSkewedInfo)(ptr) = objs[0]
			} else {
				*(*PartitionSpecStorageDescriptorSkewedInfo)(ptr) = PartitionSpecStorageDescriptorSkewedInfo{}
			}
		} else {
			*(*PartitionSpecStorageDescriptorSkewedInfo)(ptr) = PartitionSpecStorageDescriptorSkewedInfo{}
		}
	default:
		iter.ReportError("decode PartitionSpecStorageDescriptorSkewedInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SecurityConfigurationSpecEncryptionConfigurationCodec struct {
}

func (SecurityConfigurationSpecEncryptionConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SecurityConfigurationSpecEncryptionConfiguration)(ptr) == nil
}

func (SecurityConfigurationSpecEncryptionConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SecurityConfigurationSpecEncryptionConfiguration)(ptr)
	var objs []SecurityConfigurationSpecEncryptionConfiguration
	if obj != nil {
		objs = []SecurityConfigurationSpecEncryptionConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityConfigurationSpecEncryptionConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SecurityConfigurationSpecEncryptionConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SecurityConfigurationSpecEncryptionConfiguration)(ptr) = SecurityConfigurationSpecEncryptionConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SecurityConfigurationSpecEncryptionConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityConfigurationSpecEncryptionConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SecurityConfigurationSpecEncryptionConfiguration)(ptr) = objs[0]
			} else {
				*(*SecurityConfigurationSpecEncryptionConfiguration)(ptr) = SecurityConfigurationSpecEncryptionConfiguration{}
			}
		} else {
			*(*SecurityConfigurationSpecEncryptionConfiguration)(ptr) = SecurityConfigurationSpecEncryptionConfiguration{}
		}
	default:
		iter.ReportError("decode SecurityConfigurationSpecEncryptionConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SecurityConfigurationSpecEncryptionConfigurationCloudwatchEncryptionCodec struct {
}

func (SecurityConfigurationSpecEncryptionConfigurationCloudwatchEncryptionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SecurityConfigurationSpecEncryptionConfigurationCloudwatchEncryption)(ptr) == nil
}

func (SecurityConfigurationSpecEncryptionConfigurationCloudwatchEncryptionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SecurityConfigurationSpecEncryptionConfigurationCloudwatchEncryption)(ptr)
	var objs []SecurityConfigurationSpecEncryptionConfigurationCloudwatchEncryption
	if obj != nil {
		objs = []SecurityConfigurationSpecEncryptionConfigurationCloudwatchEncryption{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityConfigurationSpecEncryptionConfigurationCloudwatchEncryption{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SecurityConfigurationSpecEncryptionConfigurationCloudwatchEncryptionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SecurityConfigurationSpecEncryptionConfigurationCloudwatchEncryption)(ptr) = SecurityConfigurationSpecEncryptionConfigurationCloudwatchEncryption{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SecurityConfigurationSpecEncryptionConfigurationCloudwatchEncryption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityConfigurationSpecEncryptionConfigurationCloudwatchEncryption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SecurityConfigurationSpecEncryptionConfigurationCloudwatchEncryption)(ptr) = objs[0]
			} else {
				*(*SecurityConfigurationSpecEncryptionConfigurationCloudwatchEncryption)(ptr) = SecurityConfigurationSpecEncryptionConfigurationCloudwatchEncryption{}
			}
		} else {
			*(*SecurityConfigurationSpecEncryptionConfigurationCloudwatchEncryption)(ptr) = SecurityConfigurationSpecEncryptionConfigurationCloudwatchEncryption{}
		}
	default:
		iter.ReportError("decode SecurityConfigurationSpecEncryptionConfigurationCloudwatchEncryption", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SecurityConfigurationSpecEncryptionConfigurationJobBookmarksEncryptionCodec struct {
}

func (SecurityConfigurationSpecEncryptionConfigurationJobBookmarksEncryptionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SecurityConfigurationSpecEncryptionConfigurationJobBookmarksEncryption)(ptr) == nil
}

func (SecurityConfigurationSpecEncryptionConfigurationJobBookmarksEncryptionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SecurityConfigurationSpecEncryptionConfigurationJobBookmarksEncryption)(ptr)
	var objs []SecurityConfigurationSpecEncryptionConfigurationJobBookmarksEncryption
	if obj != nil {
		objs = []SecurityConfigurationSpecEncryptionConfigurationJobBookmarksEncryption{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityConfigurationSpecEncryptionConfigurationJobBookmarksEncryption{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SecurityConfigurationSpecEncryptionConfigurationJobBookmarksEncryptionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SecurityConfigurationSpecEncryptionConfigurationJobBookmarksEncryption)(ptr) = SecurityConfigurationSpecEncryptionConfigurationJobBookmarksEncryption{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SecurityConfigurationSpecEncryptionConfigurationJobBookmarksEncryption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityConfigurationSpecEncryptionConfigurationJobBookmarksEncryption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SecurityConfigurationSpecEncryptionConfigurationJobBookmarksEncryption)(ptr) = objs[0]
			} else {
				*(*SecurityConfigurationSpecEncryptionConfigurationJobBookmarksEncryption)(ptr) = SecurityConfigurationSpecEncryptionConfigurationJobBookmarksEncryption{}
			}
		} else {
			*(*SecurityConfigurationSpecEncryptionConfigurationJobBookmarksEncryption)(ptr) = SecurityConfigurationSpecEncryptionConfigurationJobBookmarksEncryption{}
		}
	default:
		iter.ReportError("decode SecurityConfigurationSpecEncryptionConfigurationJobBookmarksEncryption", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SecurityConfigurationSpecEncryptionConfigurationS3EncryptionCodec struct {
}

func (SecurityConfigurationSpecEncryptionConfigurationS3EncryptionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SecurityConfigurationSpecEncryptionConfigurationS3Encryption)(ptr) == nil
}

func (SecurityConfigurationSpecEncryptionConfigurationS3EncryptionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SecurityConfigurationSpecEncryptionConfigurationS3Encryption)(ptr)
	var objs []SecurityConfigurationSpecEncryptionConfigurationS3Encryption
	if obj != nil {
		objs = []SecurityConfigurationSpecEncryptionConfigurationS3Encryption{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityConfigurationSpecEncryptionConfigurationS3Encryption{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SecurityConfigurationSpecEncryptionConfigurationS3EncryptionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SecurityConfigurationSpecEncryptionConfigurationS3Encryption)(ptr) = SecurityConfigurationSpecEncryptionConfigurationS3Encryption{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SecurityConfigurationSpecEncryptionConfigurationS3Encryption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SecurityConfigurationSpecEncryptionConfigurationS3Encryption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SecurityConfigurationSpecEncryptionConfigurationS3Encryption)(ptr) = objs[0]
			} else {
				*(*SecurityConfigurationSpecEncryptionConfigurationS3Encryption)(ptr) = SecurityConfigurationSpecEncryptionConfigurationS3Encryption{}
			}
		} else {
			*(*SecurityConfigurationSpecEncryptionConfigurationS3Encryption)(ptr) = SecurityConfigurationSpecEncryptionConfigurationS3Encryption{}
		}
	default:
		iter.ReportError("decode SecurityConfigurationSpecEncryptionConfigurationS3Encryption", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TriggerSpecActionsNotificationPropertyCodec struct {
}

func (TriggerSpecActionsNotificationPropertyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TriggerSpecActionsNotificationProperty)(ptr) == nil
}

func (TriggerSpecActionsNotificationPropertyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TriggerSpecActionsNotificationProperty)(ptr)
	var objs []TriggerSpecActionsNotificationProperty
	if obj != nil {
		objs = []TriggerSpecActionsNotificationProperty{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecActionsNotificationProperty{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TriggerSpecActionsNotificationPropertyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TriggerSpecActionsNotificationProperty)(ptr) = TriggerSpecActionsNotificationProperty{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TriggerSpecActionsNotificationProperty

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecActionsNotificationProperty{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TriggerSpecActionsNotificationProperty)(ptr) = objs[0]
			} else {
				*(*TriggerSpecActionsNotificationProperty)(ptr) = TriggerSpecActionsNotificationProperty{}
			}
		} else {
			*(*TriggerSpecActionsNotificationProperty)(ptr) = TriggerSpecActionsNotificationProperty{}
		}
	default:
		iter.ReportError("decode TriggerSpecActionsNotificationProperty", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TriggerSpecPredicateCodec struct {
}

func (TriggerSpecPredicateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TriggerSpecPredicate)(ptr) == nil
}

func (TriggerSpecPredicateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TriggerSpecPredicate)(ptr)
	var objs []TriggerSpecPredicate
	if obj != nil {
		objs = []TriggerSpecPredicate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecPredicate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TriggerSpecPredicateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TriggerSpecPredicate)(ptr) = TriggerSpecPredicate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TriggerSpecPredicate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TriggerSpecPredicate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TriggerSpecPredicate)(ptr) = objs[0]
			} else {
				*(*TriggerSpecPredicate)(ptr) = TriggerSpecPredicate{}
			}
		} else {
			*(*TriggerSpecPredicate)(ptr) = TriggerSpecPredicate{}
		}
	default:
		iter.ReportError("decode TriggerSpecPredicate", "unexpected JSON type")
	}
}
