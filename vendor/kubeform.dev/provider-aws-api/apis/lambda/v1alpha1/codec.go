/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AliasSpecRoutingConfig{}).Type1()):                                  AliasSpecRoutingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CodeSigningConfigSpecAllowedPublishers{}).Type1()):                  CodeSigningConfigSpecAllowedPublishersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CodeSigningConfigSpecPolicies{}).Type1()):                           CodeSigningConfigSpecPoliciesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSourceMappingSpecDestinationConfig{}).Type1()):                 EventSourceMappingSpecDestinationConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSourceMappingSpecDestinationConfigOnFailure{}).Type1()):        EventSourceMappingSpecDestinationConfigOnFailureCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecDeadLetterConfig{}).Type1()):                            FunctionSpecDeadLetterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecEnvironment{}).Type1()):                                 FunctionSpecEnvironmentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecFileSystemConfig{}).Type1()):                            FunctionSpecFileSystemConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecImageConfig{}).Type1()):                                 FunctionSpecImageConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecTracingConfig{}).Type1()):                               FunctionSpecTracingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecVpcConfig{}).Type1()):                                   FunctionSpecVpcConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FunctionEventInvokeConfigSpecDestinationConfig{}).Type1()):          FunctionEventInvokeConfigSpecDestinationConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FunctionEventInvokeConfigSpecDestinationConfigOnFailure{}).Type1()): FunctionEventInvokeConfigSpecDestinationConfigOnFailureCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FunctionEventInvokeConfigSpecDestinationConfigOnSuccess{}).Type1()): FunctionEventInvokeConfigSpecDestinationConfigOnSuccessCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AliasSpecRoutingConfig{}).Type1()):                                  AliasSpecRoutingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CodeSigningConfigSpecAllowedPublishers{}).Type1()):                  CodeSigningConfigSpecAllowedPublishersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CodeSigningConfigSpecPolicies{}).Type1()):                           CodeSigningConfigSpecPoliciesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSourceMappingSpecDestinationConfig{}).Type1()):                 EventSourceMappingSpecDestinationConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSourceMappingSpecDestinationConfigOnFailure{}).Type1()):        EventSourceMappingSpecDestinationConfigOnFailureCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecDeadLetterConfig{}).Type1()):                            FunctionSpecDeadLetterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecEnvironment{}).Type1()):                                 FunctionSpecEnvironmentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecFileSystemConfig{}).Type1()):                            FunctionSpecFileSystemConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecImageConfig{}).Type1()):                                 FunctionSpecImageConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecTracingConfig{}).Type1()):                               FunctionSpecTracingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecVpcConfig{}).Type1()):                                   FunctionSpecVpcConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FunctionEventInvokeConfigSpecDestinationConfig{}).Type1()):          FunctionEventInvokeConfigSpecDestinationConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FunctionEventInvokeConfigSpecDestinationConfigOnFailure{}).Type1()): FunctionEventInvokeConfigSpecDestinationConfigOnFailureCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FunctionEventInvokeConfigSpecDestinationConfigOnSuccess{}).Type1()): FunctionEventInvokeConfigSpecDestinationConfigOnSuccessCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AliasSpecRoutingConfigCodec struct {
}

func (AliasSpecRoutingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AliasSpecRoutingConfig)(ptr) == nil
}

func (AliasSpecRoutingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AliasSpecRoutingConfig)(ptr)
	var objs []AliasSpecRoutingConfig
	if obj != nil {
		objs = []AliasSpecRoutingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AliasSpecRoutingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AliasSpecRoutingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AliasSpecRoutingConfig)(ptr) = AliasSpecRoutingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AliasSpecRoutingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AliasSpecRoutingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AliasSpecRoutingConfig)(ptr) = objs[0]
			} else {
				*(*AliasSpecRoutingConfig)(ptr) = AliasSpecRoutingConfig{}
			}
		} else {
			*(*AliasSpecRoutingConfig)(ptr) = AliasSpecRoutingConfig{}
		}
	default:
		iter.ReportError("decode AliasSpecRoutingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CodeSigningConfigSpecAllowedPublishersCodec struct {
}

func (CodeSigningConfigSpecAllowedPublishersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CodeSigningConfigSpecAllowedPublishers)(ptr) == nil
}

func (CodeSigningConfigSpecAllowedPublishersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CodeSigningConfigSpecAllowedPublishers)(ptr)
	var objs []CodeSigningConfigSpecAllowedPublishers
	if obj != nil {
		objs = []CodeSigningConfigSpecAllowedPublishers{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CodeSigningConfigSpecAllowedPublishers{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CodeSigningConfigSpecAllowedPublishersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CodeSigningConfigSpecAllowedPublishers)(ptr) = CodeSigningConfigSpecAllowedPublishers{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CodeSigningConfigSpecAllowedPublishers

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CodeSigningConfigSpecAllowedPublishers{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CodeSigningConfigSpecAllowedPublishers)(ptr) = objs[0]
			} else {
				*(*CodeSigningConfigSpecAllowedPublishers)(ptr) = CodeSigningConfigSpecAllowedPublishers{}
			}
		} else {
			*(*CodeSigningConfigSpecAllowedPublishers)(ptr) = CodeSigningConfigSpecAllowedPublishers{}
		}
	default:
		iter.ReportError("decode CodeSigningConfigSpecAllowedPublishers", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CodeSigningConfigSpecPoliciesCodec struct {
}

func (CodeSigningConfigSpecPoliciesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CodeSigningConfigSpecPolicies)(ptr) == nil
}

func (CodeSigningConfigSpecPoliciesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CodeSigningConfigSpecPolicies)(ptr)
	var objs []CodeSigningConfigSpecPolicies
	if obj != nil {
		objs = []CodeSigningConfigSpecPolicies{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CodeSigningConfigSpecPolicies{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CodeSigningConfigSpecPoliciesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CodeSigningConfigSpecPolicies)(ptr) = CodeSigningConfigSpecPolicies{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CodeSigningConfigSpecPolicies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CodeSigningConfigSpecPolicies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CodeSigningConfigSpecPolicies)(ptr) = objs[0]
			} else {
				*(*CodeSigningConfigSpecPolicies)(ptr) = CodeSigningConfigSpecPolicies{}
			}
		} else {
			*(*CodeSigningConfigSpecPolicies)(ptr) = CodeSigningConfigSpecPolicies{}
		}
	default:
		iter.ReportError("decode CodeSigningConfigSpecPolicies", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventSourceMappingSpecDestinationConfigCodec struct {
}

func (EventSourceMappingSpecDestinationConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventSourceMappingSpecDestinationConfig)(ptr) == nil
}

func (EventSourceMappingSpecDestinationConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventSourceMappingSpecDestinationConfig)(ptr)
	var objs []EventSourceMappingSpecDestinationConfig
	if obj != nil {
		objs = []EventSourceMappingSpecDestinationConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSourceMappingSpecDestinationConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventSourceMappingSpecDestinationConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventSourceMappingSpecDestinationConfig)(ptr) = EventSourceMappingSpecDestinationConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventSourceMappingSpecDestinationConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSourceMappingSpecDestinationConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventSourceMappingSpecDestinationConfig)(ptr) = objs[0]
			} else {
				*(*EventSourceMappingSpecDestinationConfig)(ptr) = EventSourceMappingSpecDestinationConfig{}
			}
		} else {
			*(*EventSourceMappingSpecDestinationConfig)(ptr) = EventSourceMappingSpecDestinationConfig{}
		}
	default:
		iter.ReportError("decode EventSourceMappingSpecDestinationConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventSourceMappingSpecDestinationConfigOnFailureCodec struct {
}

func (EventSourceMappingSpecDestinationConfigOnFailureCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventSourceMappingSpecDestinationConfigOnFailure)(ptr) == nil
}

func (EventSourceMappingSpecDestinationConfigOnFailureCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventSourceMappingSpecDestinationConfigOnFailure)(ptr)
	var objs []EventSourceMappingSpecDestinationConfigOnFailure
	if obj != nil {
		objs = []EventSourceMappingSpecDestinationConfigOnFailure{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSourceMappingSpecDestinationConfigOnFailure{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventSourceMappingSpecDestinationConfigOnFailureCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventSourceMappingSpecDestinationConfigOnFailure)(ptr) = EventSourceMappingSpecDestinationConfigOnFailure{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventSourceMappingSpecDestinationConfigOnFailure

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSourceMappingSpecDestinationConfigOnFailure{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventSourceMappingSpecDestinationConfigOnFailure)(ptr) = objs[0]
			} else {
				*(*EventSourceMappingSpecDestinationConfigOnFailure)(ptr) = EventSourceMappingSpecDestinationConfigOnFailure{}
			}
		} else {
			*(*EventSourceMappingSpecDestinationConfigOnFailure)(ptr) = EventSourceMappingSpecDestinationConfigOnFailure{}
		}
	default:
		iter.ReportError("decode EventSourceMappingSpecDestinationConfigOnFailure", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FunctionSpecDeadLetterConfigCodec struct {
}

func (FunctionSpecDeadLetterConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FunctionSpecDeadLetterConfig)(ptr) == nil
}

func (FunctionSpecDeadLetterConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FunctionSpecDeadLetterConfig)(ptr)
	var objs []FunctionSpecDeadLetterConfig
	if obj != nil {
		objs = []FunctionSpecDeadLetterConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecDeadLetterConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FunctionSpecDeadLetterConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FunctionSpecDeadLetterConfig)(ptr) = FunctionSpecDeadLetterConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FunctionSpecDeadLetterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecDeadLetterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FunctionSpecDeadLetterConfig)(ptr) = objs[0]
			} else {
				*(*FunctionSpecDeadLetterConfig)(ptr) = FunctionSpecDeadLetterConfig{}
			}
		} else {
			*(*FunctionSpecDeadLetterConfig)(ptr) = FunctionSpecDeadLetterConfig{}
		}
	default:
		iter.ReportError("decode FunctionSpecDeadLetterConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FunctionSpecEnvironmentCodec struct {
}

func (FunctionSpecEnvironmentCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FunctionSpecEnvironment)(ptr) == nil
}

func (FunctionSpecEnvironmentCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FunctionSpecEnvironment)(ptr)
	var objs []FunctionSpecEnvironment
	if obj != nil {
		objs = []FunctionSpecEnvironment{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecEnvironment{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FunctionSpecEnvironmentCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FunctionSpecEnvironment)(ptr) = FunctionSpecEnvironment{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FunctionSpecEnvironment

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecEnvironment{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FunctionSpecEnvironment)(ptr) = objs[0]
			} else {
				*(*FunctionSpecEnvironment)(ptr) = FunctionSpecEnvironment{}
			}
		} else {
			*(*FunctionSpecEnvironment)(ptr) = FunctionSpecEnvironment{}
		}
	default:
		iter.ReportError("decode FunctionSpecEnvironment", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FunctionSpecFileSystemConfigCodec struct {
}

func (FunctionSpecFileSystemConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FunctionSpecFileSystemConfig)(ptr) == nil
}

func (FunctionSpecFileSystemConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FunctionSpecFileSystemConfig)(ptr)
	var objs []FunctionSpecFileSystemConfig
	if obj != nil {
		objs = []FunctionSpecFileSystemConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecFileSystemConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FunctionSpecFileSystemConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FunctionSpecFileSystemConfig)(ptr) = FunctionSpecFileSystemConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FunctionSpecFileSystemConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecFileSystemConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FunctionSpecFileSystemConfig)(ptr) = objs[0]
			} else {
				*(*FunctionSpecFileSystemConfig)(ptr) = FunctionSpecFileSystemConfig{}
			}
		} else {
			*(*FunctionSpecFileSystemConfig)(ptr) = FunctionSpecFileSystemConfig{}
		}
	default:
		iter.ReportError("decode FunctionSpecFileSystemConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FunctionSpecImageConfigCodec struct {
}

func (FunctionSpecImageConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FunctionSpecImageConfig)(ptr) == nil
}

func (FunctionSpecImageConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FunctionSpecImageConfig)(ptr)
	var objs []FunctionSpecImageConfig
	if obj != nil {
		objs = []FunctionSpecImageConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecImageConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FunctionSpecImageConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FunctionSpecImageConfig)(ptr) = FunctionSpecImageConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FunctionSpecImageConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecImageConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FunctionSpecImageConfig)(ptr) = objs[0]
			} else {
				*(*FunctionSpecImageConfig)(ptr) = FunctionSpecImageConfig{}
			}
		} else {
			*(*FunctionSpecImageConfig)(ptr) = FunctionSpecImageConfig{}
		}
	default:
		iter.ReportError("decode FunctionSpecImageConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FunctionSpecTracingConfigCodec struct {
}

func (FunctionSpecTracingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FunctionSpecTracingConfig)(ptr) == nil
}

func (FunctionSpecTracingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FunctionSpecTracingConfig)(ptr)
	var objs []FunctionSpecTracingConfig
	if obj != nil {
		objs = []FunctionSpecTracingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecTracingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FunctionSpecTracingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FunctionSpecTracingConfig)(ptr) = FunctionSpecTracingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FunctionSpecTracingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecTracingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FunctionSpecTracingConfig)(ptr) = objs[0]
			} else {
				*(*FunctionSpecTracingConfig)(ptr) = FunctionSpecTracingConfig{}
			}
		} else {
			*(*FunctionSpecTracingConfig)(ptr) = FunctionSpecTracingConfig{}
		}
	default:
		iter.ReportError("decode FunctionSpecTracingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FunctionSpecVpcConfigCodec struct {
}

func (FunctionSpecVpcConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FunctionSpecVpcConfig)(ptr) == nil
}

func (FunctionSpecVpcConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FunctionSpecVpcConfig)(ptr)
	var objs []FunctionSpecVpcConfig
	if obj != nil {
		objs = []FunctionSpecVpcConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecVpcConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FunctionSpecVpcConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FunctionSpecVpcConfig)(ptr) = FunctionSpecVpcConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FunctionSpecVpcConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FunctionSpecVpcConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FunctionSpecVpcConfig)(ptr) = objs[0]
			} else {
				*(*FunctionSpecVpcConfig)(ptr) = FunctionSpecVpcConfig{}
			}
		} else {
			*(*FunctionSpecVpcConfig)(ptr) = FunctionSpecVpcConfig{}
		}
	default:
		iter.ReportError("decode FunctionSpecVpcConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FunctionEventInvokeConfigSpecDestinationConfigCodec struct {
}

func (FunctionEventInvokeConfigSpecDestinationConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FunctionEventInvokeConfigSpecDestinationConfig)(ptr) == nil
}

func (FunctionEventInvokeConfigSpecDestinationConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FunctionEventInvokeConfigSpecDestinationConfig)(ptr)
	var objs []FunctionEventInvokeConfigSpecDestinationConfig
	if obj != nil {
		objs = []FunctionEventInvokeConfigSpecDestinationConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FunctionEventInvokeConfigSpecDestinationConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FunctionEventInvokeConfigSpecDestinationConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FunctionEventInvokeConfigSpecDestinationConfig)(ptr) = FunctionEventInvokeConfigSpecDestinationConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FunctionEventInvokeConfigSpecDestinationConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FunctionEventInvokeConfigSpecDestinationConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FunctionEventInvokeConfigSpecDestinationConfig)(ptr) = objs[0]
			} else {
				*(*FunctionEventInvokeConfigSpecDestinationConfig)(ptr) = FunctionEventInvokeConfigSpecDestinationConfig{}
			}
		} else {
			*(*FunctionEventInvokeConfigSpecDestinationConfig)(ptr) = FunctionEventInvokeConfigSpecDestinationConfig{}
		}
	default:
		iter.ReportError("decode FunctionEventInvokeConfigSpecDestinationConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FunctionEventInvokeConfigSpecDestinationConfigOnFailureCodec struct {
}

func (FunctionEventInvokeConfigSpecDestinationConfigOnFailureCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FunctionEventInvokeConfigSpecDestinationConfigOnFailure)(ptr) == nil
}

func (FunctionEventInvokeConfigSpecDestinationConfigOnFailureCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FunctionEventInvokeConfigSpecDestinationConfigOnFailure)(ptr)
	var objs []FunctionEventInvokeConfigSpecDestinationConfigOnFailure
	if obj != nil {
		objs = []FunctionEventInvokeConfigSpecDestinationConfigOnFailure{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FunctionEventInvokeConfigSpecDestinationConfigOnFailure{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FunctionEventInvokeConfigSpecDestinationConfigOnFailureCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FunctionEventInvokeConfigSpecDestinationConfigOnFailure)(ptr) = FunctionEventInvokeConfigSpecDestinationConfigOnFailure{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FunctionEventInvokeConfigSpecDestinationConfigOnFailure

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FunctionEventInvokeConfigSpecDestinationConfigOnFailure{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FunctionEventInvokeConfigSpecDestinationConfigOnFailure)(ptr) = objs[0]
			} else {
				*(*FunctionEventInvokeConfigSpecDestinationConfigOnFailure)(ptr) = FunctionEventInvokeConfigSpecDestinationConfigOnFailure{}
			}
		} else {
			*(*FunctionEventInvokeConfigSpecDestinationConfigOnFailure)(ptr) = FunctionEventInvokeConfigSpecDestinationConfigOnFailure{}
		}
	default:
		iter.ReportError("decode FunctionEventInvokeConfigSpecDestinationConfigOnFailure", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FunctionEventInvokeConfigSpecDestinationConfigOnSuccessCodec struct {
}

func (FunctionEventInvokeConfigSpecDestinationConfigOnSuccessCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FunctionEventInvokeConfigSpecDestinationConfigOnSuccess)(ptr) == nil
}

func (FunctionEventInvokeConfigSpecDestinationConfigOnSuccessCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FunctionEventInvokeConfigSpecDestinationConfigOnSuccess)(ptr)
	var objs []FunctionEventInvokeConfigSpecDestinationConfigOnSuccess
	if obj != nil {
		objs = []FunctionEventInvokeConfigSpecDestinationConfigOnSuccess{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FunctionEventInvokeConfigSpecDestinationConfigOnSuccess{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FunctionEventInvokeConfigSpecDestinationConfigOnSuccessCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FunctionEventInvokeConfigSpecDestinationConfigOnSuccess)(ptr) = FunctionEventInvokeConfigSpecDestinationConfigOnSuccess{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FunctionEventInvokeConfigSpecDestinationConfigOnSuccess

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FunctionEventInvokeConfigSpecDestinationConfigOnSuccess{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FunctionEventInvokeConfigSpecDestinationConfigOnSuccess)(ptr) = objs[0]
			} else {
				*(*FunctionEventInvokeConfigSpecDestinationConfigOnSuccess)(ptr) = FunctionEventInvokeConfigSpecDestinationConfigOnSuccess{}
			}
		} else {
			*(*FunctionEventInvokeConfigSpecDestinationConfigOnSuccess)(ptr) = FunctionEventInvokeConfigSpecDestinationConfigOnSuccess{}
		}
	default:
		iter.ReportError("decode FunctionEventInvokeConfigSpecDestinationConfigOnSuccess", "unexpected JSON type")
	}
}
