/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpec{}).Type1()):                                                                          GatewayRouteSpecSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecGrpcRoute{}).Type1()):                                                                 GatewayRouteSpecSpecGrpcRouteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecGrpcRouteAction{}).Type1()):                                                           GatewayRouteSpecSpecGrpcRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecGrpcRouteActionTarget{}).Type1()):                                                     GatewayRouteSpecSpecGrpcRouteActionTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecGrpcRouteActionTargetVirtualService{}).Type1()):                                       GatewayRouteSpecSpecGrpcRouteActionTargetVirtualServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecGrpcRouteMatch{}).Type1()):                                                            GatewayRouteSpecSpecGrpcRouteMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttp2Route{}).Type1()):                                                                GatewayRouteSpecSpecHttp2RouteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttp2RouteAction{}).Type1()):                                                          GatewayRouteSpecSpecHttp2RouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttp2RouteActionTarget{}).Type1()):                                                    GatewayRouteSpecSpecHttp2RouteActionTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttp2RouteActionTargetVirtualService{}).Type1()):                                      GatewayRouteSpecSpecHttp2RouteActionTargetVirtualServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttp2RouteMatch{}).Type1()):                                                           GatewayRouteSpecSpecHttp2RouteMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttpRoute{}).Type1()):                                                                 GatewayRouteSpecSpecHttpRouteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttpRouteAction{}).Type1()):                                                           GatewayRouteSpecSpecHttpRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttpRouteActionTarget{}).Type1()):                                                     GatewayRouteSpecSpecHttpRouteActionTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttpRouteActionTargetVirtualService{}).Type1()):                                       GatewayRouteSpecSpecHttpRouteActionTargetVirtualServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttpRouteMatch{}).Type1()):                                                            GatewayRouteSpecSpecHttpRouteMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MeshSpecSpec{}).Type1()):                                                                                  MeshSpecSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MeshSpecSpecEgressFilter{}).Type1()):                                                                      MeshSpecSpecEgressFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpec{}).Type1()):                                                                                 RouteSpecSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRoute{}).Type1()):                                                                        RouteSpecSpecGrpcRouteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteAction{}).Type1()):                                                                  RouteSpecSpecGrpcRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteMatch{}).Type1()):                                                                   RouteSpecSpecGrpcRouteMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteMatchMetadataMatch{}).Type1()):                                                      RouteSpecSpecGrpcRouteMatchMetadataMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteMatchMetadataMatchRange{}).Type1()):                                                 RouteSpecSpecGrpcRouteMatchMetadataMatchRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteRetryPolicy{}).Type1()):                                                             RouteSpecSpecGrpcRouteRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteRetryPolicyPerRetryTimeout{}).Type1()):                                              RouteSpecSpecGrpcRouteRetryPolicyPerRetryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteTimeout{}).Type1()):                                                                 RouteSpecSpecGrpcRouteTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteTimeoutIdle{}).Type1()):                                                             RouteSpecSpecGrpcRouteTimeoutIdleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteTimeoutPerRequest{}).Type1()):                                                       RouteSpecSpecGrpcRouteTimeoutPerRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2Route{}).Type1()):                                                                       RouteSpecSpecHttp2RouteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteAction{}).Type1()):                                                                 RouteSpecSpecHttp2RouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteMatch{}).Type1()):                                                                  RouteSpecSpecHttp2RouteMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteMatchHeaderMatch{}).Type1()):                                                       RouteSpecSpecHttp2RouteMatchHeaderMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteMatchHeaderMatchRange{}).Type1()):                                                  RouteSpecSpecHttp2RouteMatchHeaderMatchRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteRetryPolicy{}).Type1()):                                                            RouteSpecSpecHttp2RouteRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteRetryPolicyPerRetryTimeout{}).Type1()):                                             RouteSpecSpecHttp2RouteRetryPolicyPerRetryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteTimeout{}).Type1()):                                                                RouteSpecSpecHttp2RouteTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteTimeoutIdle{}).Type1()):                                                            RouteSpecSpecHttp2RouteTimeoutIdleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteTimeoutPerRequest{}).Type1()):                                                      RouteSpecSpecHttp2RouteTimeoutPerRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRoute{}).Type1()):                                                                        RouteSpecSpecHttpRouteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteAction{}).Type1()):                                                                  RouteSpecSpecHttpRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteMatch{}).Type1()):                                                                   RouteSpecSpecHttpRouteMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteMatchHeaderMatch{}).Type1()):                                                        RouteSpecSpecHttpRouteMatchHeaderMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteMatchHeaderMatchRange{}).Type1()):                                                   RouteSpecSpecHttpRouteMatchHeaderMatchRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteRetryPolicy{}).Type1()):                                                             RouteSpecSpecHttpRouteRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteRetryPolicyPerRetryTimeout{}).Type1()):                                              RouteSpecSpecHttpRouteRetryPolicyPerRetryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteTimeout{}).Type1()):                                                                 RouteSpecSpecHttpRouteTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteTimeoutIdle{}).Type1()):                                                             RouteSpecSpecHttpRouteTimeoutIdleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteTimeoutPerRequest{}).Type1()):                                                       RouteSpecSpecHttpRouteTimeoutPerRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecTcpRoute{}).Type1()):                                                                         RouteSpecSpecTcpRouteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecTcpRouteAction{}).Type1()):                                                                   RouteSpecSpecTcpRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecTcpRouteTimeout{}).Type1()):                                                                  RouteSpecSpecTcpRouteTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecTcpRouteTimeoutIdle{}).Type1()):                                                              RouteSpecSpecTcpRouteTimeoutIdleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpec{}).Type1()):                                                                        VirtualGatewaySpecSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaults{}).Type1()):                                                         VirtualGatewaySpecSpecBackendDefaultsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicy{}).Type1()):                                             VirtualGatewaySpecSpecBackendDefaultsClientPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTls{}).Type1()):                                          VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificate{}).Type1()):                               VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateFile{}).Type1()):                           VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateSds{}).Type1()):                            VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateSdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidation{}).Type1()):                                VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames{}).Type1()):         VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch{}).Type1()):    VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrust{}).Type1()):                           VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm{}).Type1()):                        VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcmCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile{}).Type1()):                       VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds{}).Type1()):                        VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustSdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListener{}).Type1()):                                                                VirtualGatewaySpecSpecListenerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerConnectionPool{}).Type1()):                                                  VirtualGatewaySpecSpecListenerConnectionPoolCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerConnectionPoolGrpc{}).Type1()):                                              VirtualGatewaySpecSpecListenerConnectionPoolGrpcCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerConnectionPoolHttp{}).Type1()):                                              VirtualGatewaySpecSpecListenerConnectionPoolHttpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerConnectionPoolHttp2{}).Type1()):                                             VirtualGatewaySpecSpecListenerConnectionPoolHttp2Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerHealthCheck{}).Type1()):                                                     VirtualGatewaySpecSpecListenerHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerPortMapping{}).Type1()):                                                     VirtualGatewaySpecSpecListenerPortMappingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTls{}).Type1()):                                                             VirtualGatewaySpecSpecListenerTlsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsCertificate{}).Type1()):                                                  VirtualGatewaySpecSpecListenerTlsCertificateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsCertificateAcm{}).Type1()):                                               VirtualGatewaySpecSpecListenerTlsCertificateAcmCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsCertificateFile{}).Type1()):                                              VirtualGatewaySpecSpecListenerTlsCertificateFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsCertificateSds{}).Type1()):                                               VirtualGatewaySpecSpecListenerTlsCertificateSdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidation{}).Type1()):                                                   VirtualGatewaySpecSpecListenerTlsValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNames{}).Type1()):                            VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesMatch{}).Type1()):                       VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidationTrust{}).Type1()):                                              VirtualGatewaySpecSpecListenerTlsValidationTrustCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidationTrustFile{}).Type1()):                                          VirtualGatewaySpecSpecListenerTlsValidationTrustFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidationTrustSds{}).Type1()):                                           VirtualGatewaySpecSpecListenerTlsValidationTrustSdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecLogging{}).Type1()):                                                                 VirtualGatewaySpecSpecLoggingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecLoggingAccessLog{}).Type1()):                                                        VirtualGatewaySpecSpecLoggingAccessLogCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecLoggingAccessLogFile{}).Type1()):                                                    VirtualGatewaySpecSpecLoggingAccessLogFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpec{}).Type1()):                                                                           VirtualNodeSpecSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualService{}).Type1()):                                                      VirtualNodeSpecSpecBackendVirtualServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicy{}).Type1()):                                          VirtualNodeSpecSpecBackendVirtualServiceClientPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTls{}).Type1()):                                       VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificate{}).Type1()):                            VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateFile{}).Type1()):                        VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateSds{}).Type1()):                         VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateSdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidation{}).Type1()):                             VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames{}).Type1()):      VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch{}).Type1()): VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrust{}).Type1()):                        VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm{}).Type1()):                     VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcmCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile{}).Type1()):                    VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds{}).Type1()):                     VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustSdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaults{}).Type1()):                                                            VirtualNodeSpecSpecBackendDefaultsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicy{}).Type1()):                                                VirtualNodeSpecSpecBackendDefaultsClientPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTls{}).Type1()):                                             VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificate{}).Type1()):                                  VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateFile{}).Type1()):                              VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateSds{}).Type1()):                               VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateSdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidation{}).Type1()):                                   VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames{}).Type1()):            VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch{}).Type1()):       VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrust{}).Type1()):                              VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm{}).Type1()):                           VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcmCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile{}).Type1()):                          VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds{}).Type1()):                           VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustSdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListener{}).Type1()):                                                                   VirtualNodeSpecSpecListenerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerConnectionPool{}).Type1()):                                                     VirtualNodeSpecSpecListenerConnectionPoolCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerConnectionPoolGrpc{}).Type1()):                                                 VirtualNodeSpecSpecListenerConnectionPoolGrpcCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerConnectionPoolHttp{}).Type1()):                                                 VirtualNodeSpecSpecListenerConnectionPoolHttpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerConnectionPoolHttp2{}).Type1()):                                                VirtualNodeSpecSpecListenerConnectionPoolHttp2Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerConnectionPoolTcp{}).Type1()):                                                  VirtualNodeSpecSpecListenerConnectionPoolTcpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerHealthCheck{}).Type1()):                                                        VirtualNodeSpecSpecListenerHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerOutlierDetection{}).Type1()):                                                   VirtualNodeSpecSpecListenerOutlierDetectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerOutlierDetectionBaseEjectionDuration{}).Type1()):                               VirtualNodeSpecSpecListenerOutlierDetectionBaseEjectionDurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerOutlierDetectionInterval{}).Type1()):                                           VirtualNodeSpecSpecListenerOutlierDetectionIntervalCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerPortMapping{}).Type1()):                                                        VirtualNodeSpecSpecListenerPortMappingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeout{}).Type1()):                                                            VirtualNodeSpecSpecListenerTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutGrpc{}).Type1()):                                                        VirtualNodeSpecSpecListenerTimeoutGrpcCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutGrpcIdle{}).Type1()):                                                    VirtualNodeSpecSpecListenerTimeoutGrpcIdleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutGrpcPerRequest{}).Type1()):                                              VirtualNodeSpecSpecListenerTimeoutGrpcPerRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttp{}).Type1()):                                                        VirtualNodeSpecSpecListenerTimeoutHttpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttpIdle{}).Type1()):                                                    VirtualNodeSpecSpecListenerTimeoutHttpIdleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttpPerRequest{}).Type1()):                                              VirtualNodeSpecSpecListenerTimeoutHttpPerRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttp2{}).Type1()):                                                       VirtualNodeSpecSpecListenerTimeoutHttp2Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttp2Idle{}).Type1()):                                                   VirtualNodeSpecSpecListenerTimeoutHttp2IdleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttp2PerRequest{}).Type1()):                                             VirtualNodeSpecSpecListenerTimeoutHttp2PerRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutTcp{}).Type1()):                                                         VirtualNodeSpecSpecListenerTimeoutTcpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutTcpIdle{}).Type1()):                                                     VirtualNodeSpecSpecListenerTimeoutTcpIdleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTls{}).Type1()):                                                                VirtualNodeSpecSpecListenerTlsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsCertificate{}).Type1()):                                                     VirtualNodeSpecSpecListenerTlsCertificateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsCertificateAcm{}).Type1()):                                                  VirtualNodeSpecSpecListenerTlsCertificateAcmCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsCertificateFile{}).Type1()):                                                 VirtualNodeSpecSpecListenerTlsCertificateFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsCertificateSds{}).Type1()):                                                  VirtualNodeSpecSpecListenerTlsCertificateSdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidation{}).Type1()):                                                      VirtualNodeSpecSpecListenerTlsValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNames{}).Type1()):                               VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesMatch{}).Type1()):                          VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidationTrust{}).Type1()):                                                 VirtualNodeSpecSpecListenerTlsValidationTrustCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidationTrustFile{}).Type1()):                                             VirtualNodeSpecSpecListenerTlsValidationTrustFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidationTrustSds{}).Type1()):                                              VirtualNodeSpecSpecListenerTlsValidationTrustSdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecLogging{}).Type1()):                                                                    VirtualNodeSpecSpecLoggingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecLoggingAccessLog{}).Type1()):                                                           VirtualNodeSpecSpecLoggingAccessLogCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecLoggingAccessLogFile{}).Type1()):                                                       VirtualNodeSpecSpecLoggingAccessLogFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecServiceDiscovery{}).Type1()):                                                           VirtualNodeSpecSpecServiceDiscoveryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecServiceDiscoveryAwsCloudMap{}).Type1()):                                                VirtualNodeSpecSpecServiceDiscoveryAwsCloudMapCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecServiceDiscoveryDns{}).Type1()):                                                        VirtualNodeSpecSpecServiceDiscoveryDnsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualRouterSpecSpec{}).Type1()):                                                                         VirtualRouterSpecSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualRouterSpecSpecListener{}).Type1()):                                                                 VirtualRouterSpecSpecListenerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualRouterSpecSpecListenerPortMapping{}).Type1()):                                                      VirtualRouterSpecSpecListenerPortMappingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualServiceSpecSpec{}).Type1()):                                                                        VirtualServiceSpecSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualServiceSpecSpecProvider{}).Type1()):                                                                VirtualServiceSpecSpecProviderCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualServiceSpecSpecProviderVirtualNode{}).Type1()):                                                     VirtualServiceSpecSpecProviderVirtualNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualServiceSpecSpecProviderVirtualRouter{}).Type1()):                                                   VirtualServiceSpecSpecProviderVirtualRouterCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpec{}).Type1()):                                                                          GatewayRouteSpecSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecGrpcRoute{}).Type1()):                                                                 GatewayRouteSpecSpecGrpcRouteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecGrpcRouteAction{}).Type1()):                                                           GatewayRouteSpecSpecGrpcRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecGrpcRouteActionTarget{}).Type1()):                                                     GatewayRouteSpecSpecGrpcRouteActionTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecGrpcRouteActionTargetVirtualService{}).Type1()):                                       GatewayRouteSpecSpecGrpcRouteActionTargetVirtualServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecGrpcRouteMatch{}).Type1()):                                                            GatewayRouteSpecSpecGrpcRouteMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttp2Route{}).Type1()):                                                                GatewayRouteSpecSpecHttp2RouteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttp2RouteAction{}).Type1()):                                                          GatewayRouteSpecSpecHttp2RouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttp2RouteActionTarget{}).Type1()):                                                    GatewayRouteSpecSpecHttp2RouteActionTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttp2RouteActionTargetVirtualService{}).Type1()):                                      GatewayRouteSpecSpecHttp2RouteActionTargetVirtualServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttp2RouteMatch{}).Type1()):                                                           GatewayRouteSpecSpecHttp2RouteMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttpRoute{}).Type1()):                                                                 GatewayRouteSpecSpecHttpRouteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttpRouteAction{}).Type1()):                                                           GatewayRouteSpecSpecHttpRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttpRouteActionTarget{}).Type1()):                                                     GatewayRouteSpecSpecHttpRouteActionTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttpRouteActionTargetVirtualService{}).Type1()):                                       GatewayRouteSpecSpecHttpRouteActionTargetVirtualServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttpRouteMatch{}).Type1()):                                                            GatewayRouteSpecSpecHttpRouteMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MeshSpecSpec{}).Type1()):                                                                                  MeshSpecSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MeshSpecSpecEgressFilter{}).Type1()):                                                                      MeshSpecSpecEgressFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpec{}).Type1()):                                                                                 RouteSpecSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRoute{}).Type1()):                                                                        RouteSpecSpecGrpcRouteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteAction{}).Type1()):                                                                  RouteSpecSpecGrpcRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteMatch{}).Type1()):                                                                   RouteSpecSpecGrpcRouteMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteMatchMetadataMatch{}).Type1()):                                                      RouteSpecSpecGrpcRouteMatchMetadataMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteMatchMetadataMatchRange{}).Type1()):                                                 RouteSpecSpecGrpcRouteMatchMetadataMatchRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteRetryPolicy{}).Type1()):                                                             RouteSpecSpecGrpcRouteRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteRetryPolicyPerRetryTimeout{}).Type1()):                                              RouteSpecSpecGrpcRouteRetryPolicyPerRetryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteTimeout{}).Type1()):                                                                 RouteSpecSpecGrpcRouteTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteTimeoutIdle{}).Type1()):                                                             RouteSpecSpecGrpcRouteTimeoutIdleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteTimeoutPerRequest{}).Type1()):                                                       RouteSpecSpecGrpcRouteTimeoutPerRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2Route{}).Type1()):                                                                       RouteSpecSpecHttp2RouteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteAction{}).Type1()):                                                                 RouteSpecSpecHttp2RouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteMatch{}).Type1()):                                                                  RouteSpecSpecHttp2RouteMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteMatchHeaderMatch{}).Type1()):                                                       RouteSpecSpecHttp2RouteMatchHeaderMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteMatchHeaderMatchRange{}).Type1()):                                                  RouteSpecSpecHttp2RouteMatchHeaderMatchRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteRetryPolicy{}).Type1()):                                                            RouteSpecSpecHttp2RouteRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteRetryPolicyPerRetryTimeout{}).Type1()):                                             RouteSpecSpecHttp2RouteRetryPolicyPerRetryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteTimeout{}).Type1()):                                                                RouteSpecSpecHttp2RouteTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteTimeoutIdle{}).Type1()):                                                            RouteSpecSpecHttp2RouteTimeoutIdleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteTimeoutPerRequest{}).Type1()):                                                      RouteSpecSpecHttp2RouteTimeoutPerRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRoute{}).Type1()):                                                                        RouteSpecSpecHttpRouteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteAction{}).Type1()):                                                                  RouteSpecSpecHttpRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteMatch{}).Type1()):                                                                   RouteSpecSpecHttpRouteMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteMatchHeaderMatch{}).Type1()):                                                        RouteSpecSpecHttpRouteMatchHeaderMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteMatchHeaderMatchRange{}).Type1()):                                                   RouteSpecSpecHttpRouteMatchHeaderMatchRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteRetryPolicy{}).Type1()):                                                             RouteSpecSpecHttpRouteRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteRetryPolicyPerRetryTimeout{}).Type1()):                                              RouteSpecSpecHttpRouteRetryPolicyPerRetryTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteTimeout{}).Type1()):                                                                 RouteSpecSpecHttpRouteTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteTimeoutIdle{}).Type1()):                                                             RouteSpecSpecHttpRouteTimeoutIdleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteTimeoutPerRequest{}).Type1()):                                                       RouteSpecSpecHttpRouteTimeoutPerRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecTcpRoute{}).Type1()):                                                                         RouteSpecSpecTcpRouteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecTcpRouteAction{}).Type1()):                                                                   RouteSpecSpecTcpRouteActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecTcpRouteTimeout{}).Type1()):                                                                  RouteSpecSpecTcpRouteTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecTcpRouteTimeoutIdle{}).Type1()):                                                              RouteSpecSpecTcpRouteTimeoutIdleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpec{}).Type1()):                                                                        VirtualGatewaySpecSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaults{}).Type1()):                                                         VirtualGatewaySpecSpecBackendDefaultsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicy{}).Type1()):                                             VirtualGatewaySpecSpecBackendDefaultsClientPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTls{}).Type1()):                                          VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificate{}).Type1()):                               VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateFile{}).Type1()):                           VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateSds{}).Type1()):                            VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateSdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidation{}).Type1()):                                VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames{}).Type1()):         VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch{}).Type1()):    VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrust{}).Type1()):                           VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm{}).Type1()):                        VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcmCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile{}).Type1()):                       VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds{}).Type1()):                        VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustSdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListener{}).Type1()):                                                                VirtualGatewaySpecSpecListenerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerConnectionPool{}).Type1()):                                                  VirtualGatewaySpecSpecListenerConnectionPoolCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerConnectionPoolGrpc{}).Type1()):                                              VirtualGatewaySpecSpecListenerConnectionPoolGrpcCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerConnectionPoolHttp{}).Type1()):                                              VirtualGatewaySpecSpecListenerConnectionPoolHttpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerConnectionPoolHttp2{}).Type1()):                                             VirtualGatewaySpecSpecListenerConnectionPoolHttp2Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerHealthCheck{}).Type1()):                                                     VirtualGatewaySpecSpecListenerHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerPortMapping{}).Type1()):                                                     VirtualGatewaySpecSpecListenerPortMappingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTls{}).Type1()):                                                             VirtualGatewaySpecSpecListenerTlsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsCertificate{}).Type1()):                                                  VirtualGatewaySpecSpecListenerTlsCertificateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsCertificateAcm{}).Type1()):                                               VirtualGatewaySpecSpecListenerTlsCertificateAcmCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsCertificateFile{}).Type1()):                                              VirtualGatewaySpecSpecListenerTlsCertificateFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsCertificateSds{}).Type1()):                                               VirtualGatewaySpecSpecListenerTlsCertificateSdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidation{}).Type1()):                                                   VirtualGatewaySpecSpecListenerTlsValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNames{}).Type1()):                            VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesMatch{}).Type1()):                       VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidationTrust{}).Type1()):                                              VirtualGatewaySpecSpecListenerTlsValidationTrustCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidationTrustFile{}).Type1()):                                          VirtualGatewaySpecSpecListenerTlsValidationTrustFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidationTrustSds{}).Type1()):                                           VirtualGatewaySpecSpecListenerTlsValidationTrustSdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecLogging{}).Type1()):                                                                 VirtualGatewaySpecSpecLoggingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecLoggingAccessLog{}).Type1()):                                                        VirtualGatewaySpecSpecLoggingAccessLogCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecLoggingAccessLogFile{}).Type1()):                                                    VirtualGatewaySpecSpecLoggingAccessLogFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpec{}).Type1()):                                                                           VirtualNodeSpecSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualService{}).Type1()):                                                      VirtualNodeSpecSpecBackendVirtualServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicy{}).Type1()):                                          VirtualNodeSpecSpecBackendVirtualServiceClientPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTls{}).Type1()):                                       VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificate{}).Type1()):                            VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateFile{}).Type1()):                        VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateSds{}).Type1()):                         VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateSdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidation{}).Type1()):                             VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames{}).Type1()):      VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch{}).Type1()): VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrust{}).Type1()):                        VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm{}).Type1()):                     VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcmCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile{}).Type1()):                    VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds{}).Type1()):                     VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustSdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaults{}).Type1()):                                                            VirtualNodeSpecSpecBackendDefaultsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicy{}).Type1()):                                                VirtualNodeSpecSpecBackendDefaultsClientPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTls{}).Type1()):                                             VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificate{}).Type1()):                                  VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateFile{}).Type1()):                              VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateSds{}).Type1()):                               VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateSdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidation{}).Type1()):                                   VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames{}).Type1()):            VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch{}).Type1()):       VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrust{}).Type1()):                              VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm{}).Type1()):                           VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcmCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile{}).Type1()):                          VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds{}).Type1()):                           VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustSdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListener{}).Type1()):                                                                   VirtualNodeSpecSpecListenerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerConnectionPool{}).Type1()):                                                     VirtualNodeSpecSpecListenerConnectionPoolCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerConnectionPoolGrpc{}).Type1()):                                                 VirtualNodeSpecSpecListenerConnectionPoolGrpcCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerConnectionPoolHttp{}).Type1()):                                                 VirtualNodeSpecSpecListenerConnectionPoolHttpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerConnectionPoolHttp2{}).Type1()):                                                VirtualNodeSpecSpecListenerConnectionPoolHttp2Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerConnectionPoolTcp{}).Type1()):                                                  VirtualNodeSpecSpecListenerConnectionPoolTcpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerHealthCheck{}).Type1()):                                                        VirtualNodeSpecSpecListenerHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerOutlierDetection{}).Type1()):                                                   VirtualNodeSpecSpecListenerOutlierDetectionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerOutlierDetectionBaseEjectionDuration{}).Type1()):                               VirtualNodeSpecSpecListenerOutlierDetectionBaseEjectionDurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerOutlierDetectionInterval{}).Type1()):                                           VirtualNodeSpecSpecListenerOutlierDetectionIntervalCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerPortMapping{}).Type1()):                                                        VirtualNodeSpecSpecListenerPortMappingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeout{}).Type1()):                                                            VirtualNodeSpecSpecListenerTimeoutCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutGrpc{}).Type1()):                                                        VirtualNodeSpecSpecListenerTimeoutGrpcCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutGrpcIdle{}).Type1()):                                                    VirtualNodeSpecSpecListenerTimeoutGrpcIdleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutGrpcPerRequest{}).Type1()):                                              VirtualNodeSpecSpecListenerTimeoutGrpcPerRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttp{}).Type1()):                                                        VirtualNodeSpecSpecListenerTimeoutHttpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttpIdle{}).Type1()):                                                    VirtualNodeSpecSpecListenerTimeoutHttpIdleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttpPerRequest{}).Type1()):                                              VirtualNodeSpecSpecListenerTimeoutHttpPerRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttp2{}).Type1()):                                                       VirtualNodeSpecSpecListenerTimeoutHttp2Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttp2Idle{}).Type1()):                                                   VirtualNodeSpecSpecListenerTimeoutHttp2IdleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttp2PerRequest{}).Type1()):                                             VirtualNodeSpecSpecListenerTimeoutHttp2PerRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutTcp{}).Type1()):                                                         VirtualNodeSpecSpecListenerTimeoutTcpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutTcpIdle{}).Type1()):                                                     VirtualNodeSpecSpecListenerTimeoutTcpIdleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTls{}).Type1()):                                                                VirtualNodeSpecSpecListenerTlsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsCertificate{}).Type1()):                                                     VirtualNodeSpecSpecListenerTlsCertificateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsCertificateAcm{}).Type1()):                                                  VirtualNodeSpecSpecListenerTlsCertificateAcmCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsCertificateFile{}).Type1()):                                                 VirtualNodeSpecSpecListenerTlsCertificateFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsCertificateSds{}).Type1()):                                                  VirtualNodeSpecSpecListenerTlsCertificateSdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidation{}).Type1()):                                                      VirtualNodeSpecSpecListenerTlsValidationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNames{}).Type1()):                               VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesMatch{}).Type1()):                          VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesMatchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidationTrust{}).Type1()):                                                 VirtualNodeSpecSpecListenerTlsValidationTrustCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidationTrustFile{}).Type1()):                                             VirtualNodeSpecSpecListenerTlsValidationTrustFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidationTrustSds{}).Type1()):                                              VirtualNodeSpecSpecListenerTlsValidationTrustSdsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecLogging{}).Type1()):                                                                    VirtualNodeSpecSpecLoggingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecLoggingAccessLog{}).Type1()):                                                           VirtualNodeSpecSpecLoggingAccessLogCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecLoggingAccessLogFile{}).Type1()):                                                       VirtualNodeSpecSpecLoggingAccessLogFileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecServiceDiscovery{}).Type1()):                                                           VirtualNodeSpecSpecServiceDiscoveryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecServiceDiscoveryAwsCloudMap{}).Type1()):                                                VirtualNodeSpecSpecServiceDiscoveryAwsCloudMapCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecServiceDiscoveryDns{}).Type1()):                                                        VirtualNodeSpecSpecServiceDiscoveryDnsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualRouterSpecSpec{}).Type1()):                                                                         VirtualRouterSpecSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualRouterSpecSpecListener{}).Type1()):                                                                 VirtualRouterSpecSpecListenerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualRouterSpecSpecListenerPortMapping{}).Type1()):                                                      VirtualRouterSpecSpecListenerPortMappingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualServiceSpecSpec{}).Type1()):                                                                        VirtualServiceSpecSpecCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualServiceSpecSpecProvider{}).Type1()):                                                                VirtualServiceSpecSpecProviderCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualServiceSpecSpecProviderVirtualNode{}).Type1()):                                                     VirtualServiceSpecSpecProviderVirtualNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualServiceSpecSpecProviderVirtualRouter{}).Type1()):                                                   VirtualServiceSpecSpecProviderVirtualRouterCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type GatewayRouteSpecSpecCodec struct {
}

func (GatewayRouteSpecSpecCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GatewayRouteSpecSpec)(ptr) == nil
}

func (GatewayRouteSpecSpecCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GatewayRouteSpecSpec)(ptr)
	var objs []GatewayRouteSpecSpec
	if obj != nil {
		objs = []GatewayRouteSpecSpec{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpec{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GatewayRouteSpecSpecCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GatewayRouteSpecSpec)(ptr) = GatewayRouteSpecSpec{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GatewayRouteSpecSpec

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpec{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GatewayRouteSpecSpec)(ptr) = objs[0]
			} else {
				*(*GatewayRouteSpecSpec)(ptr) = GatewayRouteSpecSpec{}
			}
		} else {
			*(*GatewayRouteSpecSpec)(ptr) = GatewayRouteSpecSpec{}
		}
	default:
		iter.ReportError("decode GatewayRouteSpecSpec", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GatewayRouteSpecSpecGrpcRouteCodec struct {
}

func (GatewayRouteSpecSpecGrpcRouteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GatewayRouteSpecSpecGrpcRoute)(ptr) == nil
}

func (GatewayRouteSpecSpecGrpcRouteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GatewayRouteSpecSpecGrpcRoute)(ptr)
	var objs []GatewayRouteSpecSpecGrpcRoute
	if obj != nil {
		objs = []GatewayRouteSpecSpecGrpcRoute{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecGrpcRoute{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GatewayRouteSpecSpecGrpcRouteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GatewayRouteSpecSpecGrpcRoute)(ptr) = GatewayRouteSpecSpecGrpcRoute{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GatewayRouteSpecSpecGrpcRoute

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecGrpcRoute{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GatewayRouteSpecSpecGrpcRoute)(ptr) = objs[0]
			} else {
				*(*GatewayRouteSpecSpecGrpcRoute)(ptr) = GatewayRouteSpecSpecGrpcRoute{}
			}
		} else {
			*(*GatewayRouteSpecSpecGrpcRoute)(ptr) = GatewayRouteSpecSpecGrpcRoute{}
		}
	default:
		iter.ReportError("decode GatewayRouteSpecSpecGrpcRoute", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GatewayRouteSpecSpecGrpcRouteActionCodec struct {
}

func (GatewayRouteSpecSpecGrpcRouteActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GatewayRouteSpecSpecGrpcRouteAction)(ptr) == nil
}

func (GatewayRouteSpecSpecGrpcRouteActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GatewayRouteSpecSpecGrpcRouteAction)(ptr)
	var objs []GatewayRouteSpecSpecGrpcRouteAction
	if obj != nil {
		objs = []GatewayRouteSpecSpecGrpcRouteAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecGrpcRouteAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GatewayRouteSpecSpecGrpcRouteActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GatewayRouteSpecSpecGrpcRouteAction)(ptr) = GatewayRouteSpecSpecGrpcRouteAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GatewayRouteSpecSpecGrpcRouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecGrpcRouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GatewayRouteSpecSpecGrpcRouteAction)(ptr) = objs[0]
			} else {
				*(*GatewayRouteSpecSpecGrpcRouteAction)(ptr) = GatewayRouteSpecSpecGrpcRouteAction{}
			}
		} else {
			*(*GatewayRouteSpecSpecGrpcRouteAction)(ptr) = GatewayRouteSpecSpecGrpcRouteAction{}
		}
	default:
		iter.ReportError("decode GatewayRouteSpecSpecGrpcRouteAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GatewayRouteSpecSpecGrpcRouteActionTargetCodec struct {
}

func (GatewayRouteSpecSpecGrpcRouteActionTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GatewayRouteSpecSpecGrpcRouteActionTarget)(ptr) == nil
}

func (GatewayRouteSpecSpecGrpcRouteActionTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GatewayRouteSpecSpecGrpcRouteActionTarget)(ptr)
	var objs []GatewayRouteSpecSpecGrpcRouteActionTarget
	if obj != nil {
		objs = []GatewayRouteSpecSpecGrpcRouteActionTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecGrpcRouteActionTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GatewayRouteSpecSpecGrpcRouteActionTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GatewayRouteSpecSpecGrpcRouteActionTarget)(ptr) = GatewayRouteSpecSpecGrpcRouteActionTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GatewayRouteSpecSpecGrpcRouteActionTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecGrpcRouteActionTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GatewayRouteSpecSpecGrpcRouteActionTarget)(ptr) = objs[0]
			} else {
				*(*GatewayRouteSpecSpecGrpcRouteActionTarget)(ptr) = GatewayRouteSpecSpecGrpcRouteActionTarget{}
			}
		} else {
			*(*GatewayRouteSpecSpecGrpcRouteActionTarget)(ptr) = GatewayRouteSpecSpecGrpcRouteActionTarget{}
		}
	default:
		iter.ReportError("decode GatewayRouteSpecSpecGrpcRouteActionTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GatewayRouteSpecSpecGrpcRouteActionTargetVirtualServiceCodec struct {
}

func (GatewayRouteSpecSpecGrpcRouteActionTargetVirtualServiceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GatewayRouteSpecSpecGrpcRouteActionTargetVirtualService)(ptr) == nil
}

func (GatewayRouteSpecSpecGrpcRouteActionTargetVirtualServiceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GatewayRouteSpecSpecGrpcRouteActionTargetVirtualService)(ptr)
	var objs []GatewayRouteSpecSpecGrpcRouteActionTargetVirtualService
	if obj != nil {
		objs = []GatewayRouteSpecSpecGrpcRouteActionTargetVirtualService{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecGrpcRouteActionTargetVirtualService{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GatewayRouteSpecSpecGrpcRouteActionTargetVirtualServiceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GatewayRouteSpecSpecGrpcRouteActionTargetVirtualService)(ptr) = GatewayRouteSpecSpecGrpcRouteActionTargetVirtualService{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GatewayRouteSpecSpecGrpcRouteActionTargetVirtualService

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecGrpcRouteActionTargetVirtualService{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GatewayRouteSpecSpecGrpcRouteActionTargetVirtualService)(ptr) = objs[0]
			} else {
				*(*GatewayRouteSpecSpecGrpcRouteActionTargetVirtualService)(ptr) = GatewayRouteSpecSpecGrpcRouteActionTargetVirtualService{}
			}
		} else {
			*(*GatewayRouteSpecSpecGrpcRouteActionTargetVirtualService)(ptr) = GatewayRouteSpecSpecGrpcRouteActionTargetVirtualService{}
		}
	default:
		iter.ReportError("decode GatewayRouteSpecSpecGrpcRouteActionTargetVirtualService", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GatewayRouteSpecSpecGrpcRouteMatchCodec struct {
}

func (GatewayRouteSpecSpecGrpcRouteMatchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GatewayRouteSpecSpecGrpcRouteMatch)(ptr) == nil
}

func (GatewayRouteSpecSpecGrpcRouteMatchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GatewayRouteSpecSpecGrpcRouteMatch)(ptr)
	var objs []GatewayRouteSpecSpecGrpcRouteMatch
	if obj != nil {
		objs = []GatewayRouteSpecSpecGrpcRouteMatch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecGrpcRouteMatch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GatewayRouteSpecSpecGrpcRouteMatchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GatewayRouteSpecSpecGrpcRouteMatch)(ptr) = GatewayRouteSpecSpecGrpcRouteMatch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GatewayRouteSpecSpecGrpcRouteMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecGrpcRouteMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GatewayRouteSpecSpecGrpcRouteMatch)(ptr) = objs[0]
			} else {
				*(*GatewayRouteSpecSpecGrpcRouteMatch)(ptr) = GatewayRouteSpecSpecGrpcRouteMatch{}
			}
		} else {
			*(*GatewayRouteSpecSpecGrpcRouteMatch)(ptr) = GatewayRouteSpecSpecGrpcRouteMatch{}
		}
	default:
		iter.ReportError("decode GatewayRouteSpecSpecGrpcRouteMatch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GatewayRouteSpecSpecHttp2RouteCodec struct {
}

func (GatewayRouteSpecSpecHttp2RouteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GatewayRouteSpecSpecHttp2Route)(ptr) == nil
}

func (GatewayRouteSpecSpecHttp2RouteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GatewayRouteSpecSpecHttp2Route)(ptr)
	var objs []GatewayRouteSpecSpecHttp2Route
	if obj != nil {
		objs = []GatewayRouteSpecSpecHttp2Route{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttp2Route{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GatewayRouteSpecSpecHttp2RouteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GatewayRouteSpecSpecHttp2Route)(ptr) = GatewayRouteSpecSpecHttp2Route{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GatewayRouteSpecSpecHttp2Route

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttp2Route{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GatewayRouteSpecSpecHttp2Route)(ptr) = objs[0]
			} else {
				*(*GatewayRouteSpecSpecHttp2Route)(ptr) = GatewayRouteSpecSpecHttp2Route{}
			}
		} else {
			*(*GatewayRouteSpecSpecHttp2Route)(ptr) = GatewayRouteSpecSpecHttp2Route{}
		}
	default:
		iter.ReportError("decode GatewayRouteSpecSpecHttp2Route", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GatewayRouteSpecSpecHttp2RouteActionCodec struct {
}

func (GatewayRouteSpecSpecHttp2RouteActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GatewayRouteSpecSpecHttp2RouteAction)(ptr) == nil
}

func (GatewayRouteSpecSpecHttp2RouteActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GatewayRouteSpecSpecHttp2RouteAction)(ptr)
	var objs []GatewayRouteSpecSpecHttp2RouteAction
	if obj != nil {
		objs = []GatewayRouteSpecSpecHttp2RouteAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttp2RouteAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GatewayRouteSpecSpecHttp2RouteActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GatewayRouteSpecSpecHttp2RouteAction)(ptr) = GatewayRouteSpecSpecHttp2RouteAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GatewayRouteSpecSpecHttp2RouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttp2RouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GatewayRouteSpecSpecHttp2RouteAction)(ptr) = objs[0]
			} else {
				*(*GatewayRouteSpecSpecHttp2RouteAction)(ptr) = GatewayRouteSpecSpecHttp2RouteAction{}
			}
		} else {
			*(*GatewayRouteSpecSpecHttp2RouteAction)(ptr) = GatewayRouteSpecSpecHttp2RouteAction{}
		}
	default:
		iter.ReportError("decode GatewayRouteSpecSpecHttp2RouteAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GatewayRouteSpecSpecHttp2RouteActionTargetCodec struct {
}

func (GatewayRouteSpecSpecHttp2RouteActionTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GatewayRouteSpecSpecHttp2RouteActionTarget)(ptr) == nil
}

func (GatewayRouteSpecSpecHttp2RouteActionTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GatewayRouteSpecSpecHttp2RouteActionTarget)(ptr)
	var objs []GatewayRouteSpecSpecHttp2RouteActionTarget
	if obj != nil {
		objs = []GatewayRouteSpecSpecHttp2RouteActionTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttp2RouteActionTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GatewayRouteSpecSpecHttp2RouteActionTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GatewayRouteSpecSpecHttp2RouteActionTarget)(ptr) = GatewayRouteSpecSpecHttp2RouteActionTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GatewayRouteSpecSpecHttp2RouteActionTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttp2RouteActionTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GatewayRouteSpecSpecHttp2RouteActionTarget)(ptr) = objs[0]
			} else {
				*(*GatewayRouteSpecSpecHttp2RouteActionTarget)(ptr) = GatewayRouteSpecSpecHttp2RouteActionTarget{}
			}
		} else {
			*(*GatewayRouteSpecSpecHttp2RouteActionTarget)(ptr) = GatewayRouteSpecSpecHttp2RouteActionTarget{}
		}
	default:
		iter.ReportError("decode GatewayRouteSpecSpecHttp2RouteActionTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GatewayRouteSpecSpecHttp2RouteActionTargetVirtualServiceCodec struct {
}

func (GatewayRouteSpecSpecHttp2RouteActionTargetVirtualServiceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GatewayRouteSpecSpecHttp2RouteActionTargetVirtualService)(ptr) == nil
}

func (GatewayRouteSpecSpecHttp2RouteActionTargetVirtualServiceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GatewayRouteSpecSpecHttp2RouteActionTargetVirtualService)(ptr)
	var objs []GatewayRouteSpecSpecHttp2RouteActionTargetVirtualService
	if obj != nil {
		objs = []GatewayRouteSpecSpecHttp2RouteActionTargetVirtualService{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttp2RouteActionTargetVirtualService{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GatewayRouteSpecSpecHttp2RouteActionTargetVirtualServiceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GatewayRouteSpecSpecHttp2RouteActionTargetVirtualService)(ptr) = GatewayRouteSpecSpecHttp2RouteActionTargetVirtualService{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GatewayRouteSpecSpecHttp2RouteActionTargetVirtualService

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttp2RouteActionTargetVirtualService{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GatewayRouteSpecSpecHttp2RouteActionTargetVirtualService)(ptr) = objs[0]
			} else {
				*(*GatewayRouteSpecSpecHttp2RouteActionTargetVirtualService)(ptr) = GatewayRouteSpecSpecHttp2RouteActionTargetVirtualService{}
			}
		} else {
			*(*GatewayRouteSpecSpecHttp2RouteActionTargetVirtualService)(ptr) = GatewayRouteSpecSpecHttp2RouteActionTargetVirtualService{}
		}
	default:
		iter.ReportError("decode GatewayRouteSpecSpecHttp2RouteActionTargetVirtualService", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GatewayRouteSpecSpecHttp2RouteMatchCodec struct {
}

func (GatewayRouteSpecSpecHttp2RouteMatchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GatewayRouteSpecSpecHttp2RouteMatch)(ptr) == nil
}

func (GatewayRouteSpecSpecHttp2RouteMatchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GatewayRouteSpecSpecHttp2RouteMatch)(ptr)
	var objs []GatewayRouteSpecSpecHttp2RouteMatch
	if obj != nil {
		objs = []GatewayRouteSpecSpecHttp2RouteMatch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttp2RouteMatch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GatewayRouteSpecSpecHttp2RouteMatchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GatewayRouteSpecSpecHttp2RouteMatch)(ptr) = GatewayRouteSpecSpecHttp2RouteMatch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GatewayRouteSpecSpecHttp2RouteMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttp2RouteMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GatewayRouteSpecSpecHttp2RouteMatch)(ptr) = objs[0]
			} else {
				*(*GatewayRouteSpecSpecHttp2RouteMatch)(ptr) = GatewayRouteSpecSpecHttp2RouteMatch{}
			}
		} else {
			*(*GatewayRouteSpecSpecHttp2RouteMatch)(ptr) = GatewayRouteSpecSpecHttp2RouteMatch{}
		}
	default:
		iter.ReportError("decode GatewayRouteSpecSpecHttp2RouteMatch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GatewayRouteSpecSpecHttpRouteCodec struct {
}

func (GatewayRouteSpecSpecHttpRouteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GatewayRouteSpecSpecHttpRoute)(ptr) == nil
}

func (GatewayRouteSpecSpecHttpRouteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GatewayRouteSpecSpecHttpRoute)(ptr)
	var objs []GatewayRouteSpecSpecHttpRoute
	if obj != nil {
		objs = []GatewayRouteSpecSpecHttpRoute{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttpRoute{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GatewayRouteSpecSpecHttpRouteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GatewayRouteSpecSpecHttpRoute)(ptr) = GatewayRouteSpecSpecHttpRoute{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GatewayRouteSpecSpecHttpRoute

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttpRoute{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GatewayRouteSpecSpecHttpRoute)(ptr) = objs[0]
			} else {
				*(*GatewayRouteSpecSpecHttpRoute)(ptr) = GatewayRouteSpecSpecHttpRoute{}
			}
		} else {
			*(*GatewayRouteSpecSpecHttpRoute)(ptr) = GatewayRouteSpecSpecHttpRoute{}
		}
	default:
		iter.ReportError("decode GatewayRouteSpecSpecHttpRoute", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GatewayRouteSpecSpecHttpRouteActionCodec struct {
}

func (GatewayRouteSpecSpecHttpRouteActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GatewayRouteSpecSpecHttpRouteAction)(ptr) == nil
}

func (GatewayRouteSpecSpecHttpRouteActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GatewayRouteSpecSpecHttpRouteAction)(ptr)
	var objs []GatewayRouteSpecSpecHttpRouteAction
	if obj != nil {
		objs = []GatewayRouteSpecSpecHttpRouteAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttpRouteAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GatewayRouteSpecSpecHttpRouteActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GatewayRouteSpecSpecHttpRouteAction)(ptr) = GatewayRouteSpecSpecHttpRouteAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GatewayRouteSpecSpecHttpRouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttpRouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GatewayRouteSpecSpecHttpRouteAction)(ptr) = objs[0]
			} else {
				*(*GatewayRouteSpecSpecHttpRouteAction)(ptr) = GatewayRouteSpecSpecHttpRouteAction{}
			}
		} else {
			*(*GatewayRouteSpecSpecHttpRouteAction)(ptr) = GatewayRouteSpecSpecHttpRouteAction{}
		}
	default:
		iter.ReportError("decode GatewayRouteSpecSpecHttpRouteAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GatewayRouteSpecSpecHttpRouteActionTargetCodec struct {
}

func (GatewayRouteSpecSpecHttpRouteActionTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GatewayRouteSpecSpecHttpRouteActionTarget)(ptr) == nil
}

func (GatewayRouteSpecSpecHttpRouteActionTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GatewayRouteSpecSpecHttpRouteActionTarget)(ptr)
	var objs []GatewayRouteSpecSpecHttpRouteActionTarget
	if obj != nil {
		objs = []GatewayRouteSpecSpecHttpRouteActionTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttpRouteActionTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GatewayRouteSpecSpecHttpRouteActionTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GatewayRouteSpecSpecHttpRouteActionTarget)(ptr) = GatewayRouteSpecSpecHttpRouteActionTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GatewayRouteSpecSpecHttpRouteActionTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttpRouteActionTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GatewayRouteSpecSpecHttpRouteActionTarget)(ptr) = objs[0]
			} else {
				*(*GatewayRouteSpecSpecHttpRouteActionTarget)(ptr) = GatewayRouteSpecSpecHttpRouteActionTarget{}
			}
		} else {
			*(*GatewayRouteSpecSpecHttpRouteActionTarget)(ptr) = GatewayRouteSpecSpecHttpRouteActionTarget{}
		}
	default:
		iter.ReportError("decode GatewayRouteSpecSpecHttpRouteActionTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GatewayRouteSpecSpecHttpRouteActionTargetVirtualServiceCodec struct {
}

func (GatewayRouteSpecSpecHttpRouteActionTargetVirtualServiceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GatewayRouteSpecSpecHttpRouteActionTargetVirtualService)(ptr) == nil
}

func (GatewayRouteSpecSpecHttpRouteActionTargetVirtualServiceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GatewayRouteSpecSpecHttpRouteActionTargetVirtualService)(ptr)
	var objs []GatewayRouteSpecSpecHttpRouteActionTargetVirtualService
	if obj != nil {
		objs = []GatewayRouteSpecSpecHttpRouteActionTargetVirtualService{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttpRouteActionTargetVirtualService{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GatewayRouteSpecSpecHttpRouteActionTargetVirtualServiceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GatewayRouteSpecSpecHttpRouteActionTargetVirtualService)(ptr) = GatewayRouteSpecSpecHttpRouteActionTargetVirtualService{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GatewayRouteSpecSpecHttpRouteActionTargetVirtualService

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttpRouteActionTargetVirtualService{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GatewayRouteSpecSpecHttpRouteActionTargetVirtualService)(ptr) = objs[0]
			} else {
				*(*GatewayRouteSpecSpecHttpRouteActionTargetVirtualService)(ptr) = GatewayRouteSpecSpecHttpRouteActionTargetVirtualService{}
			}
		} else {
			*(*GatewayRouteSpecSpecHttpRouteActionTargetVirtualService)(ptr) = GatewayRouteSpecSpecHttpRouteActionTargetVirtualService{}
		}
	default:
		iter.ReportError("decode GatewayRouteSpecSpecHttpRouteActionTargetVirtualService", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GatewayRouteSpecSpecHttpRouteMatchCodec struct {
}

func (GatewayRouteSpecSpecHttpRouteMatchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GatewayRouteSpecSpecHttpRouteMatch)(ptr) == nil
}

func (GatewayRouteSpecSpecHttpRouteMatchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GatewayRouteSpecSpecHttpRouteMatch)(ptr)
	var objs []GatewayRouteSpecSpecHttpRouteMatch
	if obj != nil {
		objs = []GatewayRouteSpecSpecHttpRouteMatch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttpRouteMatch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GatewayRouteSpecSpecHttpRouteMatchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GatewayRouteSpecSpecHttpRouteMatch)(ptr) = GatewayRouteSpecSpecHttpRouteMatch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GatewayRouteSpecSpecHttpRouteMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GatewayRouteSpecSpecHttpRouteMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GatewayRouteSpecSpecHttpRouteMatch)(ptr) = objs[0]
			} else {
				*(*GatewayRouteSpecSpecHttpRouteMatch)(ptr) = GatewayRouteSpecSpecHttpRouteMatch{}
			}
		} else {
			*(*GatewayRouteSpecSpecHttpRouteMatch)(ptr) = GatewayRouteSpecSpecHttpRouteMatch{}
		}
	default:
		iter.ReportError("decode GatewayRouteSpecSpecHttpRouteMatch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MeshSpecSpecCodec struct {
}

func (MeshSpecSpecCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MeshSpecSpec)(ptr) == nil
}

func (MeshSpecSpecCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MeshSpecSpec)(ptr)
	var objs []MeshSpecSpec
	if obj != nil {
		objs = []MeshSpecSpec{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshSpecSpec{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MeshSpecSpecCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MeshSpecSpec)(ptr) = MeshSpecSpec{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MeshSpecSpec

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshSpecSpec{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MeshSpecSpec)(ptr) = objs[0]
			} else {
				*(*MeshSpecSpec)(ptr) = MeshSpecSpec{}
			}
		} else {
			*(*MeshSpecSpec)(ptr) = MeshSpecSpec{}
		}
	default:
		iter.ReportError("decode MeshSpecSpec", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MeshSpecSpecEgressFilterCodec struct {
}

func (MeshSpecSpecEgressFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MeshSpecSpecEgressFilter)(ptr) == nil
}

func (MeshSpecSpecEgressFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MeshSpecSpecEgressFilter)(ptr)
	var objs []MeshSpecSpecEgressFilter
	if obj != nil {
		objs = []MeshSpecSpecEgressFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshSpecSpecEgressFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MeshSpecSpecEgressFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MeshSpecSpecEgressFilter)(ptr) = MeshSpecSpecEgressFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MeshSpecSpecEgressFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MeshSpecSpecEgressFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MeshSpecSpecEgressFilter)(ptr) = objs[0]
			} else {
				*(*MeshSpecSpecEgressFilter)(ptr) = MeshSpecSpecEgressFilter{}
			}
		} else {
			*(*MeshSpecSpecEgressFilter)(ptr) = MeshSpecSpecEgressFilter{}
		}
	default:
		iter.ReportError("decode MeshSpecSpecEgressFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecCodec struct {
}

func (RouteSpecSpecCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpec)(ptr) == nil
}

func (RouteSpecSpecCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpec)(ptr)
	var objs []RouteSpecSpec
	if obj != nil {
		objs = []RouteSpecSpec{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpec{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpec)(ptr) = RouteSpecSpec{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpec

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpec{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpec)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpec)(ptr) = RouteSpecSpec{}
			}
		} else {
			*(*RouteSpecSpec)(ptr) = RouteSpecSpec{}
		}
	default:
		iter.ReportError("decode RouteSpecSpec", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecGrpcRouteCodec struct {
}

func (RouteSpecSpecGrpcRouteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecGrpcRoute)(ptr) == nil
}

func (RouteSpecSpecGrpcRouteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecGrpcRoute)(ptr)
	var objs []RouteSpecSpecGrpcRoute
	if obj != nil {
		objs = []RouteSpecSpecGrpcRoute{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRoute{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecGrpcRouteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecGrpcRoute)(ptr) = RouteSpecSpecGrpcRoute{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecGrpcRoute

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRoute{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecGrpcRoute)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecGrpcRoute)(ptr) = RouteSpecSpecGrpcRoute{}
			}
		} else {
			*(*RouteSpecSpecGrpcRoute)(ptr) = RouteSpecSpecGrpcRoute{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecGrpcRoute", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecGrpcRouteActionCodec struct {
}

func (RouteSpecSpecGrpcRouteActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecGrpcRouteAction)(ptr) == nil
}

func (RouteSpecSpecGrpcRouteActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecGrpcRouteAction)(ptr)
	var objs []RouteSpecSpecGrpcRouteAction
	if obj != nil {
		objs = []RouteSpecSpecGrpcRouteAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecGrpcRouteActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecGrpcRouteAction)(ptr) = RouteSpecSpecGrpcRouteAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecGrpcRouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecGrpcRouteAction)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecGrpcRouteAction)(ptr) = RouteSpecSpecGrpcRouteAction{}
			}
		} else {
			*(*RouteSpecSpecGrpcRouteAction)(ptr) = RouteSpecSpecGrpcRouteAction{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecGrpcRouteAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecGrpcRouteMatchCodec struct {
}

func (RouteSpecSpecGrpcRouteMatchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecGrpcRouteMatch)(ptr) == nil
}

func (RouteSpecSpecGrpcRouteMatchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecGrpcRouteMatch)(ptr)
	var objs []RouteSpecSpecGrpcRouteMatch
	if obj != nil {
		objs = []RouteSpecSpecGrpcRouteMatch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteMatch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecGrpcRouteMatchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecGrpcRouteMatch)(ptr) = RouteSpecSpecGrpcRouteMatch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecGrpcRouteMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecGrpcRouteMatch)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecGrpcRouteMatch)(ptr) = RouteSpecSpecGrpcRouteMatch{}
			}
		} else {
			*(*RouteSpecSpecGrpcRouteMatch)(ptr) = RouteSpecSpecGrpcRouteMatch{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecGrpcRouteMatch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecGrpcRouteMatchMetadataMatchCodec struct {
}

func (RouteSpecSpecGrpcRouteMatchMetadataMatchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecGrpcRouteMatchMetadataMatch)(ptr) == nil
}

func (RouteSpecSpecGrpcRouteMatchMetadataMatchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecGrpcRouteMatchMetadataMatch)(ptr)
	var objs []RouteSpecSpecGrpcRouteMatchMetadataMatch
	if obj != nil {
		objs = []RouteSpecSpecGrpcRouteMatchMetadataMatch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteMatchMetadataMatch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecGrpcRouteMatchMetadataMatchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecGrpcRouteMatchMetadataMatch)(ptr) = RouteSpecSpecGrpcRouteMatchMetadataMatch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecGrpcRouteMatchMetadataMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteMatchMetadataMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecGrpcRouteMatchMetadataMatch)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecGrpcRouteMatchMetadataMatch)(ptr) = RouteSpecSpecGrpcRouteMatchMetadataMatch{}
			}
		} else {
			*(*RouteSpecSpecGrpcRouteMatchMetadataMatch)(ptr) = RouteSpecSpecGrpcRouteMatchMetadataMatch{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecGrpcRouteMatchMetadataMatch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecGrpcRouteMatchMetadataMatchRangeCodec struct {
}

func (RouteSpecSpecGrpcRouteMatchMetadataMatchRangeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecGrpcRouteMatchMetadataMatchRange)(ptr) == nil
}

func (RouteSpecSpecGrpcRouteMatchMetadataMatchRangeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecGrpcRouteMatchMetadataMatchRange)(ptr)
	var objs []RouteSpecSpecGrpcRouteMatchMetadataMatchRange
	if obj != nil {
		objs = []RouteSpecSpecGrpcRouteMatchMetadataMatchRange{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteMatchMetadataMatchRange{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecGrpcRouteMatchMetadataMatchRangeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecGrpcRouteMatchMetadataMatchRange)(ptr) = RouteSpecSpecGrpcRouteMatchMetadataMatchRange{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecGrpcRouteMatchMetadataMatchRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteMatchMetadataMatchRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecGrpcRouteMatchMetadataMatchRange)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecGrpcRouteMatchMetadataMatchRange)(ptr) = RouteSpecSpecGrpcRouteMatchMetadataMatchRange{}
			}
		} else {
			*(*RouteSpecSpecGrpcRouteMatchMetadataMatchRange)(ptr) = RouteSpecSpecGrpcRouteMatchMetadataMatchRange{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecGrpcRouteMatchMetadataMatchRange", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecGrpcRouteRetryPolicyCodec struct {
}

func (RouteSpecSpecGrpcRouteRetryPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecGrpcRouteRetryPolicy)(ptr) == nil
}

func (RouteSpecSpecGrpcRouteRetryPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecGrpcRouteRetryPolicy)(ptr)
	var objs []RouteSpecSpecGrpcRouteRetryPolicy
	if obj != nil {
		objs = []RouteSpecSpecGrpcRouteRetryPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteRetryPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecGrpcRouteRetryPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecGrpcRouteRetryPolicy)(ptr) = RouteSpecSpecGrpcRouteRetryPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecGrpcRouteRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecGrpcRouteRetryPolicy)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecGrpcRouteRetryPolicy)(ptr) = RouteSpecSpecGrpcRouteRetryPolicy{}
			}
		} else {
			*(*RouteSpecSpecGrpcRouteRetryPolicy)(ptr) = RouteSpecSpecGrpcRouteRetryPolicy{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecGrpcRouteRetryPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecGrpcRouteRetryPolicyPerRetryTimeoutCodec struct {
}

func (RouteSpecSpecGrpcRouteRetryPolicyPerRetryTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecGrpcRouteRetryPolicyPerRetryTimeout)(ptr) == nil
}

func (RouteSpecSpecGrpcRouteRetryPolicyPerRetryTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecGrpcRouteRetryPolicyPerRetryTimeout)(ptr)
	var objs []RouteSpecSpecGrpcRouteRetryPolicyPerRetryTimeout
	if obj != nil {
		objs = []RouteSpecSpecGrpcRouteRetryPolicyPerRetryTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteRetryPolicyPerRetryTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecGrpcRouteRetryPolicyPerRetryTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecGrpcRouteRetryPolicyPerRetryTimeout)(ptr) = RouteSpecSpecGrpcRouteRetryPolicyPerRetryTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecGrpcRouteRetryPolicyPerRetryTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteRetryPolicyPerRetryTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecGrpcRouteRetryPolicyPerRetryTimeout)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecGrpcRouteRetryPolicyPerRetryTimeout)(ptr) = RouteSpecSpecGrpcRouteRetryPolicyPerRetryTimeout{}
			}
		} else {
			*(*RouteSpecSpecGrpcRouteRetryPolicyPerRetryTimeout)(ptr) = RouteSpecSpecGrpcRouteRetryPolicyPerRetryTimeout{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecGrpcRouteRetryPolicyPerRetryTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecGrpcRouteTimeoutCodec struct {
}

func (RouteSpecSpecGrpcRouteTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecGrpcRouteTimeout)(ptr) == nil
}

func (RouteSpecSpecGrpcRouteTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecGrpcRouteTimeout)(ptr)
	var objs []RouteSpecSpecGrpcRouteTimeout
	if obj != nil {
		objs = []RouteSpecSpecGrpcRouteTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecGrpcRouteTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecGrpcRouteTimeout)(ptr) = RouteSpecSpecGrpcRouteTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecGrpcRouteTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecGrpcRouteTimeout)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecGrpcRouteTimeout)(ptr) = RouteSpecSpecGrpcRouteTimeout{}
			}
		} else {
			*(*RouteSpecSpecGrpcRouteTimeout)(ptr) = RouteSpecSpecGrpcRouteTimeout{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecGrpcRouteTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecGrpcRouteTimeoutIdleCodec struct {
}

func (RouteSpecSpecGrpcRouteTimeoutIdleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecGrpcRouteTimeoutIdle)(ptr) == nil
}

func (RouteSpecSpecGrpcRouteTimeoutIdleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecGrpcRouteTimeoutIdle)(ptr)
	var objs []RouteSpecSpecGrpcRouteTimeoutIdle
	if obj != nil {
		objs = []RouteSpecSpecGrpcRouteTimeoutIdle{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteTimeoutIdle{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecGrpcRouteTimeoutIdleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecGrpcRouteTimeoutIdle)(ptr) = RouteSpecSpecGrpcRouteTimeoutIdle{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecGrpcRouteTimeoutIdle

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteTimeoutIdle{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecGrpcRouteTimeoutIdle)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecGrpcRouteTimeoutIdle)(ptr) = RouteSpecSpecGrpcRouteTimeoutIdle{}
			}
		} else {
			*(*RouteSpecSpecGrpcRouteTimeoutIdle)(ptr) = RouteSpecSpecGrpcRouteTimeoutIdle{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecGrpcRouteTimeoutIdle", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecGrpcRouteTimeoutPerRequestCodec struct {
}

func (RouteSpecSpecGrpcRouteTimeoutPerRequestCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecGrpcRouteTimeoutPerRequest)(ptr) == nil
}

func (RouteSpecSpecGrpcRouteTimeoutPerRequestCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecGrpcRouteTimeoutPerRequest)(ptr)
	var objs []RouteSpecSpecGrpcRouteTimeoutPerRequest
	if obj != nil {
		objs = []RouteSpecSpecGrpcRouteTimeoutPerRequest{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteTimeoutPerRequest{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecGrpcRouteTimeoutPerRequestCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecGrpcRouteTimeoutPerRequest)(ptr) = RouteSpecSpecGrpcRouteTimeoutPerRequest{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecGrpcRouteTimeoutPerRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecGrpcRouteTimeoutPerRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecGrpcRouteTimeoutPerRequest)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecGrpcRouteTimeoutPerRequest)(ptr) = RouteSpecSpecGrpcRouteTimeoutPerRequest{}
			}
		} else {
			*(*RouteSpecSpecGrpcRouteTimeoutPerRequest)(ptr) = RouteSpecSpecGrpcRouteTimeoutPerRequest{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecGrpcRouteTimeoutPerRequest", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecHttp2RouteCodec struct {
}

func (RouteSpecSpecHttp2RouteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecHttp2Route)(ptr) == nil
}

func (RouteSpecSpecHttp2RouteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecHttp2Route)(ptr)
	var objs []RouteSpecSpecHttp2Route
	if obj != nil {
		objs = []RouteSpecSpecHttp2Route{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2Route{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecHttp2RouteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecHttp2Route)(ptr) = RouteSpecSpecHttp2Route{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecHttp2Route

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2Route{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecHttp2Route)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecHttp2Route)(ptr) = RouteSpecSpecHttp2Route{}
			}
		} else {
			*(*RouteSpecSpecHttp2Route)(ptr) = RouteSpecSpecHttp2Route{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecHttp2Route", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecHttp2RouteActionCodec struct {
}

func (RouteSpecSpecHttp2RouteActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecHttp2RouteAction)(ptr) == nil
}

func (RouteSpecSpecHttp2RouteActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecHttp2RouteAction)(ptr)
	var objs []RouteSpecSpecHttp2RouteAction
	if obj != nil {
		objs = []RouteSpecSpecHttp2RouteAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecHttp2RouteActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecHttp2RouteAction)(ptr) = RouteSpecSpecHttp2RouteAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecHttp2RouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecHttp2RouteAction)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecHttp2RouteAction)(ptr) = RouteSpecSpecHttp2RouteAction{}
			}
		} else {
			*(*RouteSpecSpecHttp2RouteAction)(ptr) = RouteSpecSpecHttp2RouteAction{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecHttp2RouteAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecHttp2RouteMatchCodec struct {
}

func (RouteSpecSpecHttp2RouteMatchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecHttp2RouteMatch)(ptr) == nil
}

func (RouteSpecSpecHttp2RouteMatchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecHttp2RouteMatch)(ptr)
	var objs []RouteSpecSpecHttp2RouteMatch
	if obj != nil {
		objs = []RouteSpecSpecHttp2RouteMatch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteMatch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecHttp2RouteMatchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecHttp2RouteMatch)(ptr) = RouteSpecSpecHttp2RouteMatch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecHttp2RouteMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecHttp2RouteMatch)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecHttp2RouteMatch)(ptr) = RouteSpecSpecHttp2RouteMatch{}
			}
		} else {
			*(*RouteSpecSpecHttp2RouteMatch)(ptr) = RouteSpecSpecHttp2RouteMatch{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecHttp2RouteMatch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecHttp2RouteMatchHeaderMatchCodec struct {
}

func (RouteSpecSpecHttp2RouteMatchHeaderMatchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecHttp2RouteMatchHeaderMatch)(ptr) == nil
}

func (RouteSpecSpecHttp2RouteMatchHeaderMatchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecHttp2RouteMatchHeaderMatch)(ptr)
	var objs []RouteSpecSpecHttp2RouteMatchHeaderMatch
	if obj != nil {
		objs = []RouteSpecSpecHttp2RouteMatchHeaderMatch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteMatchHeaderMatch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecHttp2RouteMatchHeaderMatchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecHttp2RouteMatchHeaderMatch)(ptr) = RouteSpecSpecHttp2RouteMatchHeaderMatch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecHttp2RouteMatchHeaderMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteMatchHeaderMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecHttp2RouteMatchHeaderMatch)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecHttp2RouteMatchHeaderMatch)(ptr) = RouteSpecSpecHttp2RouteMatchHeaderMatch{}
			}
		} else {
			*(*RouteSpecSpecHttp2RouteMatchHeaderMatch)(ptr) = RouteSpecSpecHttp2RouteMatchHeaderMatch{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecHttp2RouteMatchHeaderMatch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecHttp2RouteMatchHeaderMatchRangeCodec struct {
}

func (RouteSpecSpecHttp2RouteMatchHeaderMatchRangeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecHttp2RouteMatchHeaderMatchRange)(ptr) == nil
}

func (RouteSpecSpecHttp2RouteMatchHeaderMatchRangeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecHttp2RouteMatchHeaderMatchRange)(ptr)
	var objs []RouteSpecSpecHttp2RouteMatchHeaderMatchRange
	if obj != nil {
		objs = []RouteSpecSpecHttp2RouteMatchHeaderMatchRange{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteMatchHeaderMatchRange{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecHttp2RouteMatchHeaderMatchRangeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecHttp2RouteMatchHeaderMatchRange)(ptr) = RouteSpecSpecHttp2RouteMatchHeaderMatchRange{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecHttp2RouteMatchHeaderMatchRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteMatchHeaderMatchRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecHttp2RouteMatchHeaderMatchRange)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecHttp2RouteMatchHeaderMatchRange)(ptr) = RouteSpecSpecHttp2RouteMatchHeaderMatchRange{}
			}
		} else {
			*(*RouteSpecSpecHttp2RouteMatchHeaderMatchRange)(ptr) = RouteSpecSpecHttp2RouteMatchHeaderMatchRange{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecHttp2RouteMatchHeaderMatchRange", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecHttp2RouteRetryPolicyCodec struct {
}

func (RouteSpecSpecHttp2RouteRetryPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecHttp2RouteRetryPolicy)(ptr) == nil
}

func (RouteSpecSpecHttp2RouteRetryPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecHttp2RouteRetryPolicy)(ptr)
	var objs []RouteSpecSpecHttp2RouteRetryPolicy
	if obj != nil {
		objs = []RouteSpecSpecHttp2RouteRetryPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteRetryPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecHttp2RouteRetryPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecHttp2RouteRetryPolicy)(ptr) = RouteSpecSpecHttp2RouteRetryPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecHttp2RouteRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecHttp2RouteRetryPolicy)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecHttp2RouteRetryPolicy)(ptr) = RouteSpecSpecHttp2RouteRetryPolicy{}
			}
		} else {
			*(*RouteSpecSpecHttp2RouteRetryPolicy)(ptr) = RouteSpecSpecHttp2RouteRetryPolicy{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecHttp2RouteRetryPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecHttp2RouteRetryPolicyPerRetryTimeoutCodec struct {
}

func (RouteSpecSpecHttp2RouteRetryPolicyPerRetryTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecHttp2RouteRetryPolicyPerRetryTimeout)(ptr) == nil
}

func (RouteSpecSpecHttp2RouteRetryPolicyPerRetryTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecHttp2RouteRetryPolicyPerRetryTimeout)(ptr)
	var objs []RouteSpecSpecHttp2RouteRetryPolicyPerRetryTimeout
	if obj != nil {
		objs = []RouteSpecSpecHttp2RouteRetryPolicyPerRetryTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteRetryPolicyPerRetryTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecHttp2RouteRetryPolicyPerRetryTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecHttp2RouteRetryPolicyPerRetryTimeout)(ptr) = RouteSpecSpecHttp2RouteRetryPolicyPerRetryTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecHttp2RouteRetryPolicyPerRetryTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteRetryPolicyPerRetryTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecHttp2RouteRetryPolicyPerRetryTimeout)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecHttp2RouteRetryPolicyPerRetryTimeout)(ptr) = RouteSpecSpecHttp2RouteRetryPolicyPerRetryTimeout{}
			}
		} else {
			*(*RouteSpecSpecHttp2RouteRetryPolicyPerRetryTimeout)(ptr) = RouteSpecSpecHttp2RouteRetryPolicyPerRetryTimeout{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecHttp2RouteRetryPolicyPerRetryTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecHttp2RouteTimeoutCodec struct {
}

func (RouteSpecSpecHttp2RouteTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecHttp2RouteTimeout)(ptr) == nil
}

func (RouteSpecSpecHttp2RouteTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecHttp2RouteTimeout)(ptr)
	var objs []RouteSpecSpecHttp2RouteTimeout
	if obj != nil {
		objs = []RouteSpecSpecHttp2RouteTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecHttp2RouteTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecHttp2RouteTimeout)(ptr) = RouteSpecSpecHttp2RouteTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecHttp2RouteTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecHttp2RouteTimeout)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecHttp2RouteTimeout)(ptr) = RouteSpecSpecHttp2RouteTimeout{}
			}
		} else {
			*(*RouteSpecSpecHttp2RouteTimeout)(ptr) = RouteSpecSpecHttp2RouteTimeout{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecHttp2RouteTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecHttp2RouteTimeoutIdleCodec struct {
}

func (RouteSpecSpecHttp2RouteTimeoutIdleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecHttp2RouteTimeoutIdle)(ptr) == nil
}

func (RouteSpecSpecHttp2RouteTimeoutIdleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecHttp2RouteTimeoutIdle)(ptr)
	var objs []RouteSpecSpecHttp2RouteTimeoutIdle
	if obj != nil {
		objs = []RouteSpecSpecHttp2RouteTimeoutIdle{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteTimeoutIdle{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecHttp2RouteTimeoutIdleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecHttp2RouteTimeoutIdle)(ptr) = RouteSpecSpecHttp2RouteTimeoutIdle{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecHttp2RouteTimeoutIdle

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteTimeoutIdle{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecHttp2RouteTimeoutIdle)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecHttp2RouteTimeoutIdle)(ptr) = RouteSpecSpecHttp2RouteTimeoutIdle{}
			}
		} else {
			*(*RouteSpecSpecHttp2RouteTimeoutIdle)(ptr) = RouteSpecSpecHttp2RouteTimeoutIdle{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecHttp2RouteTimeoutIdle", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecHttp2RouteTimeoutPerRequestCodec struct {
}

func (RouteSpecSpecHttp2RouteTimeoutPerRequestCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecHttp2RouteTimeoutPerRequest)(ptr) == nil
}

func (RouteSpecSpecHttp2RouteTimeoutPerRequestCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecHttp2RouteTimeoutPerRequest)(ptr)
	var objs []RouteSpecSpecHttp2RouteTimeoutPerRequest
	if obj != nil {
		objs = []RouteSpecSpecHttp2RouteTimeoutPerRequest{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteTimeoutPerRequest{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecHttp2RouteTimeoutPerRequestCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecHttp2RouteTimeoutPerRequest)(ptr) = RouteSpecSpecHttp2RouteTimeoutPerRequest{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecHttp2RouteTimeoutPerRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttp2RouteTimeoutPerRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecHttp2RouteTimeoutPerRequest)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecHttp2RouteTimeoutPerRequest)(ptr) = RouteSpecSpecHttp2RouteTimeoutPerRequest{}
			}
		} else {
			*(*RouteSpecSpecHttp2RouteTimeoutPerRequest)(ptr) = RouteSpecSpecHttp2RouteTimeoutPerRequest{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecHttp2RouteTimeoutPerRequest", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecHttpRouteCodec struct {
}

func (RouteSpecSpecHttpRouteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecHttpRoute)(ptr) == nil
}

func (RouteSpecSpecHttpRouteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecHttpRoute)(ptr)
	var objs []RouteSpecSpecHttpRoute
	if obj != nil {
		objs = []RouteSpecSpecHttpRoute{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRoute{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecHttpRouteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecHttpRoute)(ptr) = RouteSpecSpecHttpRoute{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecHttpRoute

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRoute{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecHttpRoute)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecHttpRoute)(ptr) = RouteSpecSpecHttpRoute{}
			}
		} else {
			*(*RouteSpecSpecHttpRoute)(ptr) = RouteSpecSpecHttpRoute{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecHttpRoute", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecHttpRouteActionCodec struct {
}

func (RouteSpecSpecHttpRouteActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecHttpRouteAction)(ptr) == nil
}

func (RouteSpecSpecHttpRouteActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecHttpRouteAction)(ptr)
	var objs []RouteSpecSpecHttpRouteAction
	if obj != nil {
		objs = []RouteSpecSpecHttpRouteAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecHttpRouteActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecHttpRouteAction)(ptr) = RouteSpecSpecHttpRouteAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecHttpRouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecHttpRouteAction)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecHttpRouteAction)(ptr) = RouteSpecSpecHttpRouteAction{}
			}
		} else {
			*(*RouteSpecSpecHttpRouteAction)(ptr) = RouteSpecSpecHttpRouteAction{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecHttpRouteAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecHttpRouteMatchCodec struct {
}

func (RouteSpecSpecHttpRouteMatchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecHttpRouteMatch)(ptr) == nil
}

func (RouteSpecSpecHttpRouteMatchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecHttpRouteMatch)(ptr)
	var objs []RouteSpecSpecHttpRouteMatch
	if obj != nil {
		objs = []RouteSpecSpecHttpRouteMatch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteMatch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecHttpRouteMatchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecHttpRouteMatch)(ptr) = RouteSpecSpecHttpRouteMatch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecHttpRouteMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecHttpRouteMatch)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecHttpRouteMatch)(ptr) = RouteSpecSpecHttpRouteMatch{}
			}
		} else {
			*(*RouteSpecSpecHttpRouteMatch)(ptr) = RouteSpecSpecHttpRouteMatch{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecHttpRouteMatch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecHttpRouteMatchHeaderMatchCodec struct {
}

func (RouteSpecSpecHttpRouteMatchHeaderMatchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecHttpRouteMatchHeaderMatch)(ptr) == nil
}

func (RouteSpecSpecHttpRouteMatchHeaderMatchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecHttpRouteMatchHeaderMatch)(ptr)
	var objs []RouteSpecSpecHttpRouteMatchHeaderMatch
	if obj != nil {
		objs = []RouteSpecSpecHttpRouteMatchHeaderMatch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteMatchHeaderMatch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecHttpRouteMatchHeaderMatchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecHttpRouteMatchHeaderMatch)(ptr) = RouteSpecSpecHttpRouteMatchHeaderMatch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecHttpRouteMatchHeaderMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteMatchHeaderMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecHttpRouteMatchHeaderMatch)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecHttpRouteMatchHeaderMatch)(ptr) = RouteSpecSpecHttpRouteMatchHeaderMatch{}
			}
		} else {
			*(*RouteSpecSpecHttpRouteMatchHeaderMatch)(ptr) = RouteSpecSpecHttpRouteMatchHeaderMatch{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecHttpRouteMatchHeaderMatch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecHttpRouteMatchHeaderMatchRangeCodec struct {
}

func (RouteSpecSpecHttpRouteMatchHeaderMatchRangeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecHttpRouteMatchHeaderMatchRange)(ptr) == nil
}

func (RouteSpecSpecHttpRouteMatchHeaderMatchRangeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecHttpRouteMatchHeaderMatchRange)(ptr)
	var objs []RouteSpecSpecHttpRouteMatchHeaderMatchRange
	if obj != nil {
		objs = []RouteSpecSpecHttpRouteMatchHeaderMatchRange{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteMatchHeaderMatchRange{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecHttpRouteMatchHeaderMatchRangeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecHttpRouteMatchHeaderMatchRange)(ptr) = RouteSpecSpecHttpRouteMatchHeaderMatchRange{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecHttpRouteMatchHeaderMatchRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteMatchHeaderMatchRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecHttpRouteMatchHeaderMatchRange)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecHttpRouteMatchHeaderMatchRange)(ptr) = RouteSpecSpecHttpRouteMatchHeaderMatchRange{}
			}
		} else {
			*(*RouteSpecSpecHttpRouteMatchHeaderMatchRange)(ptr) = RouteSpecSpecHttpRouteMatchHeaderMatchRange{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecHttpRouteMatchHeaderMatchRange", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecHttpRouteRetryPolicyCodec struct {
}

func (RouteSpecSpecHttpRouteRetryPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecHttpRouteRetryPolicy)(ptr) == nil
}

func (RouteSpecSpecHttpRouteRetryPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecHttpRouteRetryPolicy)(ptr)
	var objs []RouteSpecSpecHttpRouteRetryPolicy
	if obj != nil {
		objs = []RouteSpecSpecHttpRouteRetryPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteRetryPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecHttpRouteRetryPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecHttpRouteRetryPolicy)(ptr) = RouteSpecSpecHttpRouteRetryPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecHttpRouteRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecHttpRouteRetryPolicy)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecHttpRouteRetryPolicy)(ptr) = RouteSpecSpecHttpRouteRetryPolicy{}
			}
		} else {
			*(*RouteSpecSpecHttpRouteRetryPolicy)(ptr) = RouteSpecSpecHttpRouteRetryPolicy{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecHttpRouteRetryPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecHttpRouteRetryPolicyPerRetryTimeoutCodec struct {
}

func (RouteSpecSpecHttpRouteRetryPolicyPerRetryTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecHttpRouteRetryPolicyPerRetryTimeout)(ptr) == nil
}

func (RouteSpecSpecHttpRouteRetryPolicyPerRetryTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecHttpRouteRetryPolicyPerRetryTimeout)(ptr)
	var objs []RouteSpecSpecHttpRouteRetryPolicyPerRetryTimeout
	if obj != nil {
		objs = []RouteSpecSpecHttpRouteRetryPolicyPerRetryTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteRetryPolicyPerRetryTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecHttpRouteRetryPolicyPerRetryTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecHttpRouteRetryPolicyPerRetryTimeout)(ptr) = RouteSpecSpecHttpRouteRetryPolicyPerRetryTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecHttpRouteRetryPolicyPerRetryTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteRetryPolicyPerRetryTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecHttpRouteRetryPolicyPerRetryTimeout)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecHttpRouteRetryPolicyPerRetryTimeout)(ptr) = RouteSpecSpecHttpRouteRetryPolicyPerRetryTimeout{}
			}
		} else {
			*(*RouteSpecSpecHttpRouteRetryPolicyPerRetryTimeout)(ptr) = RouteSpecSpecHttpRouteRetryPolicyPerRetryTimeout{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecHttpRouteRetryPolicyPerRetryTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecHttpRouteTimeoutCodec struct {
}

func (RouteSpecSpecHttpRouteTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecHttpRouteTimeout)(ptr) == nil
}

func (RouteSpecSpecHttpRouteTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecHttpRouteTimeout)(ptr)
	var objs []RouteSpecSpecHttpRouteTimeout
	if obj != nil {
		objs = []RouteSpecSpecHttpRouteTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecHttpRouteTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecHttpRouteTimeout)(ptr) = RouteSpecSpecHttpRouteTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecHttpRouteTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecHttpRouteTimeout)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecHttpRouteTimeout)(ptr) = RouteSpecSpecHttpRouteTimeout{}
			}
		} else {
			*(*RouteSpecSpecHttpRouteTimeout)(ptr) = RouteSpecSpecHttpRouteTimeout{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecHttpRouteTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecHttpRouteTimeoutIdleCodec struct {
}

func (RouteSpecSpecHttpRouteTimeoutIdleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecHttpRouteTimeoutIdle)(ptr) == nil
}

func (RouteSpecSpecHttpRouteTimeoutIdleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecHttpRouteTimeoutIdle)(ptr)
	var objs []RouteSpecSpecHttpRouteTimeoutIdle
	if obj != nil {
		objs = []RouteSpecSpecHttpRouteTimeoutIdle{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteTimeoutIdle{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecHttpRouteTimeoutIdleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecHttpRouteTimeoutIdle)(ptr) = RouteSpecSpecHttpRouteTimeoutIdle{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecHttpRouteTimeoutIdle

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteTimeoutIdle{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecHttpRouteTimeoutIdle)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecHttpRouteTimeoutIdle)(ptr) = RouteSpecSpecHttpRouteTimeoutIdle{}
			}
		} else {
			*(*RouteSpecSpecHttpRouteTimeoutIdle)(ptr) = RouteSpecSpecHttpRouteTimeoutIdle{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecHttpRouteTimeoutIdle", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecHttpRouteTimeoutPerRequestCodec struct {
}

func (RouteSpecSpecHttpRouteTimeoutPerRequestCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecHttpRouteTimeoutPerRequest)(ptr) == nil
}

func (RouteSpecSpecHttpRouteTimeoutPerRequestCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecHttpRouteTimeoutPerRequest)(ptr)
	var objs []RouteSpecSpecHttpRouteTimeoutPerRequest
	if obj != nil {
		objs = []RouteSpecSpecHttpRouteTimeoutPerRequest{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteTimeoutPerRequest{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecHttpRouteTimeoutPerRequestCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecHttpRouteTimeoutPerRequest)(ptr) = RouteSpecSpecHttpRouteTimeoutPerRequest{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecHttpRouteTimeoutPerRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecHttpRouteTimeoutPerRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecHttpRouteTimeoutPerRequest)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecHttpRouteTimeoutPerRequest)(ptr) = RouteSpecSpecHttpRouteTimeoutPerRequest{}
			}
		} else {
			*(*RouteSpecSpecHttpRouteTimeoutPerRequest)(ptr) = RouteSpecSpecHttpRouteTimeoutPerRequest{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecHttpRouteTimeoutPerRequest", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecTcpRouteCodec struct {
}

func (RouteSpecSpecTcpRouteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecTcpRoute)(ptr) == nil
}

func (RouteSpecSpecTcpRouteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecTcpRoute)(ptr)
	var objs []RouteSpecSpecTcpRoute
	if obj != nil {
		objs = []RouteSpecSpecTcpRoute{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecTcpRoute{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecTcpRouteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecTcpRoute)(ptr) = RouteSpecSpecTcpRoute{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecTcpRoute

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecTcpRoute{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecTcpRoute)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecTcpRoute)(ptr) = RouteSpecSpecTcpRoute{}
			}
		} else {
			*(*RouteSpecSpecTcpRoute)(ptr) = RouteSpecSpecTcpRoute{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecTcpRoute", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecTcpRouteActionCodec struct {
}

func (RouteSpecSpecTcpRouteActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecTcpRouteAction)(ptr) == nil
}

func (RouteSpecSpecTcpRouteActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecTcpRouteAction)(ptr)
	var objs []RouteSpecSpecTcpRouteAction
	if obj != nil {
		objs = []RouteSpecSpecTcpRouteAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecTcpRouteAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecTcpRouteActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecTcpRouteAction)(ptr) = RouteSpecSpecTcpRouteAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecTcpRouteAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecTcpRouteAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecTcpRouteAction)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecTcpRouteAction)(ptr) = RouteSpecSpecTcpRouteAction{}
			}
		} else {
			*(*RouteSpecSpecTcpRouteAction)(ptr) = RouteSpecSpecTcpRouteAction{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecTcpRouteAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecTcpRouteTimeoutCodec struct {
}

func (RouteSpecSpecTcpRouteTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecTcpRouteTimeout)(ptr) == nil
}

func (RouteSpecSpecTcpRouteTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecTcpRouteTimeout)(ptr)
	var objs []RouteSpecSpecTcpRouteTimeout
	if obj != nil {
		objs = []RouteSpecSpecTcpRouteTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecTcpRouteTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecTcpRouteTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecTcpRouteTimeout)(ptr) = RouteSpecSpecTcpRouteTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecTcpRouteTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecTcpRouteTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecTcpRouteTimeout)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecTcpRouteTimeout)(ptr) = RouteSpecSpecTcpRouteTimeout{}
			}
		} else {
			*(*RouteSpecSpecTcpRouteTimeout)(ptr) = RouteSpecSpecTcpRouteTimeout{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecTcpRouteTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RouteSpecSpecTcpRouteTimeoutIdleCodec struct {
}

func (RouteSpecSpecTcpRouteTimeoutIdleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RouteSpecSpecTcpRouteTimeoutIdle)(ptr) == nil
}

func (RouteSpecSpecTcpRouteTimeoutIdleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RouteSpecSpecTcpRouteTimeoutIdle)(ptr)
	var objs []RouteSpecSpecTcpRouteTimeoutIdle
	if obj != nil {
		objs = []RouteSpecSpecTcpRouteTimeoutIdle{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecTcpRouteTimeoutIdle{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RouteSpecSpecTcpRouteTimeoutIdleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RouteSpecSpecTcpRouteTimeoutIdle)(ptr) = RouteSpecSpecTcpRouteTimeoutIdle{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RouteSpecSpecTcpRouteTimeoutIdle

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RouteSpecSpecTcpRouteTimeoutIdle{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RouteSpecSpecTcpRouteTimeoutIdle)(ptr) = objs[0]
			} else {
				*(*RouteSpecSpecTcpRouteTimeoutIdle)(ptr) = RouteSpecSpecTcpRouteTimeoutIdle{}
			}
		} else {
			*(*RouteSpecSpecTcpRouteTimeoutIdle)(ptr) = RouteSpecSpecTcpRouteTimeoutIdle{}
		}
	default:
		iter.ReportError("decode RouteSpecSpecTcpRouteTimeoutIdle", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecCodec struct {
}

func (VirtualGatewaySpecSpecCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpec)(ptr) == nil
}

func (VirtualGatewaySpecSpecCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpec)(ptr)
	var objs []VirtualGatewaySpecSpec
	if obj != nil {
		objs = []VirtualGatewaySpecSpec{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpec{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpec)(ptr) = VirtualGatewaySpecSpec{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpec

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpec{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpec)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpec)(ptr) = VirtualGatewaySpecSpec{}
			}
		} else {
			*(*VirtualGatewaySpecSpec)(ptr) = VirtualGatewaySpecSpec{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpec", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecBackendDefaultsCodec struct {
}

func (VirtualGatewaySpecSpecBackendDefaultsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecBackendDefaults)(ptr) == nil
}

func (VirtualGatewaySpecSpecBackendDefaultsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecBackendDefaults)(ptr)
	var objs []VirtualGatewaySpecSpecBackendDefaults
	if obj != nil {
		objs = []VirtualGatewaySpecSpecBackendDefaults{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaults{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecBackendDefaultsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecBackendDefaults)(ptr) = VirtualGatewaySpecSpecBackendDefaults{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecBackendDefaults

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaults{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecBackendDefaults)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecBackendDefaults)(ptr) = VirtualGatewaySpecSpecBackendDefaults{}
			}
		} else {
			*(*VirtualGatewaySpecSpecBackendDefaults)(ptr) = VirtualGatewaySpecSpecBackendDefaults{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecBackendDefaults", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecBackendDefaultsClientPolicyCodec struct {
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecBackendDefaultsClientPolicy)(ptr) == nil
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecBackendDefaultsClientPolicy)(ptr)
	var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicy
	if obj != nil {
		objs = []VirtualGatewaySpecSpecBackendDefaultsClientPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicy)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicy)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicy)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicy{}
			}
		} else {
			*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicy)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicy{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecBackendDefaultsClientPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCodec struct {
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTls)(ptr) == nil
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTls)(ptr)
	var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTls
	if obj != nil {
		objs = []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTls{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTls{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTls)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTls{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTls

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTls{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTls)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTls)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTls{}
			}
		} else {
			*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTls)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTls{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecBackendDefaultsClientPolicyTls", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateCodec struct {
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificate)(ptr) == nil
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificate)(ptr)
	var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificate
	if obj != nil {
		objs = []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificate)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificate)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificate)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificate{}
			}
		} else {
			*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificate)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificate{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateFileCodec struct {
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateFileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateFile)(ptr) == nil
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateFileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateFile)(ptr)
	var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateFile
	if obj != nil {
		objs = []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateFile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateFile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateFileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateFile)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateFile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateFile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateFile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateFile)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateFile)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateFile{}
			}
		} else {
			*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateFile)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateFile{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateFile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateSdsCodec struct {
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateSdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateSds)(ptr) == nil
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateSdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateSds)(ptr)
	var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateSds
	if obj != nil {
		objs = []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateSds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateSds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateSdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateSds)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateSds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateSds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateSds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateSds)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateSds)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateSds{}
			}
		} else {
			*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateSds)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateSds{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsCertificateSds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationCodec struct {
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidation)(ptr) == nil
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidation)(ptr)
	var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidation
	if obj != nil {
		objs = []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidation)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidation)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidation)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidation{}
			}
		} else {
			*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidation)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidation{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesCodec struct {
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames)(ptr) == nil
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames)(ptr)
	var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames
	if obj != nil {
		objs = []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames{}
			}
		} else {
			*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchCodec struct {
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch)(ptr) == nil
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch)(ptr)
	var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch
	if obj != nil {
		objs = []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch{}
			}
		} else {
			*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustCodec struct {
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrust)(ptr) == nil
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrust)(ptr)
	var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrust
	if obj != nil {
		objs = []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrust{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrust{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrust)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrust{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrust

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrust{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrust)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrust)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrust{}
			}
		} else {
			*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrust)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrust{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrust", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcmCodec struct {
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcmCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm)(ptr) == nil
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcmCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm)(ptr)
	var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm
	if obj != nil {
		objs = []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcmCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm{}
			}
		} else {
			*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustFileCodec struct {
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustFileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile)(ptr) == nil
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustFileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile)(ptr)
	var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile
	if obj != nil {
		objs = []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustFileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile{}
			}
		} else {
			*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustSdsCodec struct {
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustSdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds)(ptr) == nil
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustSdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds)(ptr)
	var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds
	if obj != nil {
		objs = []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustSdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds{}
			}
		} else {
			*(*VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds)(ptr) = VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecListenerCodec struct {
}

func (VirtualGatewaySpecSpecListenerCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecListener)(ptr) == nil
}

func (VirtualGatewaySpecSpecListenerCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecListener)(ptr)
	var objs []VirtualGatewaySpecSpecListener
	if obj != nil {
		objs = []VirtualGatewaySpecSpecListener{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListener{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecListenerCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecListener)(ptr) = VirtualGatewaySpecSpecListener{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecListener

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListener{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecListener)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecListener)(ptr) = VirtualGatewaySpecSpecListener{}
			}
		} else {
			*(*VirtualGatewaySpecSpecListener)(ptr) = VirtualGatewaySpecSpecListener{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecListener", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecListenerConnectionPoolCodec struct {
}

func (VirtualGatewaySpecSpecListenerConnectionPoolCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecListenerConnectionPool)(ptr) == nil
}

func (VirtualGatewaySpecSpecListenerConnectionPoolCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecListenerConnectionPool)(ptr)
	var objs []VirtualGatewaySpecSpecListenerConnectionPool
	if obj != nil {
		objs = []VirtualGatewaySpecSpecListenerConnectionPool{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerConnectionPool{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecListenerConnectionPoolCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecListenerConnectionPool)(ptr) = VirtualGatewaySpecSpecListenerConnectionPool{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecListenerConnectionPool

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerConnectionPool{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecListenerConnectionPool)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecListenerConnectionPool)(ptr) = VirtualGatewaySpecSpecListenerConnectionPool{}
			}
		} else {
			*(*VirtualGatewaySpecSpecListenerConnectionPool)(ptr) = VirtualGatewaySpecSpecListenerConnectionPool{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecListenerConnectionPool", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecListenerConnectionPoolGrpcCodec struct {
}

func (VirtualGatewaySpecSpecListenerConnectionPoolGrpcCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecListenerConnectionPoolGrpc)(ptr) == nil
}

func (VirtualGatewaySpecSpecListenerConnectionPoolGrpcCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecListenerConnectionPoolGrpc)(ptr)
	var objs []VirtualGatewaySpecSpecListenerConnectionPoolGrpc
	if obj != nil {
		objs = []VirtualGatewaySpecSpecListenerConnectionPoolGrpc{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerConnectionPoolGrpc{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecListenerConnectionPoolGrpcCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecListenerConnectionPoolGrpc)(ptr) = VirtualGatewaySpecSpecListenerConnectionPoolGrpc{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecListenerConnectionPoolGrpc

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerConnectionPoolGrpc{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecListenerConnectionPoolGrpc)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecListenerConnectionPoolGrpc)(ptr) = VirtualGatewaySpecSpecListenerConnectionPoolGrpc{}
			}
		} else {
			*(*VirtualGatewaySpecSpecListenerConnectionPoolGrpc)(ptr) = VirtualGatewaySpecSpecListenerConnectionPoolGrpc{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecListenerConnectionPoolGrpc", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecListenerConnectionPoolHttpCodec struct {
}

func (VirtualGatewaySpecSpecListenerConnectionPoolHttpCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecListenerConnectionPoolHttp)(ptr) == nil
}

func (VirtualGatewaySpecSpecListenerConnectionPoolHttpCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecListenerConnectionPoolHttp)(ptr)
	var objs []VirtualGatewaySpecSpecListenerConnectionPoolHttp
	if obj != nil {
		objs = []VirtualGatewaySpecSpecListenerConnectionPoolHttp{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerConnectionPoolHttp{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecListenerConnectionPoolHttpCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecListenerConnectionPoolHttp)(ptr) = VirtualGatewaySpecSpecListenerConnectionPoolHttp{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecListenerConnectionPoolHttp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerConnectionPoolHttp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecListenerConnectionPoolHttp)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecListenerConnectionPoolHttp)(ptr) = VirtualGatewaySpecSpecListenerConnectionPoolHttp{}
			}
		} else {
			*(*VirtualGatewaySpecSpecListenerConnectionPoolHttp)(ptr) = VirtualGatewaySpecSpecListenerConnectionPoolHttp{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecListenerConnectionPoolHttp", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecListenerConnectionPoolHttp2Codec struct {
}

func (VirtualGatewaySpecSpecListenerConnectionPoolHttp2Codec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecListenerConnectionPoolHttp2)(ptr) == nil
}

func (VirtualGatewaySpecSpecListenerConnectionPoolHttp2Codec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecListenerConnectionPoolHttp2)(ptr)
	var objs []VirtualGatewaySpecSpecListenerConnectionPoolHttp2
	if obj != nil {
		objs = []VirtualGatewaySpecSpecListenerConnectionPoolHttp2{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerConnectionPoolHttp2{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecListenerConnectionPoolHttp2Codec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecListenerConnectionPoolHttp2)(ptr) = VirtualGatewaySpecSpecListenerConnectionPoolHttp2{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecListenerConnectionPoolHttp2

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerConnectionPoolHttp2{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecListenerConnectionPoolHttp2)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecListenerConnectionPoolHttp2)(ptr) = VirtualGatewaySpecSpecListenerConnectionPoolHttp2{}
			}
		} else {
			*(*VirtualGatewaySpecSpecListenerConnectionPoolHttp2)(ptr) = VirtualGatewaySpecSpecListenerConnectionPoolHttp2{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecListenerConnectionPoolHttp2", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecListenerHealthCheckCodec struct {
}

func (VirtualGatewaySpecSpecListenerHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecListenerHealthCheck)(ptr) == nil
}

func (VirtualGatewaySpecSpecListenerHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecListenerHealthCheck)(ptr)
	var objs []VirtualGatewaySpecSpecListenerHealthCheck
	if obj != nil {
		objs = []VirtualGatewaySpecSpecListenerHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecListenerHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecListenerHealthCheck)(ptr) = VirtualGatewaySpecSpecListenerHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecListenerHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecListenerHealthCheck)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecListenerHealthCheck)(ptr) = VirtualGatewaySpecSpecListenerHealthCheck{}
			}
		} else {
			*(*VirtualGatewaySpecSpecListenerHealthCheck)(ptr) = VirtualGatewaySpecSpecListenerHealthCheck{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecListenerHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecListenerPortMappingCodec struct {
}

func (VirtualGatewaySpecSpecListenerPortMappingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecListenerPortMapping)(ptr) == nil
}

func (VirtualGatewaySpecSpecListenerPortMappingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecListenerPortMapping)(ptr)
	var objs []VirtualGatewaySpecSpecListenerPortMapping
	if obj != nil {
		objs = []VirtualGatewaySpecSpecListenerPortMapping{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerPortMapping{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecListenerPortMappingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecListenerPortMapping)(ptr) = VirtualGatewaySpecSpecListenerPortMapping{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecListenerPortMapping

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerPortMapping{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecListenerPortMapping)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecListenerPortMapping)(ptr) = VirtualGatewaySpecSpecListenerPortMapping{}
			}
		} else {
			*(*VirtualGatewaySpecSpecListenerPortMapping)(ptr) = VirtualGatewaySpecSpecListenerPortMapping{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecListenerPortMapping", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecListenerTlsCodec struct {
}

func (VirtualGatewaySpecSpecListenerTlsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecListenerTls)(ptr) == nil
}

func (VirtualGatewaySpecSpecListenerTlsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecListenerTls)(ptr)
	var objs []VirtualGatewaySpecSpecListenerTls
	if obj != nil {
		objs = []VirtualGatewaySpecSpecListenerTls{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTls{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecListenerTlsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecListenerTls)(ptr) = VirtualGatewaySpecSpecListenerTls{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecListenerTls

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTls{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecListenerTls)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecListenerTls)(ptr) = VirtualGatewaySpecSpecListenerTls{}
			}
		} else {
			*(*VirtualGatewaySpecSpecListenerTls)(ptr) = VirtualGatewaySpecSpecListenerTls{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecListenerTls", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecListenerTlsCertificateCodec struct {
}

func (VirtualGatewaySpecSpecListenerTlsCertificateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecListenerTlsCertificate)(ptr) == nil
}

func (VirtualGatewaySpecSpecListenerTlsCertificateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecListenerTlsCertificate)(ptr)
	var objs []VirtualGatewaySpecSpecListenerTlsCertificate
	if obj != nil {
		objs = []VirtualGatewaySpecSpecListenerTlsCertificate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsCertificate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecListenerTlsCertificateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecListenerTlsCertificate)(ptr) = VirtualGatewaySpecSpecListenerTlsCertificate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecListenerTlsCertificate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsCertificate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecListenerTlsCertificate)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecListenerTlsCertificate)(ptr) = VirtualGatewaySpecSpecListenerTlsCertificate{}
			}
		} else {
			*(*VirtualGatewaySpecSpecListenerTlsCertificate)(ptr) = VirtualGatewaySpecSpecListenerTlsCertificate{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecListenerTlsCertificate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecListenerTlsCertificateAcmCodec struct {
}

func (VirtualGatewaySpecSpecListenerTlsCertificateAcmCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecListenerTlsCertificateAcm)(ptr) == nil
}

func (VirtualGatewaySpecSpecListenerTlsCertificateAcmCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecListenerTlsCertificateAcm)(ptr)
	var objs []VirtualGatewaySpecSpecListenerTlsCertificateAcm
	if obj != nil {
		objs = []VirtualGatewaySpecSpecListenerTlsCertificateAcm{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsCertificateAcm{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecListenerTlsCertificateAcmCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecListenerTlsCertificateAcm)(ptr) = VirtualGatewaySpecSpecListenerTlsCertificateAcm{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecListenerTlsCertificateAcm

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsCertificateAcm{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecListenerTlsCertificateAcm)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecListenerTlsCertificateAcm)(ptr) = VirtualGatewaySpecSpecListenerTlsCertificateAcm{}
			}
		} else {
			*(*VirtualGatewaySpecSpecListenerTlsCertificateAcm)(ptr) = VirtualGatewaySpecSpecListenerTlsCertificateAcm{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecListenerTlsCertificateAcm", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecListenerTlsCertificateFileCodec struct {
}

func (VirtualGatewaySpecSpecListenerTlsCertificateFileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecListenerTlsCertificateFile)(ptr) == nil
}

func (VirtualGatewaySpecSpecListenerTlsCertificateFileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecListenerTlsCertificateFile)(ptr)
	var objs []VirtualGatewaySpecSpecListenerTlsCertificateFile
	if obj != nil {
		objs = []VirtualGatewaySpecSpecListenerTlsCertificateFile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsCertificateFile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecListenerTlsCertificateFileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecListenerTlsCertificateFile)(ptr) = VirtualGatewaySpecSpecListenerTlsCertificateFile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecListenerTlsCertificateFile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsCertificateFile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecListenerTlsCertificateFile)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecListenerTlsCertificateFile)(ptr) = VirtualGatewaySpecSpecListenerTlsCertificateFile{}
			}
		} else {
			*(*VirtualGatewaySpecSpecListenerTlsCertificateFile)(ptr) = VirtualGatewaySpecSpecListenerTlsCertificateFile{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecListenerTlsCertificateFile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecListenerTlsCertificateSdsCodec struct {
}

func (VirtualGatewaySpecSpecListenerTlsCertificateSdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecListenerTlsCertificateSds)(ptr) == nil
}

func (VirtualGatewaySpecSpecListenerTlsCertificateSdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecListenerTlsCertificateSds)(ptr)
	var objs []VirtualGatewaySpecSpecListenerTlsCertificateSds
	if obj != nil {
		objs = []VirtualGatewaySpecSpecListenerTlsCertificateSds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsCertificateSds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecListenerTlsCertificateSdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecListenerTlsCertificateSds)(ptr) = VirtualGatewaySpecSpecListenerTlsCertificateSds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecListenerTlsCertificateSds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsCertificateSds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecListenerTlsCertificateSds)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecListenerTlsCertificateSds)(ptr) = VirtualGatewaySpecSpecListenerTlsCertificateSds{}
			}
		} else {
			*(*VirtualGatewaySpecSpecListenerTlsCertificateSds)(ptr) = VirtualGatewaySpecSpecListenerTlsCertificateSds{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecListenerTlsCertificateSds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecListenerTlsValidationCodec struct {
}

func (VirtualGatewaySpecSpecListenerTlsValidationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecListenerTlsValidation)(ptr) == nil
}

func (VirtualGatewaySpecSpecListenerTlsValidationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecListenerTlsValidation)(ptr)
	var objs []VirtualGatewaySpecSpecListenerTlsValidation
	if obj != nil {
		objs = []VirtualGatewaySpecSpecListenerTlsValidation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecListenerTlsValidationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecListenerTlsValidation)(ptr) = VirtualGatewaySpecSpecListenerTlsValidation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecListenerTlsValidation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecListenerTlsValidation)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecListenerTlsValidation)(ptr) = VirtualGatewaySpecSpecListenerTlsValidation{}
			}
		} else {
			*(*VirtualGatewaySpecSpecListenerTlsValidation)(ptr) = VirtualGatewaySpecSpecListenerTlsValidation{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecListenerTlsValidation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesCodec struct {
}

func (VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNames)(ptr) == nil
}

func (VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNames)(ptr)
	var objs []VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNames
	if obj != nil {
		objs = []VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNames{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNames{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNames)(ptr) = VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNames{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNames

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNames{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNames)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNames)(ptr) = VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNames{}
			}
		} else {
			*(*VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNames)(ptr) = VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNames{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNames", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesMatchCodec struct {
}

func (VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesMatchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesMatch)(ptr) == nil
}

func (VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesMatchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesMatch)(ptr)
	var objs []VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesMatch
	if obj != nil {
		objs = []VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesMatch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesMatch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesMatchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesMatch)(ptr) = VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesMatch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesMatch)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesMatch)(ptr) = VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesMatch{}
			}
		} else {
			*(*VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesMatch)(ptr) = VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesMatch{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecListenerTlsValidationSubjectAlternativeNamesMatch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecListenerTlsValidationTrustCodec struct {
}

func (VirtualGatewaySpecSpecListenerTlsValidationTrustCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecListenerTlsValidationTrust)(ptr) == nil
}

func (VirtualGatewaySpecSpecListenerTlsValidationTrustCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecListenerTlsValidationTrust)(ptr)
	var objs []VirtualGatewaySpecSpecListenerTlsValidationTrust
	if obj != nil {
		objs = []VirtualGatewaySpecSpecListenerTlsValidationTrust{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidationTrust{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecListenerTlsValidationTrustCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecListenerTlsValidationTrust)(ptr) = VirtualGatewaySpecSpecListenerTlsValidationTrust{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecListenerTlsValidationTrust

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidationTrust{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecListenerTlsValidationTrust)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecListenerTlsValidationTrust)(ptr) = VirtualGatewaySpecSpecListenerTlsValidationTrust{}
			}
		} else {
			*(*VirtualGatewaySpecSpecListenerTlsValidationTrust)(ptr) = VirtualGatewaySpecSpecListenerTlsValidationTrust{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecListenerTlsValidationTrust", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecListenerTlsValidationTrustFileCodec struct {
}

func (VirtualGatewaySpecSpecListenerTlsValidationTrustFileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecListenerTlsValidationTrustFile)(ptr) == nil
}

func (VirtualGatewaySpecSpecListenerTlsValidationTrustFileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecListenerTlsValidationTrustFile)(ptr)
	var objs []VirtualGatewaySpecSpecListenerTlsValidationTrustFile
	if obj != nil {
		objs = []VirtualGatewaySpecSpecListenerTlsValidationTrustFile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidationTrustFile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecListenerTlsValidationTrustFileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecListenerTlsValidationTrustFile)(ptr) = VirtualGatewaySpecSpecListenerTlsValidationTrustFile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecListenerTlsValidationTrustFile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidationTrustFile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecListenerTlsValidationTrustFile)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecListenerTlsValidationTrustFile)(ptr) = VirtualGatewaySpecSpecListenerTlsValidationTrustFile{}
			}
		} else {
			*(*VirtualGatewaySpecSpecListenerTlsValidationTrustFile)(ptr) = VirtualGatewaySpecSpecListenerTlsValidationTrustFile{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecListenerTlsValidationTrustFile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecListenerTlsValidationTrustSdsCodec struct {
}

func (VirtualGatewaySpecSpecListenerTlsValidationTrustSdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecListenerTlsValidationTrustSds)(ptr) == nil
}

func (VirtualGatewaySpecSpecListenerTlsValidationTrustSdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecListenerTlsValidationTrustSds)(ptr)
	var objs []VirtualGatewaySpecSpecListenerTlsValidationTrustSds
	if obj != nil {
		objs = []VirtualGatewaySpecSpecListenerTlsValidationTrustSds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidationTrustSds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecListenerTlsValidationTrustSdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecListenerTlsValidationTrustSds)(ptr) = VirtualGatewaySpecSpecListenerTlsValidationTrustSds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecListenerTlsValidationTrustSds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecListenerTlsValidationTrustSds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecListenerTlsValidationTrustSds)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecListenerTlsValidationTrustSds)(ptr) = VirtualGatewaySpecSpecListenerTlsValidationTrustSds{}
			}
		} else {
			*(*VirtualGatewaySpecSpecListenerTlsValidationTrustSds)(ptr) = VirtualGatewaySpecSpecListenerTlsValidationTrustSds{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecListenerTlsValidationTrustSds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecLoggingCodec struct {
}

func (VirtualGatewaySpecSpecLoggingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecLogging)(ptr) == nil
}

func (VirtualGatewaySpecSpecLoggingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecLogging)(ptr)
	var objs []VirtualGatewaySpecSpecLogging
	if obj != nil {
		objs = []VirtualGatewaySpecSpecLogging{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecLogging{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecLoggingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecLogging)(ptr) = VirtualGatewaySpecSpecLogging{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecLogging

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecLogging{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecLogging)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecLogging)(ptr) = VirtualGatewaySpecSpecLogging{}
			}
		} else {
			*(*VirtualGatewaySpecSpecLogging)(ptr) = VirtualGatewaySpecSpecLogging{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecLogging", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecLoggingAccessLogCodec struct {
}

func (VirtualGatewaySpecSpecLoggingAccessLogCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecLoggingAccessLog)(ptr) == nil
}

func (VirtualGatewaySpecSpecLoggingAccessLogCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecLoggingAccessLog)(ptr)
	var objs []VirtualGatewaySpecSpecLoggingAccessLog
	if obj != nil {
		objs = []VirtualGatewaySpecSpecLoggingAccessLog{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecLoggingAccessLog{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecLoggingAccessLogCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecLoggingAccessLog)(ptr) = VirtualGatewaySpecSpecLoggingAccessLog{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecLoggingAccessLog

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecLoggingAccessLog{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecLoggingAccessLog)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecLoggingAccessLog)(ptr) = VirtualGatewaySpecSpecLoggingAccessLog{}
			}
		} else {
			*(*VirtualGatewaySpecSpecLoggingAccessLog)(ptr) = VirtualGatewaySpecSpecLoggingAccessLog{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecLoggingAccessLog", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualGatewaySpecSpecLoggingAccessLogFileCodec struct {
}

func (VirtualGatewaySpecSpecLoggingAccessLogFileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualGatewaySpecSpecLoggingAccessLogFile)(ptr) == nil
}

func (VirtualGatewaySpecSpecLoggingAccessLogFileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualGatewaySpecSpecLoggingAccessLogFile)(ptr)
	var objs []VirtualGatewaySpecSpecLoggingAccessLogFile
	if obj != nil {
		objs = []VirtualGatewaySpecSpecLoggingAccessLogFile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecLoggingAccessLogFile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualGatewaySpecSpecLoggingAccessLogFileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualGatewaySpecSpecLoggingAccessLogFile)(ptr) = VirtualGatewaySpecSpecLoggingAccessLogFile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualGatewaySpecSpecLoggingAccessLogFile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualGatewaySpecSpecLoggingAccessLogFile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualGatewaySpecSpecLoggingAccessLogFile)(ptr) = objs[0]
			} else {
				*(*VirtualGatewaySpecSpecLoggingAccessLogFile)(ptr) = VirtualGatewaySpecSpecLoggingAccessLogFile{}
			}
		} else {
			*(*VirtualGatewaySpecSpecLoggingAccessLogFile)(ptr) = VirtualGatewaySpecSpecLoggingAccessLogFile{}
		}
	default:
		iter.ReportError("decode VirtualGatewaySpecSpecLoggingAccessLogFile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecCodec struct {
}

func (VirtualNodeSpecSpecCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpec)(ptr) == nil
}

func (VirtualNodeSpecSpecCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpec)(ptr)
	var objs []VirtualNodeSpecSpec
	if obj != nil {
		objs = []VirtualNodeSpecSpec{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpec{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpec)(ptr) = VirtualNodeSpecSpec{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpec

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpec{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpec)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpec)(ptr) = VirtualNodeSpecSpec{}
			}
		} else {
			*(*VirtualNodeSpecSpec)(ptr) = VirtualNodeSpecSpec{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpec", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendVirtualServiceCodec struct {
}

func (VirtualNodeSpecSpecBackendVirtualServiceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendVirtualService)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendVirtualServiceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendVirtualService)(ptr)
	var objs []VirtualNodeSpecSpecBackendVirtualService
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendVirtualService{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualService{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendVirtualServiceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendVirtualService)(ptr) = VirtualNodeSpecSpecBackendVirtualService{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendVirtualService

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualService{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendVirtualService)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendVirtualService)(ptr) = VirtualNodeSpecSpecBackendVirtualService{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendVirtualService)(ptr) = VirtualNodeSpecSpecBackendVirtualService{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendVirtualService", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendVirtualServiceClientPolicyCodec struct {
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicy)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicy)(ptr)
	var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicy
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendVirtualServiceClientPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicy)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicy)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicy)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicy{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicy)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicy{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendVirtualServiceClientPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCodec struct {
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTls)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTls)(ptr)
	var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTls
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTls{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTls{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTls)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTls{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTls

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTls{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTls)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTls)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTls{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTls)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTls{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTls", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateCodec struct {
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificate)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificate)(ptr)
	var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificate
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificate)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificate)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificate)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificate{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificate)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificate{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateFileCodec struct {
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateFileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateFile)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateFileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateFile)(ptr)
	var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateFile
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateFile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateFile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateFileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateFile)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateFile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateFile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateFile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateFile)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateFile)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateFile{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateFile)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateFile{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateFile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateSdsCodec struct {
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateSdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateSds)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateSdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateSds)(ptr)
	var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateSds
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateSds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateSds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateSdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateSds)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateSds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateSds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateSds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateSds)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateSds)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateSds{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateSds)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateSds{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsCertificateSds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationCodec struct {
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidation)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidation)(ptr)
	var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidation
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidation)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidation)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidation)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidation{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidation)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidation{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesCodec struct {
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames)(ptr)
	var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNames", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatchCodec struct {
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch)(ptr)
	var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationSubjectAlternativeNamesMatch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustCodec struct {
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrust)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrust)(ptr)
	var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrust
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrust{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrust{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrust)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrust{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrust

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrust{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrust)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrust)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrust{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrust)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrust{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrust", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcmCodec struct {
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcmCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcmCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm)(ptr)
	var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcmCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustAcm", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustFileCodec struct {
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustFileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustFileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile)(ptr)
	var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustFileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustFile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustSdsCodec struct {
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustSdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustSdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds)(ptr)
	var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustSdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds)(ptr) = VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendVirtualServiceClientPolicyTlsValidationTrustSds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendDefaultsCodec struct {
}

func (VirtualNodeSpecSpecBackendDefaultsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendDefaults)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendDefaultsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendDefaults)(ptr)
	var objs []VirtualNodeSpecSpecBackendDefaults
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendDefaults{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaults{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendDefaultsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendDefaults)(ptr) = VirtualNodeSpecSpecBackendDefaults{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendDefaults

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaults{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendDefaults)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendDefaults)(ptr) = VirtualNodeSpecSpecBackendDefaults{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendDefaults)(ptr) = VirtualNodeSpecSpecBackendDefaults{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendDefaults", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendDefaultsClientPolicyCodec struct {
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendDefaultsClientPolicy)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendDefaultsClientPolicy)(ptr)
	var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicy
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendDefaultsClientPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendDefaultsClientPolicy)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicy)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicy)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicy{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendDefaultsClientPolicy)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicy{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendDefaultsClientPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCodec struct {
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendDefaultsClientPolicyTls)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendDefaultsClientPolicyTls)(ptr)
	var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicyTls
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendDefaultsClientPolicyTls{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTls{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTls)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTls{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicyTls

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTls{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTls)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTls)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTls{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTls)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTls{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendDefaultsClientPolicyTls", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateCodec struct {
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificate)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificate)(ptr)
	var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificate
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificate)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificate)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificate)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificate{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificate)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificate{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateFileCodec struct {
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateFileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateFile)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateFileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateFile)(ptr)
	var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateFile
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateFile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateFile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateFileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateFile)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateFile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateFile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateFile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateFile)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateFile)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateFile{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateFile)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateFile{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateFile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateSdsCodec struct {
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateSdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateSds)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateSdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateSds)(ptr)
	var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateSds
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateSds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateSds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateSdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateSds)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateSds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateSds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateSds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateSds)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateSds)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateSds{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateSds)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateSds{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsCertificateSds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationCodec struct {
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidation)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidation)(ptr)
	var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidation
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidation)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidation)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidation)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidation{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidation)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidation{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesCodec struct {
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames)(ptr)
	var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNames", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchCodec struct {
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch)(ptr)
	var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationSubjectAlternativeNamesMatch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustCodec struct {
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrust)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrust)(ptr)
	var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrust
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrust{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrust{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrust)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrust{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrust

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrust{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrust)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrust)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrust{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrust)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrust{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrust", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcmCodec struct {
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcmCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcmCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm)(ptr)
	var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcmCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustAcm", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustFileCodec struct {
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustFileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustFileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile)(ptr)
	var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustFileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustFile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustSdsCodec struct {
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustSdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds)(ptr) == nil
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustSdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds)(ptr)
	var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds
	if obj != nil {
		objs = []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustSdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds{}
			}
		} else {
			*(*VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds)(ptr) = VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecBackendDefaultsClientPolicyTlsValidationTrustSds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerCodec struct {
}

func (VirtualNodeSpecSpecListenerCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListener)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListener)(ptr)
	var objs []VirtualNodeSpecSpecListener
	if obj != nil {
		objs = []VirtualNodeSpecSpecListener{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListener{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListener)(ptr) = VirtualNodeSpecSpecListener{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListener

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListener{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListener)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListener)(ptr) = VirtualNodeSpecSpecListener{}
			}
		} else {
			*(*VirtualNodeSpecSpecListener)(ptr) = VirtualNodeSpecSpecListener{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListener", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerConnectionPoolCodec struct {
}

func (VirtualNodeSpecSpecListenerConnectionPoolCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerConnectionPool)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerConnectionPoolCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerConnectionPool)(ptr)
	var objs []VirtualNodeSpecSpecListenerConnectionPool
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerConnectionPool{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerConnectionPool{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerConnectionPoolCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerConnectionPool)(ptr) = VirtualNodeSpecSpecListenerConnectionPool{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerConnectionPool

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerConnectionPool{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerConnectionPool)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerConnectionPool)(ptr) = VirtualNodeSpecSpecListenerConnectionPool{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerConnectionPool)(ptr) = VirtualNodeSpecSpecListenerConnectionPool{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerConnectionPool", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerConnectionPoolGrpcCodec struct {
}

func (VirtualNodeSpecSpecListenerConnectionPoolGrpcCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerConnectionPoolGrpc)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerConnectionPoolGrpcCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerConnectionPoolGrpc)(ptr)
	var objs []VirtualNodeSpecSpecListenerConnectionPoolGrpc
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerConnectionPoolGrpc{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerConnectionPoolGrpc{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerConnectionPoolGrpcCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerConnectionPoolGrpc)(ptr) = VirtualNodeSpecSpecListenerConnectionPoolGrpc{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerConnectionPoolGrpc

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerConnectionPoolGrpc{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerConnectionPoolGrpc)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerConnectionPoolGrpc)(ptr) = VirtualNodeSpecSpecListenerConnectionPoolGrpc{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerConnectionPoolGrpc)(ptr) = VirtualNodeSpecSpecListenerConnectionPoolGrpc{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerConnectionPoolGrpc", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerConnectionPoolHttpCodec struct {
}

func (VirtualNodeSpecSpecListenerConnectionPoolHttpCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerConnectionPoolHttp)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerConnectionPoolHttpCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerConnectionPoolHttp)(ptr)
	var objs []VirtualNodeSpecSpecListenerConnectionPoolHttp
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerConnectionPoolHttp{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerConnectionPoolHttp{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerConnectionPoolHttpCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerConnectionPoolHttp)(ptr) = VirtualNodeSpecSpecListenerConnectionPoolHttp{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerConnectionPoolHttp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerConnectionPoolHttp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerConnectionPoolHttp)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerConnectionPoolHttp)(ptr) = VirtualNodeSpecSpecListenerConnectionPoolHttp{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerConnectionPoolHttp)(ptr) = VirtualNodeSpecSpecListenerConnectionPoolHttp{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerConnectionPoolHttp", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerConnectionPoolHttp2Codec struct {
}

func (VirtualNodeSpecSpecListenerConnectionPoolHttp2Codec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerConnectionPoolHttp2)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerConnectionPoolHttp2Codec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerConnectionPoolHttp2)(ptr)
	var objs []VirtualNodeSpecSpecListenerConnectionPoolHttp2
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerConnectionPoolHttp2{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerConnectionPoolHttp2{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerConnectionPoolHttp2Codec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerConnectionPoolHttp2)(ptr) = VirtualNodeSpecSpecListenerConnectionPoolHttp2{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerConnectionPoolHttp2

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerConnectionPoolHttp2{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerConnectionPoolHttp2)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerConnectionPoolHttp2)(ptr) = VirtualNodeSpecSpecListenerConnectionPoolHttp2{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerConnectionPoolHttp2)(ptr) = VirtualNodeSpecSpecListenerConnectionPoolHttp2{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerConnectionPoolHttp2", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerConnectionPoolTcpCodec struct {
}

func (VirtualNodeSpecSpecListenerConnectionPoolTcpCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerConnectionPoolTcp)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerConnectionPoolTcpCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerConnectionPoolTcp)(ptr)
	var objs []VirtualNodeSpecSpecListenerConnectionPoolTcp
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerConnectionPoolTcp{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerConnectionPoolTcp{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerConnectionPoolTcpCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerConnectionPoolTcp)(ptr) = VirtualNodeSpecSpecListenerConnectionPoolTcp{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerConnectionPoolTcp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerConnectionPoolTcp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerConnectionPoolTcp)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerConnectionPoolTcp)(ptr) = VirtualNodeSpecSpecListenerConnectionPoolTcp{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerConnectionPoolTcp)(ptr) = VirtualNodeSpecSpecListenerConnectionPoolTcp{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerConnectionPoolTcp", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerHealthCheckCodec struct {
}

func (VirtualNodeSpecSpecListenerHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerHealthCheck)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerHealthCheck)(ptr)
	var objs []VirtualNodeSpecSpecListenerHealthCheck
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerHealthCheck)(ptr) = VirtualNodeSpecSpecListenerHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerHealthCheck)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerHealthCheck)(ptr) = VirtualNodeSpecSpecListenerHealthCheck{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerHealthCheck)(ptr) = VirtualNodeSpecSpecListenerHealthCheck{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerOutlierDetectionCodec struct {
}

func (VirtualNodeSpecSpecListenerOutlierDetectionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerOutlierDetection)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerOutlierDetectionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerOutlierDetection)(ptr)
	var objs []VirtualNodeSpecSpecListenerOutlierDetection
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerOutlierDetection{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerOutlierDetection{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerOutlierDetectionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerOutlierDetection)(ptr) = VirtualNodeSpecSpecListenerOutlierDetection{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerOutlierDetection

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerOutlierDetection{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerOutlierDetection)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerOutlierDetection)(ptr) = VirtualNodeSpecSpecListenerOutlierDetection{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerOutlierDetection)(ptr) = VirtualNodeSpecSpecListenerOutlierDetection{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerOutlierDetection", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerOutlierDetectionBaseEjectionDurationCodec struct {
}

func (VirtualNodeSpecSpecListenerOutlierDetectionBaseEjectionDurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerOutlierDetectionBaseEjectionDuration)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerOutlierDetectionBaseEjectionDurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerOutlierDetectionBaseEjectionDuration)(ptr)
	var objs []VirtualNodeSpecSpecListenerOutlierDetectionBaseEjectionDuration
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerOutlierDetectionBaseEjectionDuration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerOutlierDetectionBaseEjectionDuration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerOutlierDetectionBaseEjectionDurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerOutlierDetectionBaseEjectionDuration)(ptr) = VirtualNodeSpecSpecListenerOutlierDetectionBaseEjectionDuration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerOutlierDetectionBaseEjectionDuration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerOutlierDetectionBaseEjectionDuration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerOutlierDetectionBaseEjectionDuration)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerOutlierDetectionBaseEjectionDuration)(ptr) = VirtualNodeSpecSpecListenerOutlierDetectionBaseEjectionDuration{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerOutlierDetectionBaseEjectionDuration)(ptr) = VirtualNodeSpecSpecListenerOutlierDetectionBaseEjectionDuration{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerOutlierDetectionBaseEjectionDuration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerOutlierDetectionIntervalCodec struct {
}

func (VirtualNodeSpecSpecListenerOutlierDetectionIntervalCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerOutlierDetectionInterval)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerOutlierDetectionIntervalCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerOutlierDetectionInterval)(ptr)
	var objs []VirtualNodeSpecSpecListenerOutlierDetectionInterval
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerOutlierDetectionInterval{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerOutlierDetectionInterval{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerOutlierDetectionIntervalCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerOutlierDetectionInterval)(ptr) = VirtualNodeSpecSpecListenerOutlierDetectionInterval{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerOutlierDetectionInterval

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerOutlierDetectionInterval{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerOutlierDetectionInterval)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerOutlierDetectionInterval)(ptr) = VirtualNodeSpecSpecListenerOutlierDetectionInterval{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerOutlierDetectionInterval)(ptr) = VirtualNodeSpecSpecListenerOutlierDetectionInterval{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerOutlierDetectionInterval", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerPortMappingCodec struct {
}

func (VirtualNodeSpecSpecListenerPortMappingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerPortMapping)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerPortMappingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerPortMapping)(ptr)
	var objs []VirtualNodeSpecSpecListenerPortMapping
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerPortMapping{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerPortMapping{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerPortMappingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerPortMapping)(ptr) = VirtualNodeSpecSpecListenerPortMapping{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerPortMapping

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerPortMapping{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerPortMapping)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerPortMapping)(ptr) = VirtualNodeSpecSpecListenerPortMapping{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerPortMapping)(ptr) = VirtualNodeSpecSpecListenerPortMapping{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerPortMapping", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerTimeoutCodec struct {
}

func (VirtualNodeSpecSpecListenerTimeoutCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerTimeout)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerTimeoutCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerTimeout)(ptr)
	var objs []VirtualNodeSpecSpecListenerTimeout
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerTimeout{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeout{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerTimeoutCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerTimeout)(ptr) = VirtualNodeSpecSpecListenerTimeout{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerTimeout

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeout{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerTimeout)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerTimeout)(ptr) = VirtualNodeSpecSpecListenerTimeout{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerTimeout)(ptr) = VirtualNodeSpecSpecListenerTimeout{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerTimeout", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerTimeoutGrpcCodec struct {
}

func (VirtualNodeSpecSpecListenerTimeoutGrpcCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerTimeoutGrpc)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerTimeoutGrpcCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerTimeoutGrpc)(ptr)
	var objs []VirtualNodeSpecSpecListenerTimeoutGrpc
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerTimeoutGrpc{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutGrpc{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerTimeoutGrpcCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerTimeoutGrpc)(ptr) = VirtualNodeSpecSpecListenerTimeoutGrpc{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerTimeoutGrpc

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutGrpc{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerTimeoutGrpc)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerTimeoutGrpc)(ptr) = VirtualNodeSpecSpecListenerTimeoutGrpc{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerTimeoutGrpc)(ptr) = VirtualNodeSpecSpecListenerTimeoutGrpc{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerTimeoutGrpc", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerTimeoutGrpcIdleCodec struct {
}

func (VirtualNodeSpecSpecListenerTimeoutGrpcIdleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerTimeoutGrpcIdle)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerTimeoutGrpcIdleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerTimeoutGrpcIdle)(ptr)
	var objs []VirtualNodeSpecSpecListenerTimeoutGrpcIdle
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerTimeoutGrpcIdle{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutGrpcIdle{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerTimeoutGrpcIdleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerTimeoutGrpcIdle)(ptr) = VirtualNodeSpecSpecListenerTimeoutGrpcIdle{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerTimeoutGrpcIdle

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutGrpcIdle{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerTimeoutGrpcIdle)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerTimeoutGrpcIdle)(ptr) = VirtualNodeSpecSpecListenerTimeoutGrpcIdle{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerTimeoutGrpcIdle)(ptr) = VirtualNodeSpecSpecListenerTimeoutGrpcIdle{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerTimeoutGrpcIdle", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerTimeoutGrpcPerRequestCodec struct {
}

func (VirtualNodeSpecSpecListenerTimeoutGrpcPerRequestCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerTimeoutGrpcPerRequest)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerTimeoutGrpcPerRequestCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerTimeoutGrpcPerRequest)(ptr)
	var objs []VirtualNodeSpecSpecListenerTimeoutGrpcPerRequest
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerTimeoutGrpcPerRequest{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutGrpcPerRequest{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerTimeoutGrpcPerRequestCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerTimeoutGrpcPerRequest)(ptr) = VirtualNodeSpecSpecListenerTimeoutGrpcPerRequest{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerTimeoutGrpcPerRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutGrpcPerRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerTimeoutGrpcPerRequest)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerTimeoutGrpcPerRequest)(ptr) = VirtualNodeSpecSpecListenerTimeoutGrpcPerRequest{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerTimeoutGrpcPerRequest)(ptr) = VirtualNodeSpecSpecListenerTimeoutGrpcPerRequest{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerTimeoutGrpcPerRequest", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerTimeoutHttpCodec struct {
}

func (VirtualNodeSpecSpecListenerTimeoutHttpCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerTimeoutHttp)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerTimeoutHttpCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerTimeoutHttp)(ptr)
	var objs []VirtualNodeSpecSpecListenerTimeoutHttp
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerTimeoutHttp{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttp{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerTimeoutHttpCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerTimeoutHttp)(ptr) = VirtualNodeSpecSpecListenerTimeoutHttp{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerTimeoutHttp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerTimeoutHttp)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerTimeoutHttp)(ptr) = VirtualNodeSpecSpecListenerTimeoutHttp{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerTimeoutHttp)(ptr) = VirtualNodeSpecSpecListenerTimeoutHttp{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerTimeoutHttp", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerTimeoutHttpIdleCodec struct {
}

func (VirtualNodeSpecSpecListenerTimeoutHttpIdleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerTimeoutHttpIdle)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerTimeoutHttpIdleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerTimeoutHttpIdle)(ptr)
	var objs []VirtualNodeSpecSpecListenerTimeoutHttpIdle
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerTimeoutHttpIdle{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttpIdle{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerTimeoutHttpIdleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerTimeoutHttpIdle)(ptr) = VirtualNodeSpecSpecListenerTimeoutHttpIdle{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerTimeoutHttpIdle

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttpIdle{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerTimeoutHttpIdle)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerTimeoutHttpIdle)(ptr) = VirtualNodeSpecSpecListenerTimeoutHttpIdle{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerTimeoutHttpIdle)(ptr) = VirtualNodeSpecSpecListenerTimeoutHttpIdle{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerTimeoutHttpIdle", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerTimeoutHttpPerRequestCodec struct {
}

func (VirtualNodeSpecSpecListenerTimeoutHttpPerRequestCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerTimeoutHttpPerRequest)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerTimeoutHttpPerRequestCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerTimeoutHttpPerRequest)(ptr)
	var objs []VirtualNodeSpecSpecListenerTimeoutHttpPerRequest
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerTimeoutHttpPerRequest{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttpPerRequest{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerTimeoutHttpPerRequestCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerTimeoutHttpPerRequest)(ptr) = VirtualNodeSpecSpecListenerTimeoutHttpPerRequest{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerTimeoutHttpPerRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttpPerRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerTimeoutHttpPerRequest)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerTimeoutHttpPerRequest)(ptr) = VirtualNodeSpecSpecListenerTimeoutHttpPerRequest{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerTimeoutHttpPerRequest)(ptr) = VirtualNodeSpecSpecListenerTimeoutHttpPerRequest{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerTimeoutHttpPerRequest", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerTimeoutHttp2Codec struct {
}

func (VirtualNodeSpecSpecListenerTimeoutHttp2Codec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerTimeoutHttp2)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerTimeoutHttp2Codec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerTimeoutHttp2)(ptr)
	var objs []VirtualNodeSpecSpecListenerTimeoutHttp2
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerTimeoutHttp2{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttp2{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerTimeoutHttp2Codec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerTimeoutHttp2)(ptr) = VirtualNodeSpecSpecListenerTimeoutHttp2{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerTimeoutHttp2

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttp2{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerTimeoutHttp2)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerTimeoutHttp2)(ptr) = VirtualNodeSpecSpecListenerTimeoutHttp2{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerTimeoutHttp2)(ptr) = VirtualNodeSpecSpecListenerTimeoutHttp2{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerTimeoutHttp2", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerTimeoutHttp2IdleCodec struct {
}

func (VirtualNodeSpecSpecListenerTimeoutHttp2IdleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerTimeoutHttp2Idle)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerTimeoutHttp2IdleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerTimeoutHttp2Idle)(ptr)
	var objs []VirtualNodeSpecSpecListenerTimeoutHttp2Idle
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerTimeoutHttp2Idle{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttp2Idle{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerTimeoutHttp2IdleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerTimeoutHttp2Idle)(ptr) = VirtualNodeSpecSpecListenerTimeoutHttp2Idle{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerTimeoutHttp2Idle

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttp2Idle{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerTimeoutHttp2Idle)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerTimeoutHttp2Idle)(ptr) = VirtualNodeSpecSpecListenerTimeoutHttp2Idle{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerTimeoutHttp2Idle)(ptr) = VirtualNodeSpecSpecListenerTimeoutHttp2Idle{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerTimeoutHttp2Idle", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerTimeoutHttp2PerRequestCodec struct {
}

func (VirtualNodeSpecSpecListenerTimeoutHttp2PerRequestCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerTimeoutHttp2PerRequest)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerTimeoutHttp2PerRequestCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerTimeoutHttp2PerRequest)(ptr)
	var objs []VirtualNodeSpecSpecListenerTimeoutHttp2PerRequest
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerTimeoutHttp2PerRequest{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttp2PerRequest{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerTimeoutHttp2PerRequestCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerTimeoutHttp2PerRequest)(ptr) = VirtualNodeSpecSpecListenerTimeoutHttp2PerRequest{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerTimeoutHttp2PerRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutHttp2PerRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerTimeoutHttp2PerRequest)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerTimeoutHttp2PerRequest)(ptr) = VirtualNodeSpecSpecListenerTimeoutHttp2PerRequest{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerTimeoutHttp2PerRequest)(ptr) = VirtualNodeSpecSpecListenerTimeoutHttp2PerRequest{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerTimeoutHttp2PerRequest", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerTimeoutTcpCodec struct {
}

func (VirtualNodeSpecSpecListenerTimeoutTcpCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerTimeoutTcp)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerTimeoutTcpCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerTimeoutTcp)(ptr)
	var objs []VirtualNodeSpecSpecListenerTimeoutTcp
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerTimeoutTcp{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutTcp{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerTimeoutTcpCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerTimeoutTcp)(ptr) = VirtualNodeSpecSpecListenerTimeoutTcp{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerTimeoutTcp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutTcp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerTimeoutTcp)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerTimeoutTcp)(ptr) = VirtualNodeSpecSpecListenerTimeoutTcp{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerTimeoutTcp)(ptr) = VirtualNodeSpecSpecListenerTimeoutTcp{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerTimeoutTcp", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerTimeoutTcpIdleCodec struct {
}

func (VirtualNodeSpecSpecListenerTimeoutTcpIdleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerTimeoutTcpIdle)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerTimeoutTcpIdleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerTimeoutTcpIdle)(ptr)
	var objs []VirtualNodeSpecSpecListenerTimeoutTcpIdle
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerTimeoutTcpIdle{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutTcpIdle{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerTimeoutTcpIdleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerTimeoutTcpIdle)(ptr) = VirtualNodeSpecSpecListenerTimeoutTcpIdle{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerTimeoutTcpIdle

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTimeoutTcpIdle{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerTimeoutTcpIdle)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerTimeoutTcpIdle)(ptr) = VirtualNodeSpecSpecListenerTimeoutTcpIdle{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerTimeoutTcpIdle)(ptr) = VirtualNodeSpecSpecListenerTimeoutTcpIdle{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerTimeoutTcpIdle", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerTlsCodec struct {
}

func (VirtualNodeSpecSpecListenerTlsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerTls)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerTlsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerTls)(ptr)
	var objs []VirtualNodeSpecSpecListenerTls
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerTls{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTls{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerTlsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerTls)(ptr) = VirtualNodeSpecSpecListenerTls{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerTls

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTls{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerTls)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerTls)(ptr) = VirtualNodeSpecSpecListenerTls{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerTls)(ptr) = VirtualNodeSpecSpecListenerTls{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerTls", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerTlsCertificateCodec struct {
}

func (VirtualNodeSpecSpecListenerTlsCertificateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerTlsCertificate)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerTlsCertificateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerTlsCertificate)(ptr)
	var objs []VirtualNodeSpecSpecListenerTlsCertificate
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerTlsCertificate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsCertificate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerTlsCertificateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerTlsCertificate)(ptr) = VirtualNodeSpecSpecListenerTlsCertificate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerTlsCertificate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsCertificate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerTlsCertificate)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerTlsCertificate)(ptr) = VirtualNodeSpecSpecListenerTlsCertificate{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerTlsCertificate)(ptr) = VirtualNodeSpecSpecListenerTlsCertificate{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerTlsCertificate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerTlsCertificateAcmCodec struct {
}

func (VirtualNodeSpecSpecListenerTlsCertificateAcmCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerTlsCertificateAcm)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerTlsCertificateAcmCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerTlsCertificateAcm)(ptr)
	var objs []VirtualNodeSpecSpecListenerTlsCertificateAcm
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerTlsCertificateAcm{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsCertificateAcm{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerTlsCertificateAcmCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerTlsCertificateAcm)(ptr) = VirtualNodeSpecSpecListenerTlsCertificateAcm{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerTlsCertificateAcm

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsCertificateAcm{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerTlsCertificateAcm)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerTlsCertificateAcm)(ptr) = VirtualNodeSpecSpecListenerTlsCertificateAcm{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerTlsCertificateAcm)(ptr) = VirtualNodeSpecSpecListenerTlsCertificateAcm{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerTlsCertificateAcm", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerTlsCertificateFileCodec struct {
}

func (VirtualNodeSpecSpecListenerTlsCertificateFileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerTlsCertificateFile)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerTlsCertificateFileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerTlsCertificateFile)(ptr)
	var objs []VirtualNodeSpecSpecListenerTlsCertificateFile
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerTlsCertificateFile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsCertificateFile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerTlsCertificateFileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerTlsCertificateFile)(ptr) = VirtualNodeSpecSpecListenerTlsCertificateFile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerTlsCertificateFile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsCertificateFile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerTlsCertificateFile)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerTlsCertificateFile)(ptr) = VirtualNodeSpecSpecListenerTlsCertificateFile{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerTlsCertificateFile)(ptr) = VirtualNodeSpecSpecListenerTlsCertificateFile{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerTlsCertificateFile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerTlsCertificateSdsCodec struct {
}

func (VirtualNodeSpecSpecListenerTlsCertificateSdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerTlsCertificateSds)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerTlsCertificateSdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerTlsCertificateSds)(ptr)
	var objs []VirtualNodeSpecSpecListenerTlsCertificateSds
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerTlsCertificateSds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsCertificateSds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerTlsCertificateSdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerTlsCertificateSds)(ptr) = VirtualNodeSpecSpecListenerTlsCertificateSds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerTlsCertificateSds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsCertificateSds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerTlsCertificateSds)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerTlsCertificateSds)(ptr) = VirtualNodeSpecSpecListenerTlsCertificateSds{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerTlsCertificateSds)(ptr) = VirtualNodeSpecSpecListenerTlsCertificateSds{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerTlsCertificateSds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerTlsValidationCodec struct {
}

func (VirtualNodeSpecSpecListenerTlsValidationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerTlsValidation)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerTlsValidationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerTlsValidation)(ptr)
	var objs []VirtualNodeSpecSpecListenerTlsValidation
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerTlsValidation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerTlsValidationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerTlsValidation)(ptr) = VirtualNodeSpecSpecListenerTlsValidation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerTlsValidation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerTlsValidation)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerTlsValidation)(ptr) = VirtualNodeSpecSpecListenerTlsValidation{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerTlsValidation)(ptr) = VirtualNodeSpecSpecListenerTlsValidation{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerTlsValidation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesCodec struct {
}

func (VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNames)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNames)(ptr)
	var objs []VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNames
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNames{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNames{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNames)(ptr) = VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNames{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNames

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNames{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNames)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNames)(ptr) = VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNames{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNames)(ptr) = VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNames{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNames", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesMatchCodec struct {
}

func (VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesMatchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesMatch)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesMatchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesMatch)(ptr)
	var objs []VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesMatch
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesMatch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesMatch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesMatchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesMatch)(ptr) = VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesMatch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesMatch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesMatch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesMatch)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesMatch)(ptr) = VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesMatch{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesMatch)(ptr) = VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesMatch{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerTlsValidationSubjectAlternativeNamesMatch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerTlsValidationTrustCodec struct {
}

func (VirtualNodeSpecSpecListenerTlsValidationTrustCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerTlsValidationTrust)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerTlsValidationTrustCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerTlsValidationTrust)(ptr)
	var objs []VirtualNodeSpecSpecListenerTlsValidationTrust
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerTlsValidationTrust{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidationTrust{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerTlsValidationTrustCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerTlsValidationTrust)(ptr) = VirtualNodeSpecSpecListenerTlsValidationTrust{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerTlsValidationTrust

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidationTrust{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerTlsValidationTrust)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerTlsValidationTrust)(ptr) = VirtualNodeSpecSpecListenerTlsValidationTrust{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerTlsValidationTrust)(ptr) = VirtualNodeSpecSpecListenerTlsValidationTrust{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerTlsValidationTrust", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerTlsValidationTrustFileCodec struct {
}

func (VirtualNodeSpecSpecListenerTlsValidationTrustFileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerTlsValidationTrustFile)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerTlsValidationTrustFileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerTlsValidationTrustFile)(ptr)
	var objs []VirtualNodeSpecSpecListenerTlsValidationTrustFile
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerTlsValidationTrustFile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidationTrustFile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerTlsValidationTrustFileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerTlsValidationTrustFile)(ptr) = VirtualNodeSpecSpecListenerTlsValidationTrustFile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerTlsValidationTrustFile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidationTrustFile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerTlsValidationTrustFile)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerTlsValidationTrustFile)(ptr) = VirtualNodeSpecSpecListenerTlsValidationTrustFile{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerTlsValidationTrustFile)(ptr) = VirtualNodeSpecSpecListenerTlsValidationTrustFile{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerTlsValidationTrustFile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecListenerTlsValidationTrustSdsCodec struct {
}

func (VirtualNodeSpecSpecListenerTlsValidationTrustSdsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecListenerTlsValidationTrustSds)(ptr) == nil
}

func (VirtualNodeSpecSpecListenerTlsValidationTrustSdsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecListenerTlsValidationTrustSds)(ptr)
	var objs []VirtualNodeSpecSpecListenerTlsValidationTrustSds
	if obj != nil {
		objs = []VirtualNodeSpecSpecListenerTlsValidationTrustSds{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidationTrustSds{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecListenerTlsValidationTrustSdsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecListenerTlsValidationTrustSds)(ptr) = VirtualNodeSpecSpecListenerTlsValidationTrustSds{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecListenerTlsValidationTrustSds

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecListenerTlsValidationTrustSds{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecListenerTlsValidationTrustSds)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecListenerTlsValidationTrustSds)(ptr) = VirtualNodeSpecSpecListenerTlsValidationTrustSds{}
			}
		} else {
			*(*VirtualNodeSpecSpecListenerTlsValidationTrustSds)(ptr) = VirtualNodeSpecSpecListenerTlsValidationTrustSds{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecListenerTlsValidationTrustSds", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecLoggingCodec struct {
}

func (VirtualNodeSpecSpecLoggingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecLogging)(ptr) == nil
}

func (VirtualNodeSpecSpecLoggingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecLogging)(ptr)
	var objs []VirtualNodeSpecSpecLogging
	if obj != nil {
		objs = []VirtualNodeSpecSpecLogging{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecLogging{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecLoggingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecLogging)(ptr) = VirtualNodeSpecSpecLogging{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecLogging

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecLogging{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecLogging)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecLogging)(ptr) = VirtualNodeSpecSpecLogging{}
			}
		} else {
			*(*VirtualNodeSpecSpecLogging)(ptr) = VirtualNodeSpecSpecLogging{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecLogging", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecLoggingAccessLogCodec struct {
}

func (VirtualNodeSpecSpecLoggingAccessLogCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecLoggingAccessLog)(ptr) == nil
}

func (VirtualNodeSpecSpecLoggingAccessLogCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecLoggingAccessLog)(ptr)
	var objs []VirtualNodeSpecSpecLoggingAccessLog
	if obj != nil {
		objs = []VirtualNodeSpecSpecLoggingAccessLog{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecLoggingAccessLog{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecLoggingAccessLogCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecLoggingAccessLog)(ptr) = VirtualNodeSpecSpecLoggingAccessLog{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecLoggingAccessLog

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecLoggingAccessLog{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecLoggingAccessLog)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecLoggingAccessLog)(ptr) = VirtualNodeSpecSpecLoggingAccessLog{}
			}
		} else {
			*(*VirtualNodeSpecSpecLoggingAccessLog)(ptr) = VirtualNodeSpecSpecLoggingAccessLog{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecLoggingAccessLog", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecLoggingAccessLogFileCodec struct {
}

func (VirtualNodeSpecSpecLoggingAccessLogFileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecLoggingAccessLogFile)(ptr) == nil
}

func (VirtualNodeSpecSpecLoggingAccessLogFileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecLoggingAccessLogFile)(ptr)
	var objs []VirtualNodeSpecSpecLoggingAccessLogFile
	if obj != nil {
		objs = []VirtualNodeSpecSpecLoggingAccessLogFile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecLoggingAccessLogFile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecLoggingAccessLogFileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecLoggingAccessLogFile)(ptr) = VirtualNodeSpecSpecLoggingAccessLogFile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecLoggingAccessLogFile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecLoggingAccessLogFile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecLoggingAccessLogFile)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecLoggingAccessLogFile)(ptr) = VirtualNodeSpecSpecLoggingAccessLogFile{}
			}
		} else {
			*(*VirtualNodeSpecSpecLoggingAccessLogFile)(ptr) = VirtualNodeSpecSpecLoggingAccessLogFile{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecLoggingAccessLogFile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecServiceDiscoveryCodec struct {
}

func (VirtualNodeSpecSpecServiceDiscoveryCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecServiceDiscovery)(ptr) == nil
}

func (VirtualNodeSpecSpecServiceDiscoveryCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecServiceDiscovery)(ptr)
	var objs []VirtualNodeSpecSpecServiceDiscovery
	if obj != nil {
		objs = []VirtualNodeSpecSpecServiceDiscovery{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecServiceDiscovery{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecServiceDiscoveryCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecServiceDiscovery)(ptr) = VirtualNodeSpecSpecServiceDiscovery{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecServiceDiscovery

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecServiceDiscovery{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecServiceDiscovery)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecServiceDiscovery)(ptr) = VirtualNodeSpecSpecServiceDiscovery{}
			}
		} else {
			*(*VirtualNodeSpecSpecServiceDiscovery)(ptr) = VirtualNodeSpecSpecServiceDiscovery{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecServiceDiscovery", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecServiceDiscoveryAwsCloudMapCodec struct {
}

func (VirtualNodeSpecSpecServiceDiscoveryAwsCloudMapCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecServiceDiscoveryAwsCloudMap)(ptr) == nil
}

func (VirtualNodeSpecSpecServiceDiscoveryAwsCloudMapCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecServiceDiscoveryAwsCloudMap)(ptr)
	var objs []VirtualNodeSpecSpecServiceDiscoveryAwsCloudMap
	if obj != nil {
		objs = []VirtualNodeSpecSpecServiceDiscoveryAwsCloudMap{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecServiceDiscoveryAwsCloudMap{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecServiceDiscoveryAwsCloudMapCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecServiceDiscoveryAwsCloudMap)(ptr) = VirtualNodeSpecSpecServiceDiscoveryAwsCloudMap{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecServiceDiscoveryAwsCloudMap

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecServiceDiscoveryAwsCloudMap{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecServiceDiscoveryAwsCloudMap)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecServiceDiscoveryAwsCloudMap)(ptr) = VirtualNodeSpecSpecServiceDiscoveryAwsCloudMap{}
			}
		} else {
			*(*VirtualNodeSpecSpecServiceDiscoveryAwsCloudMap)(ptr) = VirtualNodeSpecSpecServiceDiscoveryAwsCloudMap{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecServiceDiscoveryAwsCloudMap", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualNodeSpecSpecServiceDiscoveryDnsCodec struct {
}

func (VirtualNodeSpecSpecServiceDiscoveryDnsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualNodeSpecSpecServiceDiscoveryDns)(ptr) == nil
}

func (VirtualNodeSpecSpecServiceDiscoveryDnsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualNodeSpecSpecServiceDiscoveryDns)(ptr)
	var objs []VirtualNodeSpecSpecServiceDiscoveryDns
	if obj != nil {
		objs = []VirtualNodeSpecSpecServiceDiscoveryDns{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecServiceDiscoveryDns{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualNodeSpecSpecServiceDiscoveryDnsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualNodeSpecSpecServiceDiscoveryDns)(ptr) = VirtualNodeSpecSpecServiceDiscoveryDns{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualNodeSpecSpecServiceDiscoveryDns

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualNodeSpecSpecServiceDiscoveryDns{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualNodeSpecSpecServiceDiscoveryDns)(ptr) = objs[0]
			} else {
				*(*VirtualNodeSpecSpecServiceDiscoveryDns)(ptr) = VirtualNodeSpecSpecServiceDiscoveryDns{}
			}
		} else {
			*(*VirtualNodeSpecSpecServiceDiscoveryDns)(ptr) = VirtualNodeSpecSpecServiceDiscoveryDns{}
		}
	default:
		iter.ReportError("decode VirtualNodeSpecSpecServiceDiscoveryDns", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualRouterSpecSpecCodec struct {
}

func (VirtualRouterSpecSpecCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualRouterSpecSpec)(ptr) == nil
}

func (VirtualRouterSpecSpecCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualRouterSpecSpec)(ptr)
	var objs []VirtualRouterSpecSpec
	if obj != nil {
		objs = []VirtualRouterSpecSpec{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualRouterSpecSpec{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualRouterSpecSpecCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualRouterSpecSpec)(ptr) = VirtualRouterSpecSpec{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualRouterSpecSpec

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualRouterSpecSpec{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualRouterSpecSpec)(ptr) = objs[0]
			} else {
				*(*VirtualRouterSpecSpec)(ptr) = VirtualRouterSpecSpec{}
			}
		} else {
			*(*VirtualRouterSpecSpec)(ptr) = VirtualRouterSpecSpec{}
		}
	default:
		iter.ReportError("decode VirtualRouterSpecSpec", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualRouterSpecSpecListenerCodec struct {
}

func (VirtualRouterSpecSpecListenerCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualRouterSpecSpecListener)(ptr) == nil
}

func (VirtualRouterSpecSpecListenerCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualRouterSpecSpecListener)(ptr)
	var objs []VirtualRouterSpecSpecListener
	if obj != nil {
		objs = []VirtualRouterSpecSpecListener{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualRouterSpecSpecListener{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualRouterSpecSpecListenerCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualRouterSpecSpecListener)(ptr) = VirtualRouterSpecSpecListener{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualRouterSpecSpecListener

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualRouterSpecSpecListener{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualRouterSpecSpecListener)(ptr) = objs[0]
			} else {
				*(*VirtualRouterSpecSpecListener)(ptr) = VirtualRouterSpecSpecListener{}
			}
		} else {
			*(*VirtualRouterSpecSpecListener)(ptr) = VirtualRouterSpecSpecListener{}
		}
	default:
		iter.ReportError("decode VirtualRouterSpecSpecListener", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualRouterSpecSpecListenerPortMappingCodec struct {
}

func (VirtualRouterSpecSpecListenerPortMappingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualRouterSpecSpecListenerPortMapping)(ptr) == nil
}

func (VirtualRouterSpecSpecListenerPortMappingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualRouterSpecSpecListenerPortMapping)(ptr)
	var objs []VirtualRouterSpecSpecListenerPortMapping
	if obj != nil {
		objs = []VirtualRouterSpecSpecListenerPortMapping{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualRouterSpecSpecListenerPortMapping{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualRouterSpecSpecListenerPortMappingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualRouterSpecSpecListenerPortMapping)(ptr) = VirtualRouterSpecSpecListenerPortMapping{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualRouterSpecSpecListenerPortMapping

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualRouterSpecSpecListenerPortMapping{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualRouterSpecSpecListenerPortMapping)(ptr) = objs[0]
			} else {
				*(*VirtualRouterSpecSpecListenerPortMapping)(ptr) = VirtualRouterSpecSpecListenerPortMapping{}
			}
		} else {
			*(*VirtualRouterSpecSpecListenerPortMapping)(ptr) = VirtualRouterSpecSpecListenerPortMapping{}
		}
	default:
		iter.ReportError("decode VirtualRouterSpecSpecListenerPortMapping", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualServiceSpecSpecCodec struct {
}

func (VirtualServiceSpecSpecCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualServiceSpecSpec)(ptr) == nil
}

func (VirtualServiceSpecSpecCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualServiceSpecSpec)(ptr)
	var objs []VirtualServiceSpecSpec
	if obj != nil {
		objs = []VirtualServiceSpecSpec{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualServiceSpecSpec{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualServiceSpecSpecCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualServiceSpecSpec)(ptr) = VirtualServiceSpecSpec{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualServiceSpecSpec

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualServiceSpecSpec{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualServiceSpecSpec)(ptr) = objs[0]
			} else {
				*(*VirtualServiceSpecSpec)(ptr) = VirtualServiceSpecSpec{}
			}
		} else {
			*(*VirtualServiceSpecSpec)(ptr) = VirtualServiceSpecSpec{}
		}
	default:
		iter.ReportError("decode VirtualServiceSpecSpec", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualServiceSpecSpecProviderCodec struct {
}

func (VirtualServiceSpecSpecProviderCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualServiceSpecSpecProvider)(ptr) == nil
}

func (VirtualServiceSpecSpecProviderCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualServiceSpecSpecProvider)(ptr)
	var objs []VirtualServiceSpecSpecProvider
	if obj != nil {
		objs = []VirtualServiceSpecSpecProvider{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualServiceSpecSpecProvider{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualServiceSpecSpecProviderCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualServiceSpecSpecProvider)(ptr) = VirtualServiceSpecSpecProvider{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualServiceSpecSpecProvider

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualServiceSpecSpecProvider{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualServiceSpecSpecProvider)(ptr) = objs[0]
			} else {
				*(*VirtualServiceSpecSpecProvider)(ptr) = VirtualServiceSpecSpecProvider{}
			}
		} else {
			*(*VirtualServiceSpecSpecProvider)(ptr) = VirtualServiceSpecSpecProvider{}
		}
	default:
		iter.ReportError("decode VirtualServiceSpecSpecProvider", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualServiceSpecSpecProviderVirtualNodeCodec struct {
}

func (VirtualServiceSpecSpecProviderVirtualNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualServiceSpecSpecProviderVirtualNode)(ptr) == nil
}

func (VirtualServiceSpecSpecProviderVirtualNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualServiceSpecSpecProviderVirtualNode)(ptr)
	var objs []VirtualServiceSpecSpecProviderVirtualNode
	if obj != nil {
		objs = []VirtualServiceSpecSpecProviderVirtualNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualServiceSpecSpecProviderVirtualNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualServiceSpecSpecProviderVirtualNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualServiceSpecSpecProviderVirtualNode)(ptr) = VirtualServiceSpecSpecProviderVirtualNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualServiceSpecSpecProviderVirtualNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualServiceSpecSpecProviderVirtualNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualServiceSpecSpecProviderVirtualNode)(ptr) = objs[0]
			} else {
				*(*VirtualServiceSpecSpecProviderVirtualNode)(ptr) = VirtualServiceSpecSpecProviderVirtualNode{}
			}
		} else {
			*(*VirtualServiceSpecSpecProviderVirtualNode)(ptr) = VirtualServiceSpecSpecProviderVirtualNode{}
		}
	default:
		iter.ReportError("decode VirtualServiceSpecSpecProviderVirtualNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualServiceSpecSpecProviderVirtualRouterCodec struct {
}

func (VirtualServiceSpecSpecProviderVirtualRouterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualServiceSpecSpecProviderVirtualRouter)(ptr) == nil
}

func (VirtualServiceSpecSpecProviderVirtualRouterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualServiceSpecSpecProviderVirtualRouter)(ptr)
	var objs []VirtualServiceSpecSpecProviderVirtualRouter
	if obj != nil {
		objs = []VirtualServiceSpecSpecProviderVirtualRouter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualServiceSpecSpecProviderVirtualRouter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualServiceSpecSpecProviderVirtualRouterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualServiceSpecSpecProviderVirtualRouter)(ptr) = VirtualServiceSpecSpecProviderVirtualRouter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualServiceSpecSpecProviderVirtualRouter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualServiceSpecSpecProviderVirtualRouter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualServiceSpecSpecProviderVirtualRouter)(ptr) = objs[0]
			} else {
				*(*VirtualServiceSpecSpecProviderVirtualRouter)(ptr) = VirtualServiceSpecSpecProviderVirtualRouter{}
			}
		} else {
			*(*VirtualServiceSpecSpecProviderVirtualRouter)(ptr) = VirtualServiceSpecSpecProviderVirtualRouter{}
		}
	default:
		iter.ReportError("decode VirtualServiceSpecSpecProviderVirtualRouter", "unexpected JSON type")
	}
}
