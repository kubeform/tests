/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(FirewallPolicySpecFirewallPolicy{}).Type1()):                                                                               FirewallPolicySpecFirewallPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinition{}).Type1()):                                          FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction{}).Type1()):                       FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LoggingConfigurationSpecLoggingConfiguration{}).Type1()):                                                                   LoggingConfigurationSpecLoggingConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroup{}).Type1()):                                                                                         RuleGroupSpecRuleGroupCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRuleVariables{}).Type1()):                                                                            RuleGroupSpecRuleGroupRuleVariablesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRuleVariablesIpSetsIpSet{}).Type1()):                                                                 RuleGroupSpecRuleGroupRuleVariablesIpSetsIpSetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRuleVariablesPortSetsPortSet{}).Type1()):                                                             RuleGroupSpecRuleGroupRuleVariablesPortSetsPortSetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSource{}).Type1()):                                                                              RuleGroupSpecRuleGroupRulesSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceRulesSourceList{}).Type1()):                                                               RuleGroupSpecRuleGroupRulesSourceRulesSourceListCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatefulRuleHeader{}).Type1()):                                                            RuleGroupSpecRuleGroupRulesSourceStatefulRuleHeaderCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActions{}).Type1()):                                                RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition{}).Type1()):                    RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction{}).Type1()): RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition{}).Type1()):                     RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes{}).Type1()):      RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(FirewallPolicySpecFirewallPolicy{}).Type1()):                                                                               FirewallPolicySpecFirewallPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinition{}).Type1()):                                          FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction{}).Type1()):                       FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LoggingConfigurationSpecLoggingConfiguration{}).Type1()):                                                                   LoggingConfigurationSpecLoggingConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroup{}).Type1()):                                                                                         RuleGroupSpecRuleGroupCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRuleVariables{}).Type1()):                                                                            RuleGroupSpecRuleGroupRuleVariablesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRuleVariablesIpSetsIpSet{}).Type1()):                                                                 RuleGroupSpecRuleGroupRuleVariablesIpSetsIpSetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRuleVariablesPortSetsPortSet{}).Type1()):                                                             RuleGroupSpecRuleGroupRuleVariablesPortSetsPortSetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSource{}).Type1()):                                                                              RuleGroupSpecRuleGroupRulesSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceRulesSourceList{}).Type1()):                                                               RuleGroupSpecRuleGroupRulesSourceRulesSourceListCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatefulRuleHeader{}).Type1()):                                                            RuleGroupSpecRuleGroupRulesSourceStatefulRuleHeaderCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActions{}).Type1()):                                                RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition{}).Type1()):                    RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction{}).Type1()): RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition{}).Type1()):                     RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes{}).Type1()):      RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type FirewallPolicySpecFirewallPolicyCodec struct {
}

func (FirewallPolicySpecFirewallPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirewallPolicySpecFirewallPolicy)(ptr) == nil
}

func (FirewallPolicySpecFirewallPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirewallPolicySpecFirewallPolicy)(ptr)
	var objs []FirewallPolicySpecFirewallPolicy
	if obj != nil {
		objs = []FirewallPolicySpecFirewallPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallPolicySpecFirewallPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirewallPolicySpecFirewallPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirewallPolicySpecFirewallPolicy)(ptr) = FirewallPolicySpecFirewallPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirewallPolicySpecFirewallPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallPolicySpecFirewallPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirewallPolicySpecFirewallPolicy)(ptr) = objs[0]
			} else {
				*(*FirewallPolicySpecFirewallPolicy)(ptr) = FirewallPolicySpecFirewallPolicy{}
			}
		} else {
			*(*FirewallPolicySpecFirewallPolicy)(ptr) = FirewallPolicySpecFirewallPolicy{}
		}
	default:
		iter.ReportError("decode FirewallPolicySpecFirewallPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionCodec struct {
}

func (FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinition)(ptr) == nil
}

func (FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinition)(ptr)
	var objs []FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinition
	if obj != nil {
		objs = []FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinition)(ptr) = FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinition)(ptr) = objs[0]
			} else {
				*(*FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinition)(ptr) = FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinition{}
			}
		} else {
			*(*FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinition)(ptr) = FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinition{}
		}
	default:
		iter.ReportError("decode FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionCodec struct {
}

func (FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction)(ptr) == nil
}

func (FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction)(ptr)
	var objs []FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction
	if obj != nil {
		objs = []FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction)(ptr) = FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction)(ptr) = objs[0]
			} else {
				*(*FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction)(ptr) = FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction{}
			}
		} else {
			*(*FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction)(ptr) = FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction{}
		}
	default:
		iter.ReportError("decode FirewallPolicySpecFirewallPolicyStatelessCustomActionActionDefinitionPublishMetricAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LoggingConfigurationSpecLoggingConfigurationCodec struct {
}

func (LoggingConfigurationSpecLoggingConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LoggingConfigurationSpecLoggingConfiguration)(ptr) == nil
}

func (LoggingConfigurationSpecLoggingConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LoggingConfigurationSpecLoggingConfiguration)(ptr)
	var objs []LoggingConfigurationSpecLoggingConfiguration
	if obj != nil {
		objs = []LoggingConfigurationSpecLoggingConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoggingConfigurationSpecLoggingConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LoggingConfigurationSpecLoggingConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LoggingConfigurationSpecLoggingConfiguration)(ptr) = LoggingConfigurationSpecLoggingConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LoggingConfigurationSpecLoggingConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoggingConfigurationSpecLoggingConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LoggingConfigurationSpecLoggingConfiguration)(ptr) = objs[0]
			} else {
				*(*LoggingConfigurationSpecLoggingConfiguration)(ptr) = LoggingConfigurationSpecLoggingConfiguration{}
			}
		} else {
			*(*LoggingConfigurationSpecLoggingConfiguration)(ptr) = LoggingConfigurationSpecLoggingConfiguration{}
		}
	default:
		iter.ReportError("decode LoggingConfigurationSpecLoggingConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleGroupSpecRuleGroupCodec struct {
}

func (RuleGroupSpecRuleGroupCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleGroupSpecRuleGroup)(ptr) == nil
}

func (RuleGroupSpecRuleGroupCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleGroupSpecRuleGroup)(ptr)
	var objs []RuleGroupSpecRuleGroup
	if obj != nil {
		objs = []RuleGroupSpecRuleGroup{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroup{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleGroupSpecRuleGroupCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleGroupSpecRuleGroup)(ptr) = RuleGroupSpecRuleGroup{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleGroupSpecRuleGroup

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroup{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleGroupSpecRuleGroup)(ptr) = objs[0]
			} else {
				*(*RuleGroupSpecRuleGroup)(ptr) = RuleGroupSpecRuleGroup{}
			}
		} else {
			*(*RuleGroupSpecRuleGroup)(ptr) = RuleGroupSpecRuleGroup{}
		}
	default:
		iter.ReportError("decode RuleGroupSpecRuleGroup", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleGroupSpecRuleGroupRuleVariablesCodec struct {
}

func (RuleGroupSpecRuleGroupRuleVariablesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleGroupSpecRuleGroupRuleVariables)(ptr) == nil
}

func (RuleGroupSpecRuleGroupRuleVariablesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleGroupSpecRuleGroupRuleVariables)(ptr)
	var objs []RuleGroupSpecRuleGroupRuleVariables
	if obj != nil {
		objs = []RuleGroupSpecRuleGroupRuleVariables{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRuleVariables{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleGroupSpecRuleGroupRuleVariablesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleGroupSpecRuleGroupRuleVariables)(ptr) = RuleGroupSpecRuleGroupRuleVariables{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleGroupSpecRuleGroupRuleVariables

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRuleVariables{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleGroupSpecRuleGroupRuleVariables)(ptr) = objs[0]
			} else {
				*(*RuleGroupSpecRuleGroupRuleVariables)(ptr) = RuleGroupSpecRuleGroupRuleVariables{}
			}
		} else {
			*(*RuleGroupSpecRuleGroupRuleVariables)(ptr) = RuleGroupSpecRuleGroupRuleVariables{}
		}
	default:
		iter.ReportError("decode RuleGroupSpecRuleGroupRuleVariables", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleGroupSpecRuleGroupRuleVariablesIpSetsIpSetCodec struct {
}

func (RuleGroupSpecRuleGroupRuleVariablesIpSetsIpSetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleGroupSpecRuleGroupRuleVariablesIpSetsIpSet)(ptr) == nil
}

func (RuleGroupSpecRuleGroupRuleVariablesIpSetsIpSetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleGroupSpecRuleGroupRuleVariablesIpSetsIpSet)(ptr)
	var objs []RuleGroupSpecRuleGroupRuleVariablesIpSetsIpSet
	if obj != nil {
		objs = []RuleGroupSpecRuleGroupRuleVariablesIpSetsIpSet{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRuleVariablesIpSetsIpSet{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleGroupSpecRuleGroupRuleVariablesIpSetsIpSetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleGroupSpecRuleGroupRuleVariablesIpSetsIpSet)(ptr) = RuleGroupSpecRuleGroupRuleVariablesIpSetsIpSet{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleGroupSpecRuleGroupRuleVariablesIpSetsIpSet

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRuleVariablesIpSetsIpSet{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleGroupSpecRuleGroupRuleVariablesIpSetsIpSet)(ptr) = objs[0]
			} else {
				*(*RuleGroupSpecRuleGroupRuleVariablesIpSetsIpSet)(ptr) = RuleGroupSpecRuleGroupRuleVariablesIpSetsIpSet{}
			}
		} else {
			*(*RuleGroupSpecRuleGroupRuleVariablesIpSetsIpSet)(ptr) = RuleGroupSpecRuleGroupRuleVariablesIpSetsIpSet{}
		}
	default:
		iter.ReportError("decode RuleGroupSpecRuleGroupRuleVariablesIpSetsIpSet", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleGroupSpecRuleGroupRuleVariablesPortSetsPortSetCodec struct {
}

func (RuleGroupSpecRuleGroupRuleVariablesPortSetsPortSetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleGroupSpecRuleGroupRuleVariablesPortSetsPortSet)(ptr) == nil
}

func (RuleGroupSpecRuleGroupRuleVariablesPortSetsPortSetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleGroupSpecRuleGroupRuleVariablesPortSetsPortSet)(ptr)
	var objs []RuleGroupSpecRuleGroupRuleVariablesPortSetsPortSet
	if obj != nil {
		objs = []RuleGroupSpecRuleGroupRuleVariablesPortSetsPortSet{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRuleVariablesPortSetsPortSet{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleGroupSpecRuleGroupRuleVariablesPortSetsPortSetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleGroupSpecRuleGroupRuleVariablesPortSetsPortSet)(ptr) = RuleGroupSpecRuleGroupRuleVariablesPortSetsPortSet{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleGroupSpecRuleGroupRuleVariablesPortSetsPortSet

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRuleVariablesPortSetsPortSet{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleGroupSpecRuleGroupRuleVariablesPortSetsPortSet)(ptr) = objs[0]
			} else {
				*(*RuleGroupSpecRuleGroupRuleVariablesPortSetsPortSet)(ptr) = RuleGroupSpecRuleGroupRuleVariablesPortSetsPortSet{}
			}
		} else {
			*(*RuleGroupSpecRuleGroupRuleVariablesPortSetsPortSet)(ptr) = RuleGroupSpecRuleGroupRuleVariablesPortSetsPortSet{}
		}
	default:
		iter.ReportError("decode RuleGroupSpecRuleGroupRuleVariablesPortSetsPortSet", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleGroupSpecRuleGroupRulesSourceCodec struct {
}

func (RuleGroupSpecRuleGroupRulesSourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleGroupSpecRuleGroupRulesSource)(ptr) == nil
}

func (RuleGroupSpecRuleGroupRulesSourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleGroupSpecRuleGroupRulesSource)(ptr)
	var objs []RuleGroupSpecRuleGroupRulesSource
	if obj != nil {
		objs = []RuleGroupSpecRuleGroupRulesSource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleGroupSpecRuleGroupRulesSourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleGroupSpecRuleGroupRulesSource)(ptr) = RuleGroupSpecRuleGroupRulesSource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleGroupSpecRuleGroupRulesSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleGroupSpecRuleGroupRulesSource)(ptr) = objs[0]
			} else {
				*(*RuleGroupSpecRuleGroupRulesSource)(ptr) = RuleGroupSpecRuleGroupRulesSource{}
			}
		} else {
			*(*RuleGroupSpecRuleGroupRulesSource)(ptr) = RuleGroupSpecRuleGroupRulesSource{}
		}
	default:
		iter.ReportError("decode RuleGroupSpecRuleGroupRulesSource", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleGroupSpecRuleGroupRulesSourceRulesSourceListCodec struct {
}

func (RuleGroupSpecRuleGroupRulesSourceRulesSourceListCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleGroupSpecRuleGroupRulesSourceRulesSourceList)(ptr) == nil
}

func (RuleGroupSpecRuleGroupRulesSourceRulesSourceListCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleGroupSpecRuleGroupRulesSourceRulesSourceList)(ptr)
	var objs []RuleGroupSpecRuleGroupRulesSourceRulesSourceList
	if obj != nil {
		objs = []RuleGroupSpecRuleGroupRulesSourceRulesSourceList{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceRulesSourceList{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleGroupSpecRuleGroupRulesSourceRulesSourceListCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleGroupSpecRuleGroupRulesSourceRulesSourceList)(ptr) = RuleGroupSpecRuleGroupRulesSourceRulesSourceList{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleGroupSpecRuleGroupRulesSourceRulesSourceList

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceRulesSourceList{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleGroupSpecRuleGroupRulesSourceRulesSourceList)(ptr) = objs[0]
			} else {
				*(*RuleGroupSpecRuleGroupRulesSourceRulesSourceList)(ptr) = RuleGroupSpecRuleGroupRulesSourceRulesSourceList{}
			}
		} else {
			*(*RuleGroupSpecRuleGroupRulesSourceRulesSourceList)(ptr) = RuleGroupSpecRuleGroupRulesSourceRulesSourceList{}
		}
	default:
		iter.ReportError("decode RuleGroupSpecRuleGroupRulesSourceRulesSourceList", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleGroupSpecRuleGroupRulesSourceStatefulRuleHeaderCodec struct {
}

func (RuleGroupSpecRuleGroupRulesSourceStatefulRuleHeaderCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleGroupSpecRuleGroupRulesSourceStatefulRuleHeader)(ptr) == nil
}

func (RuleGroupSpecRuleGroupRulesSourceStatefulRuleHeaderCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleGroupSpecRuleGroupRulesSourceStatefulRuleHeader)(ptr)
	var objs []RuleGroupSpecRuleGroupRulesSourceStatefulRuleHeader
	if obj != nil {
		objs = []RuleGroupSpecRuleGroupRulesSourceStatefulRuleHeader{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatefulRuleHeader{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleGroupSpecRuleGroupRulesSourceStatefulRuleHeaderCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleGroupSpecRuleGroupRulesSourceStatefulRuleHeader)(ptr) = RuleGroupSpecRuleGroupRulesSourceStatefulRuleHeader{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleGroupSpecRuleGroupRulesSourceStatefulRuleHeader

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatefulRuleHeader{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleGroupSpecRuleGroupRulesSourceStatefulRuleHeader)(ptr) = objs[0]
			} else {
				*(*RuleGroupSpecRuleGroupRulesSourceStatefulRuleHeader)(ptr) = RuleGroupSpecRuleGroupRulesSourceStatefulRuleHeader{}
			}
		} else {
			*(*RuleGroupSpecRuleGroupRulesSourceStatefulRuleHeader)(ptr) = RuleGroupSpecRuleGroupRulesSourceStatefulRuleHeader{}
		}
	default:
		iter.ReportError("decode RuleGroupSpecRuleGroupRulesSourceStatefulRuleHeader", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCodec struct {
}

func (RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActions)(ptr) == nil
}

func (RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActions)(ptr)
	var objs []RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActions
	if obj != nil {
		objs = []RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActions)(ptr) = RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActions)(ptr) = objs[0]
			} else {
				*(*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActions)(ptr) = RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActions{}
			}
		} else {
			*(*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActions)(ptr) = RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActions{}
		}
	default:
		iter.ReportError("decode RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionCodec struct {
}

func (RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition)(ptr) == nil
}

func (RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition)(ptr)
	var objs []RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition
	if obj != nil {
		objs = []RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition)(ptr) = RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition)(ptr) = objs[0]
			} else {
				*(*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition)(ptr) = RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition{}
			}
		} else {
			*(*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition)(ptr) = RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition{}
		}
	default:
		iter.ReportError("decode RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionCodec struct {
}

func (RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction)(ptr) == nil
}

func (RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction)(ptr)
	var objs []RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction
	if obj != nil {
		objs = []RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction)(ptr) = RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction)(ptr) = objs[0]
			} else {
				*(*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction)(ptr) = RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction{}
			}
		} else {
			*(*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction)(ptr) = RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction{}
		}
	default:
		iter.ReportError("decode RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsCustomActionActionDefinitionPublishMetricAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionCodec struct {
}

func (RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition)(ptr) == nil
}

func (RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition)(ptr)
	var objs []RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition
	if obj != nil {
		objs = []RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition)(ptr) = RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition)(ptr) = objs[0]
			} else {
				*(*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition)(ptr) = RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition{}
			}
		} else {
			*(*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition)(ptr) = RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition{}
		}
	default:
		iter.ReportError("decode RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesCodec struct {
}

func (RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes)(ptr) == nil
}

func (RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes)(ptr)
	var objs []RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes
	if obj != nil {
		objs = []RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes)(ptr) = RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes)(ptr) = objs[0]
			} else {
				*(*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes)(ptr) = RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes{}
			}
		} else {
			*(*RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes)(ptr) = RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes{}
		}
	default:
		iter.ReportError("decode RuleGroupSpecRuleGroupRulesSourceStatelessRulesAndCustomActionsStatelessRuleRuleDefinitionMatchAttributes", "unexpected JSON type")
	}
}
