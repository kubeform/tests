/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentConfigSpecMinimumHealthyHosts{}).Type1()):                                               DeploymentConfigSpecMinimumHealthyHostsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentConfigSpecTrafficRoutingConfig{}).Type1()):                                              DeploymentConfigSpecTrafficRoutingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentConfigSpecTrafficRoutingConfigTimeBasedCanary{}).Type1()):                               DeploymentConfigSpecTrafficRoutingConfigTimeBasedCanaryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentConfigSpecTrafficRoutingConfigTimeBasedLinear{}).Type1()):                               DeploymentConfigSpecTrafficRoutingConfigTimeBasedLinearCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecAlarmConfiguration{}).Type1()):                                                 DeploymentGroupSpecAlarmConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecAutoRollbackConfiguration{}).Type1()):                                          DeploymentGroupSpecAutoRollbackConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecBlueGreenDeploymentConfig{}).Type1()):                                          DeploymentGroupSpecBlueGreenDeploymentConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecBlueGreenDeploymentConfigDeploymentReadyOption{}).Type1()):                     DeploymentGroupSpecBlueGreenDeploymentConfigDeploymentReadyOptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecBlueGreenDeploymentConfigGreenFleetProvisioningOption{}).Type1()):              DeploymentGroupSpecBlueGreenDeploymentConfigGreenFleetProvisioningOptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess{}).Type1()): DeploymentGroupSpecBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccessCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecDeploymentStyle{}).Type1()):                                                    DeploymentGroupSpecDeploymentStyleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecEcsService{}).Type1()):                                                         DeploymentGroupSpecEcsServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecLoadBalancerInfo{}).Type1()):                                                   DeploymentGroupSpecLoadBalancerInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfo{}).Type1()):                                DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute{}).Type1()):                DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoProdTrafficRouteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute{}).Type1()):                DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoTestTrafficRouteCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentConfigSpecMinimumHealthyHosts{}).Type1()):                                               DeploymentConfigSpecMinimumHealthyHostsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentConfigSpecTrafficRoutingConfig{}).Type1()):                                              DeploymentConfigSpecTrafficRoutingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentConfigSpecTrafficRoutingConfigTimeBasedCanary{}).Type1()):                               DeploymentConfigSpecTrafficRoutingConfigTimeBasedCanaryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentConfigSpecTrafficRoutingConfigTimeBasedLinear{}).Type1()):                               DeploymentConfigSpecTrafficRoutingConfigTimeBasedLinearCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecAlarmConfiguration{}).Type1()):                                                 DeploymentGroupSpecAlarmConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecAutoRollbackConfiguration{}).Type1()):                                          DeploymentGroupSpecAutoRollbackConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecBlueGreenDeploymentConfig{}).Type1()):                                          DeploymentGroupSpecBlueGreenDeploymentConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecBlueGreenDeploymentConfigDeploymentReadyOption{}).Type1()):                     DeploymentGroupSpecBlueGreenDeploymentConfigDeploymentReadyOptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecBlueGreenDeploymentConfigGreenFleetProvisioningOption{}).Type1()):              DeploymentGroupSpecBlueGreenDeploymentConfigGreenFleetProvisioningOptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess{}).Type1()): DeploymentGroupSpecBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccessCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecDeploymentStyle{}).Type1()):                                                    DeploymentGroupSpecDeploymentStyleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecEcsService{}).Type1()):                                                         DeploymentGroupSpecEcsServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecLoadBalancerInfo{}).Type1()):                                                   DeploymentGroupSpecLoadBalancerInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfo{}).Type1()):                                DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute{}).Type1()):                DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoProdTrafficRouteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute{}).Type1()):                DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoTestTrafficRouteCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type DeploymentConfigSpecMinimumHealthyHostsCodec struct {
}

func (DeploymentConfigSpecMinimumHealthyHostsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentConfigSpecMinimumHealthyHosts)(ptr) == nil
}

func (DeploymentConfigSpecMinimumHealthyHostsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentConfigSpecMinimumHealthyHosts)(ptr)
	var objs []DeploymentConfigSpecMinimumHealthyHosts
	if obj != nil {
		objs = []DeploymentConfigSpecMinimumHealthyHosts{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentConfigSpecMinimumHealthyHosts{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentConfigSpecMinimumHealthyHostsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentConfigSpecMinimumHealthyHosts)(ptr) = DeploymentConfigSpecMinimumHealthyHosts{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentConfigSpecMinimumHealthyHosts

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentConfigSpecMinimumHealthyHosts{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentConfigSpecMinimumHealthyHosts)(ptr) = objs[0]
			} else {
				*(*DeploymentConfigSpecMinimumHealthyHosts)(ptr) = DeploymentConfigSpecMinimumHealthyHosts{}
			}
		} else {
			*(*DeploymentConfigSpecMinimumHealthyHosts)(ptr) = DeploymentConfigSpecMinimumHealthyHosts{}
		}
	default:
		iter.ReportError("decode DeploymentConfigSpecMinimumHealthyHosts", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentConfigSpecTrafficRoutingConfigCodec struct {
}

func (DeploymentConfigSpecTrafficRoutingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentConfigSpecTrafficRoutingConfig)(ptr) == nil
}

func (DeploymentConfigSpecTrafficRoutingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentConfigSpecTrafficRoutingConfig)(ptr)
	var objs []DeploymentConfigSpecTrafficRoutingConfig
	if obj != nil {
		objs = []DeploymentConfigSpecTrafficRoutingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentConfigSpecTrafficRoutingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentConfigSpecTrafficRoutingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentConfigSpecTrafficRoutingConfig)(ptr) = DeploymentConfigSpecTrafficRoutingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentConfigSpecTrafficRoutingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentConfigSpecTrafficRoutingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentConfigSpecTrafficRoutingConfig)(ptr) = objs[0]
			} else {
				*(*DeploymentConfigSpecTrafficRoutingConfig)(ptr) = DeploymentConfigSpecTrafficRoutingConfig{}
			}
		} else {
			*(*DeploymentConfigSpecTrafficRoutingConfig)(ptr) = DeploymentConfigSpecTrafficRoutingConfig{}
		}
	default:
		iter.ReportError("decode DeploymentConfigSpecTrafficRoutingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentConfigSpecTrafficRoutingConfigTimeBasedCanaryCodec struct {
}

func (DeploymentConfigSpecTrafficRoutingConfigTimeBasedCanaryCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentConfigSpecTrafficRoutingConfigTimeBasedCanary)(ptr) == nil
}

func (DeploymentConfigSpecTrafficRoutingConfigTimeBasedCanaryCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentConfigSpecTrafficRoutingConfigTimeBasedCanary)(ptr)
	var objs []DeploymentConfigSpecTrafficRoutingConfigTimeBasedCanary
	if obj != nil {
		objs = []DeploymentConfigSpecTrafficRoutingConfigTimeBasedCanary{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentConfigSpecTrafficRoutingConfigTimeBasedCanary{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentConfigSpecTrafficRoutingConfigTimeBasedCanaryCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentConfigSpecTrafficRoutingConfigTimeBasedCanary)(ptr) = DeploymentConfigSpecTrafficRoutingConfigTimeBasedCanary{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentConfigSpecTrafficRoutingConfigTimeBasedCanary

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentConfigSpecTrafficRoutingConfigTimeBasedCanary{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentConfigSpecTrafficRoutingConfigTimeBasedCanary)(ptr) = objs[0]
			} else {
				*(*DeploymentConfigSpecTrafficRoutingConfigTimeBasedCanary)(ptr) = DeploymentConfigSpecTrafficRoutingConfigTimeBasedCanary{}
			}
		} else {
			*(*DeploymentConfigSpecTrafficRoutingConfigTimeBasedCanary)(ptr) = DeploymentConfigSpecTrafficRoutingConfigTimeBasedCanary{}
		}
	default:
		iter.ReportError("decode DeploymentConfigSpecTrafficRoutingConfigTimeBasedCanary", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentConfigSpecTrafficRoutingConfigTimeBasedLinearCodec struct {
}

func (DeploymentConfigSpecTrafficRoutingConfigTimeBasedLinearCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentConfigSpecTrafficRoutingConfigTimeBasedLinear)(ptr) == nil
}

func (DeploymentConfigSpecTrafficRoutingConfigTimeBasedLinearCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentConfigSpecTrafficRoutingConfigTimeBasedLinear)(ptr)
	var objs []DeploymentConfigSpecTrafficRoutingConfigTimeBasedLinear
	if obj != nil {
		objs = []DeploymentConfigSpecTrafficRoutingConfigTimeBasedLinear{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentConfigSpecTrafficRoutingConfigTimeBasedLinear{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentConfigSpecTrafficRoutingConfigTimeBasedLinearCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentConfigSpecTrafficRoutingConfigTimeBasedLinear)(ptr) = DeploymentConfigSpecTrafficRoutingConfigTimeBasedLinear{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentConfigSpecTrafficRoutingConfigTimeBasedLinear

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentConfigSpecTrafficRoutingConfigTimeBasedLinear{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentConfigSpecTrafficRoutingConfigTimeBasedLinear)(ptr) = objs[0]
			} else {
				*(*DeploymentConfigSpecTrafficRoutingConfigTimeBasedLinear)(ptr) = DeploymentConfigSpecTrafficRoutingConfigTimeBasedLinear{}
			}
		} else {
			*(*DeploymentConfigSpecTrafficRoutingConfigTimeBasedLinear)(ptr) = DeploymentConfigSpecTrafficRoutingConfigTimeBasedLinear{}
		}
	default:
		iter.ReportError("decode DeploymentConfigSpecTrafficRoutingConfigTimeBasedLinear", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentGroupSpecAlarmConfigurationCodec struct {
}

func (DeploymentGroupSpecAlarmConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentGroupSpecAlarmConfiguration)(ptr) == nil
}

func (DeploymentGroupSpecAlarmConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentGroupSpecAlarmConfiguration)(ptr)
	var objs []DeploymentGroupSpecAlarmConfiguration
	if obj != nil {
		objs = []DeploymentGroupSpecAlarmConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecAlarmConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentGroupSpecAlarmConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentGroupSpecAlarmConfiguration)(ptr) = DeploymentGroupSpecAlarmConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentGroupSpecAlarmConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecAlarmConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentGroupSpecAlarmConfiguration)(ptr) = objs[0]
			} else {
				*(*DeploymentGroupSpecAlarmConfiguration)(ptr) = DeploymentGroupSpecAlarmConfiguration{}
			}
		} else {
			*(*DeploymentGroupSpecAlarmConfiguration)(ptr) = DeploymentGroupSpecAlarmConfiguration{}
		}
	default:
		iter.ReportError("decode DeploymentGroupSpecAlarmConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentGroupSpecAutoRollbackConfigurationCodec struct {
}

func (DeploymentGroupSpecAutoRollbackConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentGroupSpecAutoRollbackConfiguration)(ptr) == nil
}

func (DeploymentGroupSpecAutoRollbackConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentGroupSpecAutoRollbackConfiguration)(ptr)
	var objs []DeploymentGroupSpecAutoRollbackConfiguration
	if obj != nil {
		objs = []DeploymentGroupSpecAutoRollbackConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecAutoRollbackConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentGroupSpecAutoRollbackConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentGroupSpecAutoRollbackConfiguration)(ptr) = DeploymentGroupSpecAutoRollbackConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentGroupSpecAutoRollbackConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecAutoRollbackConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentGroupSpecAutoRollbackConfiguration)(ptr) = objs[0]
			} else {
				*(*DeploymentGroupSpecAutoRollbackConfiguration)(ptr) = DeploymentGroupSpecAutoRollbackConfiguration{}
			}
		} else {
			*(*DeploymentGroupSpecAutoRollbackConfiguration)(ptr) = DeploymentGroupSpecAutoRollbackConfiguration{}
		}
	default:
		iter.ReportError("decode DeploymentGroupSpecAutoRollbackConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentGroupSpecBlueGreenDeploymentConfigCodec struct {
}

func (DeploymentGroupSpecBlueGreenDeploymentConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentGroupSpecBlueGreenDeploymentConfig)(ptr) == nil
}

func (DeploymentGroupSpecBlueGreenDeploymentConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentGroupSpecBlueGreenDeploymentConfig)(ptr)
	var objs []DeploymentGroupSpecBlueGreenDeploymentConfig
	if obj != nil {
		objs = []DeploymentGroupSpecBlueGreenDeploymentConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecBlueGreenDeploymentConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentGroupSpecBlueGreenDeploymentConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentGroupSpecBlueGreenDeploymentConfig)(ptr) = DeploymentGroupSpecBlueGreenDeploymentConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentGroupSpecBlueGreenDeploymentConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecBlueGreenDeploymentConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentGroupSpecBlueGreenDeploymentConfig)(ptr) = objs[0]
			} else {
				*(*DeploymentGroupSpecBlueGreenDeploymentConfig)(ptr) = DeploymentGroupSpecBlueGreenDeploymentConfig{}
			}
		} else {
			*(*DeploymentGroupSpecBlueGreenDeploymentConfig)(ptr) = DeploymentGroupSpecBlueGreenDeploymentConfig{}
		}
	default:
		iter.ReportError("decode DeploymentGroupSpecBlueGreenDeploymentConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentGroupSpecBlueGreenDeploymentConfigDeploymentReadyOptionCodec struct {
}

func (DeploymentGroupSpecBlueGreenDeploymentConfigDeploymentReadyOptionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentGroupSpecBlueGreenDeploymentConfigDeploymentReadyOption)(ptr) == nil
}

func (DeploymentGroupSpecBlueGreenDeploymentConfigDeploymentReadyOptionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentGroupSpecBlueGreenDeploymentConfigDeploymentReadyOption)(ptr)
	var objs []DeploymentGroupSpecBlueGreenDeploymentConfigDeploymentReadyOption
	if obj != nil {
		objs = []DeploymentGroupSpecBlueGreenDeploymentConfigDeploymentReadyOption{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecBlueGreenDeploymentConfigDeploymentReadyOption{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentGroupSpecBlueGreenDeploymentConfigDeploymentReadyOptionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentGroupSpecBlueGreenDeploymentConfigDeploymentReadyOption)(ptr) = DeploymentGroupSpecBlueGreenDeploymentConfigDeploymentReadyOption{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentGroupSpecBlueGreenDeploymentConfigDeploymentReadyOption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecBlueGreenDeploymentConfigDeploymentReadyOption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentGroupSpecBlueGreenDeploymentConfigDeploymentReadyOption)(ptr) = objs[0]
			} else {
				*(*DeploymentGroupSpecBlueGreenDeploymentConfigDeploymentReadyOption)(ptr) = DeploymentGroupSpecBlueGreenDeploymentConfigDeploymentReadyOption{}
			}
		} else {
			*(*DeploymentGroupSpecBlueGreenDeploymentConfigDeploymentReadyOption)(ptr) = DeploymentGroupSpecBlueGreenDeploymentConfigDeploymentReadyOption{}
		}
	default:
		iter.ReportError("decode DeploymentGroupSpecBlueGreenDeploymentConfigDeploymentReadyOption", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentGroupSpecBlueGreenDeploymentConfigGreenFleetProvisioningOptionCodec struct {
}

func (DeploymentGroupSpecBlueGreenDeploymentConfigGreenFleetProvisioningOptionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentGroupSpecBlueGreenDeploymentConfigGreenFleetProvisioningOption)(ptr) == nil
}

func (DeploymentGroupSpecBlueGreenDeploymentConfigGreenFleetProvisioningOptionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentGroupSpecBlueGreenDeploymentConfigGreenFleetProvisioningOption)(ptr)
	var objs []DeploymentGroupSpecBlueGreenDeploymentConfigGreenFleetProvisioningOption
	if obj != nil {
		objs = []DeploymentGroupSpecBlueGreenDeploymentConfigGreenFleetProvisioningOption{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecBlueGreenDeploymentConfigGreenFleetProvisioningOption{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentGroupSpecBlueGreenDeploymentConfigGreenFleetProvisioningOptionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentGroupSpecBlueGreenDeploymentConfigGreenFleetProvisioningOption)(ptr) = DeploymentGroupSpecBlueGreenDeploymentConfigGreenFleetProvisioningOption{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentGroupSpecBlueGreenDeploymentConfigGreenFleetProvisioningOption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecBlueGreenDeploymentConfigGreenFleetProvisioningOption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentGroupSpecBlueGreenDeploymentConfigGreenFleetProvisioningOption)(ptr) = objs[0]
			} else {
				*(*DeploymentGroupSpecBlueGreenDeploymentConfigGreenFleetProvisioningOption)(ptr) = DeploymentGroupSpecBlueGreenDeploymentConfigGreenFleetProvisioningOption{}
			}
		} else {
			*(*DeploymentGroupSpecBlueGreenDeploymentConfigGreenFleetProvisioningOption)(ptr) = DeploymentGroupSpecBlueGreenDeploymentConfigGreenFleetProvisioningOption{}
		}
	default:
		iter.ReportError("decode DeploymentGroupSpecBlueGreenDeploymentConfigGreenFleetProvisioningOption", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentGroupSpecBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccessCodec struct {
}

func (DeploymentGroupSpecBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccessCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentGroupSpecBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess)(ptr) == nil
}

func (DeploymentGroupSpecBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccessCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentGroupSpecBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess)(ptr)
	var objs []DeploymentGroupSpecBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess
	if obj != nil {
		objs = []DeploymentGroupSpecBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentGroupSpecBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccessCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentGroupSpecBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess)(ptr) = DeploymentGroupSpecBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentGroupSpecBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentGroupSpecBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess)(ptr) = objs[0]
			} else {
				*(*DeploymentGroupSpecBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess)(ptr) = DeploymentGroupSpecBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess{}
			}
		} else {
			*(*DeploymentGroupSpecBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess)(ptr) = DeploymentGroupSpecBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess{}
		}
	default:
		iter.ReportError("decode DeploymentGroupSpecBlueGreenDeploymentConfigTerminateBlueInstancesOnDeploymentSuccess", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentGroupSpecDeploymentStyleCodec struct {
}

func (DeploymentGroupSpecDeploymentStyleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentGroupSpecDeploymentStyle)(ptr) == nil
}

func (DeploymentGroupSpecDeploymentStyleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentGroupSpecDeploymentStyle)(ptr)
	var objs []DeploymentGroupSpecDeploymentStyle
	if obj != nil {
		objs = []DeploymentGroupSpecDeploymentStyle{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecDeploymentStyle{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentGroupSpecDeploymentStyleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentGroupSpecDeploymentStyle)(ptr) = DeploymentGroupSpecDeploymentStyle{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentGroupSpecDeploymentStyle

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecDeploymentStyle{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentGroupSpecDeploymentStyle)(ptr) = objs[0]
			} else {
				*(*DeploymentGroupSpecDeploymentStyle)(ptr) = DeploymentGroupSpecDeploymentStyle{}
			}
		} else {
			*(*DeploymentGroupSpecDeploymentStyle)(ptr) = DeploymentGroupSpecDeploymentStyle{}
		}
	default:
		iter.ReportError("decode DeploymentGroupSpecDeploymentStyle", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentGroupSpecEcsServiceCodec struct {
}

func (DeploymentGroupSpecEcsServiceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentGroupSpecEcsService)(ptr) == nil
}

func (DeploymentGroupSpecEcsServiceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentGroupSpecEcsService)(ptr)
	var objs []DeploymentGroupSpecEcsService
	if obj != nil {
		objs = []DeploymentGroupSpecEcsService{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecEcsService{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentGroupSpecEcsServiceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentGroupSpecEcsService)(ptr) = DeploymentGroupSpecEcsService{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentGroupSpecEcsService

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecEcsService{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentGroupSpecEcsService)(ptr) = objs[0]
			} else {
				*(*DeploymentGroupSpecEcsService)(ptr) = DeploymentGroupSpecEcsService{}
			}
		} else {
			*(*DeploymentGroupSpecEcsService)(ptr) = DeploymentGroupSpecEcsService{}
		}
	default:
		iter.ReportError("decode DeploymentGroupSpecEcsService", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentGroupSpecLoadBalancerInfoCodec struct {
}

func (DeploymentGroupSpecLoadBalancerInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentGroupSpecLoadBalancerInfo)(ptr) == nil
}

func (DeploymentGroupSpecLoadBalancerInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentGroupSpecLoadBalancerInfo)(ptr)
	var objs []DeploymentGroupSpecLoadBalancerInfo
	if obj != nil {
		objs = []DeploymentGroupSpecLoadBalancerInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecLoadBalancerInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentGroupSpecLoadBalancerInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentGroupSpecLoadBalancerInfo)(ptr) = DeploymentGroupSpecLoadBalancerInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentGroupSpecLoadBalancerInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecLoadBalancerInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentGroupSpecLoadBalancerInfo)(ptr) = objs[0]
			} else {
				*(*DeploymentGroupSpecLoadBalancerInfo)(ptr) = DeploymentGroupSpecLoadBalancerInfo{}
			}
		} else {
			*(*DeploymentGroupSpecLoadBalancerInfo)(ptr) = DeploymentGroupSpecLoadBalancerInfo{}
		}
	default:
		iter.ReportError("decode DeploymentGroupSpecLoadBalancerInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoCodec struct {
}

func (DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfo)(ptr) == nil
}

func (DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfo)(ptr)
	var objs []DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfo
	if obj != nil {
		objs = []DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfo)(ptr) = DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfo)(ptr) = objs[0]
			} else {
				*(*DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfo)(ptr) = DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfo{}
			}
		} else {
			*(*DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfo)(ptr) = DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfo{}
		}
	default:
		iter.ReportError("decode DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoProdTrafficRouteCodec struct {
}

func (DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoProdTrafficRouteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute)(ptr) == nil
}

func (DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoProdTrafficRouteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute)(ptr)
	var objs []DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute
	if obj != nil {
		objs = []DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoProdTrafficRouteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute)(ptr) = DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute)(ptr) = objs[0]
			} else {
				*(*DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute)(ptr) = DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute{}
			}
		} else {
			*(*DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute)(ptr) = DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute{}
		}
	default:
		iter.ReportError("decode DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoProdTrafficRoute", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoTestTrafficRouteCodec struct {
}

func (DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoTestTrafficRouteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute)(ptr) == nil
}

func (DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoTestTrafficRouteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute)(ptr)
	var objs []DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute
	if obj != nil {
		objs = []DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoTestTrafficRouteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute)(ptr) = DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute)(ptr) = objs[0]
			} else {
				*(*DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute)(ptr) = DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute{}
			}
		} else {
			*(*DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute)(ptr) = DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute{}
		}
	default:
		iter.ReportError("decode DeploymentGroupSpecLoadBalancerInfoTargetGroupPairInfoTestTrafficRoute", "unexpected JSON type")
	}
}
