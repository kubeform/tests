/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecCloudwatchLoggingOptions{}).Type1()):                                                                                     AnalyticsApplicationSpecCloudwatchLoggingOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputs{}).Type1()):                                                                                                       AnalyticsApplicationSpecInputsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsKinesisFirehose{}).Type1()):                                                                                        AnalyticsApplicationSpecInputsKinesisFirehoseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsKinesisStream{}).Type1()):                                                                                          AnalyticsApplicationSpecInputsKinesisStreamCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsParallelism{}).Type1()):                                                                                            AnalyticsApplicationSpecInputsParallelismCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsProcessingConfiguration{}).Type1()):                                                                                AnalyticsApplicationSpecInputsProcessingConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsProcessingConfigurationLambda{}).Type1()):                                                                          AnalyticsApplicationSpecInputsProcessingConfigurationLambdaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsSchema{}).Type1()):                                                                                                 AnalyticsApplicationSpecInputsSchemaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsSchemaRecordFormat{}).Type1()):                                                                                     AnalyticsApplicationSpecInputsSchemaRecordFormatCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParameters{}).Type1()):                                                                    AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCsv{}).Type1()):                                                                 AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCsvCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersJson{}).Type1()):                                                                AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersJsonCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecOutputsKinesisFirehose{}).Type1()):                                                                                       AnalyticsApplicationSpecOutputsKinesisFirehoseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecOutputsKinesisStream{}).Type1()):                                                                                         AnalyticsApplicationSpecOutputsKinesisStreamCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecOutputsLambda{}).Type1()):                                                                                                AnalyticsApplicationSpecOutputsLambdaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecOutputsSchema{}).Type1()):                                                                                                AnalyticsApplicationSpecOutputsSchemaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSources{}).Type1()):                                                                                         AnalyticsApplicationSpecReferenceDataSourcesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesS3{}).Type1()):                                                                                       AnalyticsApplicationSpecReferenceDataSourcesS3Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesSchema{}).Type1()):                                                                                   AnalyticsApplicationSpecReferenceDataSourcesSchemaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormat{}).Type1()):                                                                       AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParameters{}).Type1()):                                                      AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCsv{}).Type1()):                                                   AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCsvCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersJson{}).Type1()):                                                  AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersJsonCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecElasticsearchConfiguration{}).Type1()):                                                                                 FirehoseDeliveryStreamSpecElasticsearchConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecElasticsearchConfigurationCloudwatchLoggingOptions{}).Type1()):                                                         FirehoseDeliveryStreamSpecElasticsearchConfigurationCloudwatchLoggingOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecElasticsearchConfigurationProcessingConfiguration{}).Type1()):                                                          FirehoseDeliveryStreamSpecElasticsearchConfigurationProcessingConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecElasticsearchConfigurationVpcConfig{}).Type1()):                                                                        FirehoseDeliveryStreamSpecElasticsearchConfigurationVpcConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3Configuration{}).Type1()):                                                                                    FirehoseDeliveryStreamSpecExtendedS3ConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationCloudwatchLoggingOptions{}).Type1()):                                                            FirehoseDeliveryStreamSpecExtendedS3ConfigurationCloudwatchLoggingOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfiguration{}).Type1()):                                                   FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration{}).Type1()):                           FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer{}).Type1()):               FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJSONSerDe{}).Type1()):  FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJSONSerDeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJSONSerDe{}).Type1()): FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJSONSerDeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration{}).Type1()):                          FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer{}).Type1()):                FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe{}).Type1()):        FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe{}).Type1()):    FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration{}).Type1()):                                FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationProcessingConfiguration{}).Type1()):                                                             FirehoseDeliveryStreamSpecExtendedS3ConfigurationProcessingConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfiguration{}).Type1()):                                                               FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions{}).Type1()):                                       FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecHttpEndpointConfiguration{}).Type1()):                                                                                  FirehoseDeliveryStreamSpecHttpEndpointConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecHttpEndpointConfigurationCloudwatchLoggingOptions{}).Type1()):                                                          FirehoseDeliveryStreamSpecHttpEndpointConfigurationCloudwatchLoggingOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecHttpEndpointConfigurationProcessingConfiguration{}).Type1()):                                                           FirehoseDeliveryStreamSpecHttpEndpointConfigurationProcessingConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecHttpEndpointConfigurationRequestConfiguration{}).Type1()):                                                              FirehoseDeliveryStreamSpecHttpEndpointConfigurationRequestConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecKinesisSourceConfiguration{}).Type1()):                                                                                 FirehoseDeliveryStreamSpecKinesisSourceConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecRedshiftConfiguration{}).Type1()):                                                                                      FirehoseDeliveryStreamSpecRedshiftConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecRedshiftConfigurationCloudwatchLoggingOptions{}).Type1()):                                                              FirehoseDeliveryStreamSpecRedshiftConfigurationCloudwatchLoggingOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecRedshiftConfigurationProcessingConfiguration{}).Type1()):                                                               FirehoseDeliveryStreamSpecRedshiftConfigurationProcessingConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfiguration{}).Type1()):                                                                 FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions{}).Type1()):                                         FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecS3Configuration{}).Type1()):                                                                                            FirehoseDeliveryStreamSpecS3ConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecS3ConfigurationCloudwatchLoggingOptions{}).Type1()):                                                                    FirehoseDeliveryStreamSpecS3ConfigurationCloudwatchLoggingOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecServerSideEncryption{}).Type1()):                                                                                       FirehoseDeliveryStreamSpecServerSideEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecSplunkConfiguration{}).Type1()):                                                                                        FirehoseDeliveryStreamSpecSplunkConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecSplunkConfigurationCloudwatchLoggingOptions{}).Type1()):                                                                FirehoseDeliveryStreamSpecSplunkConfigurationCloudwatchLoggingOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecSplunkConfigurationProcessingConfiguration{}).Type1()):                                                                 FirehoseDeliveryStreamSpecSplunkConfigurationProcessingConfigurationCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecCloudwatchLoggingOptions{}).Type1()):                                                                                     AnalyticsApplicationSpecCloudwatchLoggingOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputs{}).Type1()):                                                                                                       AnalyticsApplicationSpecInputsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsKinesisFirehose{}).Type1()):                                                                                        AnalyticsApplicationSpecInputsKinesisFirehoseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsKinesisStream{}).Type1()):                                                                                          AnalyticsApplicationSpecInputsKinesisStreamCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsParallelism{}).Type1()):                                                                                            AnalyticsApplicationSpecInputsParallelismCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsProcessingConfiguration{}).Type1()):                                                                                AnalyticsApplicationSpecInputsProcessingConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsProcessingConfigurationLambda{}).Type1()):                                                                          AnalyticsApplicationSpecInputsProcessingConfigurationLambdaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsSchema{}).Type1()):                                                                                                 AnalyticsApplicationSpecInputsSchemaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsSchemaRecordFormat{}).Type1()):                                                                                     AnalyticsApplicationSpecInputsSchemaRecordFormatCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParameters{}).Type1()):                                                                    AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCsv{}).Type1()):                                                                 AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCsvCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersJson{}).Type1()):                                                                AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersJsonCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecOutputsKinesisFirehose{}).Type1()):                                                                                       AnalyticsApplicationSpecOutputsKinesisFirehoseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecOutputsKinesisStream{}).Type1()):                                                                                         AnalyticsApplicationSpecOutputsKinesisStreamCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecOutputsLambda{}).Type1()):                                                                                                AnalyticsApplicationSpecOutputsLambdaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecOutputsSchema{}).Type1()):                                                                                                AnalyticsApplicationSpecOutputsSchemaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSources{}).Type1()):                                                                                         AnalyticsApplicationSpecReferenceDataSourcesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesS3{}).Type1()):                                                                                       AnalyticsApplicationSpecReferenceDataSourcesS3Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesSchema{}).Type1()):                                                                                   AnalyticsApplicationSpecReferenceDataSourcesSchemaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormat{}).Type1()):                                                                       AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParameters{}).Type1()):                                                      AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCsv{}).Type1()):                                                   AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCsvCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersJson{}).Type1()):                                                  AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersJsonCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecElasticsearchConfiguration{}).Type1()):                                                                                 FirehoseDeliveryStreamSpecElasticsearchConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecElasticsearchConfigurationCloudwatchLoggingOptions{}).Type1()):                                                         FirehoseDeliveryStreamSpecElasticsearchConfigurationCloudwatchLoggingOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecElasticsearchConfigurationProcessingConfiguration{}).Type1()):                                                          FirehoseDeliveryStreamSpecElasticsearchConfigurationProcessingConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecElasticsearchConfigurationVpcConfig{}).Type1()):                                                                        FirehoseDeliveryStreamSpecElasticsearchConfigurationVpcConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3Configuration{}).Type1()):                                                                                    FirehoseDeliveryStreamSpecExtendedS3ConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationCloudwatchLoggingOptions{}).Type1()):                                                            FirehoseDeliveryStreamSpecExtendedS3ConfigurationCloudwatchLoggingOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfiguration{}).Type1()):                                                   FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration{}).Type1()):                           FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer{}).Type1()):               FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJSONSerDe{}).Type1()):  FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJSONSerDeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJSONSerDe{}).Type1()): FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJSONSerDeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration{}).Type1()):                          FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer{}).Type1()):                FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe{}).Type1()):        FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe{}).Type1()):    FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration{}).Type1()):                                FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationProcessingConfiguration{}).Type1()):                                                             FirehoseDeliveryStreamSpecExtendedS3ConfigurationProcessingConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfiguration{}).Type1()):                                                               FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions{}).Type1()):                                       FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecHttpEndpointConfiguration{}).Type1()):                                                                                  FirehoseDeliveryStreamSpecHttpEndpointConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecHttpEndpointConfigurationCloudwatchLoggingOptions{}).Type1()):                                                          FirehoseDeliveryStreamSpecHttpEndpointConfigurationCloudwatchLoggingOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecHttpEndpointConfigurationProcessingConfiguration{}).Type1()):                                                           FirehoseDeliveryStreamSpecHttpEndpointConfigurationProcessingConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecHttpEndpointConfigurationRequestConfiguration{}).Type1()):                                                              FirehoseDeliveryStreamSpecHttpEndpointConfigurationRequestConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecKinesisSourceConfiguration{}).Type1()):                                                                                 FirehoseDeliveryStreamSpecKinesisSourceConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecRedshiftConfiguration{}).Type1()):                                                                                      FirehoseDeliveryStreamSpecRedshiftConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecRedshiftConfigurationCloudwatchLoggingOptions{}).Type1()):                                                              FirehoseDeliveryStreamSpecRedshiftConfigurationCloudwatchLoggingOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecRedshiftConfigurationProcessingConfiguration{}).Type1()):                                                               FirehoseDeliveryStreamSpecRedshiftConfigurationProcessingConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfiguration{}).Type1()):                                                                 FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions{}).Type1()):                                         FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecS3Configuration{}).Type1()):                                                                                            FirehoseDeliveryStreamSpecS3ConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecS3ConfigurationCloudwatchLoggingOptions{}).Type1()):                                                                    FirehoseDeliveryStreamSpecS3ConfigurationCloudwatchLoggingOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecServerSideEncryption{}).Type1()):                                                                                       FirehoseDeliveryStreamSpecServerSideEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecSplunkConfiguration{}).Type1()):                                                                                        FirehoseDeliveryStreamSpecSplunkConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecSplunkConfigurationCloudwatchLoggingOptions{}).Type1()):                                                                FirehoseDeliveryStreamSpecSplunkConfigurationCloudwatchLoggingOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecSplunkConfigurationProcessingConfiguration{}).Type1()):                                                                 FirehoseDeliveryStreamSpecSplunkConfigurationProcessingConfigurationCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AnalyticsApplicationSpecCloudwatchLoggingOptionsCodec struct {
}

func (AnalyticsApplicationSpecCloudwatchLoggingOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalyticsApplicationSpecCloudwatchLoggingOptions)(ptr) == nil
}

func (AnalyticsApplicationSpecCloudwatchLoggingOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalyticsApplicationSpecCloudwatchLoggingOptions)(ptr)
	var objs []AnalyticsApplicationSpecCloudwatchLoggingOptions
	if obj != nil {
		objs = []AnalyticsApplicationSpecCloudwatchLoggingOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecCloudwatchLoggingOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalyticsApplicationSpecCloudwatchLoggingOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalyticsApplicationSpecCloudwatchLoggingOptions)(ptr) = AnalyticsApplicationSpecCloudwatchLoggingOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalyticsApplicationSpecCloudwatchLoggingOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecCloudwatchLoggingOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalyticsApplicationSpecCloudwatchLoggingOptions)(ptr) = objs[0]
			} else {
				*(*AnalyticsApplicationSpecCloudwatchLoggingOptions)(ptr) = AnalyticsApplicationSpecCloudwatchLoggingOptions{}
			}
		} else {
			*(*AnalyticsApplicationSpecCloudwatchLoggingOptions)(ptr) = AnalyticsApplicationSpecCloudwatchLoggingOptions{}
		}
	default:
		iter.ReportError("decode AnalyticsApplicationSpecCloudwatchLoggingOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalyticsApplicationSpecInputsCodec struct {
}

func (AnalyticsApplicationSpecInputsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalyticsApplicationSpecInputs)(ptr) == nil
}

func (AnalyticsApplicationSpecInputsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalyticsApplicationSpecInputs)(ptr)
	var objs []AnalyticsApplicationSpecInputs
	if obj != nil {
		objs = []AnalyticsApplicationSpecInputs{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputs{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalyticsApplicationSpecInputsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalyticsApplicationSpecInputs)(ptr) = AnalyticsApplicationSpecInputs{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalyticsApplicationSpecInputs

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputs{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalyticsApplicationSpecInputs)(ptr) = objs[0]
			} else {
				*(*AnalyticsApplicationSpecInputs)(ptr) = AnalyticsApplicationSpecInputs{}
			}
		} else {
			*(*AnalyticsApplicationSpecInputs)(ptr) = AnalyticsApplicationSpecInputs{}
		}
	default:
		iter.ReportError("decode AnalyticsApplicationSpecInputs", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalyticsApplicationSpecInputsKinesisFirehoseCodec struct {
}

func (AnalyticsApplicationSpecInputsKinesisFirehoseCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalyticsApplicationSpecInputsKinesisFirehose)(ptr) == nil
}

func (AnalyticsApplicationSpecInputsKinesisFirehoseCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalyticsApplicationSpecInputsKinesisFirehose)(ptr)
	var objs []AnalyticsApplicationSpecInputsKinesisFirehose
	if obj != nil {
		objs = []AnalyticsApplicationSpecInputsKinesisFirehose{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsKinesisFirehose{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalyticsApplicationSpecInputsKinesisFirehoseCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalyticsApplicationSpecInputsKinesisFirehose)(ptr) = AnalyticsApplicationSpecInputsKinesisFirehose{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalyticsApplicationSpecInputsKinesisFirehose

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsKinesisFirehose{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalyticsApplicationSpecInputsKinesisFirehose)(ptr) = objs[0]
			} else {
				*(*AnalyticsApplicationSpecInputsKinesisFirehose)(ptr) = AnalyticsApplicationSpecInputsKinesisFirehose{}
			}
		} else {
			*(*AnalyticsApplicationSpecInputsKinesisFirehose)(ptr) = AnalyticsApplicationSpecInputsKinesisFirehose{}
		}
	default:
		iter.ReportError("decode AnalyticsApplicationSpecInputsKinesisFirehose", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalyticsApplicationSpecInputsKinesisStreamCodec struct {
}

func (AnalyticsApplicationSpecInputsKinesisStreamCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalyticsApplicationSpecInputsKinesisStream)(ptr) == nil
}

func (AnalyticsApplicationSpecInputsKinesisStreamCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalyticsApplicationSpecInputsKinesisStream)(ptr)
	var objs []AnalyticsApplicationSpecInputsKinesisStream
	if obj != nil {
		objs = []AnalyticsApplicationSpecInputsKinesisStream{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsKinesisStream{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalyticsApplicationSpecInputsKinesisStreamCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalyticsApplicationSpecInputsKinesisStream)(ptr) = AnalyticsApplicationSpecInputsKinesisStream{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalyticsApplicationSpecInputsKinesisStream

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsKinesisStream{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalyticsApplicationSpecInputsKinesisStream)(ptr) = objs[0]
			} else {
				*(*AnalyticsApplicationSpecInputsKinesisStream)(ptr) = AnalyticsApplicationSpecInputsKinesisStream{}
			}
		} else {
			*(*AnalyticsApplicationSpecInputsKinesisStream)(ptr) = AnalyticsApplicationSpecInputsKinesisStream{}
		}
	default:
		iter.ReportError("decode AnalyticsApplicationSpecInputsKinesisStream", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalyticsApplicationSpecInputsParallelismCodec struct {
}

func (AnalyticsApplicationSpecInputsParallelismCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalyticsApplicationSpecInputsParallelism)(ptr) == nil
}

func (AnalyticsApplicationSpecInputsParallelismCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalyticsApplicationSpecInputsParallelism)(ptr)
	var objs []AnalyticsApplicationSpecInputsParallelism
	if obj != nil {
		objs = []AnalyticsApplicationSpecInputsParallelism{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsParallelism{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalyticsApplicationSpecInputsParallelismCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalyticsApplicationSpecInputsParallelism)(ptr) = AnalyticsApplicationSpecInputsParallelism{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalyticsApplicationSpecInputsParallelism

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsParallelism{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalyticsApplicationSpecInputsParallelism)(ptr) = objs[0]
			} else {
				*(*AnalyticsApplicationSpecInputsParallelism)(ptr) = AnalyticsApplicationSpecInputsParallelism{}
			}
		} else {
			*(*AnalyticsApplicationSpecInputsParallelism)(ptr) = AnalyticsApplicationSpecInputsParallelism{}
		}
	default:
		iter.ReportError("decode AnalyticsApplicationSpecInputsParallelism", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalyticsApplicationSpecInputsProcessingConfigurationCodec struct {
}

func (AnalyticsApplicationSpecInputsProcessingConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalyticsApplicationSpecInputsProcessingConfiguration)(ptr) == nil
}

func (AnalyticsApplicationSpecInputsProcessingConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalyticsApplicationSpecInputsProcessingConfiguration)(ptr)
	var objs []AnalyticsApplicationSpecInputsProcessingConfiguration
	if obj != nil {
		objs = []AnalyticsApplicationSpecInputsProcessingConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsProcessingConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalyticsApplicationSpecInputsProcessingConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalyticsApplicationSpecInputsProcessingConfiguration)(ptr) = AnalyticsApplicationSpecInputsProcessingConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalyticsApplicationSpecInputsProcessingConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsProcessingConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalyticsApplicationSpecInputsProcessingConfiguration)(ptr) = objs[0]
			} else {
				*(*AnalyticsApplicationSpecInputsProcessingConfiguration)(ptr) = AnalyticsApplicationSpecInputsProcessingConfiguration{}
			}
		} else {
			*(*AnalyticsApplicationSpecInputsProcessingConfiguration)(ptr) = AnalyticsApplicationSpecInputsProcessingConfiguration{}
		}
	default:
		iter.ReportError("decode AnalyticsApplicationSpecInputsProcessingConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalyticsApplicationSpecInputsProcessingConfigurationLambdaCodec struct {
}

func (AnalyticsApplicationSpecInputsProcessingConfigurationLambdaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalyticsApplicationSpecInputsProcessingConfigurationLambda)(ptr) == nil
}

func (AnalyticsApplicationSpecInputsProcessingConfigurationLambdaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalyticsApplicationSpecInputsProcessingConfigurationLambda)(ptr)
	var objs []AnalyticsApplicationSpecInputsProcessingConfigurationLambda
	if obj != nil {
		objs = []AnalyticsApplicationSpecInputsProcessingConfigurationLambda{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsProcessingConfigurationLambda{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalyticsApplicationSpecInputsProcessingConfigurationLambdaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalyticsApplicationSpecInputsProcessingConfigurationLambda)(ptr) = AnalyticsApplicationSpecInputsProcessingConfigurationLambda{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalyticsApplicationSpecInputsProcessingConfigurationLambda

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsProcessingConfigurationLambda{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalyticsApplicationSpecInputsProcessingConfigurationLambda)(ptr) = objs[0]
			} else {
				*(*AnalyticsApplicationSpecInputsProcessingConfigurationLambda)(ptr) = AnalyticsApplicationSpecInputsProcessingConfigurationLambda{}
			}
		} else {
			*(*AnalyticsApplicationSpecInputsProcessingConfigurationLambda)(ptr) = AnalyticsApplicationSpecInputsProcessingConfigurationLambda{}
		}
	default:
		iter.ReportError("decode AnalyticsApplicationSpecInputsProcessingConfigurationLambda", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalyticsApplicationSpecInputsSchemaCodec struct {
}

func (AnalyticsApplicationSpecInputsSchemaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalyticsApplicationSpecInputsSchema)(ptr) == nil
}

func (AnalyticsApplicationSpecInputsSchemaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalyticsApplicationSpecInputsSchema)(ptr)
	var objs []AnalyticsApplicationSpecInputsSchema
	if obj != nil {
		objs = []AnalyticsApplicationSpecInputsSchema{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsSchema{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalyticsApplicationSpecInputsSchemaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalyticsApplicationSpecInputsSchema)(ptr) = AnalyticsApplicationSpecInputsSchema{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalyticsApplicationSpecInputsSchema

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsSchema{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalyticsApplicationSpecInputsSchema)(ptr) = objs[0]
			} else {
				*(*AnalyticsApplicationSpecInputsSchema)(ptr) = AnalyticsApplicationSpecInputsSchema{}
			}
		} else {
			*(*AnalyticsApplicationSpecInputsSchema)(ptr) = AnalyticsApplicationSpecInputsSchema{}
		}
	default:
		iter.ReportError("decode AnalyticsApplicationSpecInputsSchema", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalyticsApplicationSpecInputsSchemaRecordFormatCodec struct {
}

func (AnalyticsApplicationSpecInputsSchemaRecordFormatCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalyticsApplicationSpecInputsSchemaRecordFormat)(ptr) == nil
}

func (AnalyticsApplicationSpecInputsSchemaRecordFormatCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalyticsApplicationSpecInputsSchemaRecordFormat)(ptr)
	var objs []AnalyticsApplicationSpecInputsSchemaRecordFormat
	if obj != nil {
		objs = []AnalyticsApplicationSpecInputsSchemaRecordFormat{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsSchemaRecordFormat{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalyticsApplicationSpecInputsSchemaRecordFormatCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalyticsApplicationSpecInputsSchemaRecordFormat)(ptr) = AnalyticsApplicationSpecInputsSchemaRecordFormat{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalyticsApplicationSpecInputsSchemaRecordFormat

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsSchemaRecordFormat{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalyticsApplicationSpecInputsSchemaRecordFormat)(ptr) = objs[0]
			} else {
				*(*AnalyticsApplicationSpecInputsSchemaRecordFormat)(ptr) = AnalyticsApplicationSpecInputsSchemaRecordFormat{}
			}
		} else {
			*(*AnalyticsApplicationSpecInputsSchemaRecordFormat)(ptr) = AnalyticsApplicationSpecInputsSchemaRecordFormat{}
		}
	default:
		iter.ReportError("decode AnalyticsApplicationSpecInputsSchemaRecordFormat", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCodec struct {
}

func (AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParameters)(ptr) == nil
}

func (AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParameters)(ptr)
	var objs []AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParameters
	if obj != nil {
		objs = []AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParameters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParameters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParameters)(ptr) = AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParameters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParameters)(ptr) = objs[0]
			} else {
				*(*AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParameters)(ptr) = AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParameters{}
			}
		} else {
			*(*AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParameters)(ptr) = AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParameters{}
		}
	default:
		iter.ReportError("decode AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParameters", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCsvCodec struct {
}

func (AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCsvCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCsv)(ptr) == nil
}

func (AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCsvCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCsv)(ptr)
	var objs []AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCsv
	if obj != nil {
		objs = []AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCsv{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCsv{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCsvCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCsv)(ptr) = AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCsv{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCsv

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCsv{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCsv)(ptr) = objs[0]
			} else {
				*(*AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCsv)(ptr) = AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCsv{}
			}
		} else {
			*(*AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCsv)(ptr) = AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCsv{}
		}
	default:
		iter.ReportError("decode AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersCsv", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersJsonCodec struct {
}

func (AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersJsonCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersJson)(ptr) == nil
}

func (AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersJsonCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersJson)(ptr)
	var objs []AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersJson
	if obj != nil {
		objs = []AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersJson{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersJson{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersJsonCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersJson)(ptr) = AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersJson{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersJson

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersJson{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersJson)(ptr) = objs[0]
			} else {
				*(*AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersJson)(ptr) = AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersJson{}
			}
		} else {
			*(*AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersJson)(ptr) = AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersJson{}
		}
	default:
		iter.ReportError("decode AnalyticsApplicationSpecInputsSchemaRecordFormatMappingParametersJson", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalyticsApplicationSpecOutputsKinesisFirehoseCodec struct {
}

func (AnalyticsApplicationSpecOutputsKinesisFirehoseCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalyticsApplicationSpecOutputsKinesisFirehose)(ptr) == nil
}

func (AnalyticsApplicationSpecOutputsKinesisFirehoseCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalyticsApplicationSpecOutputsKinesisFirehose)(ptr)
	var objs []AnalyticsApplicationSpecOutputsKinesisFirehose
	if obj != nil {
		objs = []AnalyticsApplicationSpecOutputsKinesisFirehose{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecOutputsKinesisFirehose{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalyticsApplicationSpecOutputsKinesisFirehoseCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalyticsApplicationSpecOutputsKinesisFirehose)(ptr) = AnalyticsApplicationSpecOutputsKinesisFirehose{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalyticsApplicationSpecOutputsKinesisFirehose

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecOutputsKinesisFirehose{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalyticsApplicationSpecOutputsKinesisFirehose)(ptr) = objs[0]
			} else {
				*(*AnalyticsApplicationSpecOutputsKinesisFirehose)(ptr) = AnalyticsApplicationSpecOutputsKinesisFirehose{}
			}
		} else {
			*(*AnalyticsApplicationSpecOutputsKinesisFirehose)(ptr) = AnalyticsApplicationSpecOutputsKinesisFirehose{}
		}
	default:
		iter.ReportError("decode AnalyticsApplicationSpecOutputsKinesisFirehose", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalyticsApplicationSpecOutputsKinesisStreamCodec struct {
}

func (AnalyticsApplicationSpecOutputsKinesisStreamCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalyticsApplicationSpecOutputsKinesisStream)(ptr) == nil
}

func (AnalyticsApplicationSpecOutputsKinesisStreamCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalyticsApplicationSpecOutputsKinesisStream)(ptr)
	var objs []AnalyticsApplicationSpecOutputsKinesisStream
	if obj != nil {
		objs = []AnalyticsApplicationSpecOutputsKinesisStream{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecOutputsKinesisStream{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalyticsApplicationSpecOutputsKinesisStreamCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalyticsApplicationSpecOutputsKinesisStream)(ptr) = AnalyticsApplicationSpecOutputsKinesisStream{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalyticsApplicationSpecOutputsKinesisStream

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecOutputsKinesisStream{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalyticsApplicationSpecOutputsKinesisStream)(ptr) = objs[0]
			} else {
				*(*AnalyticsApplicationSpecOutputsKinesisStream)(ptr) = AnalyticsApplicationSpecOutputsKinesisStream{}
			}
		} else {
			*(*AnalyticsApplicationSpecOutputsKinesisStream)(ptr) = AnalyticsApplicationSpecOutputsKinesisStream{}
		}
	default:
		iter.ReportError("decode AnalyticsApplicationSpecOutputsKinesisStream", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalyticsApplicationSpecOutputsLambdaCodec struct {
}

func (AnalyticsApplicationSpecOutputsLambdaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalyticsApplicationSpecOutputsLambda)(ptr) == nil
}

func (AnalyticsApplicationSpecOutputsLambdaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalyticsApplicationSpecOutputsLambda)(ptr)
	var objs []AnalyticsApplicationSpecOutputsLambda
	if obj != nil {
		objs = []AnalyticsApplicationSpecOutputsLambda{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecOutputsLambda{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalyticsApplicationSpecOutputsLambdaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalyticsApplicationSpecOutputsLambda)(ptr) = AnalyticsApplicationSpecOutputsLambda{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalyticsApplicationSpecOutputsLambda

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecOutputsLambda{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalyticsApplicationSpecOutputsLambda)(ptr) = objs[0]
			} else {
				*(*AnalyticsApplicationSpecOutputsLambda)(ptr) = AnalyticsApplicationSpecOutputsLambda{}
			}
		} else {
			*(*AnalyticsApplicationSpecOutputsLambda)(ptr) = AnalyticsApplicationSpecOutputsLambda{}
		}
	default:
		iter.ReportError("decode AnalyticsApplicationSpecOutputsLambda", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalyticsApplicationSpecOutputsSchemaCodec struct {
}

func (AnalyticsApplicationSpecOutputsSchemaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalyticsApplicationSpecOutputsSchema)(ptr) == nil
}

func (AnalyticsApplicationSpecOutputsSchemaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalyticsApplicationSpecOutputsSchema)(ptr)
	var objs []AnalyticsApplicationSpecOutputsSchema
	if obj != nil {
		objs = []AnalyticsApplicationSpecOutputsSchema{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecOutputsSchema{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalyticsApplicationSpecOutputsSchemaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalyticsApplicationSpecOutputsSchema)(ptr) = AnalyticsApplicationSpecOutputsSchema{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalyticsApplicationSpecOutputsSchema

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecOutputsSchema{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalyticsApplicationSpecOutputsSchema)(ptr) = objs[0]
			} else {
				*(*AnalyticsApplicationSpecOutputsSchema)(ptr) = AnalyticsApplicationSpecOutputsSchema{}
			}
		} else {
			*(*AnalyticsApplicationSpecOutputsSchema)(ptr) = AnalyticsApplicationSpecOutputsSchema{}
		}
	default:
		iter.ReportError("decode AnalyticsApplicationSpecOutputsSchema", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalyticsApplicationSpecReferenceDataSourcesCodec struct {
}

func (AnalyticsApplicationSpecReferenceDataSourcesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalyticsApplicationSpecReferenceDataSources)(ptr) == nil
}

func (AnalyticsApplicationSpecReferenceDataSourcesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalyticsApplicationSpecReferenceDataSources)(ptr)
	var objs []AnalyticsApplicationSpecReferenceDataSources
	if obj != nil {
		objs = []AnalyticsApplicationSpecReferenceDataSources{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSources{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalyticsApplicationSpecReferenceDataSourcesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalyticsApplicationSpecReferenceDataSources)(ptr) = AnalyticsApplicationSpecReferenceDataSources{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalyticsApplicationSpecReferenceDataSources

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSources{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalyticsApplicationSpecReferenceDataSources)(ptr) = objs[0]
			} else {
				*(*AnalyticsApplicationSpecReferenceDataSources)(ptr) = AnalyticsApplicationSpecReferenceDataSources{}
			}
		} else {
			*(*AnalyticsApplicationSpecReferenceDataSources)(ptr) = AnalyticsApplicationSpecReferenceDataSources{}
		}
	default:
		iter.ReportError("decode AnalyticsApplicationSpecReferenceDataSources", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalyticsApplicationSpecReferenceDataSourcesS3Codec struct {
}

func (AnalyticsApplicationSpecReferenceDataSourcesS3Codec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalyticsApplicationSpecReferenceDataSourcesS3)(ptr) == nil
}

func (AnalyticsApplicationSpecReferenceDataSourcesS3Codec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalyticsApplicationSpecReferenceDataSourcesS3)(ptr)
	var objs []AnalyticsApplicationSpecReferenceDataSourcesS3
	if obj != nil {
		objs = []AnalyticsApplicationSpecReferenceDataSourcesS3{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesS3{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalyticsApplicationSpecReferenceDataSourcesS3Codec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalyticsApplicationSpecReferenceDataSourcesS3)(ptr) = AnalyticsApplicationSpecReferenceDataSourcesS3{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalyticsApplicationSpecReferenceDataSourcesS3

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesS3{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalyticsApplicationSpecReferenceDataSourcesS3)(ptr) = objs[0]
			} else {
				*(*AnalyticsApplicationSpecReferenceDataSourcesS3)(ptr) = AnalyticsApplicationSpecReferenceDataSourcesS3{}
			}
		} else {
			*(*AnalyticsApplicationSpecReferenceDataSourcesS3)(ptr) = AnalyticsApplicationSpecReferenceDataSourcesS3{}
		}
	default:
		iter.ReportError("decode AnalyticsApplicationSpecReferenceDataSourcesS3", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalyticsApplicationSpecReferenceDataSourcesSchemaCodec struct {
}

func (AnalyticsApplicationSpecReferenceDataSourcesSchemaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalyticsApplicationSpecReferenceDataSourcesSchema)(ptr) == nil
}

func (AnalyticsApplicationSpecReferenceDataSourcesSchemaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalyticsApplicationSpecReferenceDataSourcesSchema)(ptr)
	var objs []AnalyticsApplicationSpecReferenceDataSourcesSchema
	if obj != nil {
		objs = []AnalyticsApplicationSpecReferenceDataSourcesSchema{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesSchema{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalyticsApplicationSpecReferenceDataSourcesSchemaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalyticsApplicationSpecReferenceDataSourcesSchema)(ptr) = AnalyticsApplicationSpecReferenceDataSourcesSchema{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalyticsApplicationSpecReferenceDataSourcesSchema

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesSchema{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalyticsApplicationSpecReferenceDataSourcesSchema)(ptr) = objs[0]
			} else {
				*(*AnalyticsApplicationSpecReferenceDataSourcesSchema)(ptr) = AnalyticsApplicationSpecReferenceDataSourcesSchema{}
			}
		} else {
			*(*AnalyticsApplicationSpecReferenceDataSourcesSchema)(ptr) = AnalyticsApplicationSpecReferenceDataSourcesSchema{}
		}
	default:
		iter.ReportError("decode AnalyticsApplicationSpecReferenceDataSourcesSchema", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatCodec struct {
}

func (AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormat)(ptr) == nil
}

func (AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormat)(ptr)
	var objs []AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormat
	if obj != nil {
		objs = []AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormat{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormat{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormat)(ptr) = AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormat{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormat

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormat{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormat)(ptr) = objs[0]
			} else {
				*(*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormat)(ptr) = AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormat{}
			}
		} else {
			*(*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormat)(ptr) = AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormat{}
		}
	default:
		iter.ReportError("decode AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormat", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCodec struct {
}

func (AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParameters)(ptr) == nil
}

func (AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParameters)(ptr)
	var objs []AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParameters
	if obj != nil {
		objs = []AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParameters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParameters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParameters)(ptr) = AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParameters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParameters)(ptr) = objs[0]
			} else {
				*(*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParameters)(ptr) = AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParameters{}
			}
		} else {
			*(*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParameters)(ptr) = AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParameters{}
		}
	default:
		iter.ReportError("decode AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParameters", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCsvCodec struct {
}

func (AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCsvCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCsv)(ptr) == nil
}

func (AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCsvCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCsv)(ptr)
	var objs []AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCsv
	if obj != nil {
		objs = []AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCsv{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCsv{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCsvCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCsv)(ptr) = AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCsv{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCsv

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCsv{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCsv)(ptr) = objs[0]
			} else {
				*(*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCsv)(ptr) = AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCsv{}
			}
		} else {
			*(*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCsv)(ptr) = AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCsv{}
		}
	default:
		iter.ReportError("decode AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersCsv", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersJsonCodec struct {
}

func (AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersJsonCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersJson)(ptr) == nil
}

func (AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersJsonCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersJson)(ptr)
	var objs []AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersJson
	if obj != nil {
		objs = []AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersJson{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersJson{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersJsonCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersJson)(ptr) = AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersJson{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersJson

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersJson{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersJson)(ptr) = objs[0]
			} else {
				*(*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersJson)(ptr) = AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersJson{}
			}
		} else {
			*(*AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersJson)(ptr) = AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersJson{}
		}
	default:
		iter.ReportError("decode AnalyticsApplicationSpecReferenceDataSourcesSchemaRecordFormatMappingParametersJson", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecElasticsearchConfigurationCodec struct {
}

func (FirehoseDeliveryStreamSpecElasticsearchConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecElasticsearchConfiguration)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecElasticsearchConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecElasticsearchConfiguration)(ptr)
	var objs []FirehoseDeliveryStreamSpecElasticsearchConfiguration
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecElasticsearchConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecElasticsearchConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecElasticsearchConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecElasticsearchConfiguration)(ptr) = FirehoseDeliveryStreamSpecElasticsearchConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecElasticsearchConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecElasticsearchConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecElasticsearchConfiguration)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecElasticsearchConfiguration)(ptr) = FirehoseDeliveryStreamSpecElasticsearchConfiguration{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecElasticsearchConfiguration)(ptr) = FirehoseDeliveryStreamSpecElasticsearchConfiguration{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecElasticsearchConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecElasticsearchConfigurationCloudwatchLoggingOptionsCodec struct {
}

func (FirehoseDeliveryStreamSpecElasticsearchConfigurationCloudwatchLoggingOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecElasticsearchConfigurationCloudwatchLoggingOptions)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecElasticsearchConfigurationCloudwatchLoggingOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecElasticsearchConfigurationCloudwatchLoggingOptions)(ptr)
	var objs []FirehoseDeliveryStreamSpecElasticsearchConfigurationCloudwatchLoggingOptions
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecElasticsearchConfigurationCloudwatchLoggingOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecElasticsearchConfigurationCloudwatchLoggingOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecElasticsearchConfigurationCloudwatchLoggingOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecElasticsearchConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecElasticsearchConfigurationCloudwatchLoggingOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecElasticsearchConfigurationCloudwatchLoggingOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecElasticsearchConfigurationCloudwatchLoggingOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecElasticsearchConfigurationCloudwatchLoggingOptions)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecElasticsearchConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecElasticsearchConfigurationCloudwatchLoggingOptions{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecElasticsearchConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecElasticsearchConfigurationCloudwatchLoggingOptions{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecElasticsearchConfigurationCloudwatchLoggingOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecElasticsearchConfigurationProcessingConfigurationCodec struct {
}

func (FirehoseDeliveryStreamSpecElasticsearchConfigurationProcessingConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecElasticsearchConfigurationProcessingConfiguration)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecElasticsearchConfigurationProcessingConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecElasticsearchConfigurationProcessingConfiguration)(ptr)
	var objs []FirehoseDeliveryStreamSpecElasticsearchConfigurationProcessingConfiguration
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecElasticsearchConfigurationProcessingConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecElasticsearchConfigurationProcessingConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecElasticsearchConfigurationProcessingConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecElasticsearchConfigurationProcessingConfiguration)(ptr) = FirehoseDeliveryStreamSpecElasticsearchConfigurationProcessingConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecElasticsearchConfigurationProcessingConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecElasticsearchConfigurationProcessingConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecElasticsearchConfigurationProcessingConfiguration)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecElasticsearchConfigurationProcessingConfiguration)(ptr) = FirehoseDeliveryStreamSpecElasticsearchConfigurationProcessingConfiguration{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecElasticsearchConfigurationProcessingConfiguration)(ptr) = FirehoseDeliveryStreamSpecElasticsearchConfigurationProcessingConfiguration{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecElasticsearchConfigurationProcessingConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecElasticsearchConfigurationVpcConfigCodec struct {
}

func (FirehoseDeliveryStreamSpecElasticsearchConfigurationVpcConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecElasticsearchConfigurationVpcConfig)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecElasticsearchConfigurationVpcConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecElasticsearchConfigurationVpcConfig)(ptr)
	var objs []FirehoseDeliveryStreamSpecElasticsearchConfigurationVpcConfig
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecElasticsearchConfigurationVpcConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecElasticsearchConfigurationVpcConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecElasticsearchConfigurationVpcConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecElasticsearchConfigurationVpcConfig)(ptr) = FirehoseDeliveryStreamSpecElasticsearchConfigurationVpcConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecElasticsearchConfigurationVpcConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecElasticsearchConfigurationVpcConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecElasticsearchConfigurationVpcConfig)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecElasticsearchConfigurationVpcConfig)(ptr) = FirehoseDeliveryStreamSpecElasticsearchConfigurationVpcConfig{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecElasticsearchConfigurationVpcConfig)(ptr) = FirehoseDeliveryStreamSpecElasticsearchConfigurationVpcConfig{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecElasticsearchConfigurationVpcConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecExtendedS3ConfigurationCodec struct {
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecExtendedS3Configuration)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecExtendedS3Configuration)(ptr)
	var objs []FirehoseDeliveryStreamSpecExtendedS3Configuration
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecExtendedS3Configuration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3Configuration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecExtendedS3Configuration)(ptr) = FirehoseDeliveryStreamSpecExtendedS3Configuration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecExtendedS3Configuration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3Configuration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecExtendedS3Configuration)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecExtendedS3Configuration)(ptr) = FirehoseDeliveryStreamSpecExtendedS3Configuration{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecExtendedS3Configuration)(ptr) = FirehoseDeliveryStreamSpecExtendedS3Configuration{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecExtendedS3Configuration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecExtendedS3ConfigurationCloudwatchLoggingOptionsCodec struct {
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationCloudwatchLoggingOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationCloudwatchLoggingOptions)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationCloudwatchLoggingOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationCloudwatchLoggingOptions)(ptr)
	var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationCloudwatchLoggingOptions
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecExtendedS3ConfigurationCloudwatchLoggingOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationCloudwatchLoggingOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationCloudwatchLoggingOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationCloudwatchLoggingOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationCloudwatchLoggingOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationCloudwatchLoggingOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationCloudwatchLoggingOptions)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationCloudwatchLoggingOptions{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationCloudwatchLoggingOptions{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecExtendedS3ConfigurationCloudwatchLoggingOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationCodec struct {
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfiguration)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfiguration)(ptr)
	var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfiguration
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfiguration)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfiguration)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfiguration)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfiguration{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfiguration)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfiguration{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationCodec struct {
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration)(ptr)
	var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerCodec struct {
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer)(ptr)
	var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializer", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJSONSerDeCodec struct {
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJSONSerDeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJSONSerDe)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJSONSerDeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJSONSerDe)(ptr)
	var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJSONSerDe
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJSONSerDe{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJSONSerDe{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJSONSerDeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJSONSerDe)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJSONSerDe{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJSONSerDe

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJSONSerDe{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJSONSerDe)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJSONSerDe)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJSONSerDe{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJSONSerDe)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJSONSerDe{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerHiveJSONSerDe", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJSONSerDeCodec struct {
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJSONSerDeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJSONSerDe)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJSONSerDeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJSONSerDe)(ptr)
	var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJSONSerDe
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJSONSerDe{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJSONSerDe{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJSONSerDeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJSONSerDe)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJSONSerDe{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJSONSerDe

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJSONSerDe{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJSONSerDe)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJSONSerDe)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJSONSerDe{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJSONSerDe)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJSONSerDe{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationInputFormatConfigurationDeserializerOpenXJSONSerDe", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationCodec struct {
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration)(ptr)
	var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerCodec struct {
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer)(ptr)
	var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializer", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDeCodec struct {
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe)(ptr)
	var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerOrcSerDe", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDeCodec struct {
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe)(ptr)
	var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationOutputFormatConfigurationSerializerParquetSerDe", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationCodec struct {
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration)(ptr)
	var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecExtendedS3ConfigurationDataFormatConversionConfigurationSchemaConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecExtendedS3ConfigurationProcessingConfigurationCodec struct {
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationProcessingConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationProcessingConfiguration)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationProcessingConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationProcessingConfiguration)(ptr)
	var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationProcessingConfiguration
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecExtendedS3ConfigurationProcessingConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationProcessingConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationProcessingConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationProcessingConfiguration)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationProcessingConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationProcessingConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationProcessingConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationProcessingConfiguration)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationProcessingConfiguration)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationProcessingConfiguration{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationProcessingConfiguration)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationProcessingConfiguration{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecExtendedS3ConfigurationProcessingConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCodec struct {
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfiguration)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfiguration)(ptr)
	var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfiguration
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfiguration)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfiguration)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfiguration)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfiguration{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfiguration)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfiguration{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptionsCodec struct {
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions)(ptr)
	var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecExtendedS3ConfigurationS3BackupConfigurationCloudwatchLoggingOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecHttpEndpointConfigurationCodec struct {
}

func (FirehoseDeliveryStreamSpecHttpEndpointConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecHttpEndpointConfiguration)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecHttpEndpointConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecHttpEndpointConfiguration)(ptr)
	var objs []FirehoseDeliveryStreamSpecHttpEndpointConfiguration
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecHttpEndpointConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecHttpEndpointConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecHttpEndpointConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecHttpEndpointConfiguration)(ptr) = FirehoseDeliveryStreamSpecHttpEndpointConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecHttpEndpointConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecHttpEndpointConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecHttpEndpointConfiguration)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecHttpEndpointConfiguration)(ptr) = FirehoseDeliveryStreamSpecHttpEndpointConfiguration{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecHttpEndpointConfiguration)(ptr) = FirehoseDeliveryStreamSpecHttpEndpointConfiguration{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecHttpEndpointConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecHttpEndpointConfigurationCloudwatchLoggingOptionsCodec struct {
}

func (FirehoseDeliveryStreamSpecHttpEndpointConfigurationCloudwatchLoggingOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecHttpEndpointConfigurationCloudwatchLoggingOptions)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecHttpEndpointConfigurationCloudwatchLoggingOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecHttpEndpointConfigurationCloudwatchLoggingOptions)(ptr)
	var objs []FirehoseDeliveryStreamSpecHttpEndpointConfigurationCloudwatchLoggingOptions
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecHttpEndpointConfigurationCloudwatchLoggingOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecHttpEndpointConfigurationCloudwatchLoggingOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecHttpEndpointConfigurationCloudwatchLoggingOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecHttpEndpointConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecHttpEndpointConfigurationCloudwatchLoggingOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecHttpEndpointConfigurationCloudwatchLoggingOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecHttpEndpointConfigurationCloudwatchLoggingOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecHttpEndpointConfigurationCloudwatchLoggingOptions)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecHttpEndpointConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecHttpEndpointConfigurationCloudwatchLoggingOptions{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecHttpEndpointConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecHttpEndpointConfigurationCloudwatchLoggingOptions{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecHttpEndpointConfigurationCloudwatchLoggingOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecHttpEndpointConfigurationProcessingConfigurationCodec struct {
}

func (FirehoseDeliveryStreamSpecHttpEndpointConfigurationProcessingConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecHttpEndpointConfigurationProcessingConfiguration)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecHttpEndpointConfigurationProcessingConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecHttpEndpointConfigurationProcessingConfiguration)(ptr)
	var objs []FirehoseDeliveryStreamSpecHttpEndpointConfigurationProcessingConfiguration
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecHttpEndpointConfigurationProcessingConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecHttpEndpointConfigurationProcessingConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecHttpEndpointConfigurationProcessingConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecHttpEndpointConfigurationProcessingConfiguration)(ptr) = FirehoseDeliveryStreamSpecHttpEndpointConfigurationProcessingConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecHttpEndpointConfigurationProcessingConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecHttpEndpointConfigurationProcessingConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecHttpEndpointConfigurationProcessingConfiguration)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecHttpEndpointConfigurationProcessingConfiguration)(ptr) = FirehoseDeliveryStreamSpecHttpEndpointConfigurationProcessingConfiguration{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecHttpEndpointConfigurationProcessingConfiguration)(ptr) = FirehoseDeliveryStreamSpecHttpEndpointConfigurationProcessingConfiguration{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecHttpEndpointConfigurationProcessingConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecHttpEndpointConfigurationRequestConfigurationCodec struct {
}

func (FirehoseDeliveryStreamSpecHttpEndpointConfigurationRequestConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecHttpEndpointConfigurationRequestConfiguration)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecHttpEndpointConfigurationRequestConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecHttpEndpointConfigurationRequestConfiguration)(ptr)
	var objs []FirehoseDeliveryStreamSpecHttpEndpointConfigurationRequestConfiguration
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecHttpEndpointConfigurationRequestConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecHttpEndpointConfigurationRequestConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecHttpEndpointConfigurationRequestConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecHttpEndpointConfigurationRequestConfiguration)(ptr) = FirehoseDeliveryStreamSpecHttpEndpointConfigurationRequestConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecHttpEndpointConfigurationRequestConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecHttpEndpointConfigurationRequestConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecHttpEndpointConfigurationRequestConfiguration)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecHttpEndpointConfigurationRequestConfiguration)(ptr) = FirehoseDeliveryStreamSpecHttpEndpointConfigurationRequestConfiguration{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecHttpEndpointConfigurationRequestConfiguration)(ptr) = FirehoseDeliveryStreamSpecHttpEndpointConfigurationRequestConfiguration{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecHttpEndpointConfigurationRequestConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecKinesisSourceConfigurationCodec struct {
}

func (FirehoseDeliveryStreamSpecKinesisSourceConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecKinesisSourceConfiguration)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecKinesisSourceConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecKinesisSourceConfiguration)(ptr)
	var objs []FirehoseDeliveryStreamSpecKinesisSourceConfiguration
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecKinesisSourceConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecKinesisSourceConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecKinesisSourceConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecKinesisSourceConfiguration)(ptr) = FirehoseDeliveryStreamSpecKinesisSourceConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecKinesisSourceConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecKinesisSourceConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecKinesisSourceConfiguration)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecKinesisSourceConfiguration)(ptr) = FirehoseDeliveryStreamSpecKinesisSourceConfiguration{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecKinesisSourceConfiguration)(ptr) = FirehoseDeliveryStreamSpecKinesisSourceConfiguration{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecKinesisSourceConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecRedshiftConfigurationCodec struct {
}

func (FirehoseDeliveryStreamSpecRedshiftConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecRedshiftConfiguration)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecRedshiftConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecRedshiftConfiguration)(ptr)
	var objs []FirehoseDeliveryStreamSpecRedshiftConfiguration
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecRedshiftConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecRedshiftConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecRedshiftConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecRedshiftConfiguration)(ptr) = FirehoseDeliveryStreamSpecRedshiftConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecRedshiftConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecRedshiftConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecRedshiftConfiguration)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecRedshiftConfiguration)(ptr) = FirehoseDeliveryStreamSpecRedshiftConfiguration{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecRedshiftConfiguration)(ptr) = FirehoseDeliveryStreamSpecRedshiftConfiguration{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecRedshiftConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecRedshiftConfigurationCloudwatchLoggingOptionsCodec struct {
}

func (FirehoseDeliveryStreamSpecRedshiftConfigurationCloudwatchLoggingOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecRedshiftConfigurationCloudwatchLoggingOptions)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecRedshiftConfigurationCloudwatchLoggingOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecRedshiftConfigurationCloudwatchLoggingOptions)(ptr)
	var objs []FirehoseDeliveryStreamSpecRedshiftConfigurationCloudwatchLoggingOptions
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecRedshiftConfigurationCloudwatchLoggingOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecRedshiftConfigurationCloudwatchLoggingOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecRedshiftConfigurationCloudwatchLoggingOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecRedshiftConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecRedshiftConfigurationCloudwatchLoggingOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecRedshiftConfigurationCloudwatchLoggingOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecRedshiftConfigurationCloudwatchLoggingOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecRedshiftConfigurationCloudwatchLoggingOptions)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecRedshiftConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecRedshiftConfigurationCloudwatchLoggingOptions{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecRedshiftConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecRedshiftConfigurationCloudwatchLoggingOptions{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecRedshiftConfigurationCloudwatchLoggingOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecRedshiftConfigurationProcessingConfigurationCodec struct {
}

func (FirehoseDeliveryStreamSpecRedshiftConfigurationProcessingConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecRedshiftConfigurationProcessingConfiguration)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecRedshiftConfigurationProcessingConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecRedshiftConfigurationProcessingConfiguration)(ptr)
	var objs []FirehoseDeliveryStreamSpecRedshiftConfigurationProcessingConfiguration
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecRedshiftConfigurationProcessingConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecRedshiftConfigurationProcessingConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecRedshiftConfigurationProcessingConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecRedshiftConfigurationProcessingConfiguration)(ptr) = FirehoseDeliveryStreamSpecRedshiftConfigurationProcessingConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecRedshiftConfigurationProcessingConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecRedshiftConfigurationProcessingConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecRedshiftConfigurationProcessingConfiguration)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecRedshiftConfigurationProcessingConfiguration)(ptr) = FirehoseDeliveryStreamSpecRedshiftConfigurationProcessingConfiguration{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecRedshiftConfigurationProcessingConfiguration)(ptr) = FirehoseDeliveryStreamSpecRedshiftConfigurationProcessingConfiguration{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecRedshiftConfigurationProcessingConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCodec struct {
}

func (FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfiguration)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfiguration)(ptr)
	var objs []FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfiguration
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfiguration)(ptr) = FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfiguration)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfiguration)(ptr) = FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfiguration{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfiguration)(ptr) = FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfiguration{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptionsCodec struct {
}

func (FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions)(ptr)
	var objs []FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecRedshiftConfigurationS3BackupConfigurationCloudwatchLoggingOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecS3ConfigurationCodec struct {
}

func (FirehoseDeliveryStreamSpecS3ConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecS3Configuration)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecS3ConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecS3Configuration)(ptr)
	var objs []FirehoseDeliveryStreamSpecS3Configuration
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecS3Configuration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecS3Configuration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecS3ConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecS3Configuration)(ptr) = FirehoseDeliveryStreamSpecS3Configuration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecS3Configuration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecS3Configuration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecS3Configuration)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecS3Configuration)(ptr) = FirehoseDeliveryStreamSpecS3Configuration{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecS3Configuration)(ptr) = FirehoseDeliveryStreamSpecS3Configuration{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecS3Configuration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecS3ConfigurationCloudwatchLoggingOptionsCodec struct {
}

func (FirehoseDeliveryStreamSpecS3ConfigurationCloudwatchLoggingOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecS3ConfigurationCloudwatchLoggingOptions)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecS3ConfigurationCloudwatchLoggingOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecS3ConfigurationCloudwatchLoggingOptions)(ptr)
	var objs []FirehoseDeliveryStreamSpecS3ConfigurationCloudwatchLoggingOptions
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecS3ConfigurationCloudwatchLoggingOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecS3ConfigurationCloudwatchLoggingOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecS3ConfigurationCloudwatchLoggingOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecS3ConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecS3ConfigurationCloudwatchLoggingOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecS3ConfigurationCloudwatchLoggingOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecS3ConfigurationCloudwatchLoggingOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecS3ConfigurationCloudwatchLoggingOptions)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecS3ConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecS3ConfigurationCloudwatchLoggingOptions{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecS3ConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecS3ConfigurationCloudwatchLoggingOptions{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecS3ConfigurationCloudwatchLoggingOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecServerSideEncryptionCodec struct {
}

func (FirehoseDeliveryStreamSpecServerSideEncryptionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecServerSideEncryption)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecServerSideEncryptionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecServerSideEncryption)(ptr)
	var objs []FirehoseDeliveryStreamSpecServerSideEncryption
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecServerSideEncryption{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecServerSideEncryption{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecServerSideEncryptionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecServerSideEncryption)(ptr) = FirehoseDeliveryStreamSpecServerSideEncryption{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecServerSideEncryption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecServerSideEncryption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecServerSideEncryption)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecServerSideEncryption)(ptr) = FirehoseDeliveryStreamSpecServerSideEncryption{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecServerSideEncryption)(ptr) = FirehoseDeliveryStreamSpecServerSideEncryption{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecServerSideEncryption", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecSplunkConfigurationCodec struct {
}

func (FirehoseDeliveryStreamSpecSplunkConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecSplunkConfiguration)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecSplunkConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecSplunkConfiguration)(ptr)
	var objs []FirehoseDeliveryStreamSpecSplunkConfiguration
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecSplunkConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecSplunkConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecSplunkConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecSplunkConfiguration)(ptr) = FirehoseDeliveryStreamSpecSplunkConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecSplunkConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecSplunkConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecSplunkConfiguration)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecSplunkConfiguration)(ptr) = FirehoseDeliveryStreamSpecSplunkConfiguration{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecSplunkConfiguration)(ptr) = FirehoseDeliveryStreamSpecSplunkConfiguration{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecSplunkConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecSplunkConfigurationCloudwatchLoggingOptionsCodec struct {
}

func (FirehoseDeliveryStreamSpecSplunkConfigurationCloudwatchLoggingOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecSplunkConfigurationCloudwatchLoggingOptions)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecSplunkConfigurationCloudwatchLoggingOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecSplunkConfigurationCloudwatchLoggingOptions)(ptr)
	var objs []FirehoseDeliveryStreamSpecSplunkConfigurationCloudwatchLoggingOptions
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecSplunkConfigurationCloudwatchLoggingOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecSplunkConfigurationCloudwatchLoggingOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecSplunkConfigurationCloudwatchLoggingOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecSplunkConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecSplunkConfigurationCloudwatchLoggingOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecSplunkConfigurationCloudwatchLoggingOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecSplunkConfigurationCloudwatchLoggingOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecSplunkConfigurationCloudwatchLoggingOptions)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecSplunkConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecSplunkConfigurationCloudwatchLoggingOptions{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecSplunkConfigurationCloudwatchLoggingOptions)(ptr) = FirehoseDeliveryStreamSpecSplunkConfigurationCloudwatchLoggingOptions{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecSplunkConfigurationCloudwatchLoggingOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FirehoseDeliveryStreamSpecSplunkConfigurationProcessingConfigurationCodec struct {
}

func (FirehoseDeliveryStreamSpecSplunkConfigurationProcessingConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FirehoseDeliveryStreamSpecSplunkConfigurationProcessingConfiguration)(ptr) == nil
}

func (FirehoseDeliveryStreamSpecSplunkConfigurationProcessingConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FirehoseDeliveryStreamSpecSplunkConfigurationProcessingConfiguration)(ptr)
	var objs []FirehoseDeliveryStreamSpecSplunkConfigurationProcessingConfiguration
	if obj != nil {
		objs = []FirehoseDeliveryStreamSpecSplunkConfigurationProcessingConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecSplunkConfigurationProcessingConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FirehoseDeliveryStreamSpecSplunkConfigurationProcessingConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FirehoseDeliveryStreamSpecSplunkConfigurationProcessingConfiguration)(ptr) = FirehoseDeliveryStreamSpecSplunkConfigurationProcessingConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FirehoseDeliveryStreamSpecSplunkConfigurationProcessingConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FirehoseDeliveryStreamSpecSplunkConfigurationProcessingConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FirehoseDeliveryStreamSpecSplunkConfigurationProcessingConfiguration)(ptr) = objs[0]
			} else {
				*(*FirehoseDeliveryStreamSpecSplunkConfigurationProcessingConfiguration)(ptr) = FirehoseDeliveryStreamSpecSplunkConfigurationProcessingConfiguration{}
			}
		} else {
			*(*FirehoseDeliveryStreamSpecSplunkConfigurationProcessingConfiguration)(ptr) = FirehoseDeliveryStreamSpecSplunkConfigurationProcessingConfiguration{}
		}
	default:
		iter.ReportError("decode FirehoseDeliveryStreamSpecSplunkConfigurationProcessingConfiguration", "unexpected JSON type")
	}
}
