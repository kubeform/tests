/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOrigin{}).Type1()):                               CachePolicySpecParametersInCacheKeyAndForwardedToOriginCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig{}).Type1()):                  CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies{}).Type1()):           CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig{}).Type1()):                  CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders{}).Type1()):           CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig{}).Type1()):             CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings{}).Type1()): CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehavior{}).Type1()):                                                  DistributionSpecDefaultCacheBehaviorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehaviorForwardedValues{}).Type1()):                                   DistributionSpecDefaultCacheBehaviorForwardedValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehaviorForwardedValuesCookies{}).Type1()):                            DistributionSpecDefaultCacheBehaviorForwardedValuesCookiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecLoggingConfig{}).Type1()):                                                         DistributionSpecLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOrderedCacheBehaviorForwardedValues{}).Type1()):                                   DistributionSpecOrderedCacheBehaviorForwardedValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOrderedCacheBehaviorForwardedValuesCookies{}).Type1()):                            DistributionSpecOrderedCacheBehaviorForwardedValuesCookiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginCustomOriginConfig{}).Type1()):                                              DistributionSpecOriginCustomOriginConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginS3OriginConfig{}).Type1()):                                                  DistributionSpecOriginS3OriginConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginGroupFailoverCriteria{}).Type1()):                                           DistributionSpecOriginGroupFailoverCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecRestrictions{}).Type1()):                                                          DistributionSpecRestrictionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecRestrictionsGeoRestriction{}).Type1()):                                            DistributionSpecRestrictionsGeoRestrictionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecViewerCertificate{}).Type1()):                                                     DistributionSpecViewerCertificateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecCookiesConfig{}).Type1()):                                                  OriginRequestPolicySpecCookiesConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecCookiesConfigCookies{}).Type1()):                                           OriginRequestPolicySpecCookiesConfigCookiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecHeadersConfig{}).Type1()):                                                  OriginRequestPolicySpecHeadersConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecHeadersConfigHeaders{}).Type1()):                                           OriginRequestPolicySpecHeadersConfigHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecQueryStringsConfig{}).Type1()):                                             OriginRequestPolicySpecQueryStringsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecQueryStringsConfigQueryStrings{}).Type1()):                                 OriginRequestPolicySpecQueryStringsConfigQueryStringsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RealtimeLogConfigSpecEndpoint{}).Type1()):                                                         RealtimeLogConfigSpecEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RealtimeLogConfigSpecEndpointKinesisStreamConfig{}).Type1()):                                      RealtimeLogConfigSpecEndpointKinesisStreamConfigCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOrigin{}).Type1()):                               CachePolicySpecParametersInCacheKeyAndForwardedToOriginCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig{}).Type1()):                  CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies{}).Type1()):           CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig{}).Type1()):                  CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders{}).Type1()):           CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig{}).Type1()):             CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings{}).Type1()): CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehavior{}).Type1()):                                                  DistributionSpecDefaultCacheBehaviorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehaviorForwardedValues{}).Type1()):                                   DistributionSpecDefaultCacheBehaviorForwardedValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehaviorForwardedValuesCookies{}).Type1()):                            DistributionSpecDefaultCacheBehaviorForwardedValuesCookiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecLoggingConfig{}).Type1()):                                                         DistributionSpecLoggingConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOrderedCacheBehaviorForwardedValues{}).Type1()):                                   DistributionSpecOrderedCacheBehaviorForwardedValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOrderedCacheBehaviorForwardedValuesCookies{}).Type1()):                            DistributionSpecOrderedCacheBehaviorForwardedValuesCookiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginCustomOriginConfig{}).Type1()):                                              DistributionSpecOriginCustomOriginConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginS3OriginConfig{}).Type1()):                                                  DistributionSpecOriginS3OriginConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginGroupFailoverCriteria{}).Type1()):                                           DistributionSpecOriginGroupFailoverCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecRestrictions{}).Type1()):                                                          DistributionSpecRestrictionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecRestrictionsGeoRestriction{}).Type1()):                                            DistributionSpecRestrictionsGeoRestrictionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecViewerCertificate{}).Type1()):                                                     DistributionSpecViewerCertificateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecCookiesConfig{}).Type1()):                                                  OriginRequestPolicySpecCookiesConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecCookiesConfigCookies{}).Type1()):                                           OriginRequestPolicySpecCookiesConfigCookiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecHeadersConfig{}).Type1()):                                                  OriginRequestPolicySpecHeadersConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecHeadersConfigHeaders{}).Type1()):                                           OriginRequestPolicySpecHeadersConfigHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecQueryStringsConfig{}).Type1()):                                             OriginRequestPolicySpecQueryStringsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecQueryStringsConfigQueryStrings{}).Type1()):                                 OriginRequestPolicySpecQueryStringsConfigQueryStringsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RealtimeLogConfigSpecEndpoint{}).Type1()):                                                         RealtimeLogConfigSpecEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RealtimeLogConfigSpecEndpointKinesisStreamConfig{}).Type1()):                                      RealtimeLogConfigSpecEndpointKinesisStreamConfigCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type CachePolicySpecParametersInCacheKeyAndForwardedToOriginCodec struct {
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CachePolicySpecParametersInCacheKeyAndForwardedToOrigin)(ptr) == nil
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CachePolicySpecParametersInCacheKeyAndForwardedToOrigin)(ptr)
	var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOrigin
	if obj != nil {
		objs = []CachePolicySpecParametersInCacheKeyAndForwardedToOrigin{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOrigin{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CachePolicySpecParametersInCacheKeyAndForwardedToOrigin)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOrigin{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOrigin

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOrigin{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOrigin)(ptr) = objs[0]
			} else {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOrigin)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOrigin{}
			}
		} else {
			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOrigin)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOrigin{}
		}
	default:
		iter.ReportError("decode CachePolicySpecParametersInCacheKeyAndForwardedToOrigin", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCodec struct {
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig)(ptr) == nil
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig)(ptr)
	var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig
	if obj != nil {
		objs = []CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig)(ptr) = objs[0]
			} else {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig{}
			}
		} else {
			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig{}
		}
	default:
		iter.ReportError("decode CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookiesCodec struct {
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies)(ptr) == nil
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies)(ptr)
	var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies
	if obj != nil {
		objs = []CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies)(ptr) = objs[0]
			} else {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies{}
			}
		} else {
			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies{}
		}
	default:
		iter.ReportError("decode CachePolicySpecParametersInCacheKeyAndForwardedToOriginCookiesConfigCookies", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigCodec struct {
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig)(ptr) == nil
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig)(ptr)
	var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig
	if obj != nil {
		objs = []CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig)(ptr) = objs[0]
			} else {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig{}
			}
		} else {
			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig{}
		}
	default:
		iter.ReportError("decode CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeadersCodec struct {
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeadersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders)(ptr) == nil
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeadersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders)(ptr)
	var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders
	if obj != nil {
		objs = []CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeadersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders)(ptr) = objs[0]
			} else {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders{}
			}
		} else {
			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders{}
		}
	default:
		iter.ReportError("decode CachePolicySpecParametersInCacheKeyAndForwardedToOriginHeadersConfigHeaders", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigCodec struct {
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig)(ptr) == nil
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig)(ptr)
	var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig
	if obj != nil {
		objs = []CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig)(ptr) = objs[0]
			} else {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig{}
			}
		} else {
			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig{}
		}
	default:
		iter.ReportError("decode CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringsCodec struct {
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings)(ptr) == nil
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings)(ptr)
	var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings
	if obj != nil {
		objs = []CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStringsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings)(ptr) = objs[0]
			} else {
				*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings{}
			}
		} else {
			*(*CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings)(ptr) = CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings{}
		}
	default:
		iter.ReportError("decode CachePolicySpecParametersInCacheKeyAndForwardedToOriginQueryStringsConfigQueryStrings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecDefaultCacheBehaviorCodec struct {
}

func (DistributionSpecDefaultCacheBehaviorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecDefaultCacheBehavior)(ptr) == nil
}

func (DistributionSpecDefaultCacheBehaviorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecDefaultCacheBehavior)(ptr)
	var objs []DistributionSpecDefaultCacheBehavior
	if obj != nil {
		objs = []DistributionSpecDefaultCacheBehavior{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehavior{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecDefaultCacheBehaviorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecDefaultCacheBehavior)(ptr) = DistributionSpecDefaultCacheBehavior{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecDefaultCacheBehavior

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehavior{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecDefaultCacheBehavior)(ptr) = objs[0]
			} else {
				*(*DistributionSpecDefaultCacheBehavior)(ptr) = DistributionSpecDefaultCacheBehavior{}
			}
		} else {
			*(*DistributionSpecDefaultCacheBehavior)(ptr) = DistributionSpecDefaultCacheBehavior{}
		}
	default:
		iter.ReportError("decode DistributionSpecDefaultCacheBehavior", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecDefaultCacheBehaviorForwardedValuesCodec struct {
}

func (DistributionSpecDefaultCacheBehaviorForwardedValuesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecDefaultCacheBehaviorForwardedValues)(ptr) == nil
}

func (DistributionSpecDefaultCacheBehaviorForwardedValuesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecDefaultCacheBehaviorForwardedValues)(ptr)
	var objs []DistributionSpecDefaultCacheBehaviorForwardedValues
	if obj != nil {
		objs = []DistributionSpecDefaultCacheBehaviorForwardedValues{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehaviorForwardedValues{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecDefaultCacheBehaviorForwardedValuesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecDefaultCacheBehaviorForwardedValues)(ptr) = DistributionSpecDefaultCacheBehaviorForwardedValues{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecDefaultCacheBehaviorForwardedValues

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehaviorForwardedValues{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecDefaultCacheBehaviorForwardedValues)(ptr) = objs[0]
			} else {
				*(*DistributionSpecDefaultCacheBehaviorForwardedValues)(ptr) = DistributionSpecDefaultCacheBehaviorForwardedValues{}
			}
		} else {
			*(*DistributionSpecDefaultCacheBehaviorForwardedValues)(ptr) = DistributionSpecDefaultCacheBehaviorForwardedValues{}
		}
	default:
		iter.ReportError("decode DistributionSpecDefaultCacheBehaviorForwardedValues", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecDefaultCacheBehaviorForwardedValuesCookiesCodec struct {
}

func (DistributionSpecDefaultCacheBehaviorForwardedValuesCookiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecDefaultCacheBehaviorForwardedValuesCookies)(ptr) == nil
}

func (DistributionSpecDefaultCacheBehaviorForwardedValuesCookiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecDefaultCacheBehaviorForwardedValuesCookies)(ptr)
	var objs []DistributionSpecDefaultCacheBehaviorForwardedValuesCookies
	if obj != nil {
		objs = []DistributionSpecDefaultCacheBehaviorForwardedValuesCookies{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehaviorForwardedValuesCookies{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecDefaultCacheBehaviorForwardedValuesCookiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecDefaultCacheBehaviorForwardedValuesCookies)(ptr) = DistributionSpecDefaultCacheBehaviorForwardedValuesCookies{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecDefaultCacheBehaviorForwardedValuesCookies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecDefaultCacheBehaviorForwardedValuesCookies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecDefaultCacheBehaviorForwardedValuesCookies)(ptr) = objs[0]
			} else {
				*(*DistributionSpecDefaultCacheBehaviorForwardedValuesCookies)(ptr) = DistributionSpecDefaultCacheBehaviorForwardedValuesCookies{}
			}
		} else {
			*(*DistributionSpecDefaultCacheBehaviorForwardedValuesCookies)(ptr) = DistributionSpecDefaultCacheBehaviorForwardedValuesCookies{}
		}
	default:
		iter.ReportError("decode DistributionSpecDefaultCacheBehaviorForwardedValuesCookies", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecLoggingConfigCodec struct {
}

func (DistributionSpecLoggingConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecLoggingConfig)(ptr) == nil
}

func (DistributionSpecLoggingConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecLoggingConfig)(ptr)
	var objs []DistributionSpecLoggingConfig
	if obj != nil {
		objs = []DistributionSpecLoggingConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecLoggingConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecLoggingConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecLoggingConfig)(ptr) = DistributionSpecLoggingConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecLoggingConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecLoggingConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecLoggingConfig)(ptr) = objs[0]
			} else {
				*(*DistributionSpecLoggingConfig)(ptr) = DistributionSpecLoggingConfig{}
			}
		} else {
			*(*DistributionSpecLoggingConfig)(ptr) = DistributionSpecLoggingConfig{}
		}
	default:
		iter.ReportError("decode DistributionSpecLoggingConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecOrderedCacheBehaviorForwardedValuesCodec struct {
}

func (DistributionSpecOrderedCacheBehaviorForwardedValuesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecOrderedCacheBehaviorForwardedValues)(ptr) == nil
}

func (DistributionSpecOrderedCacheBehaviorForwardedValuesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecOrderedCacheBehaviorForwardedValues)(ptr)
	var objs []DistributionSpecOrderedCacheBehaviorForwardedValues
	if obj != nil {
		objs = []DistributionSpecOrderedCacheBehaviorForwardedValues{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOrderedCacheBehaviorForwardedValues{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecOrderedCacheBehaviorForwardedValuesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecOrderedCacheBehaviorForwardedValues)(ptr) = DistributionSpecOrderedCacheBehaviorForwardedValues{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecOrderedCacheBehaviorForwardedValues

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOrderedCacheBehaviorForwardedValues{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecOrderedCacheBehaviorForwardedValues)(ptr) = objs[0]
			} else {
				*(*DistributionSpecOrderedCacheBehaviorForwardedValues)(ptr) = DistributionSpecOrderedCacheBehaviorForwardedValues{}
			}
		} else {
			*(*DistributionSpecOrderedCacheBehaviorForwardedValues)(ptr) = DistributionSpecOrderedCacheBehaviorForwardedValues{}
		}
	default:
		iter.ReportError("decode DistributionSpecOrderedCacheBehaviorForwardedValues", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecOrderedCacheBehaviorForwardedValuesCookiesCodec struct {
}

func (DistributionSpecOrderedCacheBehaviorForwardedValuesCookiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecOrderedCacheBehaviorForwardedValuesCookies)(ptr) == nil
}

func (DistributionSpecOrderedCacheBehaviorForwardedValuesCookiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecOrderedCacheBehaviorForwardedValuesCookies)(ptr)
	var objs []DistributionSpecOrderedCacheBehaviorForwardedValuesCookies
	if obj != nil {
		objs = []DistributionSpecOrderedCacheBehaviorForwardedValuesCookies{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOrderedCacheBehaviorForwardedValuesCookies{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecOrderedCacheBehaviorForwardedValuesCookiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecOrderedCacheBehaviorForwardedValuesCookies)(ptr) = DistributionSpecOrderedCacheBehaviorForwardedValuesCookies{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecOrderedCacheBehaviorForwardedValuesCookies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOrderedCacheBehaviorForwardedValuesCookies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecOrderedCacheBehaviorForwardedValuesCookies)(ptr) = objs[0]
			} else {
				*(*DistributionSpecOrderedCacheBehaviorForwardedValuesCookies)(ptr) = DistributionSpecOrderedCacheBehaviorForwardedValuesCookies{}
			}
		} else {
			*(*DistributionSpecOrderedCacheBehaviorForwardedValuesCookies)(ptr) = DistributionSpecOrderedCacheBehaviorForwardedValuesCookies{}
		}
	default:
		iter.ReportError("decode DistributionSpecOrderedCacheBehaviorForwardedValuesCookies", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecOriginCustomOriginConfigCodec struct {
}

func (DistributionSpecOriginCustomOriginConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecOriginCustomOriginConfig)(ptr) == nil
}

func (DistributionSpecOriginCustomOriginConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecOriginCustomOriginConfig)(ptr)
	var objs []DistributionSpecOriginCustomOriginConfig
	if obj != nil {
		objs = []DistributionSpecOriginCustomOriginConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginCustomOriginConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecOriginCustomOriginConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecOriginCustomOriginConfig)(ptr) = DistributionSpecOriginCustomOriginConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecOriginCustomOriginConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginCustomOriginConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecOriginCustomOriginConfig)(ptr) = objs[0]
			} else {
				*(*DistributionSpecOriginCustomOriginConfig)(ptr) = DistributionSpecOriginCustomOriginConfig{}
			}
		} else {
			*(*DistributionSpecOriginCustomOriginConfig)(ptr) = DistributionSpecOriginCustomOriginConfig{}
		}
	default:
		iter.ReportError("decode DistributionSpecOriginCustomOriginConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecOriginS3OriginConfigCodec struct {
}

func (DistributionSpecOriginS3OriginConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecOriginS3OriginConfig)(ptr) == nil
}

func (DistributionSpecOriginS3OriginConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecOriginS3OriginConfig)(ptr)
	var objs []DistributionSpecOriginS3OriginConfig
	if obj != nil {
		objs = []DistributionSpecOriginS3OriginConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginS3OriginConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecOriginS3OriginConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecOriginS3OriginConfig)(ptr) = DistributionSpecOriginS3OriginConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecOriginS3OriginConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginS3OriginConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecOriginS3OriginConfig)(ptr) = objs[0]
			} else {
				*(*DistributionSpecOriginS3OriginConfig)(ptr) = DistributionSpecOriginS3OriginConfig{}
			}
		} else {
			*(*DistributionSpecOriginS3OriginConfig)(ptr) = DistributionSpecOriginS3OriginConfig{}
		}
	default:
		iter.ReportError("decode DistributionSpecOriginS3OriginConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecOriginGroupFailoverCriteriaCodec struct {
}

func (DistributionSpecOriginGroupFailoverCriteriaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecOriginGroupFailoverCriteria)(ptr) == nil
}

func (DistributionSpecOriginGroupFailoverCriteriaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecOriginGroupFailoverCriteria)(ptr)
	var objs []DistributionSpecOriginGroupFailoverCriteria
	if obj != nil {
		objs = []DistributionSpecOriginGroupFailoverCriteria{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginGroupFailoverCriteria{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecOriginGroupFailoverCriteriaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecOriginGroupFailoverCriteria)(ptr) = DistributionSpecOriginGroupFailoverCriteria{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecOriginGroupFailoverCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecOriginGroupFailoverCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecOriginGroupFailoverCriteria)(ptr) = objs[0]
			} else {
				*(*DistributionSpecOriginGroupFailoverCriteria)(ptr) = DistributionSpecOriginGroupFailoverCriteria{}
			}
		} else {
			*(*DistributionSpecOriginGroupFailoverCriteria)(ptr) = DistributionSpecOriginGroupFailoverCriteria{}
		}
	default:
		iter.ReportError("decode DistributionSpecOriginGroupFailoverCriteria", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecRestrictionsCodec struct {
}

func (DistributionSpecRestrictionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecRestrictions)(ptr) == nil
}

func (DistributionSpecRestrictionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecRestrictions)(ptr)
	var objs []DistributionSpecRestrictions
	if obj != nil {
		objs = []DistributionSpecRestrictions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecRestrictions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecRestrictionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecRestrictions)(ptr) = DistributionSpecRestrictions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecRestrictions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecRestrictions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecRestrictions)(ptr) = objs[0]
			} else {
				*(*DistributionSpecRestrictions)(ptr) = DistributionSpecRestrictions{}
			}
		} else {
			*(*DistributionSpecRestrictions)(ptr) = DistributionSpecRestrictions{}
		}
	default:
		iter.ReportError("decode DistributionSpecRestrictions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecRestrictionsGeoRestrictionCodec struct {
}

func (DistributionSpecRestrictionsGeoRestrictionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecRestrictionsGeoRestriction)(ptr) == nil
}

func (DistributionSpecRestrictionsGeoRestrictionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecRestrictionsGeoRestriction)(ptr)
	var objs []DistributionSpecRestrictionsGeoRestriction
	if obj != nil {
		objs = []DistributionSpecRestrictionsGeoRestriction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecRestrictionsGeoRestriction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecRestrictionsGeoRestrictionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecRestrictionsGeoRestriction)(ptr) = DistributionSpecRestrictionsGeoRestriction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecRestrictionsGeoRestriction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecRestrictionsGeoRestriction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecRestrictionsGeoRestriction)(ptr) = objs[0]
			} else {
				*(*DistributionSpecRestrictionsGeoRestriction)(ptr) = DistributionSpecRestrictionsGeoRestriction{}
			}
		} else {
			*(*DistributionSpecRestrictionsGeoRestriction)(ptr) = DistributionSpecRestrictionsGeoRestriction{}
		}
	default:
		iter.ReportError("decode DistributionSpecRestrictionsGeoRestriction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DistributionSpecViewerCertificateCodec struct {
}

func (DistributionSpecViewerCertificateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DistributionSpecViewerCertificate)(ptr) == nil
}

func (DistributionSpecViewerCertificateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DistributionSpecViewerCertificate)(ptr)
	var objs []DistributionSpecViewerCertificate
	if obj != nil {
		objs = []DistributionSpecViewerCertificate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecViewerCertificate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DistributionSpecViewerCertificateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DistributionSpecViewerCertificate)(ptr) = DistributionSpecViewerCertificate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DistributionSpecViewerCertificate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DistributionSpecViewerCertificate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DistributionSpecViewerCertificate)(ptr) = objs[0]
			} else {
				*(*DistributionSpecViewerCertificate)(ptr) = DistributionSpecViewerCertificate{}
			}
		} else {
			*(*DistributionSpecViewerCertificate)(ptr) = DistributionSpecViewerCertificate{}
		}
	default:
		iter.ReportError("decode DistributionSpecViewerCertificate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type OriginRequestPolicySpecCookiesConfigCodec struct {
}

func (OriginRequestPolicySpecCookiesConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*OriginRequestPolicySpecCookiesConfig)(ptr) == nil
}

func (OriginRequestPolicySpecCookiesConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*OriginRequestPolicySpecCookiesConfig)(ptr)
	var objs []OriginRequestPolicySpecCookiesConfig
	if obj != nil {
		objs = []OriginRequestPolicySpecCookiesConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecCookiesConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (OriginRequestPolicySpecCookiesConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*OriginRequestPolicySpecCookiesConfig)(ptr) = OriginRequestPolicySpecCookiesConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []OriginRequestPolicySpecCookiesConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecCookiesConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*OriginRequestPolicySpecCookiesConfig)(ptr) = objs[0]
			} else {
				*(*OriginRequestPolicySpecCookiesConfig)(ptr) = OriginRequestPolicySpecCookiesConfig{}
			}
		} else {
			*(*OriginRequestPolicySpecCookiesConfig)(ptr) = OriginRequestPolicySpecCookiesConfig{}
		}
	default:
		iter.ReportError("decode OriginRequestPolicySpecCookiesConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type OriginRequestPolicySpecCookiesConfigCookiesCodec struct {
}

func (OriginRequestPolicySpecCookiesConfigCookiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*OriginRequestPolicySpecCookiesConfigCookies)(ptr) == nil
}

func (OriginRequestPolicySpecCookiesConfigCookiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*OriginRequestPolicySpecCookiesConfigCookies)(ptr)
	var objs []OriginRequestPolicySpecCookiesConfigCookies
	if obj != nil {
		objs = []OriginRequestPolicySpecCookiesConfigCookies{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecCookiesConfigCookies{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (OriginRequestPolicySpecCookiesConfigCookiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*OriginRequestPolicySpecCookiesConfigCookies)(ptr) = OriginRequestPolicySpecCookiesConfigCookies{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []OriginRequestPolicySpecCookiesConfigCookies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecCookiesConfigCookies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*OriginRequestPolicySpecCookiesConfigCookies)(ptr) = objs[0]
			} else {
				*(*OriginRequestPolicySpecCookiesConfigCookies)(ptr) = OriginRequestPolicySpecCookiesConfigCookies{}
			}
		} else {
			*(*OriginRequestPolicySpecCookiesConfigCookies)(ptr) = OriginRequestPolicySpecCookiesConfigCookies{}
		}
	default:
		iter.ReportError("decode OriginRequestPolicySpecCookiesConfigCookies", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type OriginRequestPolicySpecHeadersConfigCodec struct {
}

func (OriginRequestPolicySpecHeadersConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*OriginRequestPolicySpecHeadersConfig)(ptr) == nil
}

func (OriginRequestPolicySpecHeadersConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*OriginRequestPolicySpecHeadersConfig)(ptr)
	var objs []OriginRequestPolicySpecHeadersConfig
	if obj != nil {
		objs = []OriginRequestPolicySpecHeadersConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecHeadersConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (OriginRequestPolicySpecHeadersConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*OriginRequestPolicySpecHeadersConfig)(ptr) = OriginRequestPolicySpecHeadersConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []OriginRequestPolicySpecHeadersConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecHeadersConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*OriginRequestPolicySpecHeadersConfig)(ptr) = objs[0]
			} else {
				*(*OriginRequestPolicySpecHeadersConfig)(ptr) = OriginRequestPolicySpecHeadersConfig{}
			}
		} else {
			*(*OriginRequestPolicySpecHeadersConfig)(ptr) = OriginRequestPolicySpecHeadersConfig{}
		}
	default:
		iter.ReportError("decode OriginRequestPolicySpecHeadersConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type OriginRequestPolicySpecHeadersConfigHeadersCodec struct {
}

func (OriginRequestPolicySpecHeadersConfigHeadersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*OriginRequestPolicySpecHeadersConfigHeaders)(ptr) == nil
}

func (OriginRequestPolicySpecHeadersConfigHeadersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*OriginRequestPolicySpecHeadersConfigHeaders)(ptr)
	var objs []OriginRequestPolicySpecHeadersConfigHeaders
	if obj != nil {
		objs = []OriginRequestPolicySpecHeadersConfigHeaders{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecHeadersConfigHeaders{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (OriginRequestPolicySpecHeadersConfigHeadersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*OriginRequestPolicySpecHeadersConfigHeaders)(ptr) = OriginRequestPolicySpecHeadersConfigHeaders{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []OriginRequestPolicySpecHeadersConfigHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecHeadersConfigHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*OriginRequestPolicySpecHeadersConfigHeaders)(ptr) = objs[0]
			} else {
				*(*OriginRequestPolicySpecHeadersConfigHeaders)(ptr) = OriginRequestPolicySpecHeadersConfigHeaders{}
			}
		} else {
			*(*OriginRequestPolicySpecHeadersConfigHeaders)(ptr) = OriginRequestPolicySpecHeadersConfigHeaders{}
		}
	default:
		iter.ReportError("decode OriginRequestPolicySpecHeadersConfigHeaders", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type OriginRequestPolicySpecQueryStringsConfigCodec struct {
}

func (OriginRequestPolicySpecQueryStringsConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*OriginRequestPolicySpecQueryStringsConfig)(ptr) == nil
}

func (OriginRequestPolicySpecQueryStringsConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*OriginRequestPolicySpecQueryStringsConfig)(ptr)
	var objs []OriginRequestPolicySpecQueryStringsConfig
	if obj != nil {
		objs = []OriginRequestPolicySpecQueryStringsConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecQueryStringsConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (OriginRequestPolicySpecQueryStringsConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*OriginRequestPolicySpecQueryStringsConfig)(ptr) = OriginRequestPolicySpecQueryStringsConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []OriginRequestPolicySpecQueryStringsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecQueryStringsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*OriginRequestPolicySpecQueryStringsConfig)(ptr) = objs[0]
			} else {
				*(*OriginRequestPolicySpecQueryStringsConfig)(ptr) = OriginRequestPolicySpecQueryStringsConfig{}
			}
		} else {
			*(*OriginRequestPolicySpecQueryStringsConfig)(ptr) = OriginRequestPolicySpecQueryStringsConfig{}
		}
	default:
		iter.ReportError("decode OriginRequestPolicySpecQueryStringsConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type OriginRequestPolicySpecQueryStringsConfigQueryStringsCodec struct {
}

func (OriginRequestPolicySpecQueryStringsConfigQueryStringsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*OriginRequestPolicySpecQueryStringsConfigQueryStrings)(ptr) == nil
}

func (OriginRequestPolicySpecQueryStringsConfigQueryStringsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*OriginRequestPolicySpecQueryStringsConfigQueryStrings)(ptr)
	var objs []OriginRequestPolicySpecQueryStringsConfigQueryStrings
	if obj != nil {
		objs = []OriginRequestPolicySpecQueryStringsConfigQueryStrings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecQueryStringsConfigQueryStrings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (OriginRequestPolicySpecQueryStringsConfigQueryStringsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*OriginRequestPolicySpecQueryStringsConfigQueryStrings)(ptr) = OriginRequestPolicySpecQueryStringsConfigQueryStrings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []OriginRequestPolicySpecQueryStringsConfigQueryStrings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(OriginRequestPolicySpecQueryStringsConfigQueryStrings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*OriginRequestPolicySpecQueryStringsConfigQueryStrings)(ptr) = objs[0]
			} else {
				*(*OriginRequestPolicySpecQueryStringsConfigQueryStrings)(ptr) = OriginRequestPolicySpecQueryStringsConfigQueryStrings{}
			}
		} else {
			*(*OriginRequestPolicySpecQueryStringsConfigQueryStrings)(ptr) = OriginRequestPolicySpecQueryStringsConfigQueryStrings{}
		}
	default:
		iter.ReportError("decode OriginRequestPolicySpecQueryStringsConfigQueryStrings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RealtimeLogConfigSpecEndpointCodec struct {
}

func (RealtimeLogConfigSpecEndpointCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RealtimeLogConfigSpecEndpoint)(ptr) == nil
}

func (RealtimeLogConfigSpecEndpointCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RealtimeLogConfigSpecEndpoint)(ptr)
	var objs []RealtimeLogConfigSpecEndpoint
	if obj != nil {
		objs = []RealtimeLogConfigSpecEndpoint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RealtimeLogConfigSpecEndpoint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RealtimeLogConfigSpecEndpointCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RealtimeLogConfigSpecEndpoint)(ptr) = RealtimeLogConfigSpecEndpoint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RealtimeLogConfigSpecEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RealtimeLogConfigSpecEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RealtimeLogConfigSpecEndpoint)(ptr) = objs[0]
			} else {
				*(*RealtimeLogConfigSpecEndpoint)(ptr) = RealtimeLogConfigSpecEndpoint{}
			}
		} else {
			*(*RealtimeLogConfigSpecEndpoint)(ptr) = RealtimeLogConfigSpecEndpoint{}
		}
	default:
		iter.ReportError("decode RealtimeLogConfigSpecEndpoint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RealtimeLogConfigSpecEndpointKinesisStreamConfigCodec struct {
}

func (RealtimeLogConfigSpecEndpointKinesisStreamConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RealtimeLogConfigSpecEndpointKinesisStreamConfig)(ptr) == nil
}

func (RealtimeLogConfigSpecEndpointKinesisStreamConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RealtimeLogConfigSpecEndpointKinesisStreamConfig)(ptr)
	var objs []RealtimeLogConfigSpecEndpointKinesisStreamConfig
	if obj != nil {
		objs = []RealtimeLogConfigSpecEndpointKinesisStreamConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RealtimeLogConfigSpecEndpointKinesisStreamConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RealtimeLogConfigSpecEndpointKinesisStreamConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RealtimeLogConfigSpecEndpointKinesisStreamConfig)(ptr) = RealtimeLogConfigSpecEndpointKinesisStreamConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RealtimeLogConfigSpecEndpointKinesisStreamConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RealtimeLogConfigSpecEndpointKinesisStreamConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RealtimeLogConfigSpecEndpointKinesisStreamConfig)(ptr) = objs[0]
			} else {
				*(*RealtimeLogConfigSpecEndpointKinesisStreamConfig)(ptr) = RealtimeLogConfigSpecEndpointKinesisStreamConfig{}
			}
		} else {
			*(*RealtimeLogConfigSpecEndpointKinesisStreamConfig)(ptr) = RealtimeLogConfigSpecEndpointKinesisStreamConfig{}
		}
	default:
		iter.ReportError("decode RealtimeLogConfigSpecEndpointKinesisStreamConfig", "unexpected JSON type")
	}
}
