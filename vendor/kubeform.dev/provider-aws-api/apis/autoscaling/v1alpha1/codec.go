/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecInstanceRefresh{}).Type1()):                                                       GroupSpecInstanceRefreshCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecInstanceRefreshPreferences{}).Type1()):                                            GroupSpecInstanceRefreshPreferencesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecLaunchTemplate{}).Type1()):                                                        GroupSpecLaunchTemplateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecMixedInstancesPolicy{}).Type1()):                                                  GroupSpecMixedInstancesPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecMixedInstancesPolicyInstancesDistribution{}).Type1()):                             GroupSpecMixedInstancesPolicyInstancesDistributionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecMixedInstancesPolicyLaunchTemplate{}).Type1()):                                    GroupSpecMixedInstancesPolicyLaunchTemplateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification{}).Type1()):         GroupSpecMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification{}).Type1()): GroupSpecMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecWarmPool{}).Type1()):                                                              GroupSpecWarmPoolCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicySpecTargetTrackingConfiguration{}).Type1()):                                          PolicySpecTargetTrackingConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicySpecTargetTrackingConfigurationCustomizedMetricSpecification{}).Type1()):             PolicySpecTargetTrackingConfigurationCustomizedMetricSpecificationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicySpecTargetTrackingConfigurationPredefinedMetricSpecification{}).Type1()):             PolicySpecTargetTrackingConfigurationPredefinedMetricSpecificationCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecInstanceRefresh{}).Type1()):                                                       GroupSpecInstanceRefreshCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecInstanceRefreshPreferences{}).Type1()):                                            GroupSpecInstanceRefreshPreferencesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecLaunchTemplate{}).Type1()):                                                        GroupSpecLaunchTemplateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecMixedInstancesPolicy{}).Type1()):                                                  GroupSpecMixedInstancesPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecMixedInstancesPolicyInstancesDistribution{}).Type1()):                             GroupSpecMixedInstancesPolicyInstancesDistributionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecMixedInstancesPolicyLaunchTemplate{}).Type1()):                                    GroupSpecMixedInstancesPolicyLaunchTemplateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification{}).Type1()):         GroupSpecMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification{}).Type1()): GroupSpecMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecWarmPool{}).Type1()):                                                              GroupSpecWarmPoolCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicySpecTargetTrackingConfiguration{}).Type1()):                                          PolicySpecTargetTrackingConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicySpecTargetTrackingConfigurationCustomizedMetricSpecification{}).Type1()):             PolicySpecTargetTrackingConfigurationCustomizedMetricSpecificationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicySpecTargetTrackingConfigurationPredefinedMetricSpecification{}).Type1()):             PolicySpecTargetTrackingConfigurationPredefinedMetricSpecificationCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type GroupSpecInstanceRefreshCodec struct {
}

func (GroupSpecInstanceRefreshCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecInstanceRefresh)(ptr) == nil
}

func (GroupSpecInstanceRefreshCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecInstanceRefresh)(ptr)
	var objs []GroupSpecInstanceRefresh
	if obj != nil {
		objs = []GroupSpecInstanceRefresh{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecInstanceRefresh{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecInstanceRefreshCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecInstanceRefresh)(ptr) = GroupSpecInstanceRefresh{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecInstanceRefresh

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecInstanceRefresh{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecInstanceRefresh)(ptr) = objs[0]
			} else {
				*(*GroupSpecInstanceRefresh)(ptr) = GroupSpecInstanceRefresh{}
			}
		} else {
			*(*GroupSpecInstanceRefresh)(ptr) = GroupSpecInstanceRefresh{}
		}
	default:
		iter.ReportError("decode GroupSpecInstanceRefresh", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupSpecInstanceRefreshPreferencesCodec struct {
}

func (GroupSpecInstanceRefreshPreferencesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecInstanceRefreshPreferences)(ptr) == nil
}

func (GroupSpecInstanceRefreshPreferencesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecInstanceRefreshPreferences)(ptr)
	var objs []GroupSpecInstanceRefreshPreferences
	if obj != nil {
		objs = []GroupSpecInstanceRefreshPreferences{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecInstanceRefreshPreferences{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecInstanceRefreshPreferencesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecInstanceRefreshPreferences)(ptr) = GroupSpecInstanceRefreshPreferences{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecInstanceRefreshPreferences

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecInstanceRefreshPreferences{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecInstanceRefreshPreferences)(ptr) = objs[0]
			} else {
				*(*GroupSpecInstanceRefreshPreferences)(ptr) = GroupSpecInstanceRefreshPreferences{}
			}
		} else {
			*(*GroupSpecInstanceRefreshPreferences)(ptr) = GroupSpecInstanceRefreshPreferences{}
		}
	default:
		iter.ReportError("decode GroupSpecInstanceRefreshPreferences", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupSpecLaunchTemplateCodec struct {
}

func (GroupSpecLaunchTemplateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecLaunchTemplate)(ptr) == nil
}

func (GroupSpecLaunchTemplateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecLaunchTemplate)(ptr)
	var objs []GroupSpecLaunchTemplate
	if obj != nil {
		objs = []GroupSpecLaunchTemplate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecLaunchTemplate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecLaunchTemplateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecLaunchTemplate)(ptr) = GroupSpecLaunchTemplate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecLaunchTemplate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecLaunchTemplate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecLaunchTemplate)(ptr) = objs[0]
			} else {
				*(*GroupSpecLaunchTemplate)(ptr) = GroupSpecLaunchTemplate{}
			}
		} else {
			*(*GroupSpecLaunchTemplate)(ptr) = GroupSpecLaunchTemplate{}
		}
	default:
		iter.ReportError("decode GroupSpecLaunchTemplate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupSpecMixedInstancesPolicyCodec struct {
}

func (GroupSpecMixedInstancesPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecMixedInstancesPolicy)(ptr) == nil
}

func (GroupSpecMixedInstancesPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecMixedInstancesPolicy)(ptr)
	var objs []GroupSpecMixedInstancesPolicy
	if obj != nil {
		objs = []GroupSpecMixedInstancesPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecMixedInstancesPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecMixedInstancesPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecMixedInstancesPolicy)(ptr) = GroupSpecMixedInstancesPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecMixedInstancesPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecMixedInstancesPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecMixedInstancesPolicy)(ptr) = objs[0]
			} else {
				*(*GroupSpecMixedInstancesPolicy)(ptr) = GroupSpecMixedInstancesPolicy{}
			}
		} else {
			*(*GroupSpecMixedInstancesPolicy)(ptr) = GroupSpecMixedInstancesPolicy{}
		}
	default:
		iter.ReportError("decode GroupSpecMixedInstancesPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupSpecMixedInstancesPolicyInstancesDistributionCodec struct {
}

func (GroupSpecMixedInstancesPolicyInstancesDistributionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecMixedInstancesPolicyInstancesDistribution)(ptr) == nil
}

func (GroupSpecMixedInstancesPolicyInstancesDistributionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecMixedInstancesPolicyInstancesDistribution)(ptr)
	var objs []GroupSpecMixedInstancesPolicyInstancesDistribution
	if obj != nil {
		objs = []GroupSpecMixedInstancesPolicyInstancesDistribution{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecMixedInstancesPolicyInstancesDistribution{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecMixedInstancesPolicyInstancesDistributionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecMixedInstancesPolicyInstancesDistribution)(ptr) = GroupSpecMixedInstancesPolicyInstancesDistribution{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecMixedInstancesPolicyInstancesDistribution

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecMixedInstancesPolicyInstancesDistribution{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecMixedInstancesPolicyInstancesDistribution)(ptr) = objs[0]
			} else {
				*(*GroupSpecMixedInstancesPolicyInstancesDistribution)(ptr) = GroupSpecMixedInstancesPolicyInstancesDistribution{}
			}
		} else {
			*(*GroupSpecMixedInstancesPolicyInstancesDistribution)(ptr) = GroupSpecMixedInstancesPolicyInstancesDistribution{}
		}
	default:
		iter.ReportError("decode GroupSpecMixedInstancesPolicyInstancesDistribution", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupSpecMixedInstancesPolicyLaunchTemplateCodec struct {
}

func (GroupSpecMixedInstancesPolicyLaunchTemplateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecMixedInstancesPolicyLaunchTemplate)(ptr) == nil
}

func (GroupSpecMixedInstancesPolicyLaunchTemplateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecMixedInstancesPolicyLaunchTemplate)(ptr)
	var objs []GroupSpecMixedInstancesPolicyLaunchTemplate
	if obj != nil {
		objs = []GroupSpecMixedInstancesPolicyLaunchTemplate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecMixedInstancesPolicyLaunchTemplate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecMixedInstancesPolicyLaunchTemplateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecMixedInstancesPolicyLaunchTemplate)(ptr) = GroupSpecMixedInstancesPolicyLaunchTemplate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecMixedInstancesPolicyLaunchTemplate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecMixedInstancesPolicyLaunchTemplate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecMixedInstancesPolicyLaunchTemplate)(ptr) = objs[0]
			} else {
				*(*GroupSpecMixedInstancesPolicyLaunchTemplate)(ptr) = GroupSpecMixedInstancesPolicyLaunchTemplate{}
			}
		} else {
			*(*GroupSpecMixedInstancesPolicyLaunchTemplate)(ptr) = GroupSpecMixedInstancesPolicyLaunchTemplate{}
		}
	default:
		iter.ReportError("decode GroupSpecMixedInstancesPolicyLaunchTemplate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupSpecMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationCodec struct {
}

func (GroupSpecMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification)(ptr) == nil
}

func (GroupSpecMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification)(ptr)
	var objs []GroupSpecMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification
	if obj != nil {
		objs = []GroupSpecMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecificationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification)(ptr) = GroupSpecMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification)(ptr) = objs[0]
			} else {
				*(*GroupSpecMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification)(ptr) = GroupSpecMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification{}
			}
		} else {
			*(*GroupSpecMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification)(ptr) = GroupSpecMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification{}
		}
	default:
		iter.ReportError("decode GroupSpecMixedInstancesPolicyLaunchTemplateLaunchTemplateSpecification", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupSpecMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationCodec struct {
}

func (GroupSpecMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification)(ptr) == nil
}

func (GroupSpecMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification)(ptr)
	var objs []GroupSpecMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification
	if obj != nil {
		objs = []GroupSpecMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecificationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification)(ptr) = GroupSpecMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification)(ptr) = objs[0]
			} else {
				*(*GroupSpecMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification)(ptr) = GroupSpecMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification{}
			}
		} else {
			*(*GroupSpecMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification)(ptr) = GroupSpecMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification{}
		}
	default:
		iter.ReportError("decode GroupSpecMixedInstancesPolicyLaunchTemplateOverrideLaunchTemplateSpecification", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupSpecWarmPoolCodec struct {
}

func (GroupSpecWarmPoolCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecWarmPool)(ptr) == nil
}

func (GroupSpecWarmPoolCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecWarmPool)(ptr)
	var objs []GroupSpecWarmPool
	if obj != nil {
		objs = []GroupSpecWarmPool{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecWarmPool{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecWarmPoolCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecWarmPool)(ptr) = GroupSpecWarmPool{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecWarmPool

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecWarmPool{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecWarmPool)(ptr) = objs[0]
			} else {
				*(*GroupSpecWarmPool)(ptr) = GroupSpecWarmPool{}
			}
		} else {
			*(*GroupSpecWarmPool)(ptr) = GroupSpecWarmPool{}
		}
	default:
		iter.ReportError("decode GroupSpecWarmPool", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PolicySpecTargetTrackingConfigurationCodec struct {
}

func (PolicySpecTargetTrackingConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PolicySpecTargetTrackingConfiguration)(ptr) == nil
}

func (PolicySpecTargetTrackingConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PolicySpecTargetTrackingConfiguration)(ptr)
	var objs []PolicySpecTargetTrackingConfiguration
	if obj != nil {
		objs = []PolicySpecTargetTrackingConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicySpecTargetTrackingConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PolicySpecTargetTrackingConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PolicySpecTargetTrackingConfiguration)(ptr) = PolicySpecTargetTrackingConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PolicySpecTargetTrackingConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicySpecTargetTrackingConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PolicySpecTargetTrackingConfiguration)(ptr) = objs[0]
			} else {
				*(*PolicySpecTargetTrackingConfiguration)(ptr) = PolicySpecTargetTrackingConfiguration{}
			}
		} else {
			*(*PolicySpecTargetTrackingConfiguration)(ptr) = PolicySpecTargetTrackingConfiguration{}
		}
	default:
		iter.ReportError("decode PolicySpecTargetTrackingConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PolicySpecTargetTrackingConfigurationCustomizedMetricSpecificationCodec struct {
}

func (PolicySpecTargetTrackingConfigurationCustomizedMetricSpecificationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PolicySpecTargetTrackingConfigurationCustomizedMetricSpecification)(ptr) == nil
}

func (PolicySpecTargetTrackingConfigurationCustomizedMetricSpecificationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PolicySpecTargetTrackingConfigurationCustomizedMetricSpecification)(ptr)
	var objs []PolicySpecTargetTrackingConfigurationCustomizedMetricSpecification
	if obj != nil {
		objs = []PolicySpecTargetTrackingConfigurationCustomizedMetricSpecification{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicySpecTargetTrackingConfigurationCustomizedMetricSpecification{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PolicySpecTargetTrackingConfigurationCustomizedMetricSpecificationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PolicySpecTargetTrackingConfigurationCustomizedMetricSpecification)(ptr) = PolicySpecTargetTrackingConfigurationCustomizedMetricSpecification{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PolicySpecTargetTrackingConfigurationCustomizedMetricSpecification

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicySpecTargetTrackingConfigurationCustomizedMetricSpecification{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PolicySpecTargetTrackingConfigurationCustomizedMetricSpecification)(ptr) = objs[0]
			} else {
				*(*PolicySpecTargetTrackingConfigurationCustomizedMetricSpecification)(ptr) = PolicySpecTargetTrackingConfigurationCustomizedMetricSpecification{}
			}
		} else {
			*(*PolicySpecTargetTrackingConfigurationCustomizedMetricSpecification)(ptr) = PolicySpecTargetTrackingConfigurationCustomizedMetricSpecification{}
		}
	default:
		iter.ReportError("decode PolicySpecTargetTrackingConfigurationCustomizedMetricSpecification", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PolicySpecTargetTrackingConfigurationPredefinedMetricSpecificationCodec struct {
}

func (PolicySpecTargetTrackingConfigurationPredefinedMetricSpecificationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PolicySpecTargetTrackingConfigurationPredefinedMetricSpecification)(ptr) == nil
}

func (PolicySpecTargetTrackingConfigurationPredefinedMetricSpecificationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PolicySpecTargetTrackingConfigurationPredefinedMetricSpecification)(ptr)
	var objs []PolicySpecTargetTrackingConfigurationPredefinedMetricSpecification
	if obj != nil {
		objs = []PolicySpecTargetTrackingConfigurationPredefinedMetricSpecification{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicySpecTargetTrackingConfigurationPredefinedMetricSpecification{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PolicySpecTargetTrackingConfigurationPredefinedMetricSpecificationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PolicySpecTargetTrackingConfigurationPredefinedMetricSpecification)(ptr) = PolicySpecTargetTrackingConfigurationPredefinedMetricSpecification{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PolicySpecTargetTrackingConfigurationPredefinedMetricSpecification

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicySpecTargetTrackingConfigurationPredefinedMetricSpecification{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PolicySpecTargetTrackingConfigurationPredefinedMetricSpecification)(ptr) = objs[0]
			} else {
				*(*PolicySpecTargetTrackingConfigurationPredefinedMetricSpecification)(ptr) = PolicySpecTargetTrackingConfigurationPredefinedMetricSpecification{}
			}
		} else {
			*(*PolicySpecTargetTrackingConfigurationPredefinedMetricSpecification)(ptr) = PolicySpecTargetTrackingConfigurationPredefinedMetricSpecification{}
		}
	default:
		iter.ReportError("decode PolicySpecTargetTrackingConfigurationPredefinedMetricSpecification", "unexpected JSON type")
	}
}
