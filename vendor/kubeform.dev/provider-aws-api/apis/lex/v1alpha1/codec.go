/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(BotSpecAbortStatement{}).Type1()):                      BotSpecAbortStatementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BotSpecClarificationPrompt{}).Type1()):                 BotSpecClarificationPromptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BotAliasSpecConversationLogs{}).Type1()):               BotAliasSpecConversationLogsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecConclusionStatement{}).Type1()):              IntentSpecConclusionStatementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecConfirmationPrompt{}).Type1()):               IntentSpecConfirmationPromptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecDialogCodeHook{}).Type1()):                   IntentSpecDialogCodeHookCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecFollowUpPrompt{}).Type1()):                   IntentSpecFollowUpPromptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecFollowUpPromptPrompt{}).Type1()):             IntentSpecFollowUpPromptPromptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecFollowUpPromptRejectionStatement{}).Type1()): IntentSpecFollowUpPromptRejectionStatementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecFulfillmentActivity{}).Type1()):              IntentSpecFulfillmentActivityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecFulfillmentActivityCodeHook{}).Type1()):      IntentSpecFulfillmentActivityCodeHookCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecRejectionStatement{}).Type1()):               IntentSpecRejectionStatementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecSlotValueElicitationPrompt{}).Type1()):       IntentSpecSlotValueElicitationPromptCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(BotSpecAbortStatement{}).Type1()):                      BotSpecAbortStatementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BotSpecClarificationPrompt{}).Type1()):                 BotSpecClarificationPromptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BotAliasSpecConversationLogs{}).Type1()):               BotAliasSpecConversationLogsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecConclusionStatement{}).Type1()):              IntentSpecConclusionStatementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecConfirmationPrompt{}).Type1()):               IntentSpecConfirmationPromptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecDialogCodeHook{}).Type1()):                   IntentSpecDialogCodeHookCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecFollowUpPrompt{}).Type1()):                   IntentSpecFollowUpPromptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecFollowUpPromptPrompt{}).Type1()):             IntentSpecFollowUpPromptPromptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecFollowUpPromptRejectionStatement{}).Type1()): IntentSpecFollowUpPromptRejectionStatementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecFulfillmentActivity{}).Type1()):              IntentSpecFulfillmentActivityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecFulfillmentActivityCodeHook{}).Type1()):      IntentSpecFulfillmentActivityCodeHookCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecRejectionStatement{}).Type1()):               IntentSpecRejectionStatementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecSlotValueElicitationPrompt{}).Type1()):       IntentSpecSlotValueElicitationPromptCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type BotSpecAbortStatementCodec struct {
}

func (BotSpecAbortStatementCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BotSpecAbortStatement)(ptr) == nil
}

func (BotSpecAbortStatementCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BotSpecAbortStatement)(ptr)
	var objs []BotSpecAbortStatement
	if obj != nil {
		objs = []BotSpecAbortStatement{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BotSpecAbortStatement{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BotSpecAbortStatementCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BotSpecAbortStatement)(ptr) = BotSpecAbortStatement{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BotSpecAbortStatement

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BotSpecAbortStatement{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BotSpecAbortStatement)(ptr) = objs[0]
			} else {
				*(*BotSpecAbortStatement)(ptr) = BotSpecAbortStatement{}
			}
		} else {
			*(*BotSpecAbortStatement)(ptr) = BotSpecAbortStatement{}
		}
	default:
		iter.ReportError("decode BotSpecAbortStatement", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BotSpecClarificationPromptCodec struct {
}

func (BotSpecClarificationPromptCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BotSpecClarificationPrompt)(ptr) == nil
}

func (BotSpecClarificationPromptCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BotSpecClarificationPrompt)(ptr)
	var objs []BotSpecClarificationPrompt
	if obj != nil {
		objs = []BotSpecClarificationPrompt{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BotSpecClarificationPrompt{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BotSpecClarificationPromptCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BotSpecClarificationPrompt)(ptr) = BotSpecClarificationPrompt{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BotSpecClarificationPrompt

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BotSpecClarificationPrompt{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BotSpecClarificationPrompt)(ptr) = objs[0]
			} else {
				*(*BotSpecClarificationPrompt)(ptr) = BotSpecClarificationPrompt{}
			}
		} else {
			*(*BotSpecClarificationPrompt)(ptr) = BotSpecClarificationPrompt{}
		}
	default:
		iter.ReportError("decode BotSpecClarificationPrompt", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BotAliasSpecConversationLogsCodec struct {
}

func (BotAliasSpecConversationLogsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BotAliasSpecConversationLogs)(ptr) == nil
}

func (BotAliasSpecConversationLogsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BotAliasSpecConversationLogs)(ptr)
	var objs []BotAliasSpecConversationLogs
	if obj != nil {
		objs = []BotAliasSpecConversationLogs{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BotAliasSpecConversationLogs{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BotAliasSpecConversationLogsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BotAliasSpecConversationLogs)(ptr) = BotAliasSpecConversationLogs{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BotAliasSpecConversationLogs

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BotAliasSpecConversationLogs{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BotAliasSpecConversationLogs)(ptr) = objs[0]
			} else {
				*(*BotAliasSpecConversationLogs)(ptr) = BotAliasSpecConversationLogs{}
			}
		} else {
			*(*BotAliasSpecConversationLogs)(ptr) = BotAliasSpecConversationLogs{}
		}
	default:
		iter.ReportError("decode BotAliasSpecConversationLogs", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type IntentSpecConclusionStatementCodec struct {
}

func (IntentSpecConclusionStatementCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*IntentSpecConclusionStatement)(ptr) == nil
}

func (IntentSpecConclusionStatementCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*IntentSpecConclusionStatement)(ptr)
	var objs []IntentSpecConclusionStatement
	if obj != nil {
		objs = []IntentSpecConclusionStatement{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecConclusionStatement{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (IntentSpecConclusionStatementCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*IntentSpecConclusionStatement)(ptr) = IntentSpecConclusionStatement{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []IntentSpecConclusionStatement

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecConclusionStatement{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*IntentSpecConclusionStatement)(ptr) = objs[0]
			} else {
				*(*IntentSpecConclusionStatement)(ptr) = IntentSpecConclusionStatement{}
			}
		} else {
			*(*IntentSpecConclusionStatement)(ptr) = IntentSpecConclusionStatement{}
		}
	default:
		iter.ReportError("decode IntentSpecConclusionStatement", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type IntentSpecConfirmationPromptCodec struct {
}

func (IntentSpecConfirmationPromptCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*IntentSpecConfirmationPrompt)(ptr) == nil
}

func (IntentSpecConfirmationPromptCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*IntentSpecConfirmationPrompt)(ptr)
	var objs []IntentSpecConfirmationPrompt
	if obj != nil {
		objs = []IntentSpecConfirmationPrompt{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecConfirmationPrompt{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (IntentSpecConfirmationPromptCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*IntentSpecConfirmationPrompt)(ptr) = IntentSpecConfirmationPrompt{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []IntentSpecConfirmationPrompt

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecConfirmationPrompt{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*IntentSpecConfirmationPrompt)(ptr) = objs[0]
			} else {
				*(*IntentSpecConfirmationPrompt)(ptr) = IntentSpecConfirmationPrompt{}
			}
		} else {
			*(*IntentSpecConfirmationPrompt)(ptr) = IntentSpecConfirmationPrompt{}
		}
	default:
		iter.ReportError("decode IntentSpecConfirmationPrompt", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type IntentSpecDialogCodeHookCodec struct {
}

func (IntentSpecDialogCodeHookCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*IntentSpecDialogCodeHook)(ptr) == nil
}

func (IntentSpecDialogCodeHookCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*IntentSpecDialogCodeHook)(ptr)
	var objs []IntentSpecDialogCodeHook
	if obj != nil {
		objs = []IntentSpecDialogCodeHook{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecDialogCodeHook{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (IntentSpecDialogCodeHookCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*IntentSpecDialogCodeHook)(ptr) = IntentSpecDialogCodeHook{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []IntentSpecDialogCodeHook

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecDialogCodeHook{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*IntentSpecDialogCodeHook)(ptr) = objs[0]
			} else {
				*(*IntentSpecDialogCodeHook)(ptr) = IntentSpecDialogCodeHook{}
			}
		} else {
			*(*IntentSpecDialogCodeHook)(ptr) = IntentSpecDialogCodeHook{}
		}
	default:
		iter.ReportError("decode IntentSpecDialogCodeHook", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type IntentSpecFollowUpPromptCodec struct {
}

func (IntentSpecFollowUpPromptCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*IntentSpecFollowUpPrompt)(ptr) == nil
}

func (IntentSpecFollowUpPromptCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*IntentSpecFollowUpPrompt)(ptr)
	var objs []IntentSpecFollowUpPrompt
	if obj != nil {
		objs = []IntentSpecFollowUpPrompt{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecFollowUpPrompt{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (IntentSpecFollowUpPromptCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*IntentSpecFollowUpPrompt)(ptr) = IntentSpecFollowUpPrompt{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []IntentSpecFollowUpPrompt

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecFollowUpPrompt{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*IntentSpecFollowUpPrompt)(ptr) = objs[0]
			} else {
				*(*IntentSpecFollowUpPrompt)(ptr) = IntentSpecFollowUpPrompt{}
			}
		} else {
			*(*IntentSpecFollowUpPrompt)(ptr) = IntentSpecFollowUpPrompt{}
		}
	default:
		iter.ReportError("decode IntentSpecFollowUpPrompt", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type IntentSpecFollowUpPromptPromptCodec struct {
}

func (IntentSpecFollowUpPromptPromptCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*IntentSpecFollowUpPromptPrompt)(ptr) == nil
}

func (IntentSpecFollowUpPromptPromptCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*IntentSpecFollowUpPromptPrompt)(ptr)
	var objs []IntentSpecFollowUpPromptPrompt
	if obj != nil {
		objs = []IntentSpecFollowUpPromptPrompt{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecFollowUpPromptPrompt{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (IntentSpecFollowUpPromptPromptCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*IntentSpecFollowUpPromptPrompt)(ptr) = IntentSpecFollowUpPromptPrompt{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []IntentSpecFollowUpPromptPrompt

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecFollowUpPromptPrompt{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*IntentSpecFollowUpPromptPrompt)(ptr) = objs[0]
			} else {
				*(*IntentSpecFollowUpPromptPrompt)(ptr) = IntentSpecFollowUpPromptPrompt{}
			}
		} else {
			*(*IntentSpecFollowUpPromptPrompt)(ptr) = IntentSpecFollowUpPromptPrompt{}
		}
	default:
		iter.ReportError("decode IntentSpecFollowUpPromptPrompt", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type IntentSpecFollowUpPromptRejectionStatementCodec struct {
}

func (IntentSpecFollowUpPromptRejectionStatementCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*IntentSpecFollowUpPromptRejectionStatement)(ptr) == nil
}

func (IntentSpecFollowUpPromptRejectionStatementCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*IntentSpecFollowUpPromptRejectionStatement)(ptr)
	var objs []IntentSpecFollowUpPromptRejectionStatement
	if obj != nil {
		objs = []IntentSpecFollowUpPromptRejectionStatement{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecFollowUpPromptRejectionStatement{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (IntentSpecFollowUpPromptRejectionStatementCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*IntentSpecFollowUpPromptRejectionStatement)(ptr) = IntentSpecFollowUpPromptRejectionStatement{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []IntentSpecFollowUpPromptRejectionStatement

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecFollowUpPromptRejectionStatement{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*IntentSpecFollowUpPromptRejectionStatement)(ptr) = objs[0]
			} else {
				*(*IntentSpecFollowUpPromptRejectionStatement)(ptr) = IntentSpecFollowUpPromptRejectionStatement{}
			}
		} else {
			*(*IntentSpecFollowUpPromptRejectionStatement)(ptr) = IntentSpecFollowUpPromptRejectionStatement{}
		}
	default:
		iter.ReportError("decode IntentSpecFollowUpPromptRejectionStatement", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type IntentSpecFulfillmentActivityCodec struct {
}

func (IntentSpecFulfillmentActivityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*IntentSpecFulfillmentActivity)(ptr) == nil
}

func (IntentSpecFulfillmentActivityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*IntentSpecFulfillmentActivity)(ptr)
	var objs []IntentSpecFulfillmentActivity
	if obj != nil {
		objs = []IntentSpecFulfillmentActivity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecFulfillmentActivity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (IntentSpecFulfillmentActivityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*IntentSpecFulfillmentActivity)(ptr) = IntentSpecFulfillmentActivity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []IntentSpecFulfillmentActivity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecFulfillmentActivity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*IntentSpecFulfillmentActivity)(ptr) = objs[0]
			} else {
				*(*IntentSpecFulfillmentActivity)(ptr) = IntentSpecFulfillmentActivity{}
			}
		} else {
			*(*IntentSpecFulfillmentActivity)(ptr) = IntentSpecFulfillmentActivity{}
		}
	default:
		iter.ReportError("decode IntentSpecFulfillmentActivity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type IntentSpecFulfillmentActivityCodeHookCodec struct {
}

func (IntentSpecFulfillmentActivityCodeHookCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*IntentSpecFulfillmentActivityCodeHook)(ptr) == nil
}

func (IntentSpecFulfillmentActivityCodeHookCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*IntentSpecFulfillmentActivityCodeHook)(ptr)
	var objs []IntentSpecFulfillmentActivityCodeHook
	if obj != nil {
		objs = []IntentSpecFulfillmentActivityCodeHook{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecFulfillmentActivityCodeHook{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (IntentSpecFulfillmentActivityCodeHookCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*IntentSpecFulfillmentActivityCodeHook)(ptr) = IntentSpecFulfillmentActivityCodeHook{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []IntentSpecFulfillmentActivityCodeHook

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecFulfillmentActivityCodeHook{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*IntentSpecFulfillmentActivityCodeHook)(ptr) = objs[0]
			} else {
				*(*IntentSpecFulfillmentActivityCodeHook)(ptr) = IntentSpecFulfillmentActivityCodeHook{}
			}
		} else {
			*(*IntentSpecFulfillmentActivityCodeHook)(ptr) = IntentSpecFulfillmentActivityCodeHook{}
		}
	default:
		iter.ReportError("decode IntentSpecFulfillmentActivityCodeHook", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type IntentSpecRejectionStatementCodec struct {
}

func (IntentSpecRejectionStatementCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*IntentSpecRejectionStatement)(ptr) == nil
}

func (IntentSpecRejectionStatementCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*IntentSpecRejectionStatement)(ptr)
	var objs []IntentSpecRejectionStatement
	if obj != nil {
		objs = []IntentSpecRejectionStatement{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecRejectionStatement{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (IntentSpecRejectionStatementCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*IntentSpecRejectionStatement)(ptr) = IntentSpecRejectionStatement{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []IntentSpecRejectionStatement

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecRejectionStatement{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*IntentSpecRejectionStatement)(ptr) = objs[0]
			} else {
				*(*IntentSpecRejectionStatement)(ptr) = IntentSpecRejectionStatement{}
			}
		} else {
			*(*IntentSpecRejectionStatement)(ptr) = IntentSpecRejectionStatement{}
		}
	default:
		iter.ReportError("decode IntentSpecRejectionStatement", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type IntentSpecSlotValueElicitationPromptCodec struct {
}

func (IntentSpecSlotValueElicitationPromptCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*IntentSpecSlotValueElicitationPrompt)(ptr) == nil
}

func (IntentSpecSlotValueElicitationPromptCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*IntentSpecSlotValueElicitationPrompt)(ptr)
	var objs []IntentSpecSlotValueElicitationPrompt
	if obj != nil {
		objs = []IntentSpecSlotValueElicitationPrompt{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecSlotValueElicitationPrompt{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (IntentSpecSlotValueElicitationPromptCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*IntentSpecSlotValueElicitationPrompt)(ptr) = IntentSpecSlotValueElicitationPrompt{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []IntentSpecSlotValueElicitationPrompt

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(IntentSpecSlotValueElicitationPrompt{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*IntentSpecSlotValueElicitationPrompt)(ptr) = objs[0]
			} else {
				*(*IntentSpecSlotValueElicitationPrompt)(ptr) = IntentSpecSlotValueElicitationPrompt{}
			}
		} else {
			*(*IntentSpecSlotValueElicitationPrompt)(ptr) = IntentSpecSlotValueElicitationPrompt{}
		}
	default:
		iter.ReportError("decode IntentSpecSlotValueElicitationPrompt", "unexpected JSON type")
	}
}
