/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ThingTypeSpecProperties{}).Type1()):                   ThingTypeSpecPropertiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecDynamodbv2PutItem{}).Type1()):            TopicRuleSpecDynamodbv2PutItemCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorAction{}).Type1()):                  TopicRuleSpecErrorActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionCloudwatchAlarm{}).Type1()):   TopicRuleSpecErrorActionCloudwatchAlarmCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionCloudwatchMetric{}).Type1()):  TopicRuleSpecErrorActionCloudwatchMetricCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionDynamodb{}).Type1()):          TopicRuleSpecErrorActionDynamodbCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionDynamodbv2{}).Type1()):        TopicRuleSpecErrorActionDynamodbv2Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionDynamodbv2PutItem{}).Type1()): TopicRuleSpecErrorActionDynamodbv2PutItemCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionElasticsearch{}).Type1()):     TopicRuleSpecErrorActionElasticsearchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionFirehose{}).Type1()):          TopicRuleSpecErrorActionFirehoseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionIotAnalytics{}).Type1()):      TopicRuleSpecErrorActionIotAnalyticsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionIotEvents{}).Type1()):         TopicRuleSpecErrorActionIotEventsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionKinesis{}).Type1()):           TopicRuleSpecErrorActionKinesisCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionLambda{}).Type1()):            TopicRuleSpecErrorActionLambdaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionRepublish{}).Type1()):         TopicRuleSpecErrorActionRepublishCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionS3{}).Type1()):                TopicRuleSpecErrorActionS3Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionSns{}).Type1()):               TopicRuleSpecErrorActionSnsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionSqs{}).Type1()):               TopicRuleSpecErrorActionSqsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionStepFunctions{}).Type1()):     TopicRuleSpecErrorActionStepFunctionsCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ThingTypeSpecProperties{}).Type1()):                   ThingTypeSpecPropertiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecDynamodbv2PutItem{}).Type1()):            TopicRuleSpecDynamodbv2PutItemCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorAction{}).Type1()):                  TopicRuleSpecErrorActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionCloudwatchAlarm{}).Type1()):   TopicRuleSpecErrorActionCloudwatchAlarmCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionCloudwatchMetric{}).Type1()):  TopicRuleSpecErrorActionCloudwatchMetricCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionDynamodb{}).Type1()):          TopicRuleSpecErrorActionDynamodbCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionDynamodbv2{}).Type1()):        TopicRuleSpecErrorActionDynamodbv2Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionDynamodbv2PutItem{}).Type1()): TopicRuleSpecErrorActionDynamodbv2PutItemCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionElasticsearch{}).Type1()):     TopicRuleSpecErrorActionElasticsearchCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionFirehose{}).Type1()):          TopicRuleSpecErrorActionFirehoseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionIotAnalytics{}).Type1()):      TopicRuleSpecErrorActionIotAnalyticsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionIotEvents{}).Type1()):         TopicRuleSpecErrorActionIotEventsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionKinesis{}).Type1()):           TopicRuleSpecErrorActionKinesisCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionLambda{}).Type1()):            TopicRuleSpecErrorActionLambdaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionRepublish{}).Type1()):         TopicRuleSpecErrorActionRepublishCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionS3{}).Type1()):                TopicRuleSpecErrorActionS3Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionSns{}).Type1()):               TopicRuleSpecErrorActionSnsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionSqs{}).Type1()):               TopicRuleSpecErrorActionSqsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionStepFunctions{}).Type1()):     TopicRuleSpecErrorActionStepFunctionsCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type ThingTypeSpecPropertiesCodec struct {
}

func (ThingTypeSpecPropertiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ThingTypeSpecProperties)(ptr) == nil
}

func (ThingTypeSpecPropertiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ThingTypeSpecProperties)(ptr)
	var objs []ThingTypeSpecProperties
	if obj != nil {
		objs = []ThingTypeSpecProperties{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ThingTypeSpecProperties{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ThingTypeSpecPropertiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ThingTypeSpecProperties)(ptr) = ThingTypeSpecProperties{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ThingTypeSpecProperties

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ThingTypeSpecProperties{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ThingTypeSpecProperties)(ptr) = objs[0]
			} else {
				*(*ThingTypeSpecProperties)(ptr) = ThingTypeSpecProperties{}
			}
		} else {
			*(*ThingTypeSpecProperties)(ptr) = ThingTypeSpecProperties{}
		}
	default:
		iter.ReportError("decode ThingTypeSpecProperties", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicRuleSpecDynamodbv2PutItemCodec struct {
}

func (TopicRuleSpecDynamodbv2PutItemCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicRuleSpecDynamodbv2PutItem)(ptr) == nil
}

func (TopicRuleSpecDynamodbv2PutItemCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicRuleSpecDynamodbv2PutItem)(ptr)
	var objs []TopicRuleSpecDynamodbv2PutItem
	if obj != nil {
		objs = []TopicRuleSpecDynamodbv2PutItem{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecDynamodbv2PutItem{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicRuleSpecDynamodbv2PutItemCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicRuleSpecDynamodbv2PutItem)(ptr) = TopicRuleSpecDynamodbv2PutItem{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicRuleSpecDynamodbv2PutItem

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecDynamodbv2PutItem{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicRuleSpecDynamodbv2PutItem)(ptr) = objs[0]
			} else {
				*(*TopicRuleSpecDynamodbv2PutItem)(ptr) = TopicRuleSpecDynamodbv2PutItem{}
			}
		} else {
			*(*TopicRuleSpecDynamodbv2PutItem)(ptr) = TopicRuleSpecDynamodbv2PutItem{}
		}
	default:
		iter.ReportError("decode TopicRuleSpecDynamodbv2PutItem", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicRuleSpecErrorActionCodec struct {
}

func (TopicRuleSpecErrorActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicRuleSpecErrorAction)(ptr) == nil
}

func (TopicRuleSpecErrorActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicRuleSpecErrorAction)(ptr)
	var objs []TopicRuleSpecErrorAction
	if obj != nil {
		objs = []TopicRuleSpecErrorAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicRuleSpecErrorActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicRuleSpecErrorAction)(ptr) = TopicRuleSpecErrorAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicRuleSpecErrorAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicRuleSpecErrorAction)(ptr) = objs[0]
			} else {
				*(*TopicRuleSpecErrorAction)(ptr) = TopicRuleSpecErrorAction{}
			}
		} else {
			*(*TopicRuleSpecErrorAction)(ptr) = TopicRuleSpecErrorAction{}
		}
	default:
		iter.ReportError("decode TopicRuleSpecErrorAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicRuleSpecErrorActionCloudwatchAlarmCodec struct {
}

func (TopicRuleSpecErrorActionCloudwatchAlarmCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicRuleSpecErrorActionCloudwatchAlarm)(ptr) == nil
}

func (TopicRuleSpecErrorActionCloudwatchAlarmCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicRuleSpecErrorActionCloudwatchAlarm)(ptr)
	var objs []TopicRuleSpecErrorActionCloudwatchAlarm
	if obj != nil {
		objs = []TopicRuleSpecErrorActionCloudwatchAlarm{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionCloudwatchAlarm{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicRuleSpecErrorActionCloudwatchAlarmCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicRuleSpecErrorActionCloudwatchAlarm)(ptr) = TopicRuleSpecErrorActionCloudwatchAlarm{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicRuleSpecErrorActionCloudwatchAlarm

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionCloudwatchAlarm{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicRuleSpecErrorActionCloudwatchAlarm)(ptr) = objs[0]
			} else {
				*(*TopicRuleSpecErrorActionCloudwatchAlarm)(ptr) = TopicRuleSpecErrorActionCloudwatchAlarm{}
			}
		} else {
			*(*TopicRuleSpecErrorActionCloudwatchAlarm)(ptr) = TopicRuleSpecErrorActionCloudwatchAlarm{}
		}
	default:
		iter.ReportError("decode TopicRuleSpecErrorActionCloudwatchAlarm", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicRuleSpecErrorActionCloudwatchMetricCodec struct {
}

func (TopicRuleSpecErrorActionCloudwatchMetricCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicRuleSpecErrorActionCloudwatchMetric)(ptr) == nil
}

func (TopicRuleSpecErrorActionCloudwatchMetricCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicRuleSpecErrorActionCloudwatchMetric)(ptr)
	var objs []TopicRuleSpecErrorActionCloudwatchMetric
	if obj != nil {
		objs = []TopicRuleSpecErrorActionCloudwatchMetric{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionCloudwatchMetric{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicRuleSpecErrorActionCloudwatchMetricCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicRuleSpecErrorActionCloudwatchMetric)(ptr) = TopicRuleSpecErrorActionCloudwatchMetric{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicRuleSpecErrorActionCloudwatchMetric

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionCloudwatchMetric{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicRuleSpecErrorActionCloudwatchMetric)(ptr) = objs[0]
			} else {
				*(*TopicRuleSpecErrorActionCloudwatchMetric)(ptr) = TopicRuleSpecErrorActionCloudwatchMetric{}
			}
		} else {
			*(*TopicRuleSpecErrorActionCloudwatchMetric)(ptr) = TopicRuleSpecErrorActionCloudwatchMetric{}
		}
	default:
		iter.ReportError("decode TopicRuleSpecErrorActionCloudwatchMetric", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicRuleSpecErrorActionDynamodbCodec struct {
}

func (TopicRuleSpecErrorActionDynamodbCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicRuleSpecErrorActionDynamodb)(ptr) == nil
}

func (TopicRuleSpecErrorActionDynamodbCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicRuleSpecErrorActionDynamodb)(ptr)
	var objs []TopicRuleSpecErrorActionDynamodb
	if obj != nil {
		objs = []TopicRuleSpecErrorActionDynamodb{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionDynamodb{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicRuleSpecErrorActionDynamodbCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicRuleSpecErrorActionDynamodb)(ptr) = TopicRuleSpecErrorActionDynamodb{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicRuleSpecErrorActionDynamodb

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionDynamodb{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicRuleSpecErrorActionDynamodb)(ptr) = objs[0]
			} else {
				*(*TopicRuleSpecErrorActionDynamodb)(ptr) = TopicRuleSpecErrorActionDynamodb{}
			}
		} else {
			*(*TopicRuleSpecErrorActionDynamodb)(ptr) = TopicRuleSpecErrorActionDynamodb{}
		}
	default:
		iter.ReportError("decode TopicRuleSpecErrorActionDynamodb", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicRuleSpecErrorActionDynamodbv2Codec struct {
}

func (TopicRuleSpecErrorActionDynamodbv2Codec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicRuleSpecErrorActionDynamodbv2)(ptr) == nil
}

func (TopicRuleSpecErrorActionDynamodbv2Codec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicRuleSpecErrorActionDynamodbv2)(ptr)
	var objs []TopicRuleSpecErrorActionDynamodbv2
	if obj != nil {
		objs = []TopicRuleSpecErrorActionDynamodbv2{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionDynamodbv2{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicRuleSpecErrorActionDynamodbv2Codec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicRuleSpecErrorActionDynamodbv2)(ptr) = TopicRuleSpecErrorActionDynamodbv2{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicRuleSpecErrorActionDynamodbv2

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionDynamodbv2{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicRuleSpecErrorActionDynamodbv2)(ptr) = objs[0]
			} else {
				*(*TopicRuleSpecErrorActionDynamodbv2)(ptr) = TopicRuleSpecErrorActionDynamodbv2{}
			}
		} else {
			*(*TopicRuleSpecErrorActionDynamodbv2)(ptr) = TopicRuleSpecErrorActionDynamodbv2{}
		}
	default:
		iter.ReportError("decode TopicRuleSpecErrorActionDynamodbv2", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicRuleSpecErrorActionDynamodbv2PutItemCodec struct {
}

func (TopicRuleSpecErrorActionDynamodbv2PutItemCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicRuleSpecErrorActionDynamodbv2PutItem)(ptr) == nil
}

func (TopicRuleSpecErrorActionDynamodbv2PutItemCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicRuleSpecErrorActionDynamodbv2PutItem)(ptr)
	var objs []TopicRuleSpecErrorActionDynamodbv2PutItem
	if obj != nil {
		objs = []TopicRuleSpecErrorActionDynamodbv2PutItem{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionDynamodbv2PutItem{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicRuleSpecErrorActionDynamodbv2PutItemCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicRuleSpecErrorActionDynamodbv2PutItem)(ptr) = TopicRuleSpecErrorActionDynamodbv2PutItem{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicRuleSpecErrorActionDynamodbv2PutItem

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionDynamodbv2PutItem{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicRuleSpecErrorActionDynamodbv2PutItem)(ptr) = objs[0]
			} else {
				*(*TopicRuleSpecErrorActionDynamodbv2PutItem)(ptr) = TopicRuleSpecErrorActionDynamodbv2PutItem{}
			}
		} else {
			*(*TopicRuleSpecErrorActionDynamodbv2PutItem)(ptr) = TopicRuleSpecErrorActionDynamodbv2PutItem{}
		}
	default:
		iter.ReportError("decode TopicRuleSpecErrorActionDynamodbv2PutItem", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicRuleSpecErrorActionElasticsearchCodec struct {
}

func (TopicRuleSpecErrorActionElasticsearchCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicRuleSpecErrorActionElasticsearch)(ptr) == nil
}

func (TopicRuleSpecErrorActionElasticsearchCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicRuleSpecErrorActionElasticsearch)(ptr)
	var objs []TopicRuleSpecErrorActionElasticsearch
	if obj != nil {
		objs = []TopicRuleSpecErrorActionElasticsearch{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionElasticsearch{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicRuleSpecErrorActionElasticsearchCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicRuleSpecErrorActionElasticsearch)(ptr) = TopicRuleSpecErrorActionElasticsearch{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicRuleSpecErrorActionElasticsearch

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionElasticsearch{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicRuleSpecErrorActionElasticsearch)(ptr) = objs[0]
			} else {
				*(*TopicRuleSpecErrorActionElasticsearch)(ptr) = TopicRuleSpecErrorActionElasticsearch{}
			}
		} else {
			*(*TopicRuleSpecErrorActionElasticsearch)(ptr) = TopicRuleSpecErrorActionElasticsearch{}
		}
	default:
		iter.ReportError("decode TopicRuleSpecErrorActionElasticsearch", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicRuleSpecErrorActionFirehoseCodec struct {
}

func (TopicRuleSpecErrorActionFirehoseCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicRuleSpecErrorActionFirehose)(ptr) == nil
}

func (TopicRuleSpecErrorActionFirehoseCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicRuleSpecErrorActionFirehose)(ptr)
	var objs []TopicRuleSpecErrorActionFirehose
	if obj != nil {
		objs = []TopicRuleSpecErrorActionFirehose{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionFirehose{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicRuleSpecErrorActionFirehoseCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicRuleSpecErrorActionFirehose)(ptr) = TopicRuleSpecErrorActionFirehose{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicRuleSpecErrorActionFirehose

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionFirehose{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicRuleSpecErrorActionFirehose)(ptr) = objs[0]
			} else {
				*(*TopicRuleSpecErrorActionFirehose)(ptr) = TopicRuleSpecErrorActionFirehose{}
			}
		} else {
			*(*TopicRuleSpecErrorActionFirehose)(ptr) = TopicRuleSpecErrorActionFirehose{}
		}
	default:
		iter.ReportError("decode TopicRuleSpecErrorActionFirehose", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicRuleSpecErrorActionIotAnalyticsCodec struct {
}

func (TopicRuleSpecErrorActionIotAnalyticsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicRuleSpecErrorActionIotAnalytics)(ptr) == nil
}

func (TopicRuleSpecErrorActionIotAnalyticsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicRuleSpecErrorActionIotAnalytics)(ptr)
	var objs []TopicRuleSpecErrorActionIotAnalytics
	if obj != nil {
		objs = []TopicRuleSpecErrorActionIotAnalytics{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionIotAnalytics{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicRuleSpecErrorActionIotAnalyticsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicRuleSpecErrorActionIotAnalytics)(ptr) = TopicRuleSpecErrorActionIotAnalytics{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicRuleSpecErrorActionIotAnalytics

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionIotAnalytics{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicRuleSpecErrorActionIotAnalytics)(ptr) = objs[0]
			} else {
				*(*TopicRuleSpecErrorActionIotAnalytics)(ptr) = TopicRuleSpecErrorActionIotAnalytics{}
			}
		} else {
			*(*TopicRuleSpecErrorActionIotAnalytics)(ptr) = TopicRuleSpecErrorActionIotAnalytics{}
		}
	default:
		iter.ReportError("decode TopicRuleSpecErrorActionIotAnalytics", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicRuleSpecErrorActionIotEventsCodec struct {
}

func (TopicRuleSpecErrorActionIotEventsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicRuleSpecErrorActionIotEvents)(ptr) == nil
}

func (TopicRuleSpecErrorActionIotEventsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicRuleSpecErrorActionIotEvents)(ptr)
	var objs []TopicRuleSpecErrorActionIotEvents
	if obj != nil {
		objs = []TopicRuleSpecErrorActionIotEvents{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionIotEvents{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicRuleSpecErrorActionIotEventsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicRuleSpecErrorActionIotEvents)(ptr) = TopicRuleSpecErrorActionIotEvents{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicRuleSpecErrorActionIotEvents

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionIotEvents{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicRuleSpecErrorActionIotEvents)(ptr) = objs[0]
			} else {
				*(*TopicRuleSpecErrorActionIotEvents)(ptr) = TopicRuleSpecErrorActionIotEvents{}
			}
		} else {
			*(*TopicRuleSpecErrorActionIotEvents)(ptr) = TopicRuleSpecErrorActionIotEvents{}
		}
	default:
		iter.ReportError("decode TopicRuleSpecErrorActionIotEvents", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicRuleSpecErrorActionKinesisCodec struct {
}

func (TopicRuleSpecErrorActionKinesisCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicRuleSpecErrorActionKinesis)(ptr) == nil
}

func (TopicRuleSpecErrorActionKinesisCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicRuleSpecErrorActionKinesis)(ptr)
	var objs []TopicRuleSpecErrorActionKinesis
	if obj != nil {
		objs = []TopicRuleSpecErrorActionKinesis{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionKinesis{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicRuleSpecErrorActionKinesisCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicRuleSpecErrorActionKinesis)(ptr) = TopicRuleSpecErrorActionKinesis{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicRuleSpecErrorActionKinesis

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionKinesis{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicRuleSpecErrorActionKinesis)(ptr) = objs[0]
			} else {
				*(*TopicRuleSpecErrorActionKinesis)(ptr) = TopicRuleSpecErrorActionKinesis{}
			}
		} else {
			*(*TopicRuleSpecErrorActionKinesis)(ptr) = TopicRuleSpecErrorActionKinesis{}
		}
	default:
		iter.ReportError("decode TopicRuleSpecErrorActionKinesis", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicRuleSpecErrorActionLambdaCodec struct {
}

func (TopicRuleSpecErrorActionLambdaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicRuleSpecErrorActionLambda)(ptr) == nil
}

func (TopicRuleSpecErrorActionLambdaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicRuleSpecErrorActionLambda)(ptr)
	var objs []TopicRuleSpecErrorActionLambda
	if obj != nil {
		objs = []TopicRuleSpecErrorActionLambda{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionLambda{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicRuleSpecErrorActionLambdaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicRuleSpecErrorActionLambda)(ptr) = TopicRuleSpecErrorActionLambda{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicRuleSpecErrorActionLambda

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionLambda{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicRuleSpecErrorActionLambda)(ptr) = objs[0]
			} else {
				*(*TopicRuleSpecErrorActionLambda)(ptr) = TopicRuleSpecErrorActionLambda{}
			}
		} else {
			*(*TopicRuleSpecErrorActionLambda)(ptr) = TopicRuleSpecErrorActionLambda{}
		}
	default:
		iter.ReportError("decode TopicRuleSpecErrorActionLambda", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicRuleSpecErrorActionRepublishCodec struct {
}

func (TopicRuleSpecErrorActionRepublishCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicRuleSpecErrorActionRepublish)(ptr) == nil
}

func (TopicRuleSpecErrorActionRepublishCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicRuleSpecErrorActionRepublish)(ptr)
	var objs []TopicRuleSpecErrorActionRepublish
	if obj != nil {
		objs = []TopicRuleSpecErrorActionRepublish{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionRepublish{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicRuleSpecErrorActionRepublishCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicRuleSpecErrorActionRepublish)(ptr) = TopicRuleSpecErrorActionRepublish{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicRuleSpecErrorActionRepublish

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionRepublish{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicRuleSpecErrorActionRepublish)(ptr) = objs[0]
			} else {
				*(*TopicRuleSpecErrorActionRepublish)(ptr) = TopicRuleSpecErrorActionRepublish{}
			}
		} else {
			*(*TopicRuleSpecErrorActionRepublish)(ptr) = TopicRuleSpecErrorActionRepublish{}
		}
	default:
		iter.ReportError("decode TopicRuleSpecErrorActionRepublish", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicRuleSpecErrorActionS3Codec struct {
}

func (TopicRuleSpecErrorActionS3Codec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicRuleSpecErrorActionS3)(ptr) == nil
}

func (TopicRuleSpecErrorActionS3Codec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicRuleSpecErrorActionS3)(ptr)
	var objs []TopicRuleSpecErrorActionS3
	if obj != nil {
		objs = []TopicRuleSpecErrorActionS3{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionS3{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicRuleSpecErrorActionS3Codec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicRuleSpecErrorActionS3)(ptr) = TopicRuleSpecErrorActionS3{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicRuleSpecErrorActionS3

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionS3{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicRuleSpecErrorActionS3)(ptr) = objs[0]
			} else {
				*(*TopicRuleSpecErrorActionS3)(ptr) = TopicRuleSpecErrorActionS3{}
			}
		} else {
			*(*TopicRuleSpecErrorActionS3)(ptr) = TopicRuleSpecErrorActionS3{}
		}
	default:
		iter.ReportError("decode TopicRuleSpecErrorActionS3", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicRuleSpecErrorActionSnsCodec struct {
}

func (TopicRuleSpecErrorActionSnsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicRuleSpecErrorActionSns)(ptr) == nil
}

func (TopicRuleSpecErrorActionSnsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicRuleSpecErrorActionSns)(ptr)
	var objs []TopicRuleSpecErrorActionSns
	if obj != nil {
		objs = []TopicRuleSpecErrorActionSns{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionSns{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicRuleSpecErrorActionSnsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicRuleSpecErrorActionSns)(ptr) = TopicRuleSpecErrorActionSns{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicRuleSpecErrorActionSns

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionSns{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicRuleSpecErrorActionSns)(ptr) = objs[0]
			} else {
				*(*TopicRuleSpecErrorActionSns)(ptr) = TopicRuleSpecErrorActionSns{}
			}
		} else {
			*(*TopicRuleSpecErrorActionSns)(ptr) = TopicRuleSpecErrorActionSns{}
		}
	default:
		iter.ReportError("decode TopicRuleSpecErrorActionSns", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicRuleSpecErrorActionSqsCodec struct {
}

func (TopicRuleSpecErrorActionSqsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicRuleSpecErrorActionSqs)(ptr) == nil
}

func (TopicRuleSpecErrorActionSqsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicRuleSpecErrorActionSqs)(ptr)
	var objs []TopicRuleSpecErrorActionSqs
	if obj != nil {
		objs = []TopicRuleSpecErrorActionSqs{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionSqs{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicRuleSpecErrorActionSqsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicRuleSpecErrorActionSqs)(ptr) = TopicRuleSpecErrorActionSqs{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicRuleSpecErrorActionSqs

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionSqs{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicRuleSpecErrorActionSqs)(ptr) = objs[0]
			} else {
				*(*TopicRuleSpecErrorActionSqs)(ptr) = TopicRuleSpecErrorActionSqs{}
			}
		} else {
			*(*TopicRuleSpecErrorActionSqs)(ptr) = TopicRuleSpecErrorActionSqs{}
		}
	default:
		iter.ReportError("decode TopicRuleSpecErrorActionSqs", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicRuleSpecErrorActionStepFunctionsCodec struct {
}

func (TopicRuleSpecErrorActionStepFunctionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicRuleSpecErrorActionStepFunctions)(ptr) == nil
}

func (TopicRuleSpecErrorActionStepFunctionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicRuleSpecErrorActionStepFunctions)(ptr)
	var objs []TopicRuleSpecErrorActionStepFunctions
	if obj != nil {
		objs = []TopicRuleSpecErrorActionStepFunctions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionStepFunctions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicRuleSpecErrorActionStepFunctionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicRuleSpecErrorActionStepFunctions)(ptr) = TopicRuleSpecErrorActionStepFunctions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicRuleSpecErrorActionStepFunctions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicRuleSpecErrorActionStepFunctions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicRuleSpecErrorActionStepFunctions)(ptr) = objs[0]
			} else {
				*(*TopicRuleSpecErrorActionStepFunctions)(ptr) = TopicRuleSpecErrorActionStepFunctions{}
			}
		} else {
			*(*TopicRuleSpecErrorActionStepFunctions)(ptr) = TopicRuleSpecErrorActionStepFunctions{}
		}
	default:
		iter.ReportError("decode TopicRuleSpecErrorActionStepFunctions", "unexpected JSON type")
	}
}
