/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecBrokerNodeGroupInfo{}).Type1()):                  ClusterSpecBrokerNodeGroupInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClientAuthentication{}).Type1()):                 ClusterSpecClientAuthenticationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClientAuthenticationSasl{}).Type1()):             ClusterSpecClientAuthenticationSaslCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClientAuthenticationTls{}).Type1()):              ClusterSpecClientAuthenticationTlsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecConfigurationInfo{}).Type1()):                    ClusterSpecConfigurationInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecEncryptionInfo{}).Type1()):                       ClusterSpecEncryptionInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecEncryptionInfoEncryptionInTransit{}).Type1()):    ClusterSpecEncryptionInfoEncryptionInTransitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingInfo{}).Type1()):                          ClusterSpecLoggingInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingInfoBrokerLogs{}).Type1()):                ClusterSpecLoggingInfoBrokerLogsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingInfoBrokerLogsCloudwatchLogs{}).Type1()):  ClusterSpecLoggingInfoBrokerLogsCloudwatchLogsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingInfoBrokerLogsFirehose{}).Type1()):        ClusterSpecLoggingInfoBrokerLogsFirehoseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingInfoBrokerLogsS3{}).Type1()):              ClusterSpecLoggingInfoBrokerLogsS3Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOpenMonitoring{}).Type1()):                       ClusterSpecOpenMonitoringCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOpenMonitoringPrometheus{}).Type1()):             ClusterSpecOpenMonitoringPrometheusCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOpenMonitoringPrometheusJmxExporter{}).Type1()):  ClusterSpecOpenMonitoringPrometheusJmxExporterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOpenMonitoringPrometheusNodeExporter{}).Type1()): ClusterSpecOpenMonitoringPrometheusNodeExporterCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecBrokerNodeGroupInfo{}).Type1()):                  ClusterSpecBrokerNodeGroupInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClientAuthentication{}).Type1()):                 ClusterSpecClientAuthenticationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClientAuthenticationSasl{}).Type1()):             ClusterSpecClientAuthenticationSaslCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClientAuthenticationTls{}).Type1()):              ClusterSpecClientAuthenticationTlsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecConfigurationInfo{}).Type1()):                    ClusterSpecConfigurationInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecEncryptionInfo{}).Type1()):                       ClusterSpecEncryptionInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecEncryptionInfoEncryptionInTransit{}).Type1()):    ClusterSpecEncryptionInfoEncryptionInTransitCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingInfo{}).Type1()):                          ClusterSpecLoggingInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingInfoBrokerLogs{}).Type1()):                ClusterSpecLoggingInfoBrokerLogsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingInfoBrokerLogsCloudwatchLogs{}).Type1()):  ClusterSpecLoggingInfoBrokerLogsCloudwatchLogsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingInfoBrokerLogsFirehose{}).Type1()):        ClusterSpecLoggingInfoBrokerLogsFirehoseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingInfoBrokerLogsS3{}).Type1()):              ClusterSpecLoggingInfoBrokerLogsS3Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOpenMonitoring{}).Type1()):                       ClusterSpecOpenMonitoringCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOpenMonitoringPrometheus{}).Type1()):             ClusterSpecOpenMonitoringPrometheusCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOpenMonitoringPrometheusJmxExporter{}).Type1()):  ClusterSpecOpenMonitoringPrometheusJmxExporterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOpenMonitoringPrometheusNodeExporter{}).Type1()): ClusterSpecOpenMonitoringPrometheusNodeExporterCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type ClusterSpecBrokerNodeGroupInfoCodec struct {
}

func (ClusterSpecBrokerNodeGroupInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecBrokerNodeGroupInfo)(ptr) == nil
}

func (ClusterSpecBrokerNodeGroupInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecBrokerNodeGroupInfo)(ptr)
	var objs []ClusterSpecBrokerNodeGroupInfo
	if obj != nil {
		objs = []ClusterSpecBrokerNodeGroupInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecBrokerNodeGroupInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecBrokerNodeGroupInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecBrokerNodeGroupInfo)(ptr) = ClusterSpecBrokerNodeGroupInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecBrokerNodeGroupInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecBrokerNodeGroupInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecBrokerNodeGroupInfo)(ptr) = objs[0]
			} else {
				*(*ClusterSpecBrokerNodeGroupInfo)(ptr) = ClusterSpecBrokerNodeGroupInfo{}
			}
		} else {
			*(*ClusterSpecBrokerNodeGroupInfo)(ptr) = ClusterSpecBrokerNodeGroupInfo{}
		}
	default:
		iter.ReportError("decode ClusterSpecBrokerNodeGroupInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClientAuthenticationCodec struct {
}

func (ClusterSpecClientAuthenticationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClientAuthentication)(ptr) == nil
}

func (ClusterSpecClientAuthenticationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClientAuthentication)(ptr)
	var objs []ClusterSpecClientAuthentication
	if obj != nil {
		objs = []ClusterSpecClientAuthentication{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClientAuthentication{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClientAuthenticationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClientAuthentication)(ptr) = ClusterSpecClientAuthentication{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClientAuthentication

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClientAuthentication{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClientAuthentication)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClientAuthentication)(ptr) = ClusterSpecClientAuthentication{}
			}
		} else {
			*(*ClusterSpecClientAuthentication)(ptr) = ClusterSpecClientAuthentication{}
		}
	default:
		iter.ReportError("decode ClusterSpecClientAuthentication", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClientAuthenticationSaslCodec struct {
}

func (ClusterSpecClientAuthenticationSaslCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClientAuthenticationSasl)(ptr) == nil
}

func (ClusterSpecClientAuthenticationSaslCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClientAuthenticationSasl)(ptr)
	var objs []ClusterSpecClientAuthenticationSasl
	if obj != nil {
		objs = []ClusterSpecClientAuthenticationSasl{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClientAuthenticationSasl{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClientAuthenticationSaslCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClientAuthenticationSasl)(ptr) = ClusterSpecClientAuthenticationSasl{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClientAuthenticationSasl

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClientAuthenticationSasl{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClientAuthenticationSasl)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClientAuthenticationSasl)(ptr) = ClusterSpecClientAuthenticationSasl{}
			}
		} else {
			*(*ClusterSpecClientAuthenticationSasl)(ptr) = ClusterSpecClientAuthenticationSasl{}
		}
	default:
		iter.ReportError("decode ClusterSpecClientAuthenticationSasl", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecClientAuthenticationTlsCodec struct {
}

func (ClusterSpecClientAuthenticationTlsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecClientAuthenticationTls)(ptr) == nil
}

func (ClusterSpecClientAuthenticationTlsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecClientAuthenticationTls)(ptr)
	var objs []ClusterSpecClientAuthenticationTls
	if obj != nil {
		objs = []ClusterSpecClientAuthenticationTls{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClientAuthenticationTls{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecClientAuthenticationTlsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecClientAuthenticationTls)(ptr) = ClusterSpecClientAuthenticationTls{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecClientAuthenticationTls

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecClientAuthenticationTls{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecClientAuthenticationTls)(ptr) = objs[0]
			} else {
				*(*ClusterSpecClientAuthenticationTls)(ptr) = ClusterSpecClientAuthenticationTls{}
			}
		} else {
			*(*ClusterSpecClientAuthenticationTls)(ptr) = ClusterSpecClientAuthenticationTls{}
		}
	default:
		iter.ReportError("decode ClusterSpecClientAuthenticationTls", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecConfigurationInfoCodec struct {
}

func (ClusterSpecConfigurationInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecConfigurationInfo)(ptr) == nil
}

func (ClusterSpecConfigurationInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecConfigurationInfo)(ptr)
	var objs []ClusterSpecConfigurationInfo
	if obj != nil {
		objs = []ClusterSpecConfigurationInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecConfigurationInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecConfigurationInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecConfigurationInfo)(ptr) = ClusterSpecConfigurationInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecConfigurationInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecConfigurationInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecConfigurationInfo)(ptr) = objs[0]
			} else {
				*(*ClusterSpecConfigurationInfo)(ptr) = ClusterSpecConfigurationInfo{}
			}
		} else {
			*(*ClusterSpecConfigurationInfo)(ptr) = ClusterSpecConfigurationInfo{}
		}
	default:
		iter.ReportError("decode ClusterSpecConfigurationInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecEncryptionInfoCodec struct {
}

func (ClusterSpecEncryptionInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecEncryptionInfo)(ptr) == nil
}

func (ClusterSpecEncryptionInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecEncryptionInfo)(ptr)
	var objs []ClusterSpecEncryptionInfo
	if obj != nil {
		objs = []ClusterSpecEncryptionInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecEncryptionInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecEncryptionInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecEncryptionInfo)(ptr) = ClusterSpecEncryptionInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecEncryptionInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecEncryptionInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecEncryptionInfo)(ptr) = objs[0]
			} else {
				*(*ClusterSpecEncryptionInfo)(ptr) = ClusterSpecEncryptionInfo{}
			}
		} else {
			*(*ClusterSpecEncryptionInfo)(ptr) = ClusterSpecEncryptionInfo{}
		}
	default:
		iter.ReportError("decode ClusterSpecEncryptionInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecEncryptionInfoEncryptionInTransitCodec struct {
}

func (ClusterSpecEncryptionInfoEncryptionInTransitCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecEncryptionInfoEncryptionInTransit)(ptr) == nil
}

func (ClusterSpecEncryptionInfoEncryptionInTransitCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecEncryptionInfoEncryptionInTransit)(ptr)
	var objs []ClusterSpecEncryptionInfoEncryptionInTransit
	if obj != nil {
		objs = []ClusterSpecEncryptionInfoEncryptionInTransit{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecEncryptionInfoEncryptionInTransit{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecEncryptionInfoEncryptionInTransitCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecEncryptionInfoEncryptionInTransit)(ptr) = ClusterSpecEncryptionInfoEncryptionInTransit{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecEncryptionInfoEncryptionInTransit

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecEncryptionInfoEncryptionInTransit{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecEncryptionInfoEncryptionInTransit)(ptr) = objs[0]
			} else {
				*(*ClusterSpecEncryptionInfoEncryptionInTransit)(ptr) = ClusterSpecEncryptionInfoEncryptionInTransit{}
			}
		} else {
			*(*ClusterSpecEncryptionInfoEncryptionInTransit)(ptr) = ClusterSpecEncryptionInfoEncryptionInTransit{}
		}
	default:
		iter.ReportError("decode ClusterSpecEncryptionInfoEncryptionInTransit", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecLoggingInfoCodec struct {
}

func (ClusterSpecLoggingInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecLoggingInfo)(ptr) == nil
}

func (ClusterSpecLoggingInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecLoggingInfo)(ptr)
	var objs []ClusterSpecLoggingInfo
	if obj != nil {
		objs = []ClusterSpecLoggingInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecLoggingInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecLoggingInfo)(ptr) = ClusterSpecLoggingInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecLoggingInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecLoggingInfo)(ptr) = objs[0]
			} else {
				*(*ClusterSpecLoggingInfo)(ptr) = ClusterSpecLoggingInfo{}
			}
		} else {
			*(*ClusterSpecLoggingInfo)(ptr) = ClusterSpecLoggingInfo{}
		}
	default:
		iter.ReportError("decode ClusterSpecLoggingInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecLoggingInfoBrokerLogsCodec struct {
}

func (ClusterSpecLoggingInfoBrokerLogsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecLoggingInfoBrokerLogs)(ptr) == nil
}

func (ClusterSpecLoggingInfoBrokerLogsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecLoggingInfoBrokerLogs)(ptr)
	var objs []ClusterSpecLoggingInfoBrokerLogs
	if obj != nil {
		objs = []ClusterSpecLoggingInfoBrokerLogs{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingInfoBrokerLogs{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecLoggingInfoBrokerLogsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecLoggingInfoBrokerLogs)(ptr) = ClusterSpecLoggingInfoBrokerLogs{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecLoggingInfoBrokerLogs

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingInfoBrokerLogs{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecLoggingInfoBrokerLogs)(ptr) = objs[0]
			} else {
				*(*ClusterSpecLoggingInfoBrokerLogs)(ptr) = ClusterSpecLoggingInfoBrokerLogs{}
			}
		} else {
			*(*ClusterSpecLoggingInfoBrokerLogs)(ptr) = ClusterSpecLoggingInfoBrokerLogs{}
		}
	default:
		iter.ReportError("decode ClusterSpecLoggingInfoBrokerLogs", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecLoggingInfoBrokerLogsCloudwatchLogsCodec struct {
}

func (ClusterSpecLoggingInfoBrokerLogsCloudwatchLogsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecLoggingInfoBrokerLogsCloudwatchLogs)(ptr) == nil
}

func (ClusterSpecLoggingInfoBrokerLogsCloudwatchLogsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecLoggingInfoBrokerLogsCloudwatchLogs)(ptr)
	var objs []ClusterSpecLoggingInfoBrokerLogsCloudwatchLogs
	if obj != nil {
		objs = []ClusterSpecLoggingInfoBrokerLogsCloudwatchLogs{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingInfoBrokerLogsCloudwatchLogs{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecLoggingInfoBrokerLogsCloudwatchLogsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecLoggingInfoBrokerLogsCloudwatchLogs)(ptr) = ClusterSpecLoggingInfoBrokerLogsCloudwatchLogs{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecLoggingInfoBrokerLogsCloudwatchLogs

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingInfoBrokerLogsCloudwatchLogs{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecLoggingInfoBrokerLogsCloudwatchLogs)(ptr) = objs[0]
			} else {
				*(*ClusterSpecLoggingInfoBrokerLogsCloudwatchLogs)(ptr) = ClusterSpecLoggingInfoBrokerLogsCloudwatchLogs{}
			}
		} else {
			*(*ClusterSpecLoggingInfoBrokerLogsCloudwatchLogs)(ptr) = ClusterSpecLoggingInfoBrokerLogsCloudwatchLogs{}
		}
	default:
		iter.ReportError("decode ClusterSpecLoggingInfoBrokerLogsCloudwatchLogs", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecLoggingInfoBrokerLogsFirehoseCodec struct {
}

func (ClusterSpecLoggingInfoBrokerLogsFirehoseCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecLoggingInfoBrokerLogsFirehose)(ptr) == nil
}

func (ClusterSpecLoggingInfoBrokerLogsFirehoseCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecLoggingInfoBrokerLogsFirehose)(ptr)
	var objs []ClusterSpecLoggingInfoBrokerLogsFirehose
	if obj != nil {
		objs = []ClusterSpecLoggingInfoBrokerLogsFirehose{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingInfoBrokerLogsFirehose{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecLoggingInfoBrokerLogsFirehoseCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecLoggingInfoBrokerLogsFirehose)(ptr) = ClusterSpecLoggingInfoBrokerLogsFirehose{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecLoggingInfoBrokerLogsFirehose

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingInfoBrokerLogsFirehose{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecLoggingInfoBrokerLogsFirehose)(ptr) = objs[0]
			} else {
				*(*ClusterSpecLoggingInfoBrokerLogsFirehose)(ptr) = ClusterSpecLoggingInfoBrokerLogsFirehose{}
			}
		} else {
			*(*ClusterSpecLoggingInfoBrokerLogsFirehose)(ptr) = ClusterSpecLoggingInfoBrokerLogsFirehose{}
		}
	default:
		iter.ReportError("decode ClusterSpecLoggingInfoBrokerLogsFirehose", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecLoggingInfoBrokerLogsS3Codec struct {
}

func (ClusterSpecLoggingInfoBrokerLogsS3Codec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecLoggingInfoBrokerLogsS3)(ptr) == nil
}

func (ClusterSpecLoggingInfoBrokerLogsS3Codec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecLoggingInfoBrokerLogsS3)(ptr)
	var objs []ClusterSpecLoggingInfoBrokerLogsS3
	if obj != nil {
		objs = []ClusterSpecLoggingInfoBrokerLogsS3{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingInfoBrokerLogsS3{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecLoggingInfoBrokerLogsS3Codec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecLoggingInfoBrokerLogsS3)(ptr) = ClusterSpecLoggingInfoBrokerLogsS3{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecLoggingInfoBrokerLogsS3

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecLoggingInfoBrokerLogsS3{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecLoggingInfoBrokerLogsS3)(ptr) = objs[0]
			} else {
				*(*ClusterSpecLoggingInfoBrokerLogsS3)(ptr) = ClusterSpecLoggingInfoBrokerLogsS3{}
			}
		} else {
			*(*ClusterSpecLoggingInfoBrokerLogsS3)(ptr) = ClusterSpecLoggingInfoBrokerLogsS3{}
		}
	default:
		iter.ReportError("decode ClusterSpecLoggingInfoBrokerLogsS3", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecOpenMonitoringCodec struct {
}

func (ClusterSpecOpenMonitoringCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecOpenMonitoring)(ptr) == nil
}

func (ClusterSpecOpenMonitoringCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecOpenMonitoring)(ptr)
	var objs []ClusterSpecOpenMonitoring
	if obj != nil {
		objs = []ClusterSpecOpenMonitoring{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOpenMonitoring{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecOpenMonitoringCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecOpenMonitoring)(ptr) = ClusterSpecOpenMonitoring{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecOpenMonitoring

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOpenMonitoring{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecOpenMonitoring)(ptr) = objs[0]
			} else {
				*(*ClusterSpecOpenMonitoring)(ptr) = ClusterSpecOpenMonitoring{}
			}
		} else {
			*(*ClusterSpecOpenMonitoring)(ptr) = ClusterSpecOpenMonitoring{}
		}
	default:
		iter.ReportError("decode ClusterSpecOpenMonitoring", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecOpenMonitoringPrometheusCodec struct {
}

func (ClusterSpecOpenMonitoringPrometheusCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecOpenMonitoringPrometheus)(ptr) == nil
}

func (ClusterSpecOpenMonitoringPrometheusCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecOpenMonitoringPrometheus)(ptr)
	var objs []ClusterSpecOpenMonitoringPrometheus
	if obj != nil {
		objs = []ClusterSpecOpenMonitoringPrometheus{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOpenMonitoringPrometheus{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecOpenMonitoringPrometheusCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecOpenMonitoringPrometheus)(ptr) = ClusterSpecOpenMonitoringPrometheus{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecOpenMonitoringPrometheus

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOpenMonitoringPrometheus{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecOpenMonitoringPrometheus)(ptr) = objs[0]
			} else {
				*(*ClusterSpecOpenMonitoringPrometheus)(ptr) = ClusterSpecOpenMonitoringPrometheus{}
			}
		} else {
			*(*ClusterSpecOpenMonitoringPrometheus)(ptr) = ClusterSpecOpenMonitoringPrometheus{}
		}
	default:
		iter.ReportError("decode ClusterSpecOpenMonitoringPrometheus", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecOpenMonitoringPrometheusJmxExporterCodec struct {
}

func (ClusterSpecOpenMonitoringPrometheusJmxExporterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecOpenMonitoringPrometheusJmxExporter)(ptr) == nil
}

func (ClusterSpecOpenMonitoringPrometheusJmxExporterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecOpenMonitoringPrometheusJmxExporter)(ptr)
	var objs []ClusterSpecOpenMonitoringPrometheusJmxExporter
	if obj != nil {
		objs = []ClusterSpecOpenMonitoringPrometheusJmxExporter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOpenMonitoringPrometheusJmxExporter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecOpenMonitoringPrometheusJmxExporterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecOpenMonitoringPrometheusJmxExporter)(ptr) = ClusterSpecOpenMonitoringPrometheusJmxExporter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecOpenMonitoringPrometheusJmxExporter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOpenMonitoringPrometheusJmxExporter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecOpenMonitoringPrometheusJmxExporter)(ptr) = objs[0]
			} else {
				*(*ClusterSpecOpenMonitoringPrometheusJmxExporter)(ptr) = ClusterSpecOpenMonitoringPrometheusJmxExporter{}
			}
		} else {
			*(*ClusterSpecOpenMonitoringPrometheusJmxExporter)(ptr) = ClusterSpecOpenMonitoringPrometheusJmxExporter{}
		}
	default:
		iter.ReportError("decode ClusterSpecOpenMonitoringPrometheusJmxExporter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ClusterSpecOpenMonitoringPrometheusNodeExporterCodec struct {
}

func (ClusterSpecOpenMonitoringPrometheusNodeExporterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ClusterSpecOpenMonitoringPrometheusNodeExporter)(ptr) == nil
}

func (ClusterSpecOpenMonitoringPrometheusNodeExporterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ClusterSpecOpenMonitoringPrometheusNodeExporter)(ptr)
	var objs []ClusterSpecOpenMonitoringPrometheusNodeExporter
	if obj != nil {
		objs = []ClusterSpecOpenMonitoringPrometheusNodeExporter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOpenMonitoringPrometheusNodeExporter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ClusterSpecOpenMonitoringPrometheusNodeExporterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ClusterSpecOpenMonitoringPrometheusNodeExporter)(ptr) = ClusterSpecOpenMonitoringPrometheusNodeExporter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ClusterSpecOpenMonitoringPrometheusNodeExporter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ClusterSpecOpenMonitoringPrometheusNodeExporter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ClusterSpecOpenMonitoringPrometheusNodeExporter)(ptr) = objs[0]
			} else {
				*(*ClusterSpecOpenMonitoringPrometheusNodeExporter)(ptr) = ClusterSpecOpenMonitoringPrometheusNodeExporter{}
			}
		} else {
			*(*ClusterSpecOpenMonitoringPrometheusNodeExporter)(ptr) = ClusterSpecOpenMonitoringPrometheusNodeExporter{}
		}
	default:
		iter.ReportError("decode ClusterSpecOpenMonitoringPrometheusNodeExporter", "unexpected JSON type")
	}
}
