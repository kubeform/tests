/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfiguration{}).Type1()):                                                                                                                ApplicationSpecApplicationConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationApplicationCodeConfiguration{}).Type1()):                                                                                    ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContent{}).Type1()):                                                                         ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation{}).Type1()):                                                        ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationApplicationSnapshotConfiguration{}).Type1()):                                                                                ApplicationSpecApplicationConfigurationApplicationSnapshotConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationEnvironmentProperties{}).Type1()):                                                                                           ApplicationSpecApplicationConfigurationEnvironmentPropertiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationFlinkApplicationConfiguration{}).Type1()):                                                                                   ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration{}).Type1()):                                                            ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCheckpointConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration{}).Type1()):                                                            ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationMonitoringConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration{}).Type1()):                                                           ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationParallelismConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationRunConfiguration{}).Type1()):                                                                                                ApplicationSpecApplicationConfigurationRunConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationRunConfigurationApplicationRestoreConfiguration{}).Type1()):                                                                 ApplicationSpecApplicationConfigurationRunConfigurationApplicationRestoreConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationRunConfigurationFlinkRunConfiguration{}).Type1()):                                                                           ApplicationSpecApplicationConfigurationRunConfigurationFlinkRunConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfiguration{}).Type1()):                                                                                     ApplicationSpecApplicationConfigurationSqlApplicationConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInput{}).Type1()):                                                                                ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputParallelism{}).Type1()):                                                                ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputParallelismCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration{}).Type1()):                                                    ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor{}).Type1()):                                ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchema{}).Type1()):                                                                     ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat{}).Type1()):                                                         ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters{}).Type1()):                                        ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters{}).Type1()):                    ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters{}).Type1()):                   ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput{}).Type1()):                                                            ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInputCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput{}).Type1()):                                                             ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema{}).Type1()):                                                              ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchemaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput{}).Type1()):                                                          ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput{}).Type1()):                                                           ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutputCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput{}).Type1()):                                                                   ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSource{}).Type1()):                                                                  ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema{}).Type1()):                                                   ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat{}).Type1()):                                       ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters{}).Type1()):                      ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters{}).Type1()):  ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters{}).Type1()): ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource{}).Type1()):                                             ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationVpcConfiguration{}).Type1()):                                                                                                ApplicationSpecApplicationConfigurationVpcConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecCloudwatchLoggingOptions{}).Type1()):                                                                                                                ApplicationSpecCloudwatchLoggingOptionsCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfiguration{}).Type1()):                                                                                                                ApplicationSpecApplicationConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationApplicationCodeConfiguration{}).Type1()):                                                                                    ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContent{}).Type1()):                                                                         ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation{}).Type1()):                                                        ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationApplicationSnapshotConfiguration{}).Type1()):                                                                                ApplicationSpecApplicationConfigurationApplicationSnapshotConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationEnvironmentProperties{}).Type1()):                                                                                           ApplicationSpecApplicationConfigurationEnvironmentPropertiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationFlinkApplicationConfiguration{}).Type1()):                                                                                   ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration{}).Type1()):                                                            ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCheckpointConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration{}).Type1()):                                                            ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationMonitoringConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration{}).Type1()):                                                           ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationParallelismConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationRunConfiguration{}).Type1()):                                                                                                ApplicationSpecApplicationConfigurationRunConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationRunConfigurationApplicationRestoreConfiguration{}).Type1()):                                                                 ApplicationSpecApplicationConfigurationRunConfigurationApplicationRestoreConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationRunConfigurationFlinkRunConfiguration{}).Type1()):                                                                           ApplicationSpecApplicationConfigurationRunConfigurationFlinkRunConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfiguration{}).Type1()):                                                                                     ApplicationSpecApplicationConfigurationSqlApplicationConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInput{}).Type1()):                                                                                ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputParallelism{}).Type1()):                                                                ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputParallelismCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration{}).Type1()):                                                    ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor{}).Type1()):                                ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchema{}).Type1()):                                                                     ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat{}).Type1()):                                                         ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters{}).Type1()):                                        ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters{}).Type1()):                    ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters{}).Type1()):                   ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput{}).Type1()):                                                            ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInputCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput{}).Type1()):                                                             ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema{}).Type1()):                                                              ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchemaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput{}).Type1()):                                                          ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput{}).Type1()):                                                           ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutputCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput{}).Type1()):                                                                   ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSource{}).Type1()):                                                                  ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema{}).Type1()):                                                   ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat{}).Type1()):                                       ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters{}).Type1()):                      ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters{}).Type1()):  ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters{}).Type1()): ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParametersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource{}).Type1()):                                             ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationVpcConfiguration{}).Type1()):                                                                                                ApplicationSpecApplicationConfigurationVpcConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecCloudwatchLoggingOptions{}).Type1()):                                                                                                                ApplicationSpecCloudwatchLoggingOptionsCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationCodec struct {
}

func (ApplicationSpecApplicationConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfiguration)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfiguration)(ptr)
	var objs []ApplicationSpecApplicationConfiguration
	if obj != nil {
		objs = []ApplicationSpecApplicationConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfiguration)(ptr) = ApplicationSpecApplicationConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfiguration)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfiguration)(ptr) = ApplicationSpecApplicationConfiguration{}
			}
		} else {
			*(*ApplicationSpecApplicationConfiguration)(ptr) = ApplicationSpecApplicationConfiguration{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodec struct {
}

func (ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationApplicationCodeConfiguration)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationApplicationCodeConfiguration)(ptr)
	var objs []ApplicationSpecApplicationConfigurationApplicationCodeConfiguration
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationApplicationCodeConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationApplicationCodeConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationApplicationCodeConfiguration)(ptr) = ApplicationSpecApplicationConfigurationApplicationCodeConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationApplicationCodeConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationApplicationCodeConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationApplicationCodeConfiguration)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationApplicationCodeConfiguration)(ptr) = ApplicationSpecApplicationConfigurationApplicationCodeConfiguration{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationApplicationCodeConfiguration)(ptr) = ApplicationSpecApplicationConfigurationApplicationCodeConfiguration{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationApplicationCodeConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentCodec struct {
}

func (ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContent)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContent)(ptr)
	var objs []ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContent
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContent{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContent{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContent)(ptr) = ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContent{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContent

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContent{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContent)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContent)(ptr) = ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContent{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContent)(ptr) = ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContent{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContent", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationCodec struct {
}

func (ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation)(ptr)
	var objs []ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation)(ptr) = ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation)(ptr) = ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation)(ptr) = ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationApplicationCodeConfigurationCodeContentS3ContentLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationApplicationSnapshotConfigurationCodec struct {
}

func (ApplicationSpecApplicationConfigurationApplicationSnapshotConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationApplicationSnapshotConfiguration)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationApplicationSnapshotConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationApplicationSnapshotConfiguration)(ptr)
	var objs []ApplicationSpecApplicationConfigurationApplicationSnapshotConfiguration
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationApplicationSnapshotConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationApplicationSnapshotConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationApplicationSnapshotConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationApplicationSnapshotConfiguration)(ptr) = ApplicationSpecApplicationConfigurationApplicationSnapshotConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationApplicationSnapshotConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationApplicationSnapshotConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationApplicationSnapshotConfiguration)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationApplicationSnapshotConfiguration)(ptr) = ApplicationSpecApplicationConfigurationApplicationSnapshotConfiguration{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationApplicationSnapshotConfiguration)(ptr) = ApplicationSpecApplicationConfigurationApplicationSnapshotConfiguration{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationApplicationSnapshotConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationEnvironmentPropertiesCodec struct {
}

func (ApplicationSpecApplicationConfigurationEnvironmentPropertiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationEnvironmentProperties)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationEnvironmentPropertiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationEnvironmentProperties)(ptr)
	var objs []ApplicationSpecApplicationConfigurationEnvironmentProperties
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationEnvironmentProperties{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationEnvironmentProperties{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationEnvironmentPropertiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationEnvironmentProperties)(ptr) = ApplicationSpecApplicationConfigurationEnvironmentProperties{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationEnvironmentProperties

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationEnvironmentProperties{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationEnvironmentProperties)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationEnvironmentProperties)(ptr) = ApplicationSpecApplicationConfigurationEnvironmentProperties{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationEnvironmentProperties)(ptr) = ApplicationSpecApplicationConfigurationEnvironmentProperties{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationEnvironmentProperties", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCodec struct {
}

func (ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationFlinkApplicationConfiguration)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationFlinkApplicationConfiguration)(ptr)
	var objs []ApplicationSpecApplicationConfigurationFlinkApplicationConfiguration
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationFlinkApplicationConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationFlinkApplicationConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationFlinkApplicationConfiguration)(ptr) = ApplicationSpecApplicationConfigurationFlinkApplicationConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationFlinkApplicationConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationFlinkApplicationConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationFlinkApplicationConfiguration)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationFlinkApplicationConfiguration)(ptr) = ApplicationSpecApplicationConfigurationFlinkApplicationConfiguration{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationFlinkApplicationConfiguration)(ptr) = ApplicationSpecApplicationConfigurationFlinkApplicationConfiguration{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationFlinkApplicationConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCheckpointConfigurationCodec struct {
}

func (ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCheckpointConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCheckpointConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration)(ptr)
	var objs []ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCheckpointConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration)(ptr) = ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration)(ptr) = ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration)(ptr) = ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationCheckpointConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationMonitoringConfigurationCodec struct {
}

func (ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationMonitoringConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationMonitoringConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration)(ptr)
	var objs []ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationMonitoringConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration)(ptr) = ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration)(ptr) = ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration)(ptr) = ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationMonitoringConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationParallelismConfigurationCodec struct {
}

func (ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationParallelismConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationParallelismConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration)(ptr)
	var objs []ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationParallelismConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration)(ptr) = ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration)(ptr) = ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration)(ptr) = ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationFlinkApplicationConfigurationParallelismConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationRunConfigurationCodec struct {
}

func (ApplicationSpecApplicationConfigurationRunConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationRunConfiguration)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationRunConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationRunConfiguration)(ptr)
	var objs []ApplicationSpecApplicationConfigurationRunConfiguration
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationRunConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationRunConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationRunConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationRunConfiguration)(ptr) = ApplicationSpecApplicationConfigurationRunConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationRunConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationRunConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationRunConfiguration)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationRunConfiguration)(ptr) = ApplicationSpecApplicationConfigurationRunConfiguration{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationRunConfiguration)(ptr) = ApplicationSpecApplicationConfigurationRunConfiguration{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationRunConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationRunConfigurationApplicationRestoreConfigurationCodec struct {
}

func (ApplicationSpecApplicationConfigurationRunConfigurationApplicationRestoreConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationRunConfigurationApplicationRestoreConfiguration)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationRunConfigurationApplicationRestoreConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationRunConfigurationApplicationRestoreConfiguration)(ptr)
	var objs []ApplicationSpecApplicationConfigurationRunConfigurationApplicationRestoreConfiguration
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationRunConfigurationApplicationRestoreConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationRunConfigurationApplicationRestoreConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationRunConfigurationApplicationRestoreConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationRunConfigurationApplicationRestoreConfiguration)(ptr) = ApplicationSpecApplicationConfigurationRunConfigurationApplicationRestoreConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationRunConfigurationApplicationRestoreConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationRunConfigurationApplicationRestoreConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationRunConfigurationApplicationRestoreConfiguration)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationRunConfigurationApplicationRestoreConfiguration)(ptr) = ApplicationSpecApplicationConfigurationRunConfigurationApplicationRestoreConfiguration{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationRunConfigurationApplicationRestoreConfiguration)(ptr) = ApplicationSpecApplicationConfigurationRunConfigurationApplicationRestoreConfiguration{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationRunConfigurationApplicationRestoreConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationRunConfigurationFlinkRunConfigurationCodec struct {
}

func (ApplicationSpecApplicationConfigurationRunConfigurationFlinkRunConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationRunConfigurationFlinkRunConfiguration)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationRunConfigurationFlinkRunConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationRunConfigurationFlinkRunConfiguration)(ptr)
	var objs []ApplicationSpecApplicationConfigurationRunConfigurationFlinkRunConfiguration
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationRunConfigurationFlinkRunConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationRunConfigurationFlinkRunConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationRunConfigurationFlinkRunConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationRunConfigurationFlinkRunConfiguration)(ptr) = ApplicationSpecApplicationConfigurationRunConfigurationFlinkRunConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationRunConfigurationFlinkRunConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationRunConfigurationFlinkRunConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationRunConfigurationFlinkRunConfiguration)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationRunConfigurationFlinkRunConfiguration)(ptr) = ApplicationSpecApplicationConfigurationRunConfigurationFlinkRunConfiguration{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationRunConfigurationFlinkRunConfiguration)(ptr) = ApplicationSpecApplicationConfigurationRunConfigurationFlinkRunConfiguration{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationRunConfigurationFlinkRunConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationSqlApplicationConfigurationCodec struct {
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationSqlApplicationConfiguration)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationSqlApplicationConfiguration)(ptr)
	var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfiguration
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationSqlApplicationConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationSqlApplicationConfiguration)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfiguration)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfiguration)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfiguration{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationSqlApplicationConfiguration)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfiguration{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationSqlApplicationConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputCodec struct {
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInput)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInput)(ptr)
	var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInput
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInput{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInput{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInput)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInput{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInput

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInput{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInput)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInput)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInput{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInput)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInput{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInput", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputParallelismCodec struct {
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputParallelismCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputParallelism)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputParallelismCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputParallelism)(ptr)
	var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputParallelism
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputParallelism{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputParallelism{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputParallelismCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputParallelism)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputParallelism{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputParallelism

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputParallelism{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputParallelism)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputParallelism)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputParallelism{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputParallelism)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputParallelism{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputParallelism", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationCodec struct {
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration)(ptr)
	var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessorCodec struct {
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor)(ptr)
	var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputProcessingConfigurationInputLambdaProcessor", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaCodec struct {
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchema)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchema)(ptr)
	var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchema
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchema{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchema{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchema)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchema{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchema

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchema{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchema)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchema)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchema{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchema)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchema{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchema", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatCodec struct {
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat)(ptr)
	var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormat", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCodec struct {
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters)(ptr)
	var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParameters", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParametersCodec struct {
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParametersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParametersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters)(ptr)
	var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParametersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersCsvMappingParameters", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParametersCodec struct {
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParametersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParametersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters)(ptr)
	var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParametersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputInputSchemaRecordFormatMappingParametersJsonMappingParameters", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInputCodec struct {
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInputCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInputCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput)(ptr)
	var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInputCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisFirehoseInput", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputCodec struct {
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput)(ptr)
	var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInputCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationSqlApplicationConfigurationInputKinesisStreamsInput", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchemaCodec struct {
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchemaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchemaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema)(ptr)
	var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchemaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputDestinationSchema", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputCodec struct {
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput)(ptr)
	var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutputCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisFirehoseOutput", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutputCodec struct {
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutputCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutputCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput)(ptr)
	var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutputCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputKinesisStreamsOutput", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputCodec struct {
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput)(ptr)
	var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutputCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationSqlApplicationConfigurationOutputLambdaOutput", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceCodec struct {
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSource)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSource)(ptr)
	var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSource
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSource)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSource)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSource)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSource{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSource)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSource{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSource", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaCodec struct {
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema)(ptr)
	var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchema", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatCodec struct {
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat)(ptr)
	var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormat", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCodec struct {
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters)(ptr)
	var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParameters", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParametersCodec struct {
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParametersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParametersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters)(ptr)
	var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParametersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersCsvMappingParameters", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParametersCodec struct {
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParametersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParametersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters)(ptr)
	var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParametersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceReferenceSchemaRecordFormatMappingParametersJsonMappingParameters", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceCodec struct {
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource)(ptr)
	var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSourceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource)(ptr) = ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationSqlApplicationConfigurationReferenceDataSourceS3ReferenceDataSource", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecApplicationConfigurationVpcConfigurationCodec struct {
}

func (ApplicationSpecApplicationConfigurationVpcConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecApplicationConfigurationVpcConfiguration)(ptr) == nil
}

func (ApplicationSpecApplicationConfigurationVpcConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecApplicationConfigurationVpcConfiguration)(ptr)
	var objs []ApplicationSpecApplicationConfigurationVpcConfiguration
	if obj != nil {
		objs = []ApplicationSpecApplicationConfigurationVpcConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationVpcConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecApplicationConfigurationVpcConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecApplicationConfigurationVpcConfiguration)(ptr) = ApplicationSpecApplicationConfigurationVpcConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecApplicationConfigurationVpcConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecApplicationConfigurationVpcConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecApplicationConfigurationVpcConfiguration)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecApplicationConfigurationVpcConfiguration)(ptr) = ApplicationSpecApplicationConfigurationVpcConfiguration{}
			}
		} else {
			*(*ApplicationSpecApplicationConfigurationVpcConfiguration)(ptr) = ApplicationSpecApplicationConfigurationVpcConfiguration{}
		}
	default:
		iter.ReportError("decode ApplicationSpecApplicationConfigurationVpcConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApplicationSpecCloudwatchLoggingOptionsCodec struct {
}

func (ApplicationSpecCloudwatchLoggingOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApplicationSpecCloudwatchLoggingOptions)(ptr) == nil
}

func (ApplicationSpecCloudwatchLoggingOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApplicationSpecCloudwatchLoggingOptions)(ptr)
	var objs []ApplicationSpecCloudwatchLoggingOptions
	if obj != nil {
		objs = []ApplicationSpecCloudwatchLoggingOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecCloudwatchLoggingOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApplicationSpecCloudwatchLoggingOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApplicationSpecCloudwatchLoggingOptions)(ptr) = ApplicationSpecCloudwatchLoggingOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApplicationSpecCloudwatchLoggingOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApplicationSpecCloudwatchLoggingOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApplicationSpecCloudwatchLoggingOptions)(ptr) = objs[0]
			} else {
				*(*ApplicationSpecCloudwatchLoggingOptions)(ptr) = ApplicationSpecCloudwatchLoggingOptions{}
			}
		} else {
			*(*ApplicationSpecCloudwatchLoggingOptions)(ptr) = ApplicationSpecCloudwatchLoggingOptions{}
		}
	default:
		iter.ReportError("decode ApplicationSpecCloudwatchLoggingOptions", "unexpected JSON type")
	}
}
