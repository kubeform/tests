/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	base "kubeform.dev/apimachinery/api/v1alpha1"

	core "k8s.io/api/core/v1"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	kmapi "kmodules.xyz/client-go/api/v1"
)

// +genclient
// +k8s:openapi-gen=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true
// +kubebuilder:subresource:status
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`

type ElasticsearchDomain struct {
	metav1.TypeMeta   `json:",inline,omitempty"`
	metav1.ObjectMeta `json:"metadata,omitempty"`
	Spec              ElasticsearchDomainSpec   `json:"spec,omitempty"`
	Status            ElasticsearchDomainStatus `json:"status,omitempty"`
}

type ElasticsearchDomainSpec struct {
	ElasticsearchDomainSpec2 `json:",inline"`
	// +optional
	KubeformOutput ElasticsearchDomainSpec2 `json:"kubeformOutput,omitempty" tf:"-"`
}

type ElasticsearchDomainSpecAdvancedSecurityOptionsMasterUserOptions struct {
	// +optional
	MasterUserArn *string `json:"masterUserArn,omitempty" tf:"master_user_arn"`
	// +optional
	MasterUserName *string `json:"masterUserName,omitempty" tf:"master_user_name"`
	// +optional
	MasterUserPassword *string `json:"-" sensitive:"true" tf:"master_user_password"`
}

type ElasticsearchDomainSpecAdvancedSecurityOptions struct {
	Enabled *bool `json:"enabled" tf:"enabled"`
	// +optional
	InternalUserDatabaseEnabled *bool `json:"internalUserDatabaseEnabled,omitempty" tf:"internal_user_database_enabled"`
	// +optional
	MasterUserOptions *ElasticsearchDomainSpecAdvancedSecurityOptionsMasterUserOptions `json:"masterUserOptions,omitempty" tf:"master_user_options"`
}

type ElasticsearchDomainSpecClusterConfigZoneAwarenessConfig struct {
	// +optional
	AvailabilityZoneCount *int64 `json:"availabilityZoneCount,omitempty" tf:"availability_zone_count"`
}

type ElasticsearchDomainSpecClusterConfig struct {
	// +optional
	DedicatedMasterCount *int64 `json:"dedicatedMasterCount,omitempty" tf:"dedicated_master_count"`
	// +optional
	DedicatedMasterEnabled *bool `json:"dedicatedMasterEnabled,omitempty" tf:"dedicated_master_enabled"`
	// +optional
	DedicatedMasterType *string `json:"dedicatedMasterType,omitempty" tf:"dedicated_master_type"`
	// +optional
	InstanceCount *int64 `json:"instanceCount,omitempty" tf:"instance_count"`
	// +optional
	InstanceType *string `json:"instanceType,omitempty" tf:"instance_type"`
	// +optional
	WarmCount *int64 `json:"warmCount,omitempty" tf:"warm_count"`
	// +optional
	WarmEnabled *bool `json:"warmEnabled,omitempty" tf:"warm_enabled"`
	// +optional
	WarmType *string `json:"warmType,omitempty" tf:"warm_type"`
	// +optional
	ZoneAwarenessConfig *ElasticsearchDomainSpecClusterConfigZoneAwarenessConfig `json:"zoneAwarenessConfig,omitempty" tf:"zone_awareness_config"`
	// +optional
	ZoneAwarenessEnabled *bool `json:"zoneAwarenessEnabled,omitempty" tf:"zone_awareness_enabled"`
}

type ElasticsearchDomainSpecCognitoOptions struct {
	// +optional
	Enabled        *bool   `json:"enabled,omitempty" tf:"enabled"`
	IdentityPoolID *string `json:"identityPoolID" tf:"identity_pool_id"`
	RoleArn        *string `json:"roleArn" tf:"role_arn"`
	UserPoolID     *string `json:"userPoolID" tf:"user_pool_id"`
}

type ElasticsearchDomainSpecDomainEndpointOptions struct {
	// +optional
	CustomEndpoint *string `json:"customEndpoint,omitempty" tf:"custom_endpoint"`
	// +optional
	CustomEndpointCertificateArn *string `json:"customEndpointCertificateArn,omitempty" tf:"custom_endpoint_certificate_arn"`
	// +optional
	CustomEndpointEnabled *bool `json:"customEndpointEnabled,omitempty" tf:"custom_endpoint_enabled"`
	// +optional
	EnforceHTTPS *bool `json:"enforceHTTPS,omitempty" tf:"enforce_https"`
	// +optional
	TlsSecurityPolicy *string `json:"tlsSecurityPolicy,omitempty" tf:"tls_security_policy"`
}

type ElasticsearchDomainSpecEbsOptions struct {
	EbsEnabled *bool `json:"ebsEnabled" tf:"ebs_enabled"`
	// +optional
	Iops *int64 `json:"iops,omitempty" tf:"iops"`
	// +optional
	VolumeSize *int64 `json:"volumeSize,omitempty" tf:"volume_size"`
	// +optional
	VolumeType *string `json:"volumeType,omitempty" tf:"volume_type"`
}

type ElasticsearchDomainSpecEncryptAtRest struct {
	Enabled *bool `json:"enabled" tf:"enabled"`
	// +optional
	KmsKeyID *string `json:"kmsKeyID,omitempty" tf:"kms_key_id"`
}

type ElasticsearchDomainSpecLogPublishingOptions struct {
	CloudwatchLogGroupArn *string `json:"cloudwatchLogGroupArn" tf:"cloudwatch_log_group_arn"`
	// +optional
	Enabled *bool   `json:"enabled,omitempty" tf:"enabled"`
	LogType *string `json:"logType" tf:"log_type"`
}

type ElasticsearchDomainSpecNodeToNodeEncryption struct {
	Enabled *bool `json:"enabled" tf:"enabled"`
}

type ElasticsearchDomainSpecSnapshotOptions struct {
	AutomatedSnapshotStartHour *int64 `json:"automatedSnapshotStartHour" tf:"automated_snapshot_start_hour"`
}

type ElasticsearchDomainSpecVpcOptions struct {
	// +optional
	AvailabilityZones []string `json:"availabilityZones,omitempty" tf:"availability_zones"`
	// +optional
	SecurityGroupIDS []string `json:"securityGroupIDS,omitempty" tf:"security_group_ids"`
	// +optional
	SubnetIDS []string `json:"subnetIDS,omitempty" tf:"subnet_ids"`
	// +optional
	VpcID *string `json:"vpcID,omitempty" tf:"vpc_id"`
}

type ElasticsearchDomainSpec2 struct {
	TerminationPolicy base.TerminationPolicy `json:"terminationPolicy,omitempty" tf:"-"`

	Timeouts *base.ResourceTimeout `json:"timeouts,omitempty" tf:"timeouts"`

	ProviderRef core.LocalObjectReference `json:"providerRef" tf:"-"`

	ID string `json:"id,omitempty" tf:"id,omitempty"`

	SecretRef *core.LocalObjectReference `json:"secretRef,omitempty" tf:"-"`

	// +optional
	AccessPolicies *string `json:"accessPolicies,omitempty" tf:"access_policies"`
	// +optional
	AdvancedOptions *map[string]string `json:"advancedOptions,omitempty" tf:"advanced_options"`
	// +optional
	AdvancedSecurityOptions *ElasticsearchDomainSpecAdvancedSecurityOptions `json:"advancedSecurityOptions,omitempty" tf:"advanced_security_options"`
	// +optional
	Arn *string `json:"arn,omitempty" tf:"arn"`
	// +optional
	ClusterConfig *ElasticsearchDomainSpecClusterConfig `json:"clusterConfig,omitempty" tf:"cluster_config"`
	// +optional
	CognitoOptions *ElasticsearchDomainSpecCognitoOptions `json:"cognitoOptions,omitempty" tf:"cognito_options"`
	// +optional
	DomainEndpointOptions *ElasticsearchDomainSpecDomainEndpointOptions `json:"domainEndpointOptions,omitempty" tf:"domain_endpoint_options"`
	// +optional
	DomainID   *string `json:"domainID,omitempty" tf:"domain_id"`
	DomainName *string `json:"domainName" tf:"domain_name"`
	// +optional
	EbsOptions *ElasticsearchDomainSpecEbsOptions `json:"ebsOptions,omitempty" tf:"ebs_options"`
	// +optional
	ElasticsearchVersion *string `json:"elasticsearchVersion,omitempty" tf:"elasticsearch_version"`
	// +optional
	EncryptAtRest *ElasticsearchDomainSpecEncryptAtRest `json:"encryptAtRest,omitempty" tf:"encrypt_at_rest"`
	// +optional
	Endpoint *string `json:"endpoint,omitempty" tf:"endpoint"`
	// +optional
	KibanaEndpoint *string `json:"kibanaEndpoint,omitempty" tf:"kibana_endpoint"`
	// +optional
	LogPublishingOptions []ElasticsearchDomainSpecLogPublishingOptions `json:"logPublishingOptions,omitempty" tf:"log_publishing_options"`
	// +optional
	NodeToNodeEncryption *ElasticsearchDomainSpecNodeToNodeEncryption `json:"nodeToNodeEncryption,omitempty" tf:"node_to_node_encryption"`
	// +optional
	SnapshotOptions *ElasticsearchDomainSpecSnapshotOptions `json:"snapshotOptions,omitempty" tf:"snapshot_options"`
	// +optional
	Tags *map[string]string `json:"tags,omitempty" tf:"tags"`
	// +optional
	VpcOptions *ElasticsearchDomainSpecVpcOptions `json:"vpcOptions,omitempty" tf:"vpc_options"`
}

type ElasticsearchDomainStatus struct {
	// Resource generation, which is updated on mutation by the API Server.
	// +optional
	ObservedGeneration int64 `json:"observedGeneration,omitempty"`
	// +optional
	Phase base.Phase `json:"phase,omitempty"`
	// +optional
	Conditions []kmapi.Condition `json:"conditions,omitempty"`
}

// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +kubebuilder:object:root=true

// ElasticsearchDomainList is a list of ElasticsearchDomains
type ElasticsearchDomainList struct {
	metav1.TypeMeta `json:",inline"`
	metav1.ListMeta `json:"metadata,omitempty"`
	// Items is a list of ElasticsearchDomain CRD objects
	Items []ElasticsearchDomain `json:"items,omitempty"`
}
