/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AccessPointSpecPublicAccessBlockConfiguration{}).Type1()):                                                AccessPointSpecPublicAccessBlockConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccessPointSpecVpcConfiguration{}).Type1()):                                                              AccessPointSpecVpcConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecLifecycleRuleExpiration{}).Type1()):                                                            BucketSpecLifecycleRuleExpirationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecLifecycleRuleNoncurrentVersionExpiration{}).Type1()):                                           BucketSpecLifecycleRuleNoncurrentVersionExpirationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecObjectLockConfiguration{}).Type1()):                                                            BucketSpecObjectLockConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecObjectLockConfigurationRule{}).Type1()):                                                        BucketSpecObjectLockConfigurationRuleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecObjectLockConfigurationRuleDefaultRetention{}).Type1()):                                        BucketSpecObjectLockConfigurationRuleDefaultRetentionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfiguration{}).Type1()):                                                           BucketSpecReplicationConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfigurationRulesDestination{}).Type1()):                                           BucketSpecReplicationConfigurationRulesDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfigurationRulesDestinationAccessControlTranslation{}).Type1()):                   BucketSpecReplicationConfigurationRulesDestinationAccessControlTranslationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfigurationRulesFilter{}).Type1()):                                                BucketSpecReplicationConfigurationRulesFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfigurationRulesSourceSelectionCriteria{}).Type1()):                               BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects{}).Type1()):         BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjectsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecServerSideEncryptionConfiguration{}).Type1()):                                                  BucketSpecServerSideEncryptionConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecServerSideEncryptionConfigurationRule{}).Type1()):                                              BucketSpecServerSideEncryptionConfigurationRuleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault{}).Type1()):            BucketSpecServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecVersioning{}).Type1()):                                                                         BucketSpecVersioningCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecWebsite{}).Type1()):                                                                            BucketSpecWebsiteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecFilter{}).Type1()):                                                       BucketAnalyticsConfigurationSpecFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysis{}).Type1()):                                         BucketAnalyticsConfigurationSpecStorageClassAnalysisCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport{}).Type1()):                               BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination{}).Type1()):                    BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination{}).Type1()): BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestination{}).Type1()):                                                               BucketInventorySpecDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucket{}).Type1()):                                                         BucketInventorySpecDestinationBucketCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryption{}).Type1()):                                               BucketInventorySpecDestinationBucketEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryptionSseKms{}).Type1()):                                         BucketInventorySpecDestinationBucketEncryptionSseKmsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryptionSseS3{}).Type1()):                                          BucketInventorySpecDestinationBucketEncryptionSseS3Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecFilter{}).Type1()):                                                                    BucketInventorySpecFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecSchedule{}).Type1()):                                                                  BucketInventorySpecScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketMetricSpecFilter{}).Type1()):                                                                       BucketMetricSpecFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketOwnershipControlsSpecRule{}).Type1()):                                                              BucketOwnershipControlsSpecRuleCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AccessPointSpecPublicAccessBlockConfiguration{}).Type1()):                                                AccessPointSpecPublicAccessBlockConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccessPointSpecVpcConfiguration{}).Type1()):                                                              AccessPointSpecVpcConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecLifecycleRuleExpiration{}).Type1()):                                                            BucketSpecLifecycleRuleExpirationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecLifecycleRuleNoncurrentVersionExpiration{}).Type1()):                                           BucketSpecLifecycleRuleNoncurrentVersionExpirationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecObjectLockConfiguration{}).Type1()):                                                            BucketSpecObjectLockConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecObjectLockConfigurationRule{}).Type1()):                                                        BucketSpecObjectLockConfigurationRuleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecObjectLockConfigurationRuleDefaultRetention{}).Type1()):                                        BucketSpecObjectLockConfigurationRuleDefaultRetentionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfiguration{}).Type1()):                                                           BucketSpecReplicationConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfigurationRulesDestination{}).Type1()):                                           BucketSpecReplicationConfigurationRulesDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfigurationRulesDestinationAccessControlTranslation{}).Type1()):                   BucketSpecReplicationConfigurationRulesDestinationAccessControlTranslationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfigurationRulesFilter{}).Type1()):                                                BucketSpecReplicationConfigurationRulesFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfigurationRulesSourceSelectionCriteria{}).Type1()):                               BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects{}).Type1()):         BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjectsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecServerSideEncryptionConfiguration{}).Type1()):                                                  BucketSpecServerSideEncryptionConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecServerSideEncryptionConfigurationRule{}).Type1()):                                              BucketSpecServerSideEncryptionConfigurationRuleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault{}).Type1()):            BucketSpecServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecVersioning{}).Type1()):                                                                         BucketSpecVersioningCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecWebsite{}).Type1()):                                                                            BucketSpecWebsiteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecFilter{}).Type1()):                                                       BucketAnalyticsConfigurationSpecFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysis{}).Type1()):                                         BucketAnalyticsConfigurationSpecStorageClassAnalysisCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport{}).Type1()):                               BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination{}).Type1()):                    BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination{}).Type1()): BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestination{}).Type1()):                                                               BucketInventorySpecDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucket{}).Type1()):                                                         BucketInventorySpecDestinationBucketCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryption{}).Type1()):                                               BucketInventorySpecDestinationBucketEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryptionSseKms{}).Type1()):                                         BucketInventorySpecDestinationBucketEncryptionSseKmsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryptionSseS3{}).Type1()):                                          BucketInventorySpecDestinationBucketEncryptionSseS3Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecFilter{}).Type1()):                                                                    BucketInventorySpecFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecSchedule{}).Type1()):                                                                  BucketInventorySpecScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketMetricSpecFilter{}).Type1()):                                                                       BucketMetricSpecFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BucketOwnershipControlsSpecRule{}).Type1()):                                                              BucketOwnershipControlsSpecRuleCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AccessPointSpecPublicAccessBlockConfigurationCodec struct {
}

func (AccessPointSpecPublicAccessBlockConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AccessPointSpecPublicAccessBlockConfiguration)(ptr) == nil
}

func (AccessPointSpecPublicAccessBlockConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AccessPointSpecPublicAccessBlockConfiguration)(ptr)
	var objs []AccessPointSpecPublicAccessBlockConfiguration
	if obj != nil {
		objs = []AccessPointSpecPublicAccessBlockConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccessPointSpecPublicAccessBlockConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AccessPointSpecPublicAccessBlockConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AccessPointSpecPublicAccessBlockConfiguration)(ptr) = AccessPointSpecPublicAccessBlockConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AccessPointSpecPublicAccessBlockConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccessPointSpecPublicAccessBlockConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AccessPointSpecPublicAccessBlockConfiguration)(ptr) = objs[0]
			} else {
				*(*AccessPointSpecPublicAccessBlockConfiguration)(ptr) = AccessPointSpecPublicAccessBlockConfiguration{}
			}
		} else {
			*(*AccessPointSpecPublicAccessBlockConfiguration)(ptr) = AccessPointSpecPublicAccessBlockConfiguration{}
		}
	default:
		iter.ReportError("decode AccessPointSpecPublicAccessBlockConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AccessPointSpecVpcConfigurationCodec struct {
}

func (AccessPointSpecVpcConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AccessPointSpecVpcConfiguration)(ptr) == nil
}

func (AccessPointSpecVpcConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AccessPointSpecVpcConfiguration)(ptr)
	var objs []AccessPointSpecVpcConfiguration
	if obj != nil {
		objs = []AccessPointSpecVpcConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccessPointSpecVpcConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AccessPointSpecVpcConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AccessPointSpecVpcConfiguration)(ptr) = AccessPointSpecVpcConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AccessPointSpecVpcConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccessPointSpecVpcConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AccessPointSpecVpcConfiguration)(ptr) = objs[0]
			} else {
				*(*AccessPointSpecVpcConfiguration)(ptr) = AccessPointSpecVpcConfiguration{}
			}
		} else {
			*(*AccessPointSpecVpcConfiguration)(ptr) = AccessPointSpecVpcConfiguration{}
		}
	default:
		iter.ReportError("decode AccessPointSpecVpcConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketSpecLifecycleRuleExpirationCodec struct {
}

func (BucketSpecLifecycleRuleExpirationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecLifecycleRuleExpiration)(ptr) == nil
}

func (BucketSpecLifecycleRuleExpirationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecLifecycleRuleExpiration)(ptr)
	var objs []BucketSpecLifecycleRuleExpiration
	if obj != nil {
		objs = []BucketSpecLifecycleRuleExpiration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecLifecycleRuleExpiration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecLifecycleRuleExpirationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecLifecycleRuleExpiration)(ptr) = BucketSpecLifecycleRuleExpiration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecLifecycleRuleExpiration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecLifecycleRuleExpiration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecLifecycleRuleExpiration)(ptr) = objs[0]
			} else {
				*(*BucketSpecLifecycleRuleExpiration)(ptr) = BucketSpecLifecycleRuleExpiration{}
			}
		} else {
			*(*BucketSpecLifecycleRuleExpiration)(ptr) = BucketSpecLifecycleRuleExpiration{}
		}
	default:
		iter.ReportError("decode BucketSpecLifecycleRuleExpiration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketSpecLifecycleRuleNoncurrentVersionExpirationCodec struct {
}

func (BucketSpecLifecycleRuleNoncurrentVersionExpirationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecLifecycleRuleNoncurrentVersionExpiration)(ptr) == nil
}

func (BucketSpecLifecycleRuleNoncurrentVersionExpirationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecLifecycleRuleNoncurrentVersionExpiration)(ptr)
	var objs []BucketSpecLifecycleRuleNoncurrentVersionExpiration
	if obj != nil {
		objs = []BucketSpecLifecycleRuleNoncurrentVersionExpiration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecLifecycleRuleNoncurrentVersionExpiration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecLifecycleRuleNoncurrentVersionExpirationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecLifecycleRuleNoncurrentVersionExpiration)(ptr) = BucketSpecLifecycleRuleNoncurrentVersionExpiration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecLifecycleRuleNoncurrentVersionExpiration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecLifecycleRuleNoncurrentVersionExpiration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecLifecycleRuleNoncurrentVersionExpiration)(ptr) = objs[0]
			} else {
				*(*BucketSpecLifecycleRuleNoncurrentVersionExpiration)(ptr) = BucketSpecLifecycleRuleNoncurrentVersionExpiration{}
			}
		} else {
			*(*BucketSpecLifecycleRuleNoncurrentVersionExpiration)(ptr) = BucketSpecLifecycleRuleNoncurrentVersionExpiration{}
		}
	default:
		iter.ReportError("decode BucketSpecLifecycleRuleNoncurrentVersionExpiration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketSpecObjectLockConfigurationCodec struct {
}

func (BucketSpecObjectLockConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecObjectLockConfiguration)(ptr) == nil
}

func (BucketSpecObjectLockConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecObjectLockConfiguration)(ptr)
	var objs []BucketSpecObjectLockConfiguration
	if obj != nil {
		objs = []BucketSpecObjectLockConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecObjectLockConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecObjectLockConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecObjectLockConfiguration)(ptr) = BucketSpecObjectLockConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecObjectLockConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecObjectLockConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecObjectLockConfiguration)(ptr) = objs[0]
			} else {
				*(*BucketSpecObjectLockConfiguration)(ptr) = BucketSpecObjectLockConfiguration{}
			}
		} else {
			*(*BucketSpecObjectLockConfiguration)(ptr) = BucketSpecObjectLockConfiguration{}
		}
	default:
		iter.ReportError("decode BucketSpecObjectLockConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketSpecObjectLockConfigurationRuleCodec struct {
}

func (BucketSpecObjectLockConfigurationRuleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecObjectLockConfigurationRule)(ptr) == nil
}

func (BucketSpecObjectLockConfigurationRuleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecObjectLockConfigurationRule)(ptr)
	var objs []BucketSpecObjectLockConfigurationRule
	if obj != nil {
		objs = []BucketSpecObjectLockConfigurationRule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecObjectLockConfigurationRule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecObjectLockConfigurationRuleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecObjectLockConfigurationRule)(ptr) = BucketSpecObjectLockConfigurationRule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecObjectLockConfigurationRule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecObjectLockConfigurationRule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecObjectLockConfigurationRule)(ptr) = objs[0]
			} else {
				*(*BucketSpecObjectLockConfigurationRule)(ptr) = BucketSpecObjectLockConfigurationRule{}
			}
		} else {
			*(*BucketSpecObjectLockConfigurationRule)(ptr) = BucketSpecObjectLockConfigurationRule{}
		}
	default:
		iter.ReportError("decode BucketSpecObjectLockConfigurationRule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketSpecObjectLockConfigurationRuleDefaultRetentionCodec struct {
}

func (BucketSpecObjectLockConfigurationRuleDefaultRetentionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecObjectLockConfigurationRuleDefaultRetention)(ptr) == nil
}

func (BucketSpecObjectLockConfigurationRuleDefaultRetentionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecObjectLockConfigurationRuleDefaultRetention)(ptr)
	var objs []BucketSpecObjectLockConfigurationRuleDefaultRetention
	if obj != nil {
		objs = []BucketSpecObjectLockConfigurationRuleDefaultRetention{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecObjectLockConfigurationRuleDefaultRetention{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecObjectLockConfigurationRuleDefaultRetentionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecObjectLockConfigurationRuleDefaultRetention)(ptr) = BucketSpecObjectLockConfigurationRuleDefaultRetention{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecObjectLockConfigurationRuleDefaultRetention

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecObjectLockConfigurationRuleDefaultRetention{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecObjectLockConfigurationRuleDefaultRetention)(ptr) = objs[0]
			} else {
				*(*BucketSpecObjectLockConfigurationRuleDefaultRetention)(ptr) = BucketSpecObjectLockConfigurationRuleDefaultRetention{}
			}
		} else {
			*(*BucketSpecObjectLockConfigurationRuleDefaultRetention)(ptr) = BucketSpecObjectLockConfigurationRuleDefaultRetention{}
		}
	default:
		iter.ReportError("decode BucketSpecObjectLockConfigurationRuleDefaultRetention", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketSpecReplicationConfigurationCodec struct {
}

func (BucketSpecReplicationConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecReplicationConfiguration)(ptr) == nil
}

func (BucketSpecReplicationConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecReplicationConfiguration)(ptr)
	var objs []BucketSpecReplicationConfiguration
	if obj != nil {
		objs = []BucketSpecReplicationConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecReplicationConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecReplicationConfiguration)(ptr) = BucketSpecReplicationConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecReplicationConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecReplicationConfiguration)(ptr) = objs[0]
			} else {
				*(*BucketSpecReplicationConfiguration)(ptr) = BucketSpecReplicationConfiguration{}
			}
		} else {
			*(*BucketSpecReplicationConfiguration)(ptr) = BucketSpecReplicationConfiguration{}
		}
	default:
		iter.ReportError("decode BucketSpecReplicationConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketSpecReplicationConfigurationRulesDestinationCodec struct {
}

func (BucketSpecReplicationConfigurationRulesDestinationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecReplicationConfigurationRulesDestination)(ptr) == nil
}

func (BucketSpecReplicationConfigurationRulesDestinationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecReplicationConfigurationRulesDestination)(ptr)
	var objs []BucketSpecReplicationConfigurationRulesDestination
	if obj != nil {
		objs = []BucketSpecReplicationConfigurationRulesDestination{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfigurationRulesDestination{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecReplicationConfigurationRulesDestinationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecReplicationConfigurationRulesDestination)(ptr) = BucketSpecReplicationConfigurationRulesDestination{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecReplicationConfigurationRulesDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfigurationRulesDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecReplicationConfigurationRulesDestination)(ptr) = objs[0]
			} else {
				*(*BucketSpecReplicationConfigurationRulesDestination)(ptr) = BucketSpecReplicationConfigurationRulesDestination{}
			}
		} else {
			*(*BucketSpecReplicationConfigurationRulesDestination)(ptr) = BucketSpecReplicationConfigurationRulesDestination{}
		}
	default:
		iter.ReportError("decode BucketSpecReplicationConfigurationRulesDestination", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketSpecReplicationConfigurationRulesDestinationAccessControlTranslationCodec struct {
}

func (BucketSpecReplicationConfigurationRulesDestinationAccessControlTranslationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecReplicationConfigurationRulesDestinationAccessControlTranslation)(ptr) == nil
}

func (BucketSpecReplicationConfigurationRulesDestinationAccessControlTranslationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecReplicationConfigurationRulesDestinationAccessControlTranslation)(ptr)
	var objs []BucketSpecReplicationConfigurationRulesDestinationAccessControlTranslation
	if obj != nil {
		objs = []BucketSpecReplicationConfigurationRulesDestinationAccessControlTranslation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfigurationRulesDestinationAccessControlTranslation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecReplicationConfigurationRulesDestinationAccessControlTranslationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecReplicationConfigurationRulesDestinationAccessControlTranslation)(ptr) = BucketSpecReplicationConfigurationRulesDestinationAccessControlTranslation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecReplicationConfigurationRulesDestinationAccessControlTranslation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfigurationRulesDestinationAccessControlTranslation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecReplicationConfigurationRulesDestinationAccessControlTranslation)(ptr) = objs[0]
			} else {
				*(*BucketSpecReplicationConfigurationRulesDestinationAccessControlTranslation)(ptr) = BucketSpecReplicationConfigurationRulesDestinationAccessControlTranslation{}
			}
		} else {
			*(*BucketSpecReplicationConfigurationRulesDestinationAccessControlTranslation)(ptr) = BucketSpecReplicationConfigurationRulesDestinationAccessControlTranslation{}
		}
	default:
		iter.ReportError("decode BucketSpecReplicationConfigurationRulesDestinationAccessControlTranslation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketSpecReplicationConfigurationRulesFilterCodec struct {
}

func (BucketSpecReplicationConfigurationRulesFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecReplicationConfigurationRulesFilter)(ptr) == nil
}

func (BucketSpecReplicationConfigurationRulesFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecReplicationConfigurationRulesFilter)(ptr)
	var objs []BucketSpecReplicationConfigurationRulesFilter
	if obj != nil {
		objs = []BucketSpecReplicationConfigurationRulesFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfigurationRulesFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecReplicationConfigurationRulesFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecReplicationConfigurationRulesFilter)(ptr) = BucketSpecReplicationConfigurationRulesFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecReplicationConfigurationRulesFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfigurationRulesFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecReplicationConfigurationRulesFilter)(ptr) = objs[0]
			} else {
				*(*BucketSpecReplicationConfigurationRulesFilter)(ptr) = BucketSpecReplicationConfigurationRulesFilter{}
			}
		} else {
			*(*BucketSpecReplicationConfigurationRulesFilter)(ptr) = BucketSpecReplicationConfigurationRulesFilter{}
		}
	default:
		iter.ReportError("decode BucketSpecReplicationConfigurationRulesFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaCodec struct {
}

func (BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecReplicationConfigurationRulesSourceSelectionCriteria)(ptr) == nil
}

func (BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecReplicationConfigurationRulesSourceSelectionCriteria)(ptr)
	var objs []BucketSpecReplicationConfigurationRulesSourceSelectionCriteria
	if obj != nil {
		objs = []BucketSpecReplicationConfigurationRulesSourceSelectionCriteria{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfigurationRulesSourceSelectionCriteria{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecReplicationConfigurationRulesSourceSelectionCriteria)(ptr) = BucketSpecReplicationConfigurationRulesSourceSelectionCriteria{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecReplicationConfigurationRulesSourceSelectionCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfigurationRulesSourceSelectionCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecReplicationConfigurationRulesSourceSelectionCriteria)(ptr) = objs[0]
			} else {
				*(*BucketSpecReplicationConfigurationRulesSourceSelectionCriteria)(ptr) = BucketSpecReplicationConfigurationRulesSourceSelectionCriteria{}
			}
		} else {
			*(*BucketSpecReplicationConfigurationRulesSourceSelectionCriteria)(ptr) = BucketSpecReplicationConfigurationRulesSourceSelectionCriteria{}
		}
	default:
		iter.ReportError("decode BucketSpecReplicationConfigurationRulesSourceSelectionCriteria", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjectsCodec struct {
}

func (BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjectsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects)(ptr) == nil
}

func (BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjectsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects)(ptr)
	var objs []BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects
	if obj != nil {
		objs = []BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjectsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects)(ptr) = BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects)(ptr) = objs[0]
			} else {
				*(*BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects)(ptr) = BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects{}
			}
		} else {
			*(*BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects)(ptr) = BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects{}
		}
	default:
		iter.ReportError("decode BucketSpecReplicationConfigurationRulesSourceSelectionCriteriaSseKmsEncryptedObjects", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketSpecServerSideEncryptionConfigurationCodec struct {
}

func (BucketSpecServerSideEncryptionConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecServerSideEncryptionConfiguration)(ptr) == nil
}

func (BucketSpecServerSideEncryptionConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecServerSideEncryptionConfiguration)(ptr)
	var objs []BucketSpecServerSideEncryptionConfiguration
	if obj != nil {
		objs = []BucketSpecServerSideEncryptionConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecServerSideEncryptionConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecServerSideEncryptionConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecServerSideEncryptionConfiguration)(ptr) = BucketSpecServerSideEncryptionConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecServerSideEncryptionConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecServerSideEncryptionConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecServerSideEncryptionConfiguration)(ptr) = objs[0]
			} else {
				*(*BucketSpecServerSideEncryptionConfiguration)(ptr) = BucketSpecServerSideEncryptionConfiguration{}
			}
		} else {
			*(*BucketSpecServerSideEncryptionConfiguration)(ptr) = BucketSpecServerSideEncryptionConfiguration{}
		}
	default:
		iter.ReportError("decode BucketSpecServerSideEncryptionConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketSpecServerSideEncryptionConfigurationRuleCodec struct {
}

func (BucketSpecServerSideEncryptionConfigurationRuleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecServerSideEncryptionConfigurationRule)(ptr) == nil
}

func (BucketSpecServerSideEncryptionConfigurationRuleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecServerSideEncryptionConfigurationRule)(ptr)
	var objs []BucketSpecServerSideEncryptionConfigurationRule
	if obj != nil {
		objs = []BucketSpecServerSideEncryptionConfigurationRule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecServerSideEncryptionConfigurationRule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecServerSideEncryptionConfigurationRuleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecServerSideEncryptionConfigurationRule)(ptr) = BucketSpecServerSideEncryptionConfigurationRule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecServerSideEncryptionConfigurationRule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecServerSideEncryptionConfigurationRule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecServerSideEncryptionConfigurationRule)(ptr) = objs[0]
			} else {
				*(*BucketSpecServerSideEncryptionConfigurationRule)(ptr) = BucketSpecServerSideEncryptionConfigurationRule{}
			}
		} else {
			*(*BucketSpecServerSideEncryptionConfigurationRule)(ptr) = BucketSpecServerSideEncryptionConfigurationRule{}
		}
	default:
		iter.ReportError("decode BucketSpecServerSideEncryptionConfigurationRule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketSpecServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultCodec struct {
}

func (BucketSpecServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault)(ptr) == nil
}

func (BucketSpecServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault)(ptr)
	var objs []BucketSpecServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault
	if obj != nil {
		objs = []BucketSpecServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefaultCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault)(ptr) = BucketSpecServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault)(ptr) = objs[0]
			} else {
				*(*BucketSpecServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault)(ptr) = BucketSpecServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault{}
			}
		} else {
			*(*BucketSpecServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault)(ptr) = BucketSpecServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault{}
		}
	default:
		iter.ReportError("decode BucketSpecServerSideEncryptionConfigurationRuleApplyServerSideEncryptionByDefault", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketSpecVersioningCodec struct {
}

func (BucketSpecVersioningCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecVersioning)(ptr) == nil
}

func (BucketSpecVersioningCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecVersioning)(ptr)
	var objs []BucketSpecVersioning
	if obj != nil {
		objs = []BucketSpecVersioning{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecVersioning{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecVersioningCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecVersioning)(ptr) = BucketSpecVersioning{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecVersioning

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecVersioning{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecVersioning)(ptr) = objs[0]
			} else {
				*(*BucketSpecVersioning)(ptr) = BucketSpecVersioning{}
			}
		} else {
			*(*BucketSpecVersioning)(ptr) = BucketSpecVersioning{}
		}
	default:
		iter.ReportError("decode BucketSpecVersioning", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketSpecWebsiteCodec struct {
}

func (BucketSpecWebsiteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketSpecWebsite)(ptr) == nil
}

func (BucketSpecWebsiteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketSpecWebsite)(ptr)
	var objs []BucketSpecWebsite
	if obj != nil {
		objs = []BucketSpecWebsite{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecWebsite{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketSpecWebsiteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketSpecWebsite)(ptr) = BucketSpecWebsite{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketSpecWebsite

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketSpecWebsite{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketSpecWebsite)(ptr) = objs[0]
			} else {
				*(*BucketSpecWebsite)(ptr) = BucketSpecWebsite{}
			}
		} else {
			*(*BucketSpecWebsite)(ptr) = BucketSpecWebsite{}
		}
	default:
		iter.ReportError("decode BucketSpecWebsite", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketAnalyticsConfigurationSpecFilterCodec struct {
}

func (BucketAnalyticsConfigurationSpecFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketAnalyticsConfigurationSpecFilter)(ptr) == nil
}

func (BucketAnalyticsConfigurationSpecFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketAnalyticsConfigurationSpecFilter)(ptr)
	var objs []BucketAnalyticsConfigurationSpecFilter
	if obj != nil {
		objs = []BucketAnalyticsConfigurationSpecFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketAnalyticsConfigurationSpecFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketAnalyticsConfigurationSpecFilter)(ptr) = BucketAnalyticsConfigurationSpecFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketAnalyticsConfigurationSpecFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketAnalyticsConfigurationSpecFilter)(ptr) = objs[0]
			} else {
				*(*BucketAnalyticsConfigurationSpecFilter)(ptr) = BucketAnalyticsConfigurationSpecFilter{}
			}
		} else {
			*(*BucketAnalyticsConfigurationSpecFilter)(ptr) = BucketAnalyticsConfigurationSpecFilter{}
		}
	default:
		iter.ReportError("decode BucketAnalyticsConfigurationSpecFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketAnalyticsConfigurationSpecStorageClassAnalysisCodec struct {
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketAnalyticsConfigurationSpecStorageClassAnalysis)(ptr) == nil
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketAnalyticsConfigurationSpecStorageClassAnalysis)(ptr)
	var objs []BucketAnalyticsConfigurationSpecStorageClassAnalysis
	if obj != nil {
		objs = []BucketAnalyticsConfigurationSpecStorageClassAnalysis{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysis{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketAnalyticsConfigurationSpecStorageClassAnalysis)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysis{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketAnalyticsConfigurationSpecStorageClassAnalysis

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysis{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketAnalyticsConfigurationSpecStorageClassAnalysis)(ptr) = objs[0]
			} else {
				*(*BucketAnalyticsConfigurationSpecStorageClassAnalysis)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysis{}
			}
		} else {
			*(*BucketAnalyticsConfigurationSpecStorageClassAnalysis)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysis{}
		}
	default:
		iter.ReportError("decode BucketAnalyticsConfigurationSpecStorageClassAnalysis", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportCodec struct {
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport)(ptr) == nil
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport)(ptr)
	var objs []BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport
	if obj != nil {
		objs = []BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport)(ptr) = objs[0]
			} else {
				*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport{}
			}
		} else {
			*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport{}
		}
	default:
		iter.ReportError("decode BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExport", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationCodec struct {
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination)(ptr) == nil
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination)(ptr)
	var objs []BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination
	if obj != nil {
		objs = []BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination)(ptr) = objs[0]
			} else {
				*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination{}
			}
		} else {
			*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination{}
		}
	default:
		iter.ReportError("decode BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestination", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestinationCodec struct {
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestinationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination)(ptr) == nil
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestinationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination)(ptr)
	var objs []BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination
	if obj != nil {
		objs = []BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestinationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination)(ptr) = objs[0]
			} else {
				*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination{}
			}
		} else {
			*(*BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination)(ptr) = BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination{}
		}
	default:
		iter.ReportError("decode BucketAnalyticsConfigurationSpecStorageClassAnalysisDataExportDestinationS3BucketDestination", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketInventorySpecDestinationCodec struct {
}

func (BucketInventorySpecDestinationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketInventorySpecDestination)(ptr) == nil
}

func (BucketInventorySpecDestinationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketInventorySpecDestination)(ptr)
	var objs []BucketInventorySpecDestination
	if obj != nil {
		objs = []BucketInventorySpecDestination{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestination{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketInventorySpecDestinationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketInventorySpecDestination)(ptr) = BucketInventorySpecDestination{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketInventorySpecDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketInventorySpecDestination)(ptr) = objs[0]
			} else {
				*(*BucketInventorySpecDestination)(ptr) = BucketInventorySpecDestination{}
			}
		} else {
			*(*BucketInventorySpecDestination)(ptr) = BucketInventorySpecDestination{}
		}
	default:
		iter.ReportError("decode BucketInventorySpecDestination", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketInventorySpecDestinationBucketCodec struct {
}

func (BucketInventorySpecDestinationBucketCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketInventorySpecDestinationBucket)(ptr) == nil
}

func (BucketInventorySpecDestinationBucketCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketInventorySpecDestinationBucket)(ptr)
	var objs []BucketInventorySpecDestinationBucket
	if obj != nil {
		objs = []BucketInventorySpecDestinationBucket{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucket{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketInventorySpecDestinationBucketCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketInventorySpecDestinationBucket)(ptr) = BucketInventorySpecDestinationBucket{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketInventorySpecDestinationBucket

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucket{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketInventorySpecDestinationBucket)(ptr) = objs[0]
			} else {
				*(*BucketInventorySpecDestinationBucket)(ptr) = BucketInventorySpecDestinationBucket{}
			}
		} else {
			*(*BucketInventorySpecDestinationBucket)(ptr) = BucketInventorySpecDestinationBucket{}
		}
	default:
		iter.ReportError("decode BucketInventorySpecDestinationBucket", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketInventorySpecDestinationBucketEncryptionCodec struct {
}

func (BucketInventorySpecDestinationBucketEncryptionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketInventorySpecDestinationBucketEncryption)(ptr) == nil
}

func (BucketInventorySpecDestinationBucketEncryptionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketInventorySpecDestinationBucketEncryption)(ptr)
	var objs []BucketInventorySpecDestinationBucketEncryption
	if obj != nil {
		objs = []BucketInventorySpecDestinationBucketEncryption{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryption{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketInventorySpecDestinationBucketEncryptionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketInventorySpecDestinationBucketEncryption)(ptr) = BucketInventorySpecDestinationBucketEncryption{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketInventorySpecDestinationBucketEncryption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketInventorySpecDestinationBucketEncryption)(ptr) = objs[0]
			} else {
				*(*BucketInventorySpecDestinationBucketEncryption)(ptr) = BucketInventorySpecDestinationBucketEncryption{}
			}
		} else {
			*(*BucketInventorySpecDestinationBucketEncryption)(ptr) = BucketInventorySpecDestinationBucketEncryption{}
		}
	default:
		iter.ReportError("decode BucketInventorySpecDestinationBucketEncryption", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketInventorySpecDestinationBucketEncryptionSseKmsCodec struct {
}

func (BucketInventorySpecDestinationBucketEncryptionSseKmsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketInventorySpecDestinationBucketEncryptionSseKms)(ptr) == nil
}

func (BucketInventorySpecDestinationBucketEncryptionSseKmsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketInventorySpecDestinationBucketEncryptionSseKms)(ptr)
	var objs []BucketInventorySpecDestinationBucketEncryptionSseKms
	if obj != nil {
		objs = []BucketInventorySpecDestinationBucketEncryptionSseKms{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryptionSseKms{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketInventorySpecDestinationBucketEncryptionSseKmsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketInventorySpecDestinationBucketEncryptionSseKms)(ptr) = BucketInventorySpecDestinationBucketEncryptionSseKms{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketInventorySpecDestinationBucketEncryptionSseKms

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryptionSseKms{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketInventorySpecDestinationBucketEncryptionSseKms)(ptr) = objs[0]
			} else {
				*(*BucketInventorySpecDestinationBucketEncryptionSseKms)(ptr) = BucketInventorySpecDestinationBucketEncryptionSseKms{}
			}
		} else {
			*(*BucketInventorySpecDestinationBucketEncryptionSseKms)(ptr) = BucketInventorySpecDestinationBucketEncryptionSseKms{}
		}
	default:
		iter.ReportError("decode BucketInventorySpecDestinationBucketEncryptionSseKms", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketInventorySpecDestinationBucketEncryptionSseS3Codec struct {
}

func (BucketInventorySpecDestinationBucketEncryptionSseS3Codec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketInventorySpecDestinationBucketEncryptionSseS3)(ptr) == nil
}

func (BucketInventorySpecDestinationBucketEncryptionSseS3Codec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketInventorySpecDestinationBucketEncryptionSseS3)(ptr)
	var objs []BucketInventorySpecDestinationBucketEncryptionSseS3
	if obj != nil {
		objs = []BucketInventorySpecDestinationBucketEncryptionSseS3{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryptionSseS3{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketInventorySpecDestinationBucketEncryptionSseS3Codec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketInventorySpecDestinationBucketEncryptionSseS3)(ptr) = BucketInventorySpecDestinationBucketEncryptionSseS3{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketInventorySpecDestinationBucketEncryptionSseS3

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecDestinationBucketEncryptionSseS3{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketInventorySpecDestinationBucketEncryptionSseS3)(ptr) = objs[0]
			} else {
				*(*BucketInventorySpecDestinationBucketEncryptionSseS3)(ptr) = BucketInventorySpecDestinationBucketEncryptionSseS3{}
			}
		} else {
			*(*BucketInventorySpecDestinationBucketEncryptionSseS3)(ptr) = BucketInventorySpecDestinationBucketEncryptionSseS3{}
		}
	default:
		iter.ReportError("decode BucketInventorySpecDestinationBucketEncryptionSseS3", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketInventorySpecFilterCodec struct {
}

func (BucketInventorySpecFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketInventorySpecFilter)(ptr) == nil
}

func (BucketInventorySpecFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketInventorySpecFilter)(ptr)
	var objs []BucketInventorySpecFilter
	if obj != nil {
		objs = []BucketInventorySpecFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketInventorySpecFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketInventorySpecFilter)(ptr) = BucketInventorySpecFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketInventorySpecFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketInventorySpecFilter)(ptr) = objs[0]
			} else {
				*(*BucketInventorySpecFilter)(ptr) = BucketInventorySpecFilter{}
			}
		} else {
			*(*BucketInventorySpecFilter)(ptr) = BucketInventorySpecFilter{}
		}
	default:
		iter.ReportError("decode BucketInventorySpecFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketInventorySpecScheduleCodec struct {
}

func (BucketInventorySpecScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketInventorySpecSchedule)(ptr) == nil
}

func (BucketInventorySpecScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketInventorySpecSchedule)(ptr)
	var objs []BucketInventorySpecSchedule
	if obj != nil {
		objs = []BucketInventorySpecSchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecSchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketInventorySpecScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketInventorySpecSchedule)(ptr) = BucketInventorySpecSchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketInventorySpecSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketInventorySpecSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketInventorySpecSchedule)(ptr) = objs[0]
			} else {
				*(*BucketInventorySpecSchedule)(ptr) = BucketInventorySpecSchedule{}
			}
		} else {
			*(*BucketInventorySpecSchedule)(ptr) = BucketInventorySpecSchedule{}
		}
	default:
		iter.ReportError("decode BucketInventorySpecSchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketMetricSpecFilterCodec struct {
}

func (BucketMetricSpecFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketMetricSpecFilter)(ptr) == nil
}

func (BucketMetricSpecFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketMetricSpecFilter)(ptr)
	var objs []BucketMetricSpecFilter
	if obj != nil {
		objs = []BucketMetricSpecFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketMetricSpecFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketMetricSpecFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketMetricSpecFilter)(ptr) = BucketMetricSpecFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketMetricSpecFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketMetricSpecFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketMetricSpecFilter)(ptr) = objs[0]
			} else {
				*(*BucketMetricSpecFilter)(ptr) = BucketMetricSpecFilter{}
			}
		} else {
			*(*BucketMetricSpecFilter)(ptr) = BucketMetricSpecFilter{}
		}
	default:
		iter.ReportError("decode BucketMetricSpecFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BucketOwnershipControlsSpecRuleCodec struct {
}

func (BucketOwnershipControlsSpecRuleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BucketOwnershipControlsSpecRule)(ptr) == nil
}

func (BucketOwnershipControlsSpecRuleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BucketOwnershipControlsSpecRule)(ptr)
	var objs []BucketOwnershipControlsSpecRule
	if obj != nil {
		objs = []BucketOwnershipControlsSpecRule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketOwnershipControlsSpecRule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BucketOwnershipControlsSpecRuleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BucketOwnershipControlsSpecRule)(ptr) = BucketOwnershipControlsSpecRule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BucketOwnershipControlsSpecRule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BucketOwnershipControlsSpecRule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BucketOwnershipControlsSpecRule)(ptr) = objs[0]
			} else {
				*(*BucketOwnershipControlsSpecRule)(ptr) = BucketOwnershipControlsSpecRule{}
			}
		} else {
			*(*BucketOwnershipControlsSpecRule)(ptr) = BucketOwnershipControlsSpecRule{}
		}
	default:
		iter.ReportError("decode BucketOwnershipControlsSpecRule", "unexpected JSON type")
	}
}
