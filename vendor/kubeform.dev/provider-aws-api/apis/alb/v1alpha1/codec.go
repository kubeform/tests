/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AlbSpecAccessLogs{}).Type1()):                            AlbSpecAccessLogsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionAuthenticateCognito{}).Type1()): ListenerSpecDefaultActionAuthenticateCognitoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionAuthenticateOidc{}).Type1()):    ListenerSpecDefaultActionAuthenticateOidcCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionFixedResponse{}).Type1()):       ListenerSpecDefaultActionFixedResponseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionForward{}).Type1()):             ListenerSpecDefaultActionForwardCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionForwardStickiness{}).Type1()):   ListenerSpecDefaultActionForwardStickinessCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionRedirect{}).Type1()):            ListenerSpecDefaultActionRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionAuthenticateCognito{}).Type1()):    ListenerRuleSpecActionAuthenticateCognitoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionAuthenticateOidc{}).Type1()):       ListenerRuleSpecActionAuthenticateOidcCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionFixedResponse{}).Type1()):          ListenerRuleSpecActionFixedResponseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionForward{}).Type1()):                ListenerRuleSpecActionForwardCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionForwardStickiness{}).Type1()):      ListenerRuleSpecActionForwardStickinessCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionRedirect{}).Type1()):               ListenerRuleSpecActionRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecConditionHostHeader{}).Type1()):          ListenerRuleSpecConditionHostHeaderCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecConditionHttpHeader{}).Type1()):          ListenerRuleSpecConditionHttpHeaderCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecConditionHttpRequestMethod{}).Type1()):   ListenerRuleSpecConditionHttpRequestMethodCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecConditionPathPattern{}).Type1()):         ListenerRuleSpecConditionPathPatternCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecConditionSourceIP{}).Type1()):            ListenerRuleSpecConditionSourceIPCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TargetGroupSpecHealthCheck{}).Type1()):                   TargetGroupSpecHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TargetGroupSpecStickiness{}).Type1()):                    TargetGroupSpecStickinessCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AlbSpecAccessLogs{}).Type1()):                            AlbSpecAccessLogsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionAuthenticateCognito{}).Type1()): ListenerSpecDefaultActionAuthenticateCognitoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionAuthenticateOidc{}).Type1()):    ListenerSpecDefaultActionAuthenticateOidcCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionFixedResponse{}).Type1()):       ListenerSpecDefaultActionFixedResponseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionForward{}).Type1()):             ListenerSpecDefaultActionForwardCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionForwardStickiness{}).Type1()):   ListenerSpecDefaultActionForwardStickinessCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionRedirect{}).Type1()):            ListenerSpecDefaultActionRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionAuthenticateCognito{}).Type1()):    ListenerRuleSpecActionAuthenticateCognitoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionAuthenticateOidc{}).Type1()):       ListenerRuleSpecActionAuthenticateOidcCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionFixedResponse{}).Type1()):          ListenerRuleSpecActionFixedResponseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionForward{}).Type1()):                ListenerRuleSpecActionForwardCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionForwardStickiness{}).Type1()):      ListenerRuleSpecActionForwardStickinessCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionRedirect{}).Type1()):               ListenerRuleSpecActionRedirectCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecConditionHostHeader{}).Type1()):          ListenerRuleSpecConditionHostHeaderCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecConditionHttpHeader{}).Type1()):          ListenerRuleSpecConditionHttpHeaderCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecConditionHttpRequestMethod{}).Type1()):   ListenerRuleSpecConditionHttpRequestMethodCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecConditionPathPattern{}).Type1()):         ListenerRuleSpecConditionPathPatternCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecConditionSourceIP{}).Type1()):            ListenerRuleSpecConditionSourceIPCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TargetGroupSpecHealthCheck{}).Type1()):                   TargetGroupSpecHealthCheckCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TargetGroupSpecStickiness{}).Type1()):                    TargetGroupSpecStickinessCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AlbSpecAccessLogsCodec struct {
}

func (AlbSpecAccessLogsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AlbSpecAccessLogs)(ptr) == nil
}

func (AlbSpecAccessLogsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AlbSpecAccessLogs)(ptr)
	var objs []AlbSpecAccessLogs
	if obj != nil {
		objs = []AlbSpecAccessLogs{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlbSpecAccessLogs{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AlbSpecAccessLogsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AlbSpecAccessLogs)(ptr) = AlbSpecAccessLogs{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AlbSpecAccessLogs

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AlbSpecAccessLogs{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AlbSpecAccessLogs)(ptr) = objs[0]
			} else {
				*(*AlbSpecAccessLogs)(ptr) = AlbSpecAccessLogs{}
			}
		} else {
			*(*AlbSpecAccessLogs)(ptr) = AlbSpecAccessLogs{}
		}
	default:
		iter.ReportError("decode AlbSpecAccessLogs", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ListenerSpecDefaultActionAuthenticateCognitoCodec struct {
}

func (ListenerSpecDefaultActionAuthenticateCognitoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerSpecDefaultActionAuthenticateCognito)(ptr) == nil
}

func (ListenerSpecDefaultActionAuthenticateCognitoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerSpecDefaultActionAuthenticateCognito)(ptr)
	var objs []ListenerSpecDefaultActionAuthenticateCognito
	if obj != nil {
		objs = []ListenerSpecDefaultActionAuthenticateCognito{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionAuthenticateCognito{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerSpecDefaultActionAuthenticateCognitoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerSpecDefaultActionAuthenticateCognito)(ptr) = ListenerSpecDefaultActionAuthenticateCognito{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerSpecDefaultActionAuthenticateCognito

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionAuthenticateCognito{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerSpecDefaultActionAuthenticateCognito)(ptr) = objs[0]
			} else {
				*(*ListenerSpecDefaultActionAuthenticateCognito)(ptr) = ListenerSpecDefaultActionAuthenticateCognito{}
			}
		} else {
			*(*ListenerSpecDefaultActionAuthenticateCognito)(ptr) = ListenerSpecDefaultActionAuthenticateCognito{}
		}
	default:
		iter.ReportError("decode ListenerSpecDefaultActionAuthenticateCognito", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ListenerSpecDefaultActionAuthenticateOidcCodec struct {
}

func (ListenerSpecDefaultActionAuthenticateOidcCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerSpecDefaultActionAuthenticateOidc)(ptr) == nil
}

func (ListenerSpecDefaultActionAuthenticateOidcCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerSpecDefaultActionAuthenticateOidc)(ptr)
	var objs []ListenerSpecDefaultActionAuthenticateOidc
	if obj != nil {
		objs = []ListenerSpecDefaultActionAuthenticateOidc{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionAuthenticateOidc{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerSpecDefaultActionAuthenticateOidcCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerSpecDefaultActionAuthenticateOidc)(ptr) = ListenerSpecDefaultActionAuthenticateOidc{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerSpecDefaultActionAuthenticateOidc

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionAuthenticateOidc{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerSpecDefaultActionAuthenticateOidc)(ptr) = objs[0]
			} else {
				*(*ListenerSpecDefaultActionAuthenticateOidc)(ptr) = ListenerSpecDefaultActionAuthenticateOidc{}
			}
		} else {
			*(*ListenerSpecDefaultActionAuthenticateOidc)(ptr) = ListenerSpecDefaultActionAuthenticateOidc{}
		}
	default:
		iter.ReportError("decode ListenerSpecDefaultActionAuthenticateOidc", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ListenerSpecDefaultActionFixedResponseCodec struct {
}

func (ListenerSpecDefaultActionFixedResponseCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerSpecDefaultActionFixedResponse)(ptr) == nil
}

func (ListenerSpecDefaultActionFixedResponseCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerSpecDefaultActionFixedResponse)(ptr)
	var objs []ListenerSpecDefaultActionFixedResponse
	if obj != nil {
		objs = []ListenerSpecDefaultActionFixedResponse{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionFixedResponse{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerSpecDefaultActionFixedResponseCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerSpecDefaultActionFixedResponse)(ptr) = ListenerSpecDefaultActionFixedResponse{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerSpecDefaultActionFixedResponse

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionFixedResponse{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerSpecDefaultActionFixedResponse)(ptr) = objs[0]
			} else {
				*(*ListenerSpecDefaultActionFixedResponse)(ptr) = ListenerSpecDefaultActionFixedResponse{}
			}
		} else {
			*(*ListenerSpecDefaultActionFixedResponse)(ptr) = ListenerSpecDefaultActionFixedResponse{}
		}
	default:
		iter.ReportError("decode ListenerSpecDefaultActionFixedResponse", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ListenerSpecDefaultActionForwardCodec struct {
}

func (ListenerSpecDefaultActionForwardCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerSpecDefaultActionForward)(ptr) == nil
}

func (ListenerSpecDefaultActionForwardCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerSpecDefaultActionForward)(ptr)
	var objs []ListenerSpecDefaultActionForward
	if obj != nil {
		objs = []ListenerSpecDefaultActionForward{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionForward{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerSpecDefaultActionForwardCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerSpecDefaultActionForward)(ptr) = ListenerSpecDefaultActionForward{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerSpecDefaultActionForward

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionForward{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerSpecDefaultActionForward)(ptr) = objs[0]
			} else {
				*(*ListenerSpecDefaultActionForward)(ptr) = ListenerSpecDefaultActionForward{}
			}
		} else {
			*(*ListenerSpecDefaultActionForward)(ptr) = ListenerSpecDefaultActionForward{}
		}
	default:
		iter.ReportError("decode ListenerSpecDefaultActionForward", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ListenerSpecDefaultActionForwardStickinessCodec struct {
}

func (ListenerSpecDefaultActionForwardStickinessCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerSpecDefaultActionForwardStickiness)(ptr) == nil
}

func (ListenerSpecDefaultActionForwardStickinessCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerSpecDefaultActionForwardStickiness)(ptr)
	var objs []ListenerSpecDefaultActionForwardStickiness
	if obj != nil {
		objs = []ListenerSpecDefaultActionForwardStickiness{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionForwardStickiness{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerSpecDefaultActionForwardStickinessCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerSpecDefaultActionForwardStickiness)(ptr) = ListenerSpecDefaultActionForwardStickiness{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerSpecDefaultActionForwardStickiness

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionForwardStickiness{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerSpecDefaultActionForwardStickiness)(ptr) = objs[0]
			} else {
				*(*ListenerSpecDefaultActionForwardStickiness)(ptr) = ListenerSpecDefaultActionForwardStickiness{}
			}
		} else {
			*(*ListenerSpecDefaultActionForwardStickiness)(ptr) = ListenerSpecDefaultActionForwardStickiness{}
		}
	default:
		iter.ReportError("decode ListenerSpecDefaultActionForwardStickiness", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ListenerSpecDefaultActionRedirectCodec struct {
}

func (ListenerSpecDefaultActionRedirectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerSpecDefaultActionRedirect)(ptr) == nil
}

func (ListenerSpecDefaultActionRedirectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerSpecDefaultActionRedirect)(ptr)
	var objs []ListenerSpecDefaultActionRedirect
	if obj != nil {
		objs = []ListenerSpecDefaultActionRedirect{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionRedirect{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerSpecDefaultActionRedirectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerSpecDefaultActionRedirect)(ptr) = ListenerSpecDefaultActionRedirect{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerSpecDefaultActionRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerSpecDefaultActionRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerSpecDefaultActionRedirect)(ptr) = objs[0]
			} else {
				*(*ListenerSpecDefaultActionRedirect)(ptr) = ListenerSpecDefaultActionRedirect{}
			}
		} else {
			*(*ListenerSpecDefaultActionRedirect)(ptr) = ListenerSpecDefaultActionRedirect{}
		}
	default:
		iter.ReportError("decode ListenerSpecDefaultActionRedirect", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ListenerRuleSpecActionAuthenticateCognitoCodec struct {
}

func (ListenerRuleSpecActionAuthenticateCognitoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerRuleSpecActionAuthenticateCognito)(ptr) == nil
}

func (ListenerRuleSpecActionAuthenticateCognitoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerRuleSpecActionAuthenticateCognito)(ptr)
	var objs []ListenerRuleSpecActionAuthenticateCognito
	if obj != nil {
		objs = []ListenerRuleSpecActionAuthenticateCognito{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionAuthenticateCognito{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerRuleSpecActionAuthenticateCognitoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerRuleSpecActionAuthenticateCognito)(ptr) = ListenerRuleSpecActionAuthenticateCognito{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerRuleSpecActionAuthenticateCognito

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionAuthenticateCognito{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerRuleSpecActionAuthenticateCognito)(ptr) = objs[0]
			} else {
				*(*ListenerRuleSpecActionAuthenticateCognito)(ptr) = ListenerRuleSpecActionAuthenticateCognito{}
			}
		} else {
			*(*ListenerRuleSpecActionAuthenticateCognito)(ptr) = ListenerRuleSpecActionAuthenticateCognito{}
		}
	default:
		iter.ReportError("decode ListenerRuleSpecActionAuthenticateCognito", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ListenerRuleSpecActionAuthenticateOidcCodec struct {
}

func (ListenerRuleSpecActionAuthenticateOidcCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerRuleSpecActionAuthenticateOidc)(ptr) == nil
}

func (ListenerRuleSpecActionAuthenticateOidcCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerRuleSpecActionAuthenticateOidc)(ptr)
	var objs []ListenerRuleSpecActionAuthenticateOidc
	if obj != nil {
		objs = []ListenerRuleSpecActionAuthenticateOidc{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionAuthenticateOidc{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerRuleSpecActionAuthenticateOidcCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerRuleSpecActionAuthenticateOidc)(ptr) = ListenerRuleSpecActionAuthenticateOidc{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerRuleSpecActionAuthenticateOidc

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionAuthenticateOidc{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerRuleSpecActionAuthenticateOidc)(ptr) = objs[0]
			} else {
				*(*ListenerRuleSpecActionAuthenticateOidc)(ptr) = ListenerRuleSpecActionAuthenticateOidc{}
			}
		} else {
			*(*ListenerRuleSpecActionAuthenticateOidc)(ptr) = ListenerRuleSpecActionAuthenticateOidc{}
		}
	default:
		iter.ReportError("decode ListenerRuleSpecActionAuthenticateOidc", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ListenerRuleSpecActionFixedResponseCodec struct {
}

func (ListenerRuleSpecActionFixedResponseCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerRuleSpecActionFixedResponse)(ptr) == nil
}

func (ListenerRuleSpecActionFixedResponseCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerRuleSpecActionFixedResponse)(ptr)
	var objs []ListenerRuleSpecActionFixedResponse
	if obj != nil {
		objs = []ListenerRuleSpecActionFixedResponse{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionFixedResponse{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerRuleSpecActionFixedResponseCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerRuleSpecActionFixedResponse)(ptr) = ListenerRuleSpecActionFixedResponse{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerRuleSpecActionFixedResponse

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionFixedResponse{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerRuleSpecActionFixedResponse)(ptr) = objs[0]
			} else {
				*(*ListenerRuleSpecActionFixedResponse)(ptr) = ListenerRuleSpecActionFixedResponse{}
			}
		} else {
			*(*ListenerRuleSpecActionFixedResponse)(ptr) = ListenerRuleSpecActionFixedResponse{}
		}
	default:
		iter.ReportError("decode ListenerRuleSpecActionFixedResponse", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ListenerRuleSpecActionForwardCodec struct {
}

func (ListenerRuleSpecActionForwardCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerRuleSpecActionForward)(ptr) == nil
}

func (ListenerRuleSpecActionForwardCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerRuleSpecActionForward)(ptr)
	var objs []ListenerRuleSpecActionForward
	if obj != nil {
		objs = []ListenerRuleSpecActionForward{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionForward{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerRuleSpecActionForwardCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerRuleSpecActionForward)(ptr) = ListenerRuleSpecActionForward{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerRuleSpecActionForward

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionForward{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerRuleSpecActionForward)(ptr) = objs[0]
			} else {
				*(*ListenerRuleSpecActionForward)(ptr) = ListenerRuleSpecActionForward{}
			}
		} else {
			*(*ListenerRuleSpecActionForward)(ptr) = ListenerRuleSpecActionForward{}
		}
	default:
		iter.ReportError("decode ListenerRuleSpecActionForward", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ListenerRuleSpecActionForwardStickinessCodec struct {
}

func (ListenerRuleSpecActionForwardStickinessCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerRuleSpecActionForwardStickiness)(ptr) == nil
}

func (ListenerRuleSpecActionForwardStickinessCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerRuleSpecActionForwardStickiness)(ptr)
	var objs []ListenerRuleSpecActionForwardStickiness
	if obj != nil {
		objs = []ListenerRuleSpecActionForwardStickiness{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionForwardStickiness{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerRuleSpecActionForwardStickinessCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerRuleSpecActionForwardStickiness)(ptr) = ListenerRuleSpecActionForwardStickiness{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerRuleSpecActionForwardStickiness

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionForwardStickiness{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerRuleSpecActionForwardStickiness)(ptr) = objs[0]
			} else {
				*(*ListenerRuleSpecActionForwardStickiness)(ptr) = ListenerRuleSpecActionForwardStickiness{}
			}
		} else {
			*(*ListenerRuleSpecActionForwardStickiness)(ptr) = ListenerRuleSpecActionForwardStickiness{}
		}
	default:
		iter.ReportError("decode ListenerRuleSpecActionForwardStickiness", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ListenerRuleSpecActionRedirectCodec struct {
}

func (ListenerRuleSpecActionRedirectCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerRuleSpecActionRedirect)(ptr) == nil
}

func (ListenerRuleSpecActionRedirectCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerRuleSpecActionRedirect)(ptr)
	var objs []ListenerRuleSpecActionRedirect
	if obj != nil {
		objs = []ListenerRuleSpecActionRedirect{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionRedirect{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerRuleSpecActionRedirectCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerRuleSpecActionRedirect)(ptr) = ListenerRuleSpecActionRedirect{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerRuleSpecActionRedirect

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecActionRedirect{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerRuleSpecActionRedirect)(ptr) = objs[0]
			} else {
				*(*ListenerRuleSpecActionRedirect)(ptr) = ListenerRuleSpecActionRedirect{}
			}
		} else {
			*(*ListenerRuleSpecActionRedirect)(ptr) = ListenerRuleSpecActionRedirect{}
		}
	default:
		iter.ReportError("decode ListenerRuleSpecActionRedirect", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ListenerRuleSpecConditionHostHeaderCodec struct {
}

func (ListenerRuleSpecConditionHostHeaderCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerRuleSpecConditionHostHeader)(ptr) == nil
}

func (ListenerRuleSpecConditionHostHeaderCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerRuleSpecConditionHostHeader)(ptr)
	var objs []ListenerRuleSpecConditionHostHeader
	if obj != nil {
		objs = []ListenerRuleSpecConditionHostHeader{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecConditionHostHeader{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerRuleSpecConditionHostHeaderCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerRuleSpecConditionHostHeader)(ptr) = ListenerRuleSpecConditionHostHeader{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerRuleSpecConditionHostHeader

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecConditionHostHeader{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerRuleSpecConditionHostHeader)(ptr) = objs[0]
			} else {
				*(*ListenerRuleSpecConditionHostHeader)(ptr) = ListenerRuleSpecConditionHostHeader{}
			}
		} else {
			*(*ListenerRuleSpecConditionHostHeader)(ptr) = ListenerRuleSpecConditionHostHeader{}
		}
	default:
		iter.ReportError("decode ListenerRuleSpecConditionHostHeader", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ListenerRuleSpecConditionHttpHeaderCodec struct {
}

func (ListenerRuleSpecConditionHttpHeaderCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerRuleSpecConditionHttpHeader)(ptr) == nil
}

func (ListenerRuleSpecConditionHttpHeaderCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerRuleSpecConditionHttpHeader)(ptr)
	var objs []ListenerRuleSpecConditionHttpHeader
	if obj != nil {
		objs = []ListenerRuleSpecConditionHttpHeader{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecConditionHttpHeader{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerRuleSpecConditionHttpHeaderCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerRuleSpecConditionHttpHeader)(ptr) = ListenerRuleSpecConditionHttpHeader{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerRuleSpecConditionHttpHeader

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecConditionHttpHeader{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerRuleSpecConditionHttpHeader)(ptr) = objs[0]
			} else {
				*(*ListenerRuleSpecConditionHttpHeader)(ptr) = ListenerRuleSpecConditionHttpHeader{}
			}
		} else {
			*(*ListenerRuleSpecConditionHttpHeader)(ptr) = ListenerRuleSpecConditionHttpHeader{}
		}
	default:
		iter.ReportError("decode ListenerRuleSpecConditionHttpHeader", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ListenerRuleSpecConditionHttpRequestMethodCodec struct {
}

func (ListenerRuleSpecConditionHttpRequestMethodCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerRuleSpecConditionHttpRequestMethod)(ptr) == nil
}

func (ListenerRuleSpecConditionHttpRequestMethodCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerRuleSpecConditionHttpRequestMethod)(ptr)
	var objs []ListenerRuleSpecConditionHttpRequestMethod
	if obj != nil {
		objs = []ListenerRuleSpecConditionHttpRequestMethod{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecConditionHttpRequestMethod{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerRuleSpecConditionHttpRequestMethodCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerRuleSpecConditionHttpRequestMethod)(ptr) = ListenerRuleSpecConditionHttpRequestMethod{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerRuleSpecConditionHttpRequestMethod

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecConditionHttpRequestMethod{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerRuleSpecConditionHttpRequestMethod)(ptr) = objs[0]
			} else {
				*(*ListenerRuleSpecConditionHttpRequestMethod)(ptr) = ListenerRuleSpecConditionHttpRequestMethod{}
			}
		} else {
			*(*ListenerRuleSpecConditionHttpRequestMethod)(ptr) = ListenerRuleSpecConditionHttpRequestMethod{}
		}
	default:
		iter.ReportError("decode ListenerRuleSpecConditionHttpRequestMethod", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ListenerRuleSpecConditionPathPatternCodec struct {
}

func (ListenerRuleSpecConditionPathPatternCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerRuleSpecConditionPathPattern)(ptr) == nil
}

func (ListenerRuleSpecConditionPathPatternCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerRuleSpecConditionPathPattern)(ptr)
	var objs []ListenerRuleSpecConditionPathPattern
	if obj != nil {
		objs = []ListenerRuleSpecConditionPathPattern{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecConditionPathPattern{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerRuleSpecConditionPathPatternCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerRuleSpecConditionPathPattern)(ptr) = ListenerRuleSpecConditionPathPattern{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerRuleSpecConditionPathPattern

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecConditionPathPattern{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerRuleSpecConditionPathPattern)(ptr) = objs[0]
			} else {
				*(*ListenerRuleSpecConditionPathPattern)(ptr) = ListenerRuleSpecConditionPathPattern{}
			}
		} else {
			*(*ListenerRuleSpecConditionPathPattern)(ptr) = ListenerRuleSpecConditionPathPattern{}
		}
	default:
		iter.ReportError("decode ListenerRuleSpecConditionPathPattern", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ListenerRuleSpecConditionSourceIPCodec struct {
}

func (ListenerRuleSpecConditionSourceIPCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ListenerRuleSpecConditionSourceIP)(ptr) == nil
}

func (ListenerRuleSpecConditionSourceIPCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ListenerRuleSpecConditionSourceIP)(ptr)
	var objs []ListenerRuleSpecConditionSourceIP
	if obj != nil {
		objs = []ListenerRuleSpecConditionSourceIP{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecConditionSourceIP{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ListenerRuleSpecConditionSourceIPCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ListenerRuleSpecConditionSourceIP)(ptr) = ListenerRuleSpecConditionSourceIP{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ListenerRuleSpecConditionSourceIP

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ListenerRuleSpecConditionSourceIP{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ListenerRuleSpecConditionSourceIP)(ptr) = objs[0]
			} else {
				*(*ListenerRuleSpecConditionSourceIP)(ptr) = ListenerRuleSpecConditionSourceIP{}
			}
		} else {
			*(*ListenerRuleSpecConditionSourceIP)(ptr) = ListenerRuleSpecConditionSourceIP{}
		}
	default:
		iter.ReportError("decode ListenerRuleSpecConditionSourceIP", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TargetGroupSpecHealthCheckCodec struct {
}

func (TargetGroupSpecHealthCheckCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TargetGroupSpecHealthCheck)(ptr) == nil
}

func (TargetGroupSpecHealthCheckCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TargetGroupSpecHealthCheck)(ptr)
	var objs []TargetGroupSpecHealthCheck
	if obj != nil {
		objs = []TargetGroupSpecHealthCheck{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TargetGroupSpecHealthCheck{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TargetGroupSpecHealthCheckCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TargetGroupSpecHealthCheck)(ptr) = TargetGroupSpecHealthCheck{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TargetGroupSpecHealthCheck

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TargetGroupSpecHealthCheck{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TargetGroupSpecHealthCheck)(ptr) = objs[0]
			} else {
				*(*TargetGroupSpecHealthCheck)(ptr) = TargetGroupSpecHealthCheck{}
			}
		} else {
			*(*TargetGroupSpecHealthCheck)(ptr) = TargetGroupSpecHealthCheck{}
		}
	default:
		iter.ReportError("decode TargetGroupSpecHealthCheck", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TargetGroupSpecStickinessCodec struct {
}

func (TargetGroupSpecStickinessCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TargetGroupSpecStickiness)(ptr) == nil
}

func (TargetGroupSpecStickinessCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TargetGroupSpecStickiness)(ptr)
	var objs []TargetGroupSpecStickiness
	if obj != nil {
		objs = []TargetGroupSpecStickiness{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TargetGroupSpecStickiness{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TargetGroupSpecStickinessCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TargetGroupSpecStickiness)(ptr) = TargetGroupSpecStickiness{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TargetGroupSpecStickiness

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TargetGroupSpecStickiness{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TargetGroupSpecStickiness)(ptr) = objs[0]
			} else {
				*(*TargetGroupSpecStickiness)(ptr) = TargetGroupSpecStickiness{}
			}
		} else {
			*(*TargetGroupSpecStickiness)(ptr) = TargetGroupSpecStickiness{}
		}
	default:
		iter.ReportError("decode TargetGroupSpecStickiness", "unexpected JSON type")
	}
}
