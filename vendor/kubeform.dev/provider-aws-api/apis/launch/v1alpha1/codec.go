/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigurationSpecMetadataOptions{}).Type1()):                                      ConfigurationSpecMetadataOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigurationSpecRootBlockDevice{}).Type1()):                                      ConfigurationSpecRootBlockDeviceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecBlockDeviceMappingsEbs{}).Type1()):                                    TemplateSpecBlockDeviceMappingsEbsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecCapacityReservationSpecification{}).Type1()):                          TemplateSpecCapacityReservationSpecificationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecCapacityReservationSpecificationCapacityReservationTarget{}).Type1()): TemplateSpecCapacityReservationSpecificationCapacityReservationTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecCpuOptions{}).Type1()):                                                TemplateSpecCpuOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecCreditSpecification{}).Type1()):                                       TemplateSpecCreditSpecificationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecElasticInferenceAccelerator{}).Type1()):                               TemplateSpecElasticInferenceAcceleratorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecEnclaveOptions{}).Type1()):                                            TemplateSpecEnclaveOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecHibernationOptions{}).Type1()):                                        TemplateSpecHibernationOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecIamInstanceProfile{}).Type1()):                                        TemplateSpecIamInstanceProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecInstanceMarketOptions{}).Type1()):                                     TemplateSpecInstanceMarketOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecInstanceMarketOptionsSpotOptions{}).Type1()):                          TemplateSpecInstanceMarketOptionsSpotOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecMetadataOptions{}).Type1()):                                           TemplateSpecMetadataOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecMonitoring{}).Type1()):                                                TemplateSpecMonitoringCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecPlacement{}).Type1()):                                                 TemplateSpecPlacementCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigurationSpecMetadataOptions{}).Type1()):                                      ConfigurationSpecMetadataOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigurationSpecRootBlockDevice{}).Type1()):                                      ConfigurationSpecRootBlockDeviceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecBlockDeviceMappingsEbs{}).Type1()):                                    TemplateSpecBlockDeviceMappingsEbsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecCapacityReservationSpecification{}).Type1()):                          TemplateSpecCapacityReservationSpecificationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecCapacityReservationSpecificationCapacityReservationTarget{}).Type1()): TemplateSpecCapacityReservationSpecificationCapacityReservationTargetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecCpuOptions{}).Type1()):                                                TemplateSpecCpuOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecCreditSpecification{}).Type1()):                                       TemplateSpecCreditSpecificationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecElasticInferenceAccelerator{}).Type1()):                               TemplateSpecElasticInferenceAcceleratorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecEnclaveOptions{}).Type1()):                                            TemplateSpecEnclaveOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecHibernationOptions{}).Type1()):                                        TemplateSpecHibernationOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecIamInstanceProfile{}).Type1()):                                        TemplateSpecIamInstanceProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecInstanceMarketOptions{}).Type1()):                                     TemplateSpecInstanceMarketOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecInstanceMarketOptionsSpotOptions{}).Type1()):                          TemplateSpecInstanceMarketOptionsSpotOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecMetadataOptions{}).Type1()):                                           TemplateSpecMetadataOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecMonitoring{}).Type1()):                                                TemplateSpecMonitoringCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecPlacement{}).Type1()):                                                 TemplateSpecPlacementCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type ConfigurationSpecMetadataOptionsCodec struct {
}

func (ConfigurationSpecMetadataOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigurationSpecMetadataOptions)(ptr) == nil
}

func (ConfigurationSpecMetadataOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigurationSpecMetadataOptions)(ptr)
	var objs []ConfigurationSpecMetadataOptions
	if obj != nil {
		objs = []ConfigurationSpecMetadataOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigurationSpecMetadataOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigurationSpecMetadataOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigurationSpecMetadataOptions)(ptr) = ConfigurationSpecMetadataOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigurationSpecMetadataOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigurationSpecMetadataOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigurationSpecMetadataOptions)(ptr) = objs[0]
			} else {
				*(*ConfigurationSpecMetadataOptions)(ptr) = ConfigurationSpecMetadataOptions{}
			}
		} else {
			*(*ConfigurationSpecMetadataOptions)(ptr) = ConfigurationSpecMetadataOptions{}
		}
	default:
		iter.ReportError("decode ConfigurationSpecMetadataOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ConfigurationSpecRootBlockDeviceCodec struct {
}

func (ConfigurationSpecRootBlockDeviceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigurationSpecRootBlockDevice)(ptr) == nil
}

func (ConfigurationSpecRootBlockDeviceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigurationSpecRootBlockDevice)(ptr)
	var objs []ConfigurationSpecRootBlockDevice
	if obj != nil {
		objs = []ConfigurationSpecRootBlockDevice{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigurationSpecRootBlockDevice{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigurationSpecRootBlockDeviceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigurationSpecRootBlockDevice)(ptr) = ConfigurationSpecRootBlockDevice{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigurationSpecRootBlockDevice

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigurationSpecRootBlockDevice{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigurationSpecRootBlockDevice)(ptr) = objs[0]
			} else {
				*(*ConfigurationSpecRootBlockDevice)(ptr) = ConfigurationSpecRootBlockDevice{}
			}
		} else {
			*(*ConfigurationSpecRootBlockDevice)(ptr) = ConfigurationSpecRootBlockDevice{}
		}
	default:
		iter.ReportError("decode ConfigurationSpecRootBlockDevice", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TemplateSpecBlockDeviceMappingsEbsCodec struct {
}

func (TemplateSpecBlockDeviceMappingsEbsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TemplateSpecBlockDeviceMappingsEbs)(ptr) == nil
}

func (TemplateSpecBlockDeviceMappingsEbsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TemplateSpecBlockDeviceMappingsEbs)(ptr)
	var objs []TemplateSpecBlockDeviceMappingsEbs
	if obj != nil {
		objs = []TemplateSpecBlockDeviceMappingsEbs{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecBlockDeviceMappingsEbs{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TemplateSpecBlockDeviceMappingsEbsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TemplateSpecBlockDeviceMappingsEbs)(ptr) = TemplateSpecBlockDeviceMappingsEbs{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TemplateSpecBlockDeviceMappingsEbs

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecBlockDeviceMappingsEbs{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TemplateSpecBlockDeviceMappingsEbs)(ptr) = objs[0]
			} else {
				*(*TemplateSpecBlockDeviceMappingsEbs)(ptr) = TemplateSpecBlockDeviceMappingsEbs{}
			}
		} else {
			*(*TemplateSpecBlockDeviceMappingsEbs)(ptr) = TemplateSpecBlockDeviceMappingsEbs{}
		}
	default:
		iter.ReportError("decode TemplateSpecBlockDeviceMappingsEbs", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TemplateSpecCapacityReservationSpecificationCodec struct {
}

func (TemplateSpecCapacityReservationSpecificationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TemplateSpecCapacityReservationSpecification)(ptr) == nil
}

func (TemplateSpecCapacityReservationSpecificationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TemplateSpecCapacityReservationSpecification)(ptr)
	var objs []TemplateSpecCapacityReservationSpecification
	if obj != nil {
		objs = []TemplateSpecCapacityReservationSpecification{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecCapacityReservationSpecification{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TemplateSpecCapacityReservationSpecificationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TemplateSpecCapacityReservationSpecification)(ptr) = TemplateSpecCapacityReservationSpecification{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TemplateSpecCapacityReservationSpecification

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecCapacityReservationSpecification{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TemplateSpecCapacityReservationSpecification)(ptr) = objs[0]
			} else {
				*(*TemplateSpecCapacityReservationSpecification)(ptr) = TemplateSpecCapacityReservationSpecification{}
			}
		} else {
			*(*TemplateSpecCapacityReservationSpecification)(ptr) = TemplateSpecCapacityReservationSpecification{}
		}
	default:
		iter.ReportError("decode TemplateSpecCapacityReservationSpecification", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TemplateSpecCapacityReservationSpecificationCapacityReservationTargetCodec struct {
}

func (TemplateSpecCapacityReservationSpecificationCapacityReservationTargetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TemplateSpecCapacityReservationSpecificationCapacityReservationTarget)(ptr) == nil
}

func (TemplateSpecCapacityReservationSpecificationCapacityReservationTargetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TemplateSpecCapacityReservationSpecificationCapacityReservationTarget)(ptr)
	var objs []TemplateSpecCapacityReservationSpecificationCapacityReservationTarget
	if obj != nil {
		objs = []TemplateSpecCapacityReservationSpecificationCapacityReservationTarget{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecCapacityReservationSpecificationCapacityReservationTarget{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TemplateSpecCapacityReservationSpecificationCapacityReservationTargetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TemplateSpecCapacityReservationSpecificationCapacityReservationTarget)(ptr) = TemplateSpecCapacityReservationSpecificationCapacityReservationTarget{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TemplateSpecCapacityReservationSpecificationCapacityReservationTarget

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecCapacityReservationSpecificationCapacityReservationTarget{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TemplateSpecCapacityReservationSpecificationCapacityReservationTarget)(ptr) = objs[0]
			} else {
				*(*TemplateSpecCapacityReservationSpecificationCapacityReservationTarget)(ptr) = TemplateSpecCapacityReservationSpecificationCapacityReservationTarget{}
			}
		} else {
			*(*TemplateSpecCapacityReservationSpecificationCapacityReservationTarget)(ptr) = TemplateSpecCapacityReservationSpecificationCapacityReservationTarget{}
		}
	default:
		iter.ReportError("decode TemplateSpecCapacityReservationSpecificationCapacityReservationTarget", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TemplateSpecCpuOptionsCodec struct {
}

func (TemplateSpecCpuOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TemplateSpecCpuOptions)(ptr) == nil
}

func (TemplateSpecCpuOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TemplateSpecCpuOptions)(ptr)
	var objs []TemplateSpecCpuOptions
	if obj != nil {
		objs = []TemplateSpecCpuOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecCpuOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TemplateSpecCpuOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TemplateSpecCpuOptions)(ptr) = TemplateSpecCpuOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TemplateSpecCpuOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecCpuOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TemplateSpecCpuOptions)(ptr) = objs[0]
			} else {
				*(*TemplateSpecCpuOptions)(ptr) = TemplateSpecCpuOptions{}
			}
		} else {
			*(*TemplateSpecCpuOptions)(ptr) = TemplateSpecCpuOptions{}
		}
	default:
		iter.ReportError("decode TemplateSpecCpuOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TemplateSpecCreditSpecificationCodec struct {
}

func (TemplateSpecCreditSpecificationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TemplateSpecCreditSpecification)(ptr) == nil
}

func (TemplateSpecCreditSpecificationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TemplateSpecCreditSpecification)(ptr)
	var objs []TemplateSpecCreditSpecification
	if obj != nil {
		objs = []TemplateSpecCreditSpecification{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecCreditSpecification{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TemplateSpecCreditSpecificationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TemplateSpecCreditSpecification)(ptr) = TemplateSpecCreditSpecification{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TemplateSpecCreditSpecification

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecCreditSpecification{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TemplateSpecCreditSpecification)(ptr) = objs[0]
			} else {
				*(*TemplateSpecCreditSpecification)(ptr) = TemplateSpecCreditSpecification{}
			}
		} else {
			*(*TemplateSpecCreditSpecification)(ptr) = TemplateSpecCreditSpecification{}
		}
	default:
		iter.ReportError("decode TemplateSpecCreditSpecification", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TemplateSpecElasticInferenceAcceleratorCodec struct {
}

func (TemplateSpecElasticInferenceAcceleratorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TemplateSpecElasticInferenceAccelerator)(ptr) == nil
}

func (TemplateSpecElasticInferenceAcceleratorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TemplateSpecElasticInferenceAccelerator)(ptr)
	var objs []TemplateSpecElasticInferenceAccelerator
	if obj != nil {
		objs = []TemplateSpecElasticInferenceAccelerator{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecElasticInferenceAccelerator{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TemplateSpecElasticInferenceAcceleratorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TemplateSpecElasticInferenceAccelerator)(ptr) = TemplateSpecElasticInferenceAccelerator{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TemplateSpecElasticInferenceAccelerator

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecElasticInferenceAccelerator{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TemplateSpecElasticInferenceAccelerator)(ptr) = objs[0]
			} else {
				*(*TemplateSpecElasticInferenceAccelerator)(ptr) = TemplateSpecElasticInferenceAccelerator{}
			}
		} else {
			*(*TemplateSpecElasticInferenceAccelerator)(ptr) = TemplateSpecElasticInferenceAccelerator{}
		}
	default:
		iter.ReportError("decode TemplateSpecElasticInferenceAccelerator", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TemplateSpecEnclaveOptionsCodec struct {
}

func (TemplateSpecEnclaveOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TemplateSpecEnclaveOptions)(ptr) == nil
}

func (TemplateSpecEnclaveOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TemplateSpecEnclaveOptions)(ptr)
	var objs []TemplateSpecEnclaveOptions
	if obj != nil {
		objs = []TemplateSpecEnclaveOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecEnclaveOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TemplateSpecEnclaveOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TemplateSpecEnclaveOptions)(ptr) = TemplateSpecEnclaveOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TemplateSpecEnclaveOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecEnclaveOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TemplateSpecEnclaveOptions)(ptr) = objs[0]
			} else {
				*(*TemplateSpecEnclaveOptions)(ptr) = TemplateSpecEnclaveOptions{}
			}
		} else {
			*(*TemplateSpecEnclaveOptions)(ptr) = TemplateSpecEnclaveOptions{}
		}
	default:
		iter.ReportError("decode TemplateSpecEnclaveOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TemplateSpecHibernationOptionsCodec struct {
}

func (TemplateSpecHibernationOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TemplateSpecHibernationOptions)(ptr) == nil
}

func (TemplateSpecHibernationOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TemplateSpecHibernationOptions)(ptr)
	var objs []TemplateSpecHibernationOptions
	if obj != nil {
		objs = []TemplateSpecHibernationOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecHibernationOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TemplateSpecHibernationOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TemplateSpecHibernationOptions)(ptr) = TemplateSpecHibernationOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TemplateSpecHibernationOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecHibernationOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TemplateSpecHibernationOptions)(ptr) = objs[0]
			} else {
				*(*TemplateSpecHibernationOptions)(ptr) = TemplateSpecHibernationOptions{}
			}
		} else {
			*(*TemplateSpecHibernationOptions)(ptr) = TemplateSpecHibernationOptions{}
		}
	default:
		iter.ReportError("decode TemplateSpecHibernationOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TemplateSpecIamInstanceProfileCodec struct {
}

func (TemplateSpecIamInstanceProfileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TemplateSpecIamInstanceProfile)(ptr) == nil
}

func (TemplateSpecIamInstanceProfileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TemplateSpecIamInstanceProfile)(ptr)
	var objs []TemplateSpecIamInstanceProfile
	if obj != nil {
		objs = []TemplateSpecIamInstanceProfile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecIamInstanceProfile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TemplateSpecIamInstanceProfileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TemplateSpecIamInstanceProfile)(ptr) = TemplateSpecIamInstanceProfile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TemplateSpecIamInstanceProfile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecIamInstanceProfile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TemplateSpecIamInstanceProfile)(ptr) = objs[0]
			} else {
				*(*TemplateSpecIamInstanceProfile)(ptr) = TemplateSpecIamInstanceProfile{}
			}
		} else {
			*(*TemplateSpecIamInstanceProfile)(ptr) = TemplateSpecIamInstanceProfile{}
		}
	default:
		iter.ReportError("decode TemplateSpecIamInstanceProfile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TemplateSpecInstanceMarketOptionsCodec struct {
}

func (TemplateSpecInstanceMarketOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TemplateSpecInstanceMarketOptions)(ptr) == nil
}

func (TemplateSpecInstanceMarketOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TemplateSpecInstanceMarketOptions)(ptr)
	var objs []TemplateSpecInstanceMarketOptions
	if obj != nil {
		objs = []TemplateSpecInstanceMarketOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecInstanceMarketOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TemplateSpecInstanceMarketOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TemplateSpecInstanceMarketOptions)(ptr) = TemplateSpecInstanceMarketOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TemplateSpecInstanceMarketOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecInstanceMarketOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TemplateSpecInstanceMarketOptions)(ptr) = objs[0]
			} else {
				*(*TemplateSpecInstanceMarketOptions)(ptr) = TemplateSpecInstanceMarketOptions{}
			}
		} else {
			*(*TemplateSpecInstanceMarketOptions)(ptr) = TemplateSpecInstanceMarketOptions{}
		}
	default:
		iter.ReportError("decode TemplateSpecInstanceMarketOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TemplateSpecInstanceMarketOptionsSpotOptionsCodec struct {
}

func (TemplateSpecInstanceMarketOptionsSpotOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TemplateSpecInstanceMarketOptionsSpotOptions)(ptr) == nil
}

func (TemplateSpecInstanceMarketOptionsSpotOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TemplateSpecInstanceMarketOptionsSpotOptions)(ptr)
	var objs []TemplateSpecInstanceMarketOptionsSpotOptions
	if obj != nil {
		objs = []TemplateSpecInstanceMarketOptionsSpotOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecInstanceMarketOptionsSpotOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TemplateSpecInstanceMarketOptionsSpotOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TemplateSpecInstanceMarketOptionsSpotOptions)(ptr) = TemplateSpecInstanceMarketOptionsSpotOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TemplateSpecInstanceMarketOptionsSpotOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecInstanceMarketOptionsSpotOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TemplateSpecInstanceMarketOptionsSpotOptions)(ptr) = objs[0]
			} else {
				*(*TemplateSpecInstanceMarketOptionsSpotOptions)(ptr) = TemplateSpecInstanceMarketOptionsSpotOptions{}
			}
		} else {
			*(*TemplateSpecInstanceMarketOptionsSpotOptions)(ptr) = TemplateSpecInstanceMarketOptionsSpotOptions{}
		}
	default:
		iter.ReportError("decode TemplateSpecInstanceMarketOptionsSpotOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TemplateSpecMetadataOptionsCodec struct {
}

func (TemplateSpecMetadataOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TemplateSpecMetadataOptions)(ptr) == nil
}

func (TemplateSpecMetadataOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TemplateSpecMetadataOptions)(ptr)
	var objs []TemplateSpecMetadataOptions
	if obj != nil {
		objs = []TemplateSpecMetadataOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecMetadataOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TemplateSpecMetadataOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TemplateSpecMetadataOptions)(ptr) = TemplateSpecMetadataOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TemplateSpecMetadataOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecMetadataOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TemplateSpecMetadataOptions)(ptr) = objs[0]
			} else {
				*(*TemplateSpecMetadataOptions)(ptr) = TemplateSpecMetadataOptions{}
			}
		} else {
			*(*TemplateSpecMetadataOptions)(ptr) = TemplateSpecMetadataOptions{}
		}
	default:
		iter.ReportError("decode TemplateSpecMetadataOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TemplateSpecMonitoringCodec struct {
}

func (TemplateSpecMonitoringCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TemplateSpecMonitoring)(ptr) == nil
}

func (TemplateSpecMonitoringCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TemplateSpecMonitoring)(ptr)
	var objs []TemplateSpecMonitoring
	if obj != nil {
		objs = []TemplateSpecMonitoring{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecMonitoring{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TemplateSpecMonitoringCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TemplateSpecMonitoring)(ptr) = TemplateSpecMonitoring{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TemplateSpecMonitoring

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecMonitoring{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TemplateSpecMonitoring)(ptr) = objs[0]
			} else {
				*(*TemplateSpecMonitoring)(ptr) = TemplateSpecMonitoring{}
			}
		} else {
			*(*TemplateSpecMonitoring)(ptr) = TemplateSpecMonitoring{}
		}
	default:
		iter.ReportError("decode TemplateSpecMonitoring", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TemplateSpecPlacementCodec struct {
}

func (TemplateSpecPlacementCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TemplateSpecPlacement)(ptr) == nil
}

func (TemplateSpecPlacementCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TemplateSpecPlacement)(ptr)
	var objs []TemplateSpecPlacement
	if obj != nil {
		objs = []TemplateSpecPlacement{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecPlacement{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TemplateSpecPlacementCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TemplateSpecPlacement)(ptr) = TemplateSpecPlacement{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TemplateSpecPlacement

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TemplateSpecPlacement{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TemplateSpecPlacement)(ptr) = objs[0]
			} else {
				*(*TemplateSpecPlacement)(ptr) = TemplateSpecPlacement{}
			}
		} else {
			*(*TemplateSpecPlacement)(ptr) = TemplateSpecPlacement{}
		}
	default:
		iter.ReportError("decode TemplateSpecPlacement", "unexpected JSON type")
	}
}
