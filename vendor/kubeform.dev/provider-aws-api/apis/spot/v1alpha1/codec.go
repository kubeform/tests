/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(FleetRequestSpecLaunchTemplateConfigLaunchTemplateSpecification{}).Type1()): FleetRequestSpecLaunchTemplateConfigLaunchTemplateSpecificationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FleetRequestSpecSpotMaintenanceStrategies{}).Type1()):                       FleetRequestSpecSpotMaintenanceStrategiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FleetRequestSpecSpotMaintenanceStrategiesCapacityRebalance{}).Type1()):      FleetRequestSpecSpotMaintenanceStrategiesCapacityRebalanceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceRequestSpecCreditSpecification{}).Type1()):                          InstanceRequestSpecCreditSpecificationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceRequestSpecEnclaveOptions{}).Type1()):                               InstanceRequestSpecEnclaveOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceRequestSpecMetadataOptions{}).Type1()):                              InstanceRequestSpecMetadataOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceRequestSpecRootBlockDevice{}).Type1()):                              InstanceRequestSpecRootBlockDeviceCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(FleetRequestSpecLaunchTemplateConfigLaunchTemplateSpecification{}).Type1()): FleetRequestSpecLaunchTemplateConfigLaunchTemplateSpecificationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FleetRequestSpecSpotMaintenanceStrategies{}).Type1()):                       FleetRequestSpecSpotMaintenanceStrategiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FleetRequestSpecSpotMaintenanceStrategiesCapacityRebalance{}).Type1()):      FleetRequestSpecSpotMaintenanceStrategiesCapacityRebalanceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceRequestSpecCreditSpecification{}).Type1()):                          InstanceRequestSpecCreditSpecificationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceRequestSpecEnclaveOptions{}).Type1()):                               InstanceRequestSpecEnclaveOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceRequestSpecMetadataOptions{}).Type1()):                              InstanceRequestSpecMetadataOptionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InstanceRequestSpecRootBlockDevice{}).Type1()):                              InstanceRequestSpecRootBlockDeviceCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type FleetRequestSpecLaunchTemplateConfigLaunchTemplateSpecificationCodec struct {
}

func (FleetRequestSpecLaunchTemplateConfigLaunchTemplateSpecificationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FleetRequestSpecLaunchTemplateConfigLaunchTemplateSpecification)(ptr) == nil
}

func (FleetRequestSpecLaunchTemplateConfigLaunchTemplateSpecificationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FleetRequestSpecLaunchTemplateConfigLaunchTemplateSpecification)(ptr)
	var objs []FleetRequestSpecLaunchTemplateConfigLaunchTemplateSpecification
	if obj != nil {
		objs = []FleetRequestSpecLaunchTemplateConfigLaunchTemplateSpecification{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FleetRequestSpecLaunchTemplateConfigLaunchTemplateSpecification{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FleetRequestSpecLaunchTemplateConfigLaunchTemplateSpecificationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FleetRequestSpecLaunchTemplateConfigLaunchTemplateSpecification)(ptr) = FleetRequestSpecLaunchTemplateConfigLaunchTemplateSpecification{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FleetRequestSpecLaunchTemplateConfigLaunchTemplateSpecification

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FleetRequestSpecLaunchTemplateConfigLaunchTemplateSpecification{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FleetRequestSpecLaunchTemplateConfigLaunchTemplateSpecification)(ptr) = objs[0]
			} else {
				*(*FleetRequestSpecLaunchTemplateConfigLaunchTemplateSpecification)(ptr) = FleetRequestSpecLaunchTemplateConfigLaunchTemplateSpecification{}
			}
		} else {
			*(*FleetRequestSpecLaunchTemplateConfigLaunchTemplateSpecification)(ptr) = FleetRequestSpecLaunchTemplateConfigLaunchTemplateSpecification{}
		}
	default:
		iter.ReportError("decode FleetRequestSpecLaunchTemplateConfigLaunchTemplateSpecification", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FleetRequestSpecSpotMaintenanceStrategiesCodec struct {
}

func (FleetRequestSpecSpotMaintenanceStrategiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FleetRequestSpecSpotMaintenanceStrategies)(ptr) == nil
}

func (FleetRequestSpecSpotMaintenanceStrategiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FleetRequestSpecSpotMaintenanceStrategies)(ptr)
	var objs []FleetRequestSpecSpotMaintenanceStrategies
	if obj != nil {
		objs = []FleetRequestSpecSpotMaintenanceStrategies{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FleetRequestSpecSpotMaintenanceStrategies{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FleetRequestSpecSpotMaintenanceStrategiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FleetRequestSpecSpotMaintenanceStrategies)(ptr) = FleetRequestSpecSpotMaintenanceStrategies{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FleetRequestSpecSpotMaintenanceStrategies

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FleetRequestSpecSpotMaintenanceStrategies{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FleetRequestSpecSpotMaintenanceStrategies)(ptr) = objs[0]
			} else {
				*(*FleetRequestSpecSpotMaintenanceStrategies)(ptr) = FleetRequestSpecSpotMaintenanceStrategies{}
			}
		} else {
			*(*FleetRequestSpecSpotMaintenanceStrategies)(ptr) = FleetRequestSpecSpotMaintenanceStrategies{}
		}
	default:
		iter.ReportError("decode FleetRequestSpecSpotMaintenanceStrategies", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FleetRequestSpecSpotMaintenanceStrategiesCapacityRebalanceCodec struct {
}

func (FleetRequestSpecSpotMaintenanceStrategiesCapacityRebalanceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FleetRequestSpecSpotMaintenanceStrategiesCapacityRebalance)(ptr) == nil
}

func (FleetRequestSpecSpotMaintenanceStrategiesCapacityRebalanceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FleetRequestSpecSpotMaintenanceStrategiesCapacityRebalance)(ptr)
	var objs []FleetRequestSpecSpotMaintenanceStrategiesCapacityRebalance
	if obj != nil {
		objs = []FleetRequestSpecSpotMaintenanceStrategiesCapacityRebalance{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FleetRequestSpecSpotMaintenanceStrategiesCapacityRebalance{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FleetRequestSpecSpotMaintenanceStrategiesCapacityRebalanceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FleetRequestSpecSpotMaintenanceStrategiesCapacityRebalance)(ptr) = FleetRequestSpecSpotMaintenanceStrategiesCapacityRebalance{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FleetRequestSpecSpotMaintenanceStrategiesCapacityRebalance

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FleetRequestSpecSpotMaintenanceStrategiesCapacityRebalance{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FleetRequestSpecSpotMaintenanceStrategiesCapacityRebalance)(ptr) = objs[0]
			} else {
				*(*FleetRequestSpecSpotMaintenanceStrategiesCapacityRebalance)(ptr) = FleetRequestSpecSpotMaintenanceStrategiesCapacityRebalance{}
			}
		} else {
			*(*FleetRequestSpecSpotMaintenanceStrategiesCapacityRebalance)(ptr) = FleetRequestSpecSpotMaintenanceStrategiesCapacityRebalance{}
		}
	default:
		iter.ReportError("decode FleetRequestSpecSpotMaintenanceStrategiesCapacityRebalance", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceRequestSpecCreditSpecificationCodec struct {
}

func (InstanceRequestSpecCreditSpecificationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceRequestSpecCreditSpecification)(ptr) == nil
}

func (InstanceRequestSpecCreditSpecificationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceRequestSpecCreditSpecification)(ptr)
	var objs []InstanceRequestSpecCreditSpecification
	if obj != nil {
		objs = []InstanceRequestSpecCreditSpecification{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceRequestSpecCreditSpecification{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceRequestSpecCreditSpecificationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceRequestSpecCreditSpecification)(ptr) = InstanceRequestSpecCreditSpecification{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceRequestSpecCreditSpecification

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceRequestSpecCreditSpecification{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceRequestSpecCreditSpecification)(ptr) = objs[0]
			} else {
				*(*InstanceRequestSpecCreditSpecification)(ptr) = InstanceRequestSpecCreditSpecification{}
			}
		} else {
			*(*InstanceRequestSpecCreditSpecification)(ptr) = InstanceRequestSpecCreditSpecification{}
		}
	default:
		iter.ReportError("decode InstanceRequestSpecCreditSpecification", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceRequestSpecEnclaveOptionsCodec struct {
}

func (InstanceRequestSpecEnclaveOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceRequestSpecEnclaveOptions)(ptr) == nil
}

func (InstanceRequestSpecEnclaveOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceRequestSpecEnclaveOptions)(ptr)
	var objs []InstanceRequestSpecEnclaveOptions
	if obj != nil {
		objs = []InstanceRequestSpecEnclaveOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceRequestSpecEnclaveOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceRequestSpecEnclaveOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceRequestSpecEnclaveOptions)(ptr) = InstanceRequestSpecEnclaveOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceRequestSpecEnclaveOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceRequestSpecEnclaveOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceRequestSpecEnclaveOptions)(ptr) = objs[0]
			} else {
				*(*InstanceRequestSpecEnclaveOptions)(ptr) = InstanceRequestSpecEnclaveOptions{}
			}
		} else {
			*(*InstanceRequestSpecEnclaveOptions)(ptr) = InstanceRequestSpecEnclaveOptions{}
		}
	default:
		iter.ReportError("decode InstanceRequestSpecEnclaveOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceRequestSpecMetadataOptionsCodec struct {
}

func (InstanceRequestSpecMetadataOptionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceRequestSpecMetadataOptions)(ptr) == nil
}

func (InstanceRequestSpecMetadataOptionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceRequestSpecMetadataOptions)(ptr)
	var objs []InstanceRequestSpecMetadataOptions
	if obj != nil {
		objs = []InstanceRequestSpecMetadataOptions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceRequestSpecMetadataOptions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceRequestSpecMetadataOptionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceRequestSpecMetadataOptions)(ptr) = InstanceRequestSpecMetadataOptions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceRequestSpecMetadataOptions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceRequestSpecMetadataOptions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceRequestSpecMetadataOptions)(ptr) = objs[0]
			} else {
				*(*InstanceRequestSpecMetadataOptions)(ptr) = InstanceRequestSpecMetadataOptions{}
			}
		} else {
			*(*InstanceRequestSpecMetadataOptions)(ptr) = InstanceRequestSpecMetadataOptions{}
		}
	default:
		iter.ReportError("decode InstanceRequestSpecMetadataOptions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InstanceRequestSpecRootBlockDeviceCodec struct {
}

func (InstanceRequestSpecRootBlockDeviceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InstanceRequestSpecRootBlockDevice)(ptr) == nil
}

func (InstanceRequestSpecRootBlockDeviceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InstanceRequestSpecRootBlockDevice)(ptr)
	var objs []InstanceRequestSpecRootBlockDevice
	if obj != nil {
		objs = []InstanceRequestSpecRootBlockDevice{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceRequestSpecRootBlockDevice{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InstanceRequestSpecRootBlockDeviceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InstanceRequestSpecRootBlockDevice)(ptr) = InstanceRequestSpecRootBlockDevice{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InstanceRequestSpecRootBlockDevice

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InstanceRequestSpecRootBlockDevice{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InstanceRequestSpecRootBlockDevice)(ptr) = objs[0]
			} else {
				*(*InstanceRequestSpecRootBlockDevice)(ptr) = InstanceRequestSpecRootBlockDevice{}
			}
		} else {
			*(*InstanceRequestSpecRootBlockDevice)(ptr) = InstanceRequestSpecRootBlockDevice{}
		}
	default:
		iter.ReportError("decode InstanceRequestSpecRootBlockDevice", "unexpected JSON type")
	}
}
