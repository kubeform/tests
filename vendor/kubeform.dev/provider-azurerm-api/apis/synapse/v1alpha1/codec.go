/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecAutoPause{}).Type1()):          SparkPoolSpecAutoPauseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecAutoScale{}).Type1()):          SparkPoolSpecAutoScaleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecLibraryRequirement{}).Type1()): SparkPoolSpecLibraryRequirementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SqlPoolSpecRestore{}).Type1()):              SqlPoolSpecRestoreCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecAadAdmin{}).Type1()):           WorkspaceSpecAadAdminCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecAzureDevopsRepo{}).Type1()):    WorkspaceSpecAzureDevopsRepoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecGithubRepo{}).Type1()):         WorkspaceSpecGithubRepoCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecAutoPause{}).Type1()):          SparkPoolSpecAutoPauseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecAutoScale{}).Type1()):          SparkPoolSpecAutoScaleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecLibraryRequirement{}).Type1()): SparkPoolSpecLibraryRequirementCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SqlPoolSpecRestore{}).Type1()):              SqlPoolSpecRestoreCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecAadAdmin{}).Type1()):           WorkspaceSpecAadAdminCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecAzureDevopsRepo{}).Type1()):    WorkspaceSpecAzureDevopsRepoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecGithubRepo{}).Type1()):         WorkspaceSpecGithubRepoCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type SparkPoolSpecAutoPauseCodec struct {
}

func (SparkPoolSpecAutoPauseCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SparkPoolSpecAutoPause)(ptr) == nil
}

func (SparkPoolSpecAutoPauseCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SparkPoolSpecAutoPause)(ptr)
	var objs []SparkPoolSpecAutoPause
	if obj != nil {
		objs = []SparkPoolSpecAutoPause{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecAutoPause{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SparkPoolSpecAutoPauseCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SparkPoolSpecAutoPause)(ptr) = SparkPoolSpecAutoPause{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SparkPoolSpecAutoPause

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecAutoPause{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SparkPoolSpecAutoPause)(ptr) = objs[0]
			} else {
				*(*SparkPoolSpecAutoPause)(ptr) = SparkPoolSpecAutoPause{}
			}
		} else {
			*(*SparkPoolSpecAutoPause)(ptr) = SparkPoolSpecAutoPause{}
		}
	default:
		iter.ReportError("decode SparkPoolSpecAutoPause", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SparkPoolSpecAutoScaleCodec struct {
}

func (SparkPoolSpecAutoScaleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SparkPoolSpecAutoScale)(ptr) == nil
}

func (SparkPoolSpecAutoScaleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SparkPoolSpecAutoScale)(ptr)
	var objs []SparkPoolSpecAutoScale
	if obj != nil {
		objs = []SparkPoolSpecAutoScale{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecAutoScale{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SparkPoolSpecAutoScaleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SparkPoolSpecAutoScale)(ptr) = SparkPoolSpecAutoScale{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SparkPoolSpecAutoScale

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecAutoScale{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SparkPoolSpecAutoScale)(ptr) = objs[0]
			} else {
				*(*SparkPoolSpecAutoScale)(ptr) = SparkPoolSpecAutoScale{}
			}
		} else {
			*(*SparkPoolSpecAutoScale)(ptr) = SparkPoolSpecAutoScale{}
		}
	default:
		iter.ReportError("decode SparkPoolSpecAutoScale", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SparkPoolSpecLibraryRequirementCodec struct {
}

func (SparkPoolSpecLibraryRequirementCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SparkPoolSpecLibraryRequirement)(ptr) == nil
}

func (SparkPoolSpecLibraryRequirementCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SparkPoolSpecLibraryRequirement)(ptr)
	var objs []SparkPoolSpecLibraryRequirement
	if obj != nil {
		objs = []SparkPoolSpecLibraryRequirement{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecLibraryRequirement{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SparkPoolSpecLibraryRequirementCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SparkPoolSpecLibraryRequirement)(ptr) = SparkPoolSpecLibraryRequirement{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SparkPoolSpecLibraryRequirement

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkPoolSpecLibraryRequirement{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SparkPoolSpecLibraryRequirement)(ptr) = objs[0]
			} else {
				*(*SparkPoolSpecLibraryRequirement)(ptr) = SparkPoolSpecLibraryRequirement{}
			}
		} else {
			*(*SparkPoolSpecLibraryRequirement)(ptr) = SparkPoolSpecLibraryRequirement{}
		}
	default:
		iter.ReportError("decode SparkPoolSpecLibraryRequirement", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SqlPoolSpecRestoreCodec struct {
}

func (SqlPoolSpecRestoreCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SqlPoolSpecRestore)(ptr) == nil
}

func (SqlPoolSpecRestoreCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SqlPoolSpecRestore)(ptr)
	var objs []SqlPoolSpecRestore
	if obj != nil {
		objs = []SqlPoolSpecRestore{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SqlPoolSpecRestore{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SqlPoolSpecRestoreCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SqlPoolSpecRestore)(ptr) = SqlPoolSpecRestore{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SqlPoolSpecRestore

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SqlPoolSpecRestore{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SqlPoolSpecRestore)(ptr) = objs[0]
			} else {
				*(*SqlPoolSpecRestore)(ptr) = SqlPoolSpecRestore{}
			}
		} else {
			*(*SqlPoolSpecRestore)(ptr) = SqlPoolSpecRestore{}
		}
	default:
		iter.ReportError("decode SqlPoolSpecRestore", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkspaceSpecAadAdminCodec struct {
}

func (WorkspaceSpecAadAdminCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkspaceSpecAadAdmin)(ptr) == nil
}

func (WorkspaceSpecAadAdminCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkspaceSpecAadAdmin)(ptr)
	var objs []WorkspaceSpecAadAdmin
	if obj != nil {
		objs = []WorkspaceSpecAadAdmin{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecAadAdmin{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkspaceSpecAadAdminCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkspaceSpecAadAdmin)(ptr) = WorkspaceSpecAadAdmin{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkspaceSpecAadAdmin

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecAadAdmin{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkspaceSpecAadAdmin)(ptr) = objs[0]
			} else {
				*(*WorkspaceSpecAadAdmin)(ptr) = WorkspaceSpecAadAdmin{}
			}
		} else {
			*(*WorkspaceSpecAadAdmin)(ptr) = WorkspaceSpecAadAdmin{}
		}
	default:
		iter.ReportError("decode WorkspaceSpecAadAdmin", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkspaceSpecAzureDevopsRepoCodec struct {
}

func (WorkspaceSpecAzureDevopsRepoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkspaceSpecAzureDevopsRepo)(ptr) == nil
}

func (WorkspaceSpecAzureDevopsRepoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkspaceSpecAzureDevopsRepo)(ptr)
	var objs []WorkspaceSpecAzureDevopsRepo
	if obj != nil {
		objs = []WorkspaceSpecAzureDevopsRepo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecAzureDevopsRepo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkspaceSpecAzureDevopsRepoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkspaceSpecAzureDevopsRepo)(ptr) = WorkspaceSpecAzureDevopsRepo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkspaceSpecAzureDevopsRepo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecAzureDevopsRepo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkspaceSpecAzureDevopsRepo)(ptr) = objs[0]
			} else {
				*(*WorkspaceSpecAzureDevopsRepo)(ptr) = WorkspaceSpecAzureDevopsRepo{}
			}
		} else {
			*(*WorkspaceSpecAzureDevopsRepo)(ptr) = WorkspaceSpecAzureDevopsRepo{}
		}
	default:
		iter.ReportError("decode WorkspaceSpecAzureDevopsRepo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type WorkspaceSpecGithubRepoCodec struct {
}

func (WorkspaceSpecGithubRepoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*WorkspaceSpecGithubRepo)(ptr) == nil
}

func (WorkspaceSpecGithubRepoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*WorkspaceSpecGithubRepo)(ptr)
	var objs []WorkspaceSpecGithubRepo
	if obj != nil {
		objs = []WorkspaceSpecGithubRepo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecGithubRepo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (WorkspaceSpecGithubRepoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*WorkspaceSpecGithubRepo)(ptr) = WorkspaceSpecGithubRepo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []WorkspaceSpecGithubRepo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(WorkspaceSpecGithubRepo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*WorkspaceSpecGithubRepo)(ptr) = objs[0]
			} else {
				*(*WorkspaceSpecGithubRepo)(ptr) = WorkspaceSpecGithubRepo{}
			}
		} else {
			*(*WorkspaceSpecGithubRepo)(ptr) = WorkspaceSpecGithubRepo{}
		}
	default:
		iter.ReportError("decode WorkspaceSpecGithubRepo", "unexpected JSON type")
	}
}
