/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(PolicyFileShareSpecBackup{}).Type1()):           PolicyFileShareSpecBackupCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicyFileShareSpecRetentionDaily{}).Type1()):   PolicyFileShareSpecRetentionDailyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicyFileShareSpecRetentionMonthly{}).Type1()): PolicyFileShareSpecRetentionMonthlyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicyFileShareSpecRetentionWeekly{}).Type1()):  PolicyFileShareSpecRetentionWeeklyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicyFileShareSpecRetentionYearly{}).Type1()):  PolicyFileShareSpecRetentionYearlyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicyVmSpecBackup{}).Type1()):                  PolicyVmSpecBackupCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicyVmSpecRetentionDaily{}).Type1()):          PolicyVmSpecRetentionDailyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicyVmSpecRetentionMonthly{}).Type1()):        PolicyVmSpecRetentionMonthlyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicyVmSpecRetentionWeekly{}).Type1()):         PolicyVmSpecRetentionWeeklyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicyVmSpecRetentionYearly{}).Type1()):         PolicyVmSpecRetentionYearlyCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(PolicyFileShareSpecBackup{}).Type1()):           PolicyFileShareSpecBackupCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicyFileShareSpecRetentionDaily{}).Type1()):   PolicyFileShareSpecRetentionDailyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicyFileShareSpecRetentionMonthly{}).Type1()): PolicyFileShareSpecRetentionMonthlyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicyFileShareSpecRetentionWeekly{}).Type1()):  PolicyFileShareSpecRetentionWeeklyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicyFileShareSpecRetentionYearly{}).Type1()):  PolicyFileShareSpecRetentionYearlyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicyVmSpecBackup{}).Type1()):                  PolicyVmSpecBackupCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicyVmSpecRetentionDaily{}).Type1()):          PolicyVmSpecRetentionDailyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicyVmSpecRetentionMonthly{}).Type1()):        PolicyVmSpecRetentionMonthlyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicyVmSpecRetentionWeekly{}).Type1()):         PolicyVmSpecRetentionWeeklyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(PolicyVmSpecRetentionYearly{}).Type1()):         PolicyVmSpecRetentionYearlyCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type PolicyFileShareSpecBackupCodec struct {
}

func (PolicyFileShareSpecBackupCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PolicyFileShareSpecBackup)(ptr) == nil
}

func (PolicyFileShareSpecBackupCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PolicyFileShareSpecBackup)(ptr)
	var objs []PolicyFileShareSpecBackup
	if obj != nil {
		objs = []PolicyFileShareSpecBackup{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicyFileShareSpecBackup{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PolicyFileShareSpecBackupCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PolicyFileShareSpecBackup)(ptr) = PolicyFileShareSpecBackup{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PolicyFileShareSpecBackup

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicyFileShareSpecBackup{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PolicyFileShareSpecBackup)(ptr) = objs[0]
			} else {
				*(*PolicyFileShareSpecBackup)(ptr) = PolicyFileShareSpecBackup{}
			}
		} else {
			*(*PolicyFileShareSpecBackup)(ptr) = PolicyFileShareSpecBackup{}
		}
	default:
		iter.ReportError("decode PolicyFileShareSpecBackup", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PolicyFileShareSpecRetentionDailyCodec struct {
}

func (PolicyFileShareSpecRetentionDailyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PolicyFileShareSpecRetentionDaily)(ptr) == nil
}

func (PolicyFileShareSpecRetentionDailyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PolicyFileShareSpecRetentionDaily)(ptr)
	var objs []PolicyFileShareSpecRetentionDaily
	if obj != nil {
		objs = []PolicyFileShareSpecRetentionDaily{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicyFileShareSpecRetentionDaily{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PolicyFileShareSpecRetentionDailyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PolicyFileShareSpecRetentionDaily)(ptr) = PolicyFileShareSpecRetentionDaily{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PolicyFileShareSpecRetentionDaily

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicyFileShareSpecRetentionDaily{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PolicyFileShareSpecRetentionDaily)(ptr) = objs[0]
			} else {
				*(*PolicyFileShareSpecRetentionDaily)(ptr) = PolicyFileShareSpecRetentionDaily{}
			}
		} else {
			*(*PolicyFileShareSpecRetentionDaily)(ptr) = PolicyFileShareSpecRetentionDaily{}
		}
	default:
		iter.ReportError("decode PolicyFileShareSpecRetentionDaily", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PolicyFileShareSpecRetentionMonthlyCodec struct {
}

func (PolicyFileShareSpecRetentionMonthlyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PolicyFileShareSpecRetentionMonthly)(ptr) == nil
}

func (PolicyFileShareSpecRetentionMonthlyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PolicyFileShareSpecRetentionMonthly)(ptr)
	var objs []PolicyFileShareSpecRetentionMonthly
	if obj != nil {
		objs = []PolicyFileShareSpecRetentionMonthly{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicyFileShareSpecRetentionMonthly{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PolicyFileShareSpecRetentionMonthlyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PolicyFileShareSpecRetentionMonthly)(ptr) = PolicyFileShareSpecRetentionMonthly{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PolicyFileShareSpecRetentionMonthly

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicyFileShareSpecRetentionMonthly{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PolicyFileShareSpecRetentionMonthly)(ptr) = objs[0]
			} else {
				*(*PolicyFileShareSpecRetentionMonthly)(ptr) = PolicyFileShareSpecRetentionMonthly{}
			}
		} else {
			*(*PolicyFileShareSpecRetentionMonthly)(ptr) = PolicyFileShareSpecRetentionMonthly{}
		}
	default:
		iter.ReportError("decode PolicyFileShareSpecRetentionMonthly", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PolicyFileShareSpecRetentionWeeklyCodec struct {
}

func (PolicyFileShareSpecRetentionWeeklyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PolicyFileShareSpecRetentionWeekly)(ptr) == nil
}

func (PolicyFileShareSpecRetentionWeeklyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PolicyFileShareSpecRetentionWeekly)(ptr)
	var objs []PolicyFileShareSpecRetentionWeekly
	if obj != nil {
		objs = []PolicyFileShareSpecRetentionWeekly{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicyFileShareSpecRetentionWeekly{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PolicyFileShareSpecRetentionWeeklyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PolicyFileShareSpecRetentionWeekly)(ptr) = PolicyFileShareSpecRetentionWeekly{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PolicyFileShareSpecRetentionWeekly

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicyFileShareSpecRetentionWeekly{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PolicyFileShareSpecRetentionWeekly)(ptr) = objs[0]
			} else {
				*(*PolicyFileShareSpecRetentionWeekly)(ptr) = PolicyFileShareSpecRetentionWeekly{}
			}
		} else {
			*(*PolicyFileShareSpecRetentionWeekly)(ptr) = PolicyFileShareSpecRetentionWeekly{}
		}
	default:
		iter.ReportError("decode PolicyFileShareSpecRetentionWeekly", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PolicyFileShareSpecRetentionYearlyCodec struct {
}

func (PolicyFileShareSpecRetentionYearlyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PolicyFileShareSpecRetentionYearly)(ptr) == nil
}

func (PolicyFileShareSpecRetentionYearlyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PolicyFileShareSpecRetentionYearly)(ptr)
	var objs []PolicyFileShareSpecRetentionYearly
	if obj != nil {
		objs = []PolicyFileShareSpecRetentionYearly{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicyFileShareSpecRetentionYearly{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PolicyFileShareSpecRetentionYearlyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PolicyFileShareSpecRetentionYearly)(ptr) = PolicyFileShareSpecRetentionYearly{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PolicyFileShareSpecRetentionYearly

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicyFileShareSpecRetentionYearly{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PolicyFileShareSpecRetentionYearly)(ptr) = objs[0]
			} else {
				*(*PolicyFileShareSpecRetentionYearly)(ptr) = PolicyFileShareSpecRetentionYearly{}
			}
		} else {
			*(*PolicyFileShareSpecRetentionYearly)(ptr) = PolicyFileShareSpecRetentionYearly{}
		}
	default:
		iter.ReportError("decode PolicyFileShareSpecRetentionYearly", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PolicyVmSpecBackupCodec struct {
}

func (PolicyVmSpecBackupCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PolicyVmSpecBackup)(ptr) == nil
}

func (PolicyVmSpecBackupCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PolicyVmSpecBackup)(ptr)
	var objs []PolicyVmSpecBackup
	if obj != nil {
		objs = []PolicyVmSpecBackup{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicyVmSpecBackup{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PolicyVmSpecBackupCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PolicyVmSpecBackup)(ptr) = PolicyVmSpecBackup{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PolicyVmSpecBackup

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicyVmSpecBackup{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PolicyVmSpecBackup)(ptr) = objs[0]
			} else {
				*(*PolicyVmSpecBackup)(ptr) = PolicyVmSpecBackup{}
			}
		} else {
			*(*PolicyVmSpecBackup)(ptr) = PolicyVmSpecBackup{}
		}
	default:
		iter.ReportError("decode PolicyVmSpecBackup", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PolicyVmSpecRetentionDailyCodec struct {
}

func (PolicyVmSpecRetentionDailyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PolicyVmSpecRetentionDaily)(ptr) == nil
}

func (PolicyVmSpecRetentionDailyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PolicyVmSpecRetentionDaily)(ptr)
	var objs []PolicyVmSpecRetentionDaily
	if obj != nil {
		objs = []PolicyVmSpecRetentionDaily{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicyVmSpecRetentionDaily{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PolicyVmSpecRetentionDailyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PolicyVmSpecRetentionDaily)(ptr) = PolicyVmSpecRetentionDaily{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PolicyVmSpecRetentionDaily

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicyVmSpecRetentionDaily{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PolicyVmSpecRetentionDaily)(ptr) = objs[0]
			} else {
				*(*PolicyVmSpecRetentionDaily)(ptr) = PolicyVmSpecRetentionDaily{}
			}
		} else {
			*(*PolicyVmSpecRetentionDaily)(ptr) = PolicyVmSpecRetentionDaily{}
		}
	default:
		iter.ReportError("decode PolicyVmSpecRetentionDaily", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PolicyVmSpecRetentionMonthlyCodec struct {
}

func (PolicyVmSpecRetentionMonthlyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PolicyVmSpecRetentionMonthly)(ptr) == nil
}

func (PolicyVmSpecRetentionMonthlyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PolicyVmSpecRetentionMonthly)(ptr)
	var objs []PolicyVmSpecRetentionMonthly
	if obj != nil {
		objs = []PolicyVmSpecRetentionMonthly{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicyVmSpecRetentionMonthly{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PolicyVmSpecRetentionMonthlyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PolicyVmSpecRetentionMonthly)(ptr) = PolicyVmSpecRetentionMonthly{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PolicyVmSpecRetentionMonthly

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicyVmSpecRetentionMonthly{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PolicyVmSpecRetentionMonthly)(ptr) = objs[0]
			} else {
				*(*PolicyVmSpecRetentionMonthly)(ptr) = PolicyVmSpecRetentionMonthly{}
			}
		} else {
			*(*PolicyVmSpecRetentionMonthly)(ptr) = PolicyVmSpecRetentionMonthly{}
		}
	default:
		iter.ReportError("decode PolicyVmSpecRetentionMonthly", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PolicyVmSpecRetentionWeeklyCodec struct {
}

func (PolicyVmSpecRetentionWeeklyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PolicyVmSpecRetentionWeekly)(ptr) == nil
}

func (PolicyVmSpecRetentionWeeklyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PolicyVmSpecRetentionWeekly)(ptr)
	var objs []PolicyVmSpecRetentionWeekly
	if obj != nil {
		objs = []PolicyVmSpecRetentionWeekly{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicyVmSpecRetentionWeekly{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PolicyVmSpecRetentionWeeklyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PolicyVmSpecRetentionWeekly)(ptr) = PolicyVmSpecRetentionWeekly{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PolicyVmSpecRetentionWeekly

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicyVmSpecRetentionWeekly{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PolicyVmSpecRetentionWeekly)(ptr) = objs[0]
			} else {
				*(*PolicyVmSpecRetentionWeekly)(ptr) = PolicyVmSpecRetentionWeekly{}
			}
		} else {
			*(*PolicyVmSpecRetentionWeekly)(ptr) = PolicyVmSpecRetentionWeekly{}
		}
	default:
		iter.ReportError("decode PolicyVmSpecRetentionWeekly", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type PolicyVmSpecRetentionYearlyCodec struct {
}

func (PolicyVmSpecRetentionYearlyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*PolicyVmSpecRetentionYearly)(ptr) == nil
}

func (PolicyVmSpecRetentionYearlyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*PolicyVmSpecRetentionYearly)(ptr)
	var objs []PolicyVmSpecRetentionYearly
	if obj != nil {
		objs = []PolicyVmSpecRetentionYearly{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicyVmSpecRetentionYearly{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (PolicyVmSpecRetentionYearlyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*PolicyVmSpecRetentionYearly)(ptr) = PolicyVmSpecRetentionYearly{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []PolicyVmSpecRetentionYearly

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(PolicyVmSpecRetentionYearly{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*PolicyVmSpecRetentionYearly)(ptr) = objs[0]
			} else {
				*(*PolicyVmSpecRetentionYearly)(ptr) = PolicyVmSpecRetentionYearly{}
			}
		} else {
			*(*PolicyVmSpecRetentionYearly)(ptr) = PolicyVmSpecRetentionYearly{}
		}
	default:
		iter.ReportError("decode PolicyVmSpecRetentionYearly", "unexpected JSON type")
	}
}
