/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AssetFilterSpecPresentationTimeRange{}).Type1()):                                            AssetFilterSpecPresentationTimeRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ContentKeyPolicySpecPolicyOptionFairplayConfiguration{}).Type1()):                           ContentKeyPolicySpecPolicyOptionFairplayConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ContentKeyPolicySpecPolicyOptionFairplayConfigurationOfflineRentalConfiguration{}).Type1()): ContentKeyPolicySpecPolicyOptionFairplayConfigurationOfflineRentalConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ContentKeyPolicySpecPolicyOptionPlayreadyConfigurationLicensePlayRight{}).Type1()):          ContentKeyPolicySpecPolicyOptionPlayreadyConfigurationLicensePlayRightCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ContentKeyPolicySpecPolicyOptionTokenRestriction{}).Type1()):                                ContentKeyPolicySpecPolicyOptionTokenRestrictionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecInputAsset{}).Type1()):                                                               JobSpecInputAssetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LiveEventSpecCrossSiteAccessPolicy{}).Type1()):                                              LiveEventSpecCrossSiteAccessPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LiveEventSpecEncoding{}).Type1()):                                                           LiveEventSpecEncodingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LiveEventSpecInput{}).Type1()):                                                              LiveEventSpecInputCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LiveEventSpecPreview{}).Type1()):                                                            LiveEventSpecPreviewCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServicesAccountSpecIdentity{}).Type1()):                                                     ServicesAccountSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServicesAccountSpecKeyDeliveryAccessControl{}).Type1()):                                     ServicesAccountSpecKeyDeliveryAccessControlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StreamingEndpointSpecAccessControl{}).Type1()):                                              StreamingEndpointSpecAccessControlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StreamingEndpointSpecCrossSiteAccessPolicy{}).Type1()):                                      StreamingEndpointSpecCrossSiteAccessPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCbcs{}).Type1()):                                         StreamingPolicySpecCommonEncryptionCbcsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCbcsDefaultContentKey{}).Type1()):                        StreamingPolicySpecCommonEncryptionCbcsDefaultContentKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCbcsDrmFairplay{}).Type1()):                              StreamingPolicySpecCommonEncryptionCbcsDrmFairplayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCbcsEnabledProtocols{}).Type1()):                         StreamingPolicySpecCommonEncryptionCbcsEnabledProtocolsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCenc{}).Type1()):                                         StreamingPolicySpecCommonEncryptionCencCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCencDefaultContentKey{}).Type1()):                        StreamingPolicySpecCommonEncryptionCencDefaultContentKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCencDrmPlayready{}).Type1()):                             StreamingPolicySpecCommonEncryptionCencDrmPlayreadyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCencEnabledProtocols{}).Type1()):                         StreamingPolicySpecCommonEncryptionCencEnabledProtocolsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecNoEncryptionEnabledProtocols{}).Type1()):                                 StreamingPolicySpecNoEncryptionEnabledProtocolsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransformSpecOutputAudioAnalyzerPreset{}).Type1()):                                          TransformSpecOutputAudioAnalyzerPresetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransformSpecOutputBuiltinPreset{}).Type1()):                                                TransformSpecOutputBuiltinPresetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransformSpecOutputFaceDetectorPreset{}).Type1()):                                           TransformSpecOutputFaceDetectorPresetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransformSpecOutputVideoAnalyzerPreset{}).Type1()):                                          TransformSpecOutputVideoAnalyzerPresetCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AssetFilterSpecPresentationTimeRange{}).Type1()):                                            AssetFilterSpecPresentationTimeRangeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ContentKeyPolicySpecPolicyOptionFairplayConfiguration{}).Type1()):                           ContentKeyPolicySpecPolicyOptionFairplayConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ContentKeyPolicySpecPolicyOptionFairplayConfigurationOfflineRentalConfiguration{}).Type1()): ContentKeyPolicySpecPolicyOptionFairplayConfigurationOfflineRentalConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ContentKeyPolicySpecPolicyOptionPlayreadyConfigurationLicensePlayRight{}).Type1()):          ContentKeyPolicySpecPolicyOptionPlayreadyConfigurationLicensePlayRightCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ContentKeyPolicySpecPolicyOptionTokenRestriction{}).Type1()):                                ContentKeyPolicySpecPolicyOptionTokenRestrictionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(JobSpecInputAsset{}).Type1()):                                                               JobSpecInputAssetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LiveEventSpecCrossSiteAccessPolicy{}).Type1()):                                              LiveEventSpecCrossSiteAccessPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LiveEventSpecEncoding{}).Type1()):                                                           LiveEventSpecEncodingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LiveEventSpecInput{}).Type1()):                                                              LiveEventSpecInputCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LiveEventSpecPreview{}).Type1()):                                                            LiveEventSpecPreviewCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServicesAccountSpecIdentity{}).Type1()):                                                     ServicesAccountSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServicesAccountSpecKeyDeliveryAccessControl{}).Type1()):                                     ServicesAccountSpecKeyDeliveryAccessControlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StreamingEndpointSpecAccessControl{}).Type1()):                                              StreamingEndpointSpecAccessControlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StreamingEndpointSpecCrossSiteAccessPolicy{}).Type1()):                                      StreamingEndpointSpecCrossSiteAccessPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCbcs{}).Type1()):                                         StreamingPolicySpecCommonEncryptionCbcsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCbcsDefaultContentKey{}).Type1()):                        StreamingPolicySpecCommonEncryptionCbcsDefaultContentKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCbcsDrmFairplay{}).Type1()):                              StreamingPolicySpecCommonEncryptionCbcsDrmFairplayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCbcsEnabledProtocols{}).Type1()):                         StreamingPolicySpecCommonEncryptionCbcsEnabledProtocolsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCenc{}).Type1()):                                         StreamingPolicySpecCommonEncryptionCencCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCencDefaultContentKey{}).Type1()):                        StreamingPolicySpecCommonEncryptionCencDefaultContentKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCencDrmPlayready{}).Type1()):                             StreamingPolicySpecCommonEncryptionCencDrmPlayreadyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCencEnabledProtocols{}).Type1()):                         StreamingPolicySpecCommonEncryptionCencEnabledProtocolsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecNoEncryptionEnabledProtocols{}).Type1()):                                 StreamingPolicySpecNoEncryptionEnabledProtocolsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransformSpecOutputAudioAnalyzerPreset{}).Type1()):                                          TransformSpecOutputAudioAnalyzerPresetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransformSpecOutputBuiltinPreset{}).Type1()):                                                TransformSpecOutputBuiltinPresetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransformSpecOutputFaceDetectorPreset{}).Type1()):                                           TransformSpecOutputFaceDetectorPresetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TransformSpecOutputVideoAnalyzerPreset{}).Type1()):                                          TransformSpecOutputVideoAnalyzerPresetCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AssetFilterSpecPresentationTimeRangeCodec struct {
}

func (AssetFilterSpecPresentationTimeRangeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AssetFilterSpecPresentationTimeRange)(ptr) == nil
}

func (AssetFilterSpecPresentationTimeRangeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AssetFilterSpecPresentationTimeRange)(ptr)
	var objs []AssetFilterSpecPresentationTimeRange
	if obj != nil {
		objs = []AssetFilterSpecPresentationTimeRange{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AssetFilterSpecPresentationTimeRange{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AssetFilterSpecPresentationTimeRangeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AssetFilterSpecPresentationTimeRange)(ptr) = AssetFilterSpecPresentationTimeRange{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AssetFilterSpecPresentationTimeRange

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AssetFilterSpecPresentationTimeRange{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AssetFilterSpecPresentationTimeRange)(ptr) = objs[0]
			} else {
				*(*AssetFilterSpecPresentationTimeRange)(ptr) = AssetFilterSpecPresentationTimeRange{}
			}
		} else {
			*(*AssetFilterSpecPresentationTimeRange)(ptr) = AssetFilterSpecPresentationTimeRange{}
		}
	default:
		iter.ReportError("decode AssetFilterSpecPresentationTimeRange", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ContentKeyPolicySpecPolicyOptionFairplayConfigurationCodec struct {
}

func (ContentKeyPolicySpecPolicyOptionFairplayConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ContentKeyPolicySpecPolicyOptionFairplayConfiguration)(ptr) == nil
}

func (ContentKeyPolicySpecPolicyOptionFairplayConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ContentKeyPolicySpecPolicyOptionFairplayConfiguration)(ptr)
	var objs []ContentKeyPolicySpecPolicyOptionFairplayConfiguration
	if obj != nil {
		objs = []ContentKeyPolicySpecPolicyOptionFairplayConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ContentKeyPolicySpecPolicyOptionFairplayConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ContentKeyPolicySpecPolicyOptionFairplayConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ContentKeyPolicySpecPolicyOptionFairplayConfiguration)(ptr) = ContentKeyPolicySpecPolicyOptionFairplayConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ContentKeyPolicySpecPolicyOptionFairplayConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ContentKeyPolicySpecPolicyOptionFairplayConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ContentKeyPolicySpecPolicyOptionFairplayConfiguration)(ptr) = objs[0]
			} else {
				*(*ContentKeyPolicySpecPolicyOptionFairplayConfiguration)(ptr) = ContentKeyPolicySpecPolicyOptionFairplayConfiguration{}
			}
		} else {
			*(*ContentKeyPolicySpecPolicyOptionFairplayConfiguration)(ptr) = ContentKeyPolicySpecPolicyOptionFairplayConfiguration{}
		}
	default:
		iter.ReportError("decode ContentKeyPolicySpecPolicyOptionFairplayConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ContentKeyPolicySpecPolicyOptionFairplayConfigurationOfflineRentalConfigurationCodec struct {
}

func (ContentKeyPolicySpecPolicyOptionFairplayConfigurationOfflineRentalConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ContentKeyPolicySpecPolicyOptionFairplayConfigurationOfflineRentalConfiguration)(ptr) == nil
}

func (ContentKeyPolicySpecPolicyOptionFairplayConfigurationOfflineRentalConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ContentKeyPolicySpecPolicyOptionFairplayConfigurationOfflineRentalConfiguration)(ptr)
	var objs []ContentKeyPolicySpecPolicyOptionFairplayConfigurationOfflineRentalConfiguration
	if obj != nil {
		objs = []ContentKeyPolicySpecPolicyOptionFairplayConfigurationOfflineRentalConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ContentKeyPolicySpecPolicyOptionFairplayConfigurationOfflineRentalConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ContentKeyPolicySpecPolicyOptionFairplayConfigurationOfflineRentalConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ContentKeyPolicySpecPolicyOptionFairplayConfigurationOfflineRentalConfiguration)(ptr) = ContentKeyPolicySpecPolicyOptionFairplayConfigurationOfflineRentalConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ContentKeyPolicySpecPolicyOptionFairplayConfigurationOfflineRentalConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ContentKeyPolicySpecPolicyOptionFairplayConfigurationOfflineRentalConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ContentKeyPolicySpecPolicyOptionFairplayConfigurationOfflineRentalConfiguration)(ptr) = objs[0]
			} else {
				*(*ContentKeyPolicySpecPolicyOptionFairplayConfigurationOfflineRentalConfiguration)(ptr) = ContentKeyPolicySpecPolicyOptionFairplayConfigurationOfflineRentalConfiguration{}
			}
		} else {
			*(*ContentKeyPolicySpecPolicyOptionFairplayConfigurationOfflineRentalConfiguration)(ptr) = ContentKeyPolicySpecPolicyOptionFairplayConfigurationOfflineRentalConfiguration{}
		}
	default:
		iter.ReportError("decode ContentKeyPolicySpecPolicyOptionFairplayConfigurationOfflineRentalConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ContentKeyPolicySpecPolicyOptionPlayreadyConfigurationLicensePlayRightCodec struct {
}

func (ContentKeyPolicySpecPolicyOptionPlayreadyConfigurationLicensePlayRightCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ContentKeyPolicySpecPolicyOptionPlayreadyConfigurationLicensePlayRight)(ptr) == nil
}

func (ContentKeyPolicySpecPolicyOptionPlayreadyConfigurationLicensePlayRightCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ContentKeyPolicySpecPolicyOptionPlayreadyConfigurationLicensePlayRight)(ptr)
	var objs []ContentKeyPolicySpecPolicyOptionPlayreadyConfigurationLicensePlayRight
	if obj != nil {
		objs = []ContentKeyPolicySpecPolicyOptionPlayreadyConfigurationLicensePlayRight{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ContentKeyPolicySpecPolicyOptionPlayreadyConfigurationLicensePlayRight{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ContentKeyPolicySpecPolicyOptionPlayreadyConfigurationLicensePlayRightCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ContentKeyPolicySpecPolicyOptionPlayreadyConfigurationLicensePlayRight)(ptr) = ContentKeyPolicySpecPolicyOptionPlayreadyConfigurationLicensePlayRight{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ContentKeyPolicySpecPolicyOptionPlayreadyConfigurationLicensePlayRight

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ContentKeyPolicySpecPolicyOptionPlayreadyConfigurationLicensePlayRight{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ContentKeyPolicySpecPolicyOptionPlayreadyConfigurationLicensePlayRight)(ptr) = objs[0]
			} else {
				*(*ContentKeyPolicySpecPolicyOptionPlayreadyConfigurationLicensePlayRight)(ptr) = ContentKeyPolicySpecPolicyOptionPlayreadyConfigurationLicensePlayRight{}
			}
		} else {
			*(*ContentKeyPolicySpecPolicyOptionPlayreadyConfigurationLicensePlayRight)(ptr) = ContentKeyPolicySpecPolicyOptionPlayreadyConfigurationLicensePlayRight{}
		}
	default:
		iter.ReportError("decode ContentKeyPolicySpecPolicyOptionPlayreadyConfigurationLicensePlayRight", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ContentKeyPolicySpecPolicyOptionTokenRestrictionCodec struct {
}

func (ContentKeyPolicySpecPolicyOptionTokenRestrictionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ContentKeyPolicySpecPolicyOptionTokenRestriction)(ptr) == nil
}

func (ContentKeyPolicySpecPolicyOptionTokenRestrictionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ContentKeyPolicySpecPolicyOptionTokenRestriction)(ptr)
	var objs []ContentKeyPolicySpecPolicyOptionTokenRestriction
	if obj != nil {
		objs = []ContentKeyPolicySpecPolicyOptionTokenRestriction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ContentKeyPolicySpecPolicyOptionTokenRestriction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ContentKeyPolicySpecPolicyOptionTokenRestrictionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ContentKeyPolicySpecPolicyOptionTokenRestriction)(ptr) = ContentKeyPolicySpecPolicyOptionTokenRestriction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ContentKeyPolicySpecPolicyOptionTokenRestriction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ContentKeyPolicySpecPolicyOptionTokenRestriction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ContentKeyPolicySpecPolicyOptionTokenRestriction)(ptr) = objs[0]
			} else {
				*(*ContentKeyPolicySpecPolicyOptionTokenRestriction)(ptr) = ContentKeyPolicySpecPolicyOptionTokenRestriction{}
			}
		} else {
			*(*ContentKeyPolicySpecPolicyOptionTokenRestriction)(ptr) = ContentKeyPolicySpecPolicyOptionTokenRestriction{}
		}
	default:
		iter.ReportError("decode ContentKeyPolicySpecPolicyOptionTokenRestriction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type JobSpecInputAssetCodec struct {
}

func (JobSpecInputAssetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*JobSpecInputAsset)(ptr) == nil
}

func (JobSpecInputAssetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*JobSpecInputAsset)(ptr)
	var objs []JobSpecInputAsset
	if obj != nil {
		objs = []JobSpecInputAsset{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecInputAsset{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (JobSpecInputAssetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*JobSpecInputAsset)(ptr) = JobSpecInputAsset{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []JobSpecInputAsset

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(JobSpecInputAsset{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*JobSpecInputAsset)(ptr) = objs[0]
			} else {
				*(*JobSpecInputAsset)(ptr) = JobSpecInputAsset{}
			}
		} else {
			*(*JobSpecInputAsset)(ptr) = JobSpecInputAsset{}
		}
	default:
		iter.ReportError("decode JobSpecInputAsset", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LiveEventSpecCrossSiteAccessPolicyCodec struct {
}

func (LiveEventSpecCrossSiteAccessPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LiveEventSpecCrossSiteAccessPolicy)(ptr) == nil
}

func (LiveEventSpecCrossSiteAccessPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LiveEventSpecCrossSiteAccessPolicy)(ptr)
	var objs []LiveEventSpecCrossSiteAccessPolicy
	if obj != nil {
		objs = []LiveEventSpecCrossSiteAccessPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LiveEventSpecCrossSiteAccessPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LiveEventSpecCrossSiteAccessPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LiveEventSpecCrossSiteAccessPolicy)(ptr) = LiveEventSpecCrossSiteAccessPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LiveEventSpecCrossSiteAccessPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LiveEventSpecCrossSiteAccessPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LiveEventSpecCrossSiteAccessPolicy)(ptr) = objs[0]
			} else {
				*(*LiveEventSpecCrossSiteAccessPolicy)(ptr) = LiveEventSpecCrossSiteAccessPolicy{}
			}
		} else {
			*(*LiveEventSpecCrossSiteAccessPolicy)(ptr) = LiveEventSpecCrossSiteAccessPolicy{}
		}
	default:
		iter.ReportError("decode LiveEventSpecCrossSiteAccessPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LiveEventSpecEncodingCodec struct {
}

func (LiveEventSpecEncodingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LiveEventSpecEncoding)(ptr) == nil
}

func (LiveEventSpecEncodingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LiveEventSpecEncoding)(ptr)
	var objs []LiveEventSpecEncoding
	if obj != nil {
		objs = []LiveEventSpecEncoding{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LiveEventSpecEncoding{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LiveEventSpecEncodingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LiveEventSpecEncoding)(ptr) = LiveEventSpecEncoding{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LiveEventSpecEncoding

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LiveEventSpecEncoding{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LiveEventSpecEncoding)(ptr) = objs[0]
			} else {
				*(*LiveEventSpecEncoding)(ptr) = LiveEventSpecEncoding{}
			}
		} else {
			*(*LiveEventSpecEncoding)(ptr) = LiveEventSpecEncoding{}
		}
	default:
		iter.ReportError("decode LiveEventSpecEncoding", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LiveEventSpecInputCodec struct {
}

func (LiveEventSpecInputCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LiveEventSpecInput)(ptr) == nil
}

func (LiveEventSpecInputCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LiveEventSpecInput)(ptr)
	var objs []LiveEventSpecInput
	if obj != nil {
		objs = []LiveEventSpecInput{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LiveEventSpecInput{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LiveEventSpecInputCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LiveEventSpecInput)(ptr) = LiveEventSpecInput{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LiveEventSpecInput

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LiveEventSpecInput{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LiveEventSpecInput)(ptr) = objs[0]
			} else {
				*(*LiveEventSpecInput)(ptr) = LiveEventSpecInput{}
			}
		} else {
			*(*LiveEventSpecInput)(ptr) = LiveEventSpecInput{}
		}
	default:
		iter.ReportError("decode LiveEventSpecInput", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LiveEventSpecPreviewCodec struct {
}

func (LiveEventSpecPreviewCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LiveEventSpecPreview)(ptr) == nil
}

func (LiveEventSpecPreviewCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LiveEventSpecPreview)(ptr)
	var objs []LiveEventSpecPreview
	if obj != nil {
		objs = []LiveEventSpecPreview{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LiveEventSpecPreview{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LiveEventSpecPreviewCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LiveEventSpecPreview)(ptr) = LiveEventSpecPreview{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LiveEventSpecPreview

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LiveEventSpecPreview{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LiveEventSpecPreview)(ptr) = objs[0]
			} else {
				*(*LiveEventSpecPreview)(ptr) = LiveEventSpecPreview{}
			}
		} else {
			*(*LiveEventSpecPreview)(ptr) = LiveEventSpecPreview{}
		}
	default:
		iter.ReportError("decode LiveEventSpecPreview", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServicesAccountSpecIdentityCodec struct {
}

func (ServicesAccountSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServicesAccountSpecIdentity)(ptr) == nil
}

func (ServicesAccountSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServicesAccountSpecIdentity)(ptr)
	var objs []ServicesAccountSpecIdentity
	if obj != nil {
		objs = []ServicesAccountSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServicesAccountSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServicesAccountSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServicesAccountSpecIdentity)(ptr) = ServicesAccountSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServicesAccountSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServicesAccountSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServicesAccountSpecIdentity)(ptr) = objs[0]
			} else {
				*(*ServicesAccountSpecIdentity)(ptr) = ServicesAccountSpecIdentity{}
			}
		} else {
			*(*ServicesAccountSpecIdentity)(ptr) = ServicesAccountSpecIdentity{}
		}
	default:
		iter.ReportError("decode ServicesAccountSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServicesAccountSpecKeyDeliveryAccessControlCodec struct {
}

func (ServicesAccountSpecKeyDeliveryAccessControlCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServicesAccountSpecKeyDeliveryAccessControl)(ptr) == nil
}

func (ServicesAccountSpecKeyDeliveryAccessControlCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServicesAccountSpecKeyDeliveryAccessControl)(ptr)
	var objs []ServicesAccountSpecKeyDeliveryAccessControl
	if obj != nil {
		objs = []ServicesAccountSpecKeyDeliveryAccessControl{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServicesAccountSpecKeyDeliveryAccessControl{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServicesAccountSpecKeyDeliveryAccessControlCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServicesAccountSpecKeyDeliveryAccessControl)(ptr) = ServicesAccountSpecKeyDeliveryAccessControl{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServicesAccountSpecKeyDeliveryAccessControl

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServicesAccountSpecKeyDeliveryAccessControl{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServicesAccountSpecKeyDeliveryAccessControl)(ptr) = objs[0]
			} else {
				*(*ServicesAccountSpecKeyDeliveryAccessControl)(ptr) = ServicesAccountSpecKeyDeliveryAccessControl{}
			}
		} else {
			*(*ServicesAccountSpecKeyDeliveryAccessControl)(ptr) = ServicesAccountSpecKeyDeliveryAccessControl{}
		}
	default:
		iter.ReportError("decode ServicesAccountSpecKeyDeliveryAccessControl", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StreamingEndpointSpecAccessControlCodec struct {
}

func (StreamingEndpointSpecAccessControlCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StreamingEndpointSpecAccessControl)(ptr) == nil
}

func (StreamingEndpointSpecAccessControlCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StreamingEndpointSpecAccessControl)(ptr)
	var objs []StreamingEndpointSpecAccessControl
	if obj != nil {
		objs = []StreamingEndpointSpecAccessControl{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StreamingEndpointSpecAccessControl{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StreamingEndpointSpecAccessControlCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StreamingEndpointSpecAccessControl)(ptr) = StreamingEndpointSpecAccessControl{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StreamingEndpointSpecAccessControl

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StreamingEndpointSpecAccessControl{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StreamingEndpointSpecAccessControl)(ptr) = objs[0]
			} else {
				*(*StreamingEndpointSpecAccessControl)(ptr) = StreamingEndpointSpecAccessControl{}
			}
		} else {
			*(*StreamingEndpointSpecAccessControl)(ptr) = StreamingEndpointSpecAccessControl{}
		}
	default:
		iter.ReportError("decode StreamingEndpointSpecAccessControl", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StreamingEndpointSpecCrossSiteAccessPolicyCodec struct {
}

func (StreamingEndpointSpecCrossSiteAccessPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StreamingEndpointSpecCrossSiteAccessPolicy)(ptr) == nil
}

func (StreamingEndpointSpecCrossSiteAccessPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StreamingEndpointSpecCrossSiteAccessPolicy)(ptr)
	var objs []StreamingEndpointSpecCrossSiteAccessPolicy
	if obj != nil {
		objs = []StreamingEndpointSpecCrossSiteAccessPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StreamingEndpointSpecCrossSiteAccessPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StreamingEndpointSpecCrossSiteAccessPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StreamingEndpointSpecCrossSiteAccessPolicy)(ptr) = StreamingEndpointSpecCrossSiteAccessPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StreamingEndpointSpecCrossSiteAccessPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StreamingEndpointSpecCrossSiteAccessPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StreamingEndpointSpecCrossSiteAccessPolicy)(ptr) = objs[0]
			} else {
				*(*StreamingEndpointSpecCrossSiteAccessPolicy)(ptr) = StreamingEndpointSpecCrossSiteAccessPolicy{}
			}
		} else {
			*(*StreamingEndpointSpecCrossSiteAccessPolicy)(ptr) = StreamingEndpointSpecCrossSiteAccessPolicy{}
		}
	default:
		iter.ReportError("decode StreamingEndpointSpecCrossSiteAccessPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StreamingPolicySpecCommonEncryptionCbcsCodec struct {
}

func (StreamingPolicySpecCommonEncryptionCbcsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StreamingPolicySpecCommonEncryptionCbcs)(ptr) == nil
}

func (StreamingPolicySpecCommonEncryptionCbcsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StreamingPolicySpecCommonEncryptionCbcs)(ptr)
	var objs []StreamingPolicySpecCommonEncryptionCbcs
	if obj != nil {
		objs = []StreamingPolicySpecCommonEncryptionCbcs{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCbcs{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StreamingPolicySpecCommonEncryptionCbcsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StreamingPolicySpecCommonEncryptionCbcs)(ptr) = StreamingPolicySpecCommonEncryptionCbcs{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StreamingPolicySpecCommonEncryptionCbcs

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCbcs{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StreamingPolicySpecCommonEncryptionCbcs)(ptr) = objs[0]
			} else {
				*(*StreamingPolicySpecCommonEncryptionCbcs)(ptr) = StreamingPolicySpecCommonEncryptionCbcs{}
			}
		} else {
			*(*StreamingPolicySpecCommonEncryptionCbcs)(ptr) = StreamingPolicySpecCommonEncryptionCbcs{}
		}
	default:
		iter.ReportError("decode StreamingPolicySpecCommonEncryptionCbcs", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StreamingPolicySpecCommonEncryptionCbcsDefaultContentKeyCodec struct {
}

func (StreamingPolicySpecCommonEncryptionCbcsDefaultContentKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StreamingPolicySpecCommonEncryptionCbcsDefaultContentKey)(ptr) == nil
}

func (StreamingPolicySpecCommonEncryptionCbcsDefaultContentKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StreamingPolicySpecCommonEncryptionCbcsDefaultContentKey)(ptr)
	var objs []StreamingPolicySpecCommonEncryptionCbcsDefaultContentKey
	if obj != nil {
		objs = []StreamingPolicySpecCommonEncryptionCbcsDefaultContentKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCbcsDefaultContentKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StreamingPolicySpecCommonEncryptionCbcsDefaultContentKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StreamingPolicySpecCommonEncryptionCbcsDefaultContentKey)(ptr) = StreamingPolicySpecCommonEncryptionCbcsDefaultContentKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StreamingPolicySpecCommonEncryptionCbcsDefaultContentKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCbcsDefaultContentKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StreamingPolicySpecCommonEncryptionCbcsDefaultContentKey)(ptr) = objs[0]
			} else {
				*(*StreamingPolicySpecCommonEncryptionCbcsDefaultContentKey)(ptr) = StreamingPolicySpecCommonEncryptionCbcsDefaultContentKey{}
			}
		} else {
			*(*StreamingPolicySpecCommonEncryptionCbcsDefaultContentKey)(ptr) = StreamingPolicySpecCommonEncryptionCbcsDefaultContentKey{}
		}
	default:
		iter.ReportError("decode StreamingPolicySpecCommonEncryptionCbcsDefaultContentKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StreamingPolicySpecCommonEncryptionCbcsDrmFairplayCodec struct {
}

func (StreamingPolicySpecCommonEncryptionCbcsDrmFairplayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StreamingPolicySpecCommonEncryptionCbcsDrmFairplay)(ptr) == nil
}

func (StreamingPolicySpecCommonEncryptionCbcsDrmFairplayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StreamingPolicySpecCommonEncryptionCbcsDrmFairplay)(ptr)
	var objs []StreamingPolicySpecCommonEncryptionCbcsDrmFairplay
	if obj != nil {
		objs = []StreamingPolicySpecCommonEncryptionCbcsDrmFairplay{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCbcsDrmFairplay{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StreamingPolicySpecCommonEncryptionCbcsDrmFairplayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StreamingPolicySpecCommonEncryptionCbcsDrmFairplay)(ptr) = StreamingPolicySpecCommonEncryptionCbcsDrmFairplay{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StreamingPolicySpecCommonEncryptionCbcsDrmFairplay

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCbcsDrmFairplay{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StreamingPolicySpecCommonEncryptionCbcsDrmFairplay)(ptr) = objs[0]
			} else {
				*(*StreamingPolicySpecCommonEncryptionCbcsDrmFairplay)(ptr) = StreamingPolicySpecCommonEncryptionCbcsDrmFairplay{}
			}
		} else {
			*(*StreamingPolicySpecCommonEncryptionCbcsDrmFairplay)(ptr) = StreamingPolicySpecCommonEncryptionCbcsDrmFairplay{}
		}
	default:
		iter.ReportError("decode StreamingPolicySpecCommonEncryptionCbcsDrmFairplay", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StreamingPolicySpecCommonEncryptionCbcsEnabledProtocolsCodec struct {
}

func (StreamingPolicySpecCommonEncryptionCbcsEnabledProtocolsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StreamingPolicySpecCommonEncryptionCbcsEnabledProtocols)(ptr) == nil
}

func (StreamingPolicySpecCommonEncryptionCbcsEnabledProtocolsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StreamingPolicySpecCommonEncryptionCbcsEnabledProtocols)(ptr)
	var objs []StreamingPolicySpecCommonEncryptionCbcsEnabledProtocols
	if obj != nil {
		objs = []StreamingPolicySpecCommonEncryptionCbcsEnabledProtocols{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCbcsEnabledProtocols{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StreamingPolicySpecCommonEncryptionCbcsEnabledProtocolsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StreamingPolicySpecCommonEncryptionCbcsEnabledProtocols)(ptr) = StreamingPolicySpecCommonEncryptionCbcsEnabledProtocols{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StreamingPolicySpecCommonEncryptionCbcsEnabledProtocols

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCbcsEnabledProtocols{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StreamingPolicySpecCommonEncryptionCbcsEnabledProtocols)(ptr) = objs[0]
			} else {
				*(*StreamingPolicySpecCommonEncryptionCbcsEnabledProtocols)(ptr) = StreamingPolicySpecCommonEncryptionCbcsEnabledProtocols{}
			}
		} else {
			*(*StreamingPolicySpecCommonEncryptionCbcsEnabledProtocols)(ptr) = StreamingPolicySpecCommonEncryptionCbcsEnabledProtocols{}
		}
	default:
		iter.ReportError("decode StreamingPolicySpecCommonEncryptionCbcsEnabledProtocols", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StreamingPolicySpecCommonEncryptionCencCodec struct {
}

func (StreamingPolicySpecCommonEncryptionCencCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StreamingPolicySpecCommonEncryptionCenc)(ptr) == nil
}

func (StreamingPolicySpecCommonEncryptionCencCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StreamingPolicySpecCommonEncryptionCenc)(ptr)
	var objs []StreamingPolicySpecCommonEncryptionCenc
	if obj != nil {
		objs = []StreamingPolicySpecCommonEncryptionCenc{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCenc{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StreamingPolicySpecCommonEncryptionCencCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StreamingPolicySpecCommonEncryptionCenc)(ptr) = StreamingPolicySpecCommonEncryptionCenc{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StreamingPolicySpecCommonEncryptionCenc

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCenc{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StreamingPolicySpecCommonEncryptionCenc)(ptr) = objs[0]
			} else {
				*(*StreamingPolicySpecCommonEncryptionCenc)(ptr) = StreamingPolicySpecCommonEncryptionCenc{}
			}
		} else {
			*(*StreamingPolicySpecCommonEncryptionCenc)(ptr) = StreamingPolicySpecCommonEncryptionCenc{}
		}
	default:
		iter.ReportError("decode StreamingPolicySpecCommonEncryptionCenc", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StreamingPolicySpecCommonEncryptionCencDefaultContentKeyCodec struct {
}

func (StreamingPolicySpecCommonEncryptionCencDefaultContentKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StreamingPolicySpecCommonEncryptionCencDefaultContentKey)(ptr) == nil
}

func (StreamingPolicySpecCommonEncryptionCencDefaultContentKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StreamingPolicySpecCommonEncryptionCencDefaultContentKey)(ptr)
	var objs []StreamingPolicySpecCommonEncryptionCencDefaultContentKey
	if obj != nil {
		objs = []StreamingPolicySpecCommonEncryptionCencDefaultContentKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCencDefaultContentKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StreamingPolicySpecCommonEncryptionCencDefaultContentKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StreamingPolicySpecCommonEncryptionCencDefaultContentKey)(ptr) = StreamingPolicySpecCommonEncryptionCencDefaultContentKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StreamingPolicySpecCommonEncryptionCencDefaultContentKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCencDefaultContentKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StreamingPolicySpecCommonEncryptionCencDefaultContentKey)(ptr) = objs[0]
			} else {
				*(*StreamingPolicySpecCommonEncryptionCencDefaultContentKey)(ptr) = StreamingPolicySpecCommonEncryptionCencDefaultContentKey{}
			}
		} else {
			*(*StreamingPolicySpecCommonEncryptionCencDefaultContentKey)(ptr) = StreamingPolicySpecCommonEncryptionCencDefaultContentKey{}
		}
	default:
		iter.ReportError("decode StreamingPolicySpecCommonEncryptionCencDefaultContentKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StreamingPolicySpecCommonEncryptionCencDrmPlayreadyCodec struct {
}

func (StreamingPolicySpecCommonEncryptionCencDrmPlayreadyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StreamingPolicySpecCommonEncryptionCencDrmPlayready)(ptr) == nil
}

func (StreamingPolicySpecCommonEncryptionCencDrmPlayreadyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StreamingPolicySpecCommonEncryptionCencDrmPlayready)(ptr)
	var objs []StreamingPolicySpecCommonEncryptionCencDrmPlayready
	if obj != nil {
		objs = []StreamingPolicySpecCommonEncryptionCencDrmPlayready{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCencDrmPlayready{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StreamingPolicySpecCommonEncryptionCencDrmPlayreadyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StreamingPolicySpecCommonEncryptionCencDrmPlayready)(ptr) = StreamingPolicySpecCommonEncryptionCencDrmPlayready{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StreamingPolicySpecCommonEncryptionCencDrmPlayready

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCencDrmPlayready{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StreamingPolicySpecCommonEncryptionCencDrmPlayready)(ptr) = objs[0]
			} else {
				*(*StreamingPolicySpecCommonEncryptionCencDrmPlayready)(ptr) = StreamingPolicySpecCommonEncryptionCencDrmPlayready{}
			}
		} else {
			*(*StreamingPolicySpecCommonEncryptionCencDrmPlayready)(ptr) = StreamingPolicySpecCommonEncryptionCencDrmPlayready{}
		}
	default:
		iter.ReportError("decode StreamingPolicySpecCommonEncryptionCencDrmPlayready", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StreamingPolicySpecCommonEncryptionCencEnabledProtocolsCodec struct {
}

func (StreamingPolicySpecCommonEncryptionCencEnabledProtocolsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StreamingPolicySpecCommonEncryptionCencEnabledProtocols)(ptr) == nil
}

func (StreamingPolicySpecCommonEncryptionCencEnabledProtocolsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StreamingPolicySpecCommonEncryptionCencEnabledProtocols)(ptr)
	var objs []StreamingPolicySpecCommonEncryptionCencEnabledProtocols
	if obj != nil {
		objs = []StreamingPolicySpecCommonEncryptionCencEnabledProtocols{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCencEnabledProtocols{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StreamingPolicySpecCommonEncryptionCencEnabledProtocolsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StreamingPolicySpecCommonEncryptionCencEnabledProtocols)(ptr) = StreamingPolicySpecCommonEncryptionCencEnabledProtocols{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StreamingPolicySpecCommonEncryptionCencEnabledProtocols

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecCommonEncryptionCencEnabledProtocols{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StreamingPolicySpecCommonEncryptionCencEnabledProtocols)(ptr) = objs[0]
			} else {
				*(*StreamingPolicySpecCommonEncryptionCencEnabledProtocols)(ptr) = StreamingPolicySpecCommonEncryptionCencEnabledProtocols{}
			}
		} else {
			*(*StreamingPolicySpecCommonEncryptionCencEnabledProtocols)(ptr) = StreamingPolicySpecCommonEncryptionCencEnabledProtocols{}
		}
	default:
		iter.ReportError("decode StreamingPolicySpecCommonEncryptionCencEnabledProtocols", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StreamingPolicySpecNoEncryptionEnabledProtocolsCodec struct {
}

func (StreamingPolicySpecNoEncryptionEnabledProtocolsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StreamingPolicySpecNoEncryptionEnabledProtocols)(ptr) == nil
}

func (StreamingPolicySpecNoEncryptionEnabledProtocolsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StreamingPolicySpecNoEncryptionEnabledProtocols)(ptr)
	var objs []StreamingPolicySpecNoEncryptionEnabledProtocols
	if obj != nil {
		objs = []StreamingPolicySpecNoEncryptionEnabledProtocols{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecNoEncryptionEnabledProtocols{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StreamingPolicySpecNoEncryptionEnabledProtocolsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StreamingPolicySpecNoEncryptionEnabledProtocols)(ptr) = StreamingPolicySpecNoEncryptionEnabledProtocols{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StreamingPolicySpecNoEncryptionEnabledProtocols

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StreamingPolicySpecNoEncryptionEnabledProtocols{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StreamingPolicySpecNoEncryptionEnabledProtocols)(ptr) = objs[0]
			} else {
				*(*StreamingPolicySpecNoEncryptionEnabledProtocols)(ptr) = StreamingPolicySpecNoEncryptionEnabledProtocols{}
			}
		} else {
			*(*StreamingPolicySpecNoEncryptionEnabledProtocols)(ptr) = StreamingPolicySpecNoEncryptionEnabledProtocols{}
		}
	default:
		iter.ReportError("decode StreamingPolicySpecNoEncryptionEnabledProtocols", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TransformSpecOutputAudioAnalyzerPresetCodec struct {
}

func (TransformSpecOutputAudioAnalyzerPresetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TransformSpecOutputAudioAnalyzerPreset)(ptr) == nil
}

func (TransformSpecOutputAudioAnalyzerPresetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TransformSpecOutputAudioAnalyzerPreset)(ptr)
	var objs []TransformSpecOutputAudioAnalyzerPreset
	if obj != nil {
		objs = []TransformSpecOutputAudioAnalyzerPreset{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransformSpecOutputAudioAnalyzerPreset{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TransformSpecOutputAudioAnalyzerPresetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TransformSpecOutputAudioAnalyzerPreset)(ptr) = TransformSpecOutputAudioAnalyzerPreset{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TransformSpecOutputAudioAnalyzerPreset

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransformSpecOutputAudioAnalyzerPreset{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TransformSpecOutputAudioAnalyzerPreset)(ptr) = objs[0]
			} else {
				*(*TransformSpecOutputAudioAnalyzerPreset)(ptr) = TransformSpecOutputAudioAnalyzerPreset{}
			}
		} else {
			*(*TransformSpecOutputAudioAnalyzerPreset)(ptr) = TransformSpecOutputAudioAnalyzerPreset{}
		}
	default:
		iter.ReportError("decode TransformSpecOutputAudioAnalyzerPreset", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TransformSpecOutputBuiltinPresetCodec struct {
}

func (TransformSpecOutputBuiltinPresetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TransformSpecOutputBuiltinPreset)(ptr) == nil
}

func (TransformSpecOutputBuiltinPresetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TransformSpecOutputBuiltinPreset)(ptr)
	var objs []TransformSpecOutputBuiltinPreset
	if obj != nil {
		objs = []TransformSpecOutputBuiltinPreset{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransformSpecOutputBuiltinPreset{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TransformSpecOutputBuiltinPresetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TransformSpecOutputBuiltinPreset)(ptr) = TransformSpecOutputBuiltinPreset{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TransformSpecOutputBuiltinPreset

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransformSpecOutputBuiltinPreset{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TransformSpecOutputBuiltinPreset)(ptr) = objs[0]
			} else {
				*(*TransformSpecOutputBuiltinPreset)(ptr) = TransformSpecOutputBuiltinPreset{}
			}
		} else {
			*(*TransformSpecOutputBuiltinPreset)(ptr) = TransformSpecOutputBuiltinPreset{}
		}
	default:
		iter.ReportError("decode TransformSpecOutputBuiltinPreset", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TransformSpecOutputFaceDetectorPresetCodec struct {
}

func (TransformSpecOutputFaceDetectorPresetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TransformSpecOutputFaceDetectorPreset)(ptr) == nil
}

func (TransformSpecOutputFaceDetectorPresetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TransformSpecOutputFaceDetectorPreset)(ptr)
	var objs []TransformSpecOutputFaceDetectorPreset
	if obj != nil {
		objs = []TransformSpecOutputFaceDetectorPreset{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransformSpecOutputFaceDetectorPreset{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TransformSpecOutputFaceDetectorPresetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TransformSpecOutputFaceDetectorPreset)(ptr) = TransformSpecOutputFaceDetectorPreset{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TransformSpecOutputFaceDetectorPreset

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransformSpecOutputFaceDetectorPreset{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TransformSpecOutputFaceDetectorPreset)(ptr) = objs[0]
			} else {
				*(*TransformSpecOutputFaceDetectorPreset)(ptr) = TransformSpecOutputFaceDetectorPreset{}
			}
		} else {
			*(*TransformSpecOutputFaceDetectorPreset)(ptr) = TransformSpecOutputFaceDetectorPreset{}
		}
	default:
		iter.ReportError("decode TransformSpecOutputFaceDetectorPreset", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TransformSpecOutputVideoAnalyzerPresetCodec struct {
}

func (TransformSpecOutputVideoAnalyzerPresetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TransformSpecOutputVideoAnalyzerPreset)(ptr) == nil
}

func (TransformSpecOutputVideoAnalyzerPresetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TransformSpecOutputVideoAnalyzerPreset)(ptr)
	var objs []TransformSpecOutputVideoAnalyzerPreset
	if obj != nil {
		objs = []TransformSpecOutputVideoAnalyzerPreset{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransformSpecOutputVideoAnalyzerPreset{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TransformSpecOutputVideoAnalyzerPresetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TransformSpecOutputVideoAnalyzerPreset)(ptr) = TransformSpecOutputVideoAnalyzerPreset{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TransformSpecOutputVideoAnalyzerPreset

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TransformSpecOutputVideoAnalyzerPreset{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TransformSpecOutputVideoAnalyzerPreset)(ptr) = objs[0]
			} else {
				*(*TransformSpecOutputVideoAnalyzerPreset)(ptr) = TransformSpecOutputVideoAnalyzerPreset{}
			}
		} else {
			*(*TransformSpecOutputVideoAnalyzerPreset)(ptr) = TransformSpecOutputVideoAnalyzerPreset{}
		}
	default:
		iter.ReportError("decode TransformSpecOutputVideoAnalyzerPreset", "unexpected JSON type")
	}
}
