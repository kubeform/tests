/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfile{}).Type1()):                               KubernetesClusterSpecAddonProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileAciConnectorLinux{}).Type1()):              KubernetesClusterSpecAddonProfileAciConnectorLinuxCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileAzurePolicy{}).Type1()):                    KubernetesClusterSpecAddonProfileAzurePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileHttpApplicationRouting{}).Type1()):         KubernetesClusterSpecAddonProfileHttpApplicationRoutingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileIngressApplicationGateway{}).Type1()):      KubernetesClusterSpecAddonProfileIngressApplicationGatewayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileKubeDashboard{}).Type1()):                  KubernetesClusterSpecAddonProfileKubeDashboardCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileOmsAgent{}).Type1()):                       KubernetesClusterSpecAddonProfileOmsAgentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAutoScalerProfile{}).Type1()):                          KubernetesClusterSpecAutoScalerProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePool{}).Type1()):                            KubernetesClusterSpecDefaultNodePoolCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolUpgradeSettings{}).Type1()):             KubernetesClusterSpecDefaultNodePoolUpgradeSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecIdentity{}).Type1()):                                   KubernetesClusterSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecLinuxProfile{}).Type1()):                               KubernetesClusterSpecLinuxProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecLinuxProfileSshKey{}).Type1()):                         KubernetesClusterSpecLinuxProfileSshKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecNetworkProfile{}).Type1()):                             KubernetesClusterSpecNetworkProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecNetworkProfileLoadBalancerProfile{}).Type1()):          KubernetesClusterSpecNetworkProfileLoadBalancerProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecRoleBasedAccessControl{}).Type1()):                     KubernetesClusterSpecRoleBasedAccessControlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory{}).Type1()): KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectoryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecServicePrincipal{}).Type1()):                           KubernetesClusterSpecServicePrincipalCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecWindowsProfile{}).Type1()):                             KubernetesClusterSpecWindowsProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecUpgradeSettings{}).Type1()):                                     NodePoolSpecUpgradeSettingsCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfile{}).Type1()):                               KubernetesClusterSpecAddonProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileAciConnectorLinux{}).Type1()):              KubernetesClusterSpecAddonProfileAciConnectorLinuxCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileAzurePolicy{}).Type1()):                    KubernetesClusterSpecAddonProfileAzurePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileHttpApplicationRouting{}).Type1()):         KubernetesClusterSpecAddonProfileHttpApplicationRoutingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileIngressApplicationGateway{}).Type1()):      KubernetesClusterSpecAddonProfileIngressApplicationGatewayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileKubeDashboard{}).Type1()):                  KubernetesClusterSpecAddonProfileKubeDashboardCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileOmsAgent{}).Type1()):                       KubernetesClusterSpecAddonProfileOmsAgentCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAutoScalerProfile{}).Type1()):                          KubernetesClusterSpecAutoScalerProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePool{}).Type1()):                            KubernetesClusterSpecDefaultNodePoolCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolUpgradeSettings{}).Type1()):             KubernetesClusterSpecDefaultNodePoolUpgradeSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecIdentity{}).Type1()):                                   KubernetesClusterSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecLinuxProfile{}).Type1()):                               KubernetesClusterSpecLinuxProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecLinuxProfileSshKey{}).Type1()):                         KubernetesClusterSpecLinuxProfileSshKeyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecNetworkProfile{}).Type1()):                             KubernetesClusterSpecNetworkProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecNetworkProfileLoadBalancerProfile{}).Type1()):          KubernetesClusterSpecNetworkProfileLoadBalancerProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecRoleBasedAccessControl{}).Type1()):                     KubernetesClusterSpecRoleBasedAccessControlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory{}).Type1()): KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectoryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecServicePrincipal{}).Type1()):                           KubernetesClusterSpecServicePrincipalCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecWindowsProfile{}).Type1()):                             KubernetesClusterSpecWindowsProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecUpgradeSettings{}).Type1()):                                     NodePoolSpecUpgradeSettingsCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecAddonProfileCodec struct {
}

func (KubernetesClusterSpecAddonProfileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecAddonProfile)(ptr) == nil
}

func (KubernetesClusterSpecAddonProfileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecAddonProfile)(ptr)
	var objs []KubernetesClusterSpecAddonProfile
	if obj != nil {
		objs = []KubernetesClusterSpecAddonProfile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecAddonProfileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecAddonProfile)(ptr) = KubernetesClusterSpecAddonProfile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecAddonProfile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecAddonProfile)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecAddonProfile)(ptr) = KubernetesClusterSpecAddonProfile{}
			}
		} else {
			*(*KubernetesClusterSpecAddonProfile)(ptr) = KubernetesClusterSpecAddonProfile{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecAddonProfile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecAddonProfileAciConnectorLinuxCodec struct {
}

func (KubernetesClusterSpecAddonProfileAciConnectorLinuxCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecAddonProfileAciConnectorLinux)(ptr) == nil
}

func (KubernetesClusterSpecAddonProfileAciConnectorLinuxCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecAddonProfileAciConnectorLinux)(ptr)
	var objs []KubernetesClusterSpecAddonProfileAciConnectorLinux
	if obj != nil {
		objs = []KubernetesClusterSpecAddonProfileAciConnectorLinux{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileAciConnectorLinux{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecAddonProfileAciConnectorLinuxCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecAddonProfileAciConnectorLinux)(ptr) = KubernetesClusterSpecAddonProfileAciConnectorLinux{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecAddonProfileAciConnectorLinux

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileAciConnectorLinux{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecAddonProfileAciConnectorLinux)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecAddonProfileAciConnectorLinux)(ptr) = KubernetesClusterSpecAddonProfileAciConnectorLinux{}
			}
		} else {
			*(*KubernetesClusterSpecAddonProfileAciConnectorLinux)(ptr) = KubernetesClusterSpecAddonProfileAciConnectorLinux{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecAddonProfileAciConnectorLinux", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecAddonProfileAzurePolicyCodec struct {
}

func (KubernetesClusterSpecAddonProfileAzurePolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecAddonProfileAzurePolicy)(ptr) == nil
}

func (KubernetesClusterSpecAddonProfileAzurePolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecAddonProfileAzurePolicy)(ptr)
	var objs []KubernetesClusterSpecAddonProfileAzurePolicy
	if obj != nil {
		objs = []KubernetesClusterSpecAddonProfileAzurePolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileAzurePolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecAddonProfileAzurePolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecAddonProfileAzurePolicy)(ptr) = KubernetesClusterSpecAddonProfileAzurePolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecAddonProfileAzurePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileAzurePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecAddonProfileAzurePolicy)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecAddonProfileAzurePolicy)(ptr) = KubernetesClusterSpecAddonProfileAzurePolicy{}
			}
		} else {
			*(*KubernetesClusterSpecAddonProfileAzurePolicy)(ptr) = KubernetesClusterSpecAddonProfileAzurePolicy{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecAddonProfileAzurePolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecAddonProfileHttpApplicationRoutingCodec struct {
}

func (KubernetesClusterSpecAddonProfileHttpApplicationRoutingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecAddonProfileHttpApplicationRouting)(ptr) == nil
}

func (KubernetesClusterSpecAddonProfileHttpApplicationRoutingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecAddonProfileHttpApplicationRouting)(ptr)
	var objs []KubernetesClusterSpecAddonProfileHttpApplicationRouting
	if obj != nil {
		objs = []KubernetesClusterSpecAddonProfileHttpApplicationRouting{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileHttpApplicationRouting{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecAddonProfileHttpApplicationRoutingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecAddonProfileHttpApplicationRouting)(ptr) = KubernetesClusterSpecAddonProfileHttpApplicationRouting{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecAddonProfileHttpApplicationRouting

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileHttpApplicationRouting{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecAddonProfileHttpApplicationRouting)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecAddonProfileHttpApplicationRouting)(ptr) = KubernetesClusterSpecAddonProfileHttpApplicationRouting{}
			}
		} else {
			*(*KubernetesClusterSpecAddonProfileHttpApplicationRouting)(ptr) = KubernetesClusterSpecAddonProfileHttpApplicationRouting{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecAddonProfileHttpApplicationRouting", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecAddonProfileIngressApplicationGatewayCodec struct {
}

func (KubernetesClusterSpecAddonProfileIngressApplicationGatewayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecAddonProfileIngressApplicationGateway)(ptr) == nil
}

func (KubernetesClusterSpecAddonProfileIngressApplicationGatewayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecAddonProfileIngressApplicationGateway)(ptr)
	var objs []KubernetesClusterSpecAddonProfileIngressApplicationGateway
	if obj != nil {
		objs = []KubernetesClusterSpecAddonProfileIngressApplicationGateway{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileIngressApplicationGateway{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecAddonProfileIngressApplicationGatewayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecAddonProfileIngressApplicationGateway)(ptr) = KubernetesClusterSpecAddonProfileIngressApplicationGateway{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecAddonProfileIngressApplicationGateway

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileIngressApplicationGateway{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecAddonProfileIngressApplicationGateway)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecAddonProfileIngressApplicationGateway)(ptr) = KubernetesClusterSpecAddonProfileIngressApplicationGateway{}
			}
		} else {
			*(*KubernetesClusterSpecAddonProfileIngressApplicationGateway)(ptr) = KubernetesClusterSpecAddonProfileIngressApplicationGateway{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecAddonProfileIngressApplicationGateway", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecAddonProfileKubeDashboardCodec struct {
}

func (KubernetesClusterSpecAddonProfileKubeDashboardCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecAddonProfileKubeDashboard)(ptr) == nil
}

func (KubernetesClusterSpecAddonProfileKubeDashboardCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecAddonProfileKubeDashboard)(ptr)
	var objs []KubernetesClusterSpecAddonProfileKubeDashboard
	if obj != nil {
		objs = []KubernetesClusterSpecAddonProfileKubeDashboard{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileKubeDashboard{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecAddonProfileKubeDashboardCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecAddonProfileKubeDashboard)(ptr) = KubernetesClusterSpecAddonProfileKubeDashboard{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecAddonProfileKubeDashboard

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileKubeDashboard{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecAddonProfileKubeDashboard)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecAddonProfileKubeDashboard)(ptr) = KubernetesClusterSpecAddonProfileKubeDashboard{}
			}
		} else {
			*(*KubernetesClusterSpecAddonProfileKubeDashboard)(ptr) = KubernetesClusterSpecAddonProfileKubeDashboard{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecAddonProfileKubeDashboard", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecAddonProfileOmsAgentCodec struct {
}

func (KubernetesClusterSpecAddonProfileOmsAgentCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecAddonProfileOmsAgent)(ptr) == nil
}

func (KubernetesClusterSpecAddonProfileOmsAgentCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecAddonProfileOmsAgent)(ptr)
	var objs []KubernetesClusterSpecAddonProfileOmsAgent
	if obj != nil {
		objs = []KubernetesClusterSpecAddonProfileOmsAgent{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileOmsAgent{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecAddonProfileOmsAgentCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecAddonProfileOmsAgent)(ptr) = KubernetesClusterSpecAddonProfileOmsAgent{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecAddonProfileOmsAgent

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAddonProfileOmsAgent{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecAddonProfileOmsAgent)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecAddonProfileOmsAgent)(ptr) = KubernetesClusterSpecAddonProfileOmsAgent{}
			}
		} else {
			*(*KubernetesClusterSpecAddonProfileOmsAgent)(ptr) = KubernetesClusterSpecAddonProfileOmsAgent{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecAddonProfileOmsAgent", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecAutoScalerProfileCodec struct {
}

func (KubernetesClusterSpecAutoScalerProfileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecAutoScalerProfile)(ptr) == nil
}

func (KubernetesClusterSpecAutoScalerProfileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecAutoScalerProfile)(ptr)
	var objs []KubernetesClusterSpecAutoScalerProfile
	if obj != nil {
		objs = []KubernetesClusterSpecAutoScalerProfile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAutoScalerProfile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecAutoScalerProfileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecAutoScalerProfile)(ptr) = KubernetesClusterSpecAutoScalerProfile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecAutoScalerProfile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecAutoScalerProfile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecAutoScalerProfile)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecAutoScalerProfile)(ptr) = KubernetesClusterSpecAutoScalerProfile{}
			}
		} else {
			*(*KubernetesClusterSpecAutoScalerProfile)(ptr) = KubernetesClusterSpecAutoScalerProfile{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecAutoScalerProfile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecDefaultNodePoolCodec struct {
}

func (KubernetesClusterSpecDefaultNodePoolCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecDefaultNodePool)(ptr) == nil
}

func (KubernetesClusterSpecDefaultNodePoolCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecDefaultNodePool)(ptr)
	var objs []KubernetesClusterSpecDefaultNodePool
	if obj != nil {
		objs = []KubernetesClusterSpecDefaultNodePool{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePool{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecDefaultNodePoolCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecDefaultNodePool)(ptr) = KubernetesClusterSpecDefaultNodePool{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecDefaultNodePool

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePool{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecDefaultNodePool)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecDefaultNodePool)(ptr) = KubernetesClusterSpecDefaultNodePool{}
			}
		} else {
			*(*KubernetesClusterSpecDefaultNodePool)(ptr) = KubernetesClusterSpecDefaultNodePool{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecDefaultNodePool", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecDefaultNodePoolUpgradeSettingsCodec struct {
}

func (KubernetesClusterSpecDefaultNodePoolUpgradeSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecDefaultNodePoolUpgradeSettings)(ptr) == nil
}

func (KubernetesClusterSpecDefaultNodePoolUpgradeSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecDefaultNodePoolUpgradeSettings)(ptr)
	var objs []KubernetesClusterSpecDefaultNodePoolUpgradeSettings
	if obj != nil {
		objs = []KubernetesClusterSpecDefaultNodePoolUpgradeSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolUpgradeSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecDefaultNodePoolUpgradeSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecDefaultNodePoolUpgradeSettings)(ptr) = KubernetesClusterSpecDefaultNodePoolUpgradeSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecDefaultNodePoolUpgradeSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecDefaultNodePoolUpgradeSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecDefaultNodePoolUpgradeSettings)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecDefaultNodePoolUpgradeSettings)(ptr) = KubernetesClusterSpecDefaultNodePoolUpgradeSettings{}
			}
		} else {
			*(*KubernetesClusterSpecDefaultNodePoolUpgradeSettings)(ptr) = KubernetesClusterSpecDefaultNodePoolUpgradeSettings{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecDefaultNodePoolUpgradeSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecIdentityCodec struct {
}

func (KubernetesClusterSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecIdentity)(ptr) == nil
}

func (KubernetesClusterSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecIdentity)(ptr)
	var objs []KubernetesClusterSpecIdentity
	if obj != nil {
		objs = []KubernetesClusterSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecIdentity)(ptr) = KubernetesClusterSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecIdentity)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecIdentity)(ptr) = KubernetesClusterSpecIdentity{}
			}
		} else {
			*(*KubernetesClusterSpecIdentity)(ptr) = KubernetesClusterSpecIdentity{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecLinuxProfileCodec struct {
}

func (KubernetesClusterSpecLinuxProfileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecLinuxProfile)(ptr) == nil
}

func (KubernetesClusterSpecLinuxProfileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecLinuxProfile)(ptr)
	var objs []KubernetesClusterSpecLinuxProfile
	if obj != nil {
		objs = []KubernetesClusterSpecLinuxProfile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecLinuxProfile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecLinuxProfileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecLinuxProfile)(ptr) = KubernetesClusterSpecLinuxProfile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecLinuxProfile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecLinuxProfile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecLinuxProfile)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecLinuxProfile)(ptr) = KubernetesClusterSpecLinuxProfile{}
			}
		} else {
			*(*KubernetesClusterSpecLinuxProfile)(ptr) = KubernetesClusterSpecLinuxProfile{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecLinuxProfile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecLinuxProfileSshKeyCodec struct {
}

func (KubernetesClusterSpecLinuxProfileSshKeyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecLinuxProfileSshKey)(ptr) == nil
}

func (KubernetesClusterSpecLinuxProfileSshKeyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecLinuxProfileSshKey)(ptr)
	var objs []KubernetesClusterSpecLinuxProfileSshKey
	if obj != nil {
		objs = []KubernetesClusterSpecLinuxProfileSshKey{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecLinuxProfileSshKey{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecLinuxProfileSshKeyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecLinuxProfileSshKey)(ptr) = KubernetesClusterSpecLinuxProfileSshKey{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecLinuxProfileSshKey

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecLinuxProfileSshKey{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecLinuxProfileSshKey)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecLinuxProfileSshKey)(ptr) = KubernetesClusterSpecLinuxProfileSshKey{}
			}
		} else {
			*(*KubernetesClusterSpecLinuxProfileSshKey)(ptr) = KubernetesClusterSpecLinuxProfileSshKey{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecLinuxProfileSshKey", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecNetworkProfileCodec struct {
}

func (KubernetesClusterSpecNetworkProfileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecNetworkProfile)(ptr) == nil
}

func (KubernetesClusterSpecNetworkProfileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecNetworkProfile)(ptr)
	var objs []KubernetesClusterSpecNetworkProfile
	if obj != nil {
		objs = []KubernetesClusterSpecNetworkProfile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecNetworkProfile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecNetworkProfileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecNetworkProfile)(ptr) = KubernetesClusterSpecNetworkProfile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecNetworkProfile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecNetworkProfile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecNetworkProfile)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecNetworkProfile)(ptr) = KubernetesClusterSpecNetworkProfile{}
			}
		} else {
			*(*KubernetesClusterSpecNetworkProfile)(ptr) = KubernetesClusterSpecNetworkProfile{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecNetworkProfile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecNetworkProfileLoadBalancerProfileCodec struct {
}

func (KubernetesClusterSpecNetworkProfileLoadBalancerProfileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecNetworkProfileLoadBalancerProfile)(ptr) == nil
}

func (KubernetesClusterSpecNetworkProfileLoadBalancerProfileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecNetworkProfileLoadBalancerProfile)(ptr)
	var objs []KubernetesClusterSpecNetworkProfileLoadBalancerProfile
	if obj != nil {
		objs = []KubernetesClusterSpecNetworkProfileLoadBalancerProfile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecNetworkProfileLoadBalancerProfile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecNetworkProfileLoadBalancerProfileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecNetworkProfileLoadBalancerProfile)(ptr) = KubernetesClusterSpecNetworkProfileLoadBalancerProfile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecNetworkProfileLoadBalancerProfile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecNetworkProfileLoadBalancerProfile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecNetworkProfileLoadBalancerProfile)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecNetworkProfileLoadBalancerProfile)(ptr) = KubernetesClusterSpecNetworkProfileLoadBalancerProfile{}
			}
		} else {
			*(*KubernetesClusterSpecNetworkProfileLoadBalancerProfile)(ptr) = KubernetesClusterSpecNetworkProfileLoadBalancerProfile{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecNetworkProfileLoadBalancerProfile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecRoleBasedAccessControlCodec struct {
}

func (KubernetesClusterSpecRoleBasedAccessControlCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecRoleBasedAccessControl)(ptr) == nil
}

func (KubernetesClusterSpecRoleBasedAccessControlCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecRoleBasedAccessControl)(ptr)
	var objs []KubernetesClusterSpecRoleBasedAccessControl
	if obj != nil {
		objs = []KubernetesClusterSpecRoleBasedAccessControl{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecRoleBasedAccessControl{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecRoleBasedAccessControlCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecRoleBasedAccessControl)(ptr) = KubernetesClusterSpecRoleBasedAccessControl{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecRoleBasedAccessControl

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecRoleBasedAccessControl{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecRoleBasedAccessControl)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecRoleBasedAccessControl)(ptr) = KubernetesClusterSpecRoleBasedAccessControl{}
			}
		} else {
			*(*KubernetesClusterSpecRoleBasedAccessControl)(ptr) = KubernetesClusterSpecRoleBasedAccessControl{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecRoleBasedAccessControl", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectoryCodec struct {
}

func (KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectoryCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory)(ptr) == nil
}

func (KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectoryCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory)(ptr)
	var objs []KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory
	if obj != nil {
		objs = []KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectoryCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory)(ptr) = KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory)(ptr) = KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory{}
			}
		} else {
			*(*KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory)(ptr) = KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecRoleBasedAccessControlAzureActiveDirectory", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecServicePrincipalCodec struct {
}

func (KubernetesClusterSpecServicePrincipalCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecServicePrincipal)(ptr) == nil
}

func (KubernetesClusterSpecServicePrincipalCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecServicePrincipal)(ptr)
	var objs []KubernetesClusterSpecServicePrincipal
	if obj != nil {
		objs = []KubernetesClusterSpecServicePrincipal{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecServicePrincipal{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecServicePrincipalCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecServicePrincipal)(ptr) = KubernetesClusterSpecServicePrincipal{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecServicePrincipal

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecServicePrincipal{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecServicePrincipal)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecServicePrincipal)(ptr) = KubernetesClusterSpecServicePrincipal{}
			}
		} else {
			*(*KubernetesClusterSpecServicePrincipal)(ptr) = KubernetesClusterSpecServicePrincipal{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecServicePrincipal", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KubernetesClusterSpecWindowsProfileCodec struct {
}

func (KubernetesClusterSpecWindowsProfileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KubernetesClusterSpecWindowsProfile)(ptr) == nil
}

func (KubernetesClusterSpecWindowsProfileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KubernetesClusterSpecWindowsProfile)(ptr)
	var objs []KubernetesClusterSpecWindowsProfile
	if obj != nil {
		objs = []KubernetesClusterSpecWindowsProfile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecWindowsProfile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KubernetesClusterSpecWindowsProfileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KubernetesClusterSpecWindowsProfile)(ptr) = KubernetesClusterSpecWindowsProfile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KubernetesClusterSpecWindowsProfile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KubernetesClusterSpecWindowsProfile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KubernetesClusterSpecWindowsProfile)(ptr) = objs[0]
			} else {
				*(*KubernetesClusterSpecWindowsProfile)(ptr) = KubernetesClusterSpecWindowsProfile{}
			}
		} else {
			*(*KubernetesClusterSpecWindowsProfile)(ptr) = KubernetesClusterSpecWindowsProfile{}
		}
	default:
		iter.ReportError("decode KubernetesClusterSpecWindowsProfile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NodePoolSpecUpgradeSettingsCodec struct {
}

func (NodePoolSpecUpgradeSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NodePoolSpecUpgradeSettings)(ptr) == nil
}

func (NodePoolSpecUpgradeSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NodePoolSpecUpgradeSettings)(ptr)
	var objs []NodePoolSpecUpgradeSettings
	if obj != nil {
		objs = []NodePoolSpecUpgradeSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecUpgradeSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NodePoolSpecUpgradeSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NodePoolSpecUpgradeSettings)(ptr) = NodePoolSpecUpgradeSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NodePoolSpecUpgradeSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NodePoolSpecUpgradeSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NodePoolSpecUpgradeSettings)(ptr) = objs[0]
			} else {
				*(*NodePoolSpecUpgradeSettings)(ptr) = NodePoolSpecUpgradeSettings{}
			}
		} else {
			*(*NodePoolSpecUpgradeSettings)(ptr) = NodePoolSpecUpgradeSettings{}
		}
	default:
		iter.ReportError("decode NodePoolSpecUpgradeSettings", "unexpected JSON type")
	}
}
