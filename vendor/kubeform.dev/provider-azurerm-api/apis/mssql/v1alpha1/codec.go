/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecExtendedAuditingPolicy{}).Type1()):                   DatabaseSpecExtendedAuditingPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecLongTermRetentionPolicy{}).Type1()):                  DatabaseSpecLongTermRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecShortTermRetentionPolicy{}).Type1()):                 DatabaseSpecShortTermRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecThreatDetectionPolicy{}).Type1()):                    DatabaseSpecThreatDetectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ElasticpoolSpecPerDatabaseSettings{}).Type1()):                   ElasticpoolSpecPerDatabaseSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ElasticpoolSpecSku{}).Type1()):                                   ElasticpoolSpecSkuCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServerSpecAzureadAdministrator{}).Type1()):                       ServerSpecAzureadAdministratorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServerSpecExtendedAuditingPolicy{}).Type1()):                     ServerSpecExtendedAuditingPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServerSpecIdentity{}).Type1()):                                   ServerSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServerVulnerabilityAssessmentSpecRecurringScans{}).Type1()):      ServerVulnerabilityAssessmentSpecRecurringScansCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecAutoBackup{}).Type1()):                         VirtualMachineSpecAutoBackupCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecAutoBackupManualSchedule{}).Type1()):           VirtualMachineSpecAutoBackupManualScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecAutoPatching{}).Type1()):                       VirtualMachineSpecAutoPatchingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecKeyVaultCredential{}).Type1()):                 VirtualMachineSpecKeyVaultCredentialCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecStorageConfiguration{}).Type1()):               VirtualMachineSpecStorageConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecStorageConfigurationDataSettings{}).Type1()):   VirtualMachineSpecStorageConfigurationDataSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecStorageConfigurationLogSettings{}).Type1()):    VirtualMachineSpecStorageConfigurationLogSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecStorageConfigurationTempDbSettings{}).Type1()): VirtualMachineSpecStorageConfigurationTempDbSettingsCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecExtendedAuditingPolicy{}).Type1()):                   DatabaseSpecExtendedAuditingPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecLongTermRetentionPolicy{}).Type1()):                  DatabaseSpecLongTermRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecShortTermRetentionPolicy{}).Type1()):                 DatabaseSpecShortTermRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecThreatDetectionPolicy{}).Type1()):                    DatabaseSpecThreatDetectionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ElasticpoolSpecPerDatabaseSettings{}).Type1()):                   ElasticpoolSpecPerDatabaseSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ElasticpoolSpecSku{}).Type1()):                                   ElasticpoolSpecSkuCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServerSpecAzureadAdministrator{}).Type1()):                       ServerSpecAzureadAdministratorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServerSpecExtendedAuditingPolicy{}).Type1()):                     ServerSpecExtendedAuditingPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServerSpecIdentity{}).Type1()):                                   ServerSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServerVulnerabilityAssessmentSpecRecurringScans{}).Type1()):      ServerVulnerabilityAssessmentSpecRecurringScansCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecAutoBackup{}).Type1()):                         VirtualMachineSpecAutoBackupCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecAutoBackupManualSchedule{}).Type1()):           VirtualMachineSpecAutoBackupManualScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecAutoPatching{}).Type1()):                       VirtualMachineSpecAutoPatchingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecKeyVaultCredential{}).Type1()):                 VirtualMachineSpecKeyVaultCredentialCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecStorageConfiguration{}).Type1()):               VirtualMachineSpecStorageConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecStorageConfigurationDataSettings{}).Type1()):   VirtualMachineSpecStorageConfigurationDataSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecStorageConfigurationLogSettings{}).Type1()):    VirtualMachineSpecStorageConfigurationLogSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecStorageConfigurationTempDbSettings{}).Type1()): VirtualMachineSpecStorageConfigurationTempDbSettingsCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type DatabaseSpecExtendedAuditingPolicyCodec struct {
}

func (DatabaseSpecExtendedAuditingPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DatabaseSpecExtendedAuditingPolicy)(ptr) == nil
}

func (DatabaseSpecExtendedAuditingPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DatabaseSpecExtendedAuditingPolicy)(ptr)
	var objs []DatabaseSpecExtendedAuditingPolicy
	if obj != nil {
		objs = []DatabaseSpecExtendedAuditingPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecExtendedAuditingPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DatabaseSpecExtendedAuditingPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DatabaseSpecExtendedAuditingPolicy)(ptr) = DatabaseSpecExtendedAuditingPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DatabaseSpecExtendedAuditingPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecExtendedAuditingPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DatabaseSpecExtendedAuditingPolicy)(ptr) = objs[0]
			} else {
				*(*DatabaseSpecExtendedAuditingPolicy)(ptr) = DatabaseSpecExtendedAuditingPolicy{}
			}
		} else {
			*(*DatabaseSpecExtendedAuditingPolicy)(ptr) = DatabaseSpecExtendedAuditingPolicy{}
		}
	default:
		iter.ReportError("decode DatabaseSpecExtendedAuditingPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DatabaseSpecLongTermRetentionPolicyCodec struct {
}

func (DatabaseSpecLongTermRetentionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DatabaseSpecLongTermRetentionPolicy)(ptr) == nil
}

func (DatabaseSpecLongTermRetentionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DatabaseSpecLongTermRetentionPolicy)(ptr)
	var objs []DatabaseSpecLongTermRetentionPolicy
	if obj != nil {
		objs = []DatabaseSpecLongTermRetentionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecLongTermRetentionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DatabaseSpecLongTermRetentionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DatabaseSpecLongTermRetentionPolicy)(ptr) = DatabaseSpecLongTermRetentionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DatabaseSpecLongTermRetentionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecLongTermRetentionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DatabaseSpecLongTermRetentionPolicy)(ptr) = objs[0]
			} else {
				*(*DatabaseSpecLongTermRetentionPolicy)(ptr) = DatabaseSpecLongTermRetentionPolicy{}
			}
		} else {
			*(*DatabaseSpecLongTermRetentionPolicy)(ptr) = DatabaseSpecLongTermRetentionPolicy{}
		}
	default:
		iter.ReportError("decode DatabaseSpecLongTermRetentionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DatabaseSpecShortTermRetentionPolicyCodec struct {
}

func (DatabaseSpecShortTermRetentionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DatabaseSpecShortTermRetentionPolicy)(ptr) == nil
}

func (DatabaseSpecShortTermRetentionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DatabaseSpecShortTermRetentionPolicy)(ptr)
	var objs []DatabaseSpecShortTermRetentionPolicy
	if obj != nil {
		objs = []DatabaseSpecShortTermRetentionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecShortTermRetentionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DatabaseSpecShortTermRetentionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DatabaseSpecShortTermRetentionPolicy)(ptr) = DatabaseSpecShortTermRetentionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DatabaseSpecShortTermRetentionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecShortTermRetentionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DatabaseSpecShortTermRetentionPolicy)(ptr) = objs[0]
			} else {
				*(*DatabaseSpecShortTermRetentionPolicy)(ptr) = DatabaseSpecShortTermRetentionPolicy{}
			}
		} else {
			*(*DatabaseSpecShortTermRetentionPolicy)(ptr) = DatabaseSpecShortTermRetentionPolicy{}
		}
	default:
		iter.ReportError("decode DatabaseSpecShortTermRetentionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DatabaseSpecThreatDetectionPolicyCodec struct {
}

func (DatabaseSpecThreatDetectionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DatabaseSpecThreatDetectionPolicy)(ptr) == nil
}

func (DatabaseSpecThreatDetectionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DatabaseSpecThreatDetectionPolicy)(ptr)
	var objs []DatabaseSpecThreatDetectionPolicy
	if obj != nil {
		objs = []DatabaseSpecThreatDetectionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecThreatDetectionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DatabaseSpecThreatDetectionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DatabaseSpecThreatDetectionPolicy)(ptr) = DatabaseSpecThreatDetectionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DatabaseSpecThreatDetectionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DatabaseSpecThreatDetectionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DatabaseSpecThreatDetectionPolicy)(ptr) = objs[0]
			} else {
				*(*DatabaseSpecThreatDetectionPolicy)(ptr) = DatabaseSpecThreatDetectionPolicy{}
			}
		} else {
			*(*DatabaseSpecThreatDetectionPolicy)(ptr) = DatabaseSpecThreatDetectionPolicy{}
		}
	default:
		iter.ReportError("decode DatabaseSpecThreatDetectionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ElasticpoolSpecPerDatabaseSettingsCodec struct {
}

func (ElasticpoolSpecPerDatabaseSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ElasticpoolSpecPerDatabaseSettings)(ptr) == nil
}

func (ElasticpoolSpecPerDatabaseSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ElasticpoolSpecPerDatabaseSettings)(ptr)
	var objs []ElasticpoolSpecPerDatabaseSettings
	if obj != nil {
		objs = []ElasticpoolSpecPerDatabaseSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ElasticpoolSpecPerDatabaseSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ElasticpoolSpecPerDatabaseSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ElasticpoolSpecPerDatabaseSettings)(ptr) = ElasticpoolSpecPerDatabaseSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ElasticpoolSpecPerDatabaseSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ElasticpoolSpecPerDatabaseSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ElasticpoolSpecPerDatabaseSettings)(ptr) = objs[0]
			} else {
				*(*ElasticpoolSpecPerDatabaseSettings)(ptr) = ElasticpoolSpecPerDatabaseSettings{}
			}
		} else {
			*(*ElasticpoolSpecPerDatabaseSettings)(ptr) = ElasticpoolSpecPerDatabaseSettings{}
		}
	default:
		iter.ReportError("decode ElasticpoolSpecPerDatabaseSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ElasticpoolSpecSkuCodec struct {
}

func (ElasticpoolSpecSkuCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ElasticpoolSpecSku)(ptr) == nil
}

func (ElasticpoolSpecSkuCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ElasticpoolSpecSku)(ptr)
	var objs []ElasticpoolSpecSku
	if obj != nil {
		objs = []ElasticpoolSpecSku{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ElasticpoolSpecSku{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ElasticpoolSpecSkuCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ElasticpoolSpecSku)(ptr) = ElasticpoolSpecSku{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ElasticpoolSpecSku

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ElasticpoolSpecSku{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ElasticpoolSpecSku)(ptr) = objs[0]
			} else {
				*(*ElasticpoolSpecSku)(ptr) = ElasticpoolSpecSku{}
			}
		} else {
			*(*ElasticpoolSpecSku)(ptr) = ElasticpoolSpecSku{}
		}
	default:
		iter.ReportError("decode ElasticpoolSpecSku", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServerSpecAzureadAdministratorCodec struct {
}

func (ServerSpecAzureadAdministratorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServerSpecAzureadAdministrator)(ptr) == nil
}

func (ServerSpecAzureadAdministratorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServerSpecAzureadAdministrator)(ptr)
	var objs []ServerSpecAzureadAdministrator
	if obj != nil {
		objs = []ServerSpecAzureadAdministrator{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServerSpecAzureadAdministrator{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServerSpecAzureadAdministratorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServerSpecAzureadAdministrator)(ptr) = ServerSpecAzureadAdministrator{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServerSpecAzureadAdministrator

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServerSpecAzureadAdministrator{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServerSpecAzureadAdministrator)(ptr) = objs[0]
			} else {
				*(*ServerSpecAzureadAdministrator)(ptr) = ServerSpecAzureadAdministrator{}
			}
		} else {
			*(*ServerSpecAzureadAdministrator)(ptr) = ServerSpecAzureadAdministrator{}
		}
	default:
		iter.ReportError("decode ServerSpecAzureadAdministrator", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServerSpecExtendedAuditingPolicyCodec struct {
}

func (ServerSpecExtendedAuditingPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServerSpecExtendedAuditingPolicy)(ptr) == nil
}

func (ServerSpecExtendedAuditingPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServerSpecExtendedAuditingPolicy)(ptr)
	var objs []ServerSpecExtendedAuditingPolicy
	if obj != nil {
		objs = []ServerSpecExtendedAuditingPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServerSpecExtendedAuditingPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServerSpecExtendedAuditingPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServerSpecExtendedAuditingPolicy)(ptr) = ServerSpecExtendedAuditingPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServerSpecExtendedAuditingPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServerSpecExtendedAuditingPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServerSpecExtendedAuditingPolicy)(ptr) = objs[0]
			} else {
				*(*ServerSpecExtendedAuditingPolicy)(ptr) = ServerSpecExtendedAuditingPolicy{}
			}
		} else {
			*(*ServerSpecExtendedAuditingPolicy)(ptr) = ServerSpecExtendedAuditingPolicy{}
		}
	default:
		iter.ReportError("decode ServerSpecExtendedAuditingPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServerSpecIdentityCodec struct {
}

func (ServerSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServerSpecIdentity)(ptr) == nil
}

func (ServerSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServerSpecIdentity)(ptr)
	var objs []ServerSpecIdentity
	if obj != nil {
		objs = []ServerSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServerSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServerSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServerSpecIdentity)(ptr) = ServerSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServerSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServerSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServerSpecIdentity)(ptr) = objs[0]
			} else {
				*(*ServerSpecIdentity)(ptr) = ServerSpecIdentity{}
			}
		} else {
			*(*ServerSpecIdentity)(ptr) = ServerSpecIdentity{}
		}
	default:
		iter.ReportError("decode ServerSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServerVulnerabilityAssessmentSpecRecurringScansCodec struct {
}

func (ServerVulnerabilityAssessmentSpecRecurringScansCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServerVulnerabilityAssessmentSpecRecurringScans)(ptr) == nil
}

func (ServerVulnerabilityAssessmentSpecRecurringScansCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServerVulnerabilityAssessmentSpecRecurringScans)(ptr)
	var objs []ServerVulnerabilityAssessmentSpecRecurringScans
	if obj != nil {
		objs = []ServerVulnerabilityAssessmentSpecRecurringScans{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServerVulnerabilityAssessmentSpecRecurringScans{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServerVulnerabilityAssessmentSpecRecurringScansCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServerVulnerabilityAssessmentSpecRecurringScans)(ptr) = ServerVulnerabilityAssessmentSpecRecurringScans{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServerVulnerabilityAssessmentSpecRecurringScans

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServerVulnerabilityAssessmentSpecRecurringScans{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServerVulnerabilityAssessmentSpecRecurringScans)(ptr) = objs[0]
			} else {
				*(*ServerVulnerabilityAssessmentSpecRecurringScans)(ptr) = ServerVulnerabilityAssessmentSpecRecurringScans{}
			}
		} else {
			*(*ServerVulnerabilityAssessmentSpecRecurringScans)(ptr) = ServerVulnerabilityAssessmentSpecRecurringScans{}
		}
	default:
		iter.ReportError("decode ServerVulnerabilityAssessmentSpecRecurringScans", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineSpecAutoBackupCodec struct {
}

func (VirtualMachineSpecAutoBackupCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineSpecAutoBackup)(ptr) == nil
}

func (VirtualMachineSpecAutoBackupCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineSpecAutoBackup)(ptr)
	var objs []VirtualMachineSpecAutoBackup
	if obj != nil {
		objs = []VirtualMachineSpecAutoBackup{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecAutoBackup{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineSpecAutoBackupCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineSpecAutoBackup)(ptr) = VirtualMachineSpecAutoBackup{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineSpecAutoBackup

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecAutoBackup{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineSpecAutoBackup)(ptr) = objs[0]
			} else {
				*(*VirtualMachineSpecAutoBackup)(ptr) = VirtualMachineSpecAutoBackup{}
			}
		} else {
			*(*VirtualMachineSpecAutoBackup)(ptr) = VirtualMachineSpecAutoBackup{}
		}
	default:
		iter.ReportError("decode VirtualMachineSpecAutoBackup", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineSpecAutoBackupManualScheduleCodec struct {
}

func (VirtualMachineSpecAutoBackupManualScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineSpecAutoBackupManualSchedule)(ptr) == nil
}

func (VirtualMachineSpecAutoBackupManualScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineSpecAutoBackupManualSchedule)(ptr)
	var objs []VirtualMachineSpecAutoBackupManualSchedule
	if obj != nil {
		objs = []VirtualMachineSpecAutoBackupManualSchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecAutoBackupManualSchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineSpecAutoBackupManualScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineSpecAutoBackupManualSchedule)(ptr) = VirtualMachineSpecAutoBackupManualSchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineSpecAutoBackupManualSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecAutoBackupManualSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineSpecAutoBackupManualSchedule)(ptr) = objs[0]
			} else {
				*(*VirtualMachineSpecAutoBackupManualSchedule)(ptr) = VirtualMachineSpecAutoBackupManualSchedule{}
			}
		} else {
			*(*VirtualMachineSpecAutoBackupManualSchedule)(ptr) = VirtualMachineSpecAutoBackupManualSchedule{}
		}
	default:
		iter.ReportError("decode VirtualMachineSpecAutoBackupManualSchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineSpecAutoPatchingCodec struct {
}

func (VirtualMachineSpecAutoPatchingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineSpecAutoPatching)(ptr) == nil
}

func (VirtualMachineSpecAutoPatchingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineSpecAutoPatching)(ptr)
	var objs []VirtualMachineSpecAutoPatching
	if obj != nil {
		objs = []VirtualMachineSpecAutoPatching{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecAutoPatching{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineSpecAutoPatchingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineSpecAutoPatching)(ptr) = VirtualMachineSpecAutoPatching{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineSpecAutoPatching

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecAutoPatching{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineSpecAutoPatching)(ptr) = objs[0]
			} else {
				*(*VirtualMachineSpecAutoPatching)(ptr) = VirtualMachineSpecAutoPatching{}
			}
		} else {
			*(*VirtualMachineSpecAutoPatching)(ptr) = VirtualMachineSpecAutoPatching{}
		}
	default:
		iter.ReportError("decode VirtualMachineSpecAutoPatching", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineSpecKeyVaultCredentialCodec struct {
}

func (VirtualMachineSpecKeyVaultCredentialCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineSpecKeyVaultCredential)(ptr) == nil
}

func (VirtualMachineSpecKeyVaultCredentialCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineSpecKeyVaultCredential)(ptr)
	var objs []VirtualMachineSpecKeyVaultCredential
	if obj != nil {
		objs = []VirtualMachineSpecKeyVaultCredential{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecKeyVaultCredential{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineSpecKeyVaultCredentialCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineSpecKeyVaultCredential)(ptr) = VirtualMachineSpecKeyVaultCredential{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineSpecKeyVaultCredential

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecKeyVaultCredential{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineSpecKeyVaultCredential)(ptr) = objs[0]
			} else {
				*(*VirtualMachineSpecKeyVaultCredential)(ptr) = VirtualMachineSpecKeyVaultCredential{}
			}
		} else {
			*(*VirtualMachineSpecKeyVaultCredential)(ptr) = VirtualMachineSpecKeyVaultCredential{}
		}
	default:
		iter.ReportError("decode VirtualMachineSpecKeyVaultCredential", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineSpecStorageConfigurationCodec struct {
}

func (VirtualMachineSpecStorageConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineSpecStorageConfiguration)(ptr) == nil
}

func (VirtualMachineSpecStorageConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineSpecStorageConfiguration)(ptr)
	var objs []VirtualMachineSpecStorageConfiguration
	if obj != nil {
		objs = []VirtualMachineSpecStorageConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecStorageConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineSpecStorageConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineSpecStorageConfiguration)(ptr) = VirtualMachineSpecStorageConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineSpecStorageConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecStorageConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineSpecStorageConfiguration)(ptr) = objs[0]
			} else {
				*(*VirtualMachineSpecStorageConfiguration)(ptr) = VirtualMachineSpecStorageConfiguration{}
			}
		} else {
			*(*VirtualMachineSpecStorageConfiguration)(ptr) = VirtualMachineSpecStorageConfiguration{}
		}
	default:
		iter.ReportError("decode VirtualMachineSpecStorageConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineSpecStorageConfigurationDataSettingsCodec struct {
}

func (VirtualMachineSpecStorageConfigurationDataSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineSpecStorageConfigurationDataSettings)(ptr) == nil
}

func (VirtualMachineSpecStorageConfigurationDataSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineSpecStorageConfigurationDataSettings)(ptr)
	var objs []VirtualMachineSpecStorageConfigurationDataSettings
	if obj != nil {
		objs = []VirtualMachineSpecStorageConfigurationDataSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecStorageConfigurationDataSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineSpecStorageConfigurationDataSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineSpecStorageConfigurationDataSettings)(ptr) = VirtualMachineSpecStorageConfigurationDataSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineSpecStorageConfigurationDataSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecStorageConfigurationDataSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineSpecStorageConfigurationDataSettings)(ptr) = objs[0]
			} else {
				*(*VirtualMachineSpecStorageConfigurationDataSettings)(ptr) = VirtualMachineSpecStorageConfigurationDataSettings{}
			}
		} else {
			*(*VirtualMachineSpecStorageConfigurationDataSettings)(ptr) = VirtualMachineSpecStorageConfigurationDataSettings{}
		}
	default:
		iter.ReportError("decode VirtualMachineSpecStorageConfigurationDataSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineSpecStorageConfigurationLogSettingsCodec struct {
}

func (VirtualMachineSpecStorageConfigurationLogSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineSpecStorageConfigurationLogSettings)(ptr) == nil
}

func (VirtualMachineSpecStorageConfigurationLogSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineSpecStorageConfigurationLogSettings)(ptr)
	var objs []VirtualMachineSpecStorageConfigurationLogSettings
	if obj != nil {
		objs = []VirtualMachineSpecStorageConfigurationLogSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecStorageConfigurationLogSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineSpecStorageConfigurationLogSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineSpecStorageConfigurationLogSettings)(ptr) = VirtualMachineSpecStorageConfigurationLogSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineSpecStorageConfigurationLogSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecStorageConfigurationLogSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineSpecStorageConfigurationLogSettings)(ptr) = objs[0]
			} else {
				*(*VirtualMachineSpecStorageConfigurationLogSettings)(ptr) = VirtualMachineSpecStorageConfigurationLogSettings{}
			}
		} else {
			*(*VirtualMachineSpecStorageConfigurationLogSettings)(ptr) = VirtualMachineSpecStorageConfigurationLogSettings{}
		}
	default:
		iter.ReportError("decode VirtualMachineSpecStorageConfigurationLogSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineSpecStorageConfigurationTempDbSettingsCodec struct {
}

func (VirtualMachineSpecStorageConfigurationTempDbSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineSpecStorageConfigurationTempDbSettings)(ptr) == nil
}

func (VirtualMachineSpecStorageConfigurationTempDbSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineSpecStorageConfigurationTempDbSettings)(ptr)
	var objs []VirtualMachineSpecStorageConfigurationTempDbSettings
	if obj != nil {
		objs = []VirtualMachineSpecStorageConfigurationTempDbSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecStorageConfigurationTempDbSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineSpecStorageConfigurationTempDbSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineSpecStorageConfigurationTempDbSettings)(ptr) = VirtualMachineSpecStorageConfigurationTempDbSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineSpecStorageConfigurationTempDbSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecStorageConfigurationTempDbSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineSpecStorageConfigurationTempDbSettings)(ptr) = objs[0]
			} else {
				*(*VirtualMachineSpecStorageConfigurationTempDbSettings)(ptr) = VirtualMachineSpecStorageConfigurationTempDbSettings{}
			}
		} else {
			*(*VirtualMachineSpecStorageConfigurationTempDbSettings)(ptr) = VirtualMachineSpecStorageConfigurationTempDbSettings{}
		}
	default:
		iter.ReportError("decode VirtualMachineSpecStorageConfigurationTempDbSettings", "unexpected JSON type")
	}
}
