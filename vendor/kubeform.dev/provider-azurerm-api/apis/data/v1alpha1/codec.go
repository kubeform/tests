/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecGithubConfiguration{}).Type1()):                           FactorySpecGithubConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecIdentity{}).Type1()):                                      FactorySpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecVstsConfiguration{}).Type1()):                             FactorySpecVstsConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}).Type1()):  FactoryDatasetDelimitedTextSpecAzureBlobStorageLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecHttpServerLocation{}).Type1()):        FactoryDatasetDelimitedTextSpecHttpServerLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecAzureBlobStorageLocation{}).Type1()):           FactoryDatasetJSONSpecAzureBlobStorageLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecHttpServerLocation{}).Type1()):                 FactoryDatasetJSONSpecHttpServerLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecAzureBlobStorageLocation{}).Type1()):        FactoryDatasetParquetSpecAzureBlobStorageLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecHttpServerLocation{}).Type1()):              FactoryDatasetParquetSpecHttpServerLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}).Type1()):        FactoryIntegrationRuntimeAzureSsisSpecCatalogInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}).Type1()):  FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScriptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}).Type1()):    FactoryIntegrationRuntimeAzureSsisSpecVnetIntegrationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCatalogInfo{}).Type1()):          FactoryIntegrationRuntimeManagedSpecCatalogInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}).Type1()):    FactoryIntegrationRuntimeManagedSpecCustomSetupScriptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecVnetIntegration{}).Type1()):      FactoryIntegrationRuntimeManagedSpecVnetIntegrationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecInstancePool{}).Type1()):      FactoryLinkedServiceAzureDatabricksSpecInstancePoolCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}).Type1()):  FactoryLinkedServiceAzureDatabricksSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}).Type1()):  FactoryLinkedServiceAzureDatabricksSpecNewClusterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}).Type1()): FactoryLinkedServiceAzureFileStorageSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}).Type1()): FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}).Type1()):        FactoryLinkedServiceSnowflakeSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}).Type1()):        FactoryLinkedServiceSQLServerSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSynapseSpecKeyVaultPassword{}).Type1()):          FactoryLinkedServiceSynapseSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ShareSpecSnapshotSchedule{}).Type1()):                                ShareSpecSnapshotScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ShareAccountSpecIdentity{}).Type1()):                                 ShareAccountSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ShareDatasetBlobStorageSpecStorageAccount{}).Type1()):                ShareDatasetBlobStorageSpecStorageAccountCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecGithubConfiguration{}).Type1()):                           FactorySpecGithubConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecIdentity{}).Type1()):                                      FactorySpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecVstsConfiguration{}).Type1()):                             FactorySpecVstsConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}).Type1()):  FactoryDatasetDelimitedTextSpecAzureBlobStorageLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecHttpServerLocation{}).Type1()):        FactoryDatasetDelimitedTextSpecHttpServerLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecAzureBlobStorageLocation{}).Type1()):           FactoryDatasetJSONSpecAzureBlobStorageLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecHttpServerLocation{}).Type1()):                 FactoryDatasetJSONSpecHttpServerLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecAzureBlobStorageLocation{}).Type1()):        FactoryDatasetParquetSpecAzureBlobStorageLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecHttpServerLocation{}).Type1()):              FactoryDatasetParquetSpecHttpServerLocationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}).Type1()):        FactoryIntegrationRuntimeAzureSsisSpecCatalogInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}).Type1()):  FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScriptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}).Type1()):    FactoryIntegrationRuntimeAzureSsisSpecVnetIntegrationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCatalogInfo{}).Type1()):          FactoryIntegrationRuntimeManagedSpecCatalogInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}).Type1()):    FactoryIntegrationRuntimeManagedSpecCustomSetupScriptCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecVnetIntegration{}).Type1()):      FactoryIntegrationRuntimeManagedSpecVnetIntegrationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecInstancePool{}).Type1()):      FactoryLinkedServiceAzureDatabricksSpecInstancePoolCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}).Type1()):  FactoryLinkedServiceAzureDatabricksSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}).Type1()):  FactoryLinkedServiceAzureDatabricksSpecNewClusterConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}).Type1()): FactoryLinkedServiceAzureFileStorageSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}).Type1()): FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}).Type1()):        FactoryLinkedServiceSnowflakeSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}).Type1()):        FactoryLinkedServiceSQLServerSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSynapseSpecKeyVaultPassword{}).Type1()):          FactoryLinkedServiceSynapseSpecKeyVaultPasswordCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ShareSpecSnapshotSchedule{}).Type1()):                                ShareSpecSnapshotScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ShareAccountSpecIdentity{}).Type1()):                                 ShareAccountSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ShareDatasetBlobStorageSpecStorageAccount{}).Type1()):                ShareDatasetBlobStorageSpecStorageAccountCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type FactorySpecGithubConfigurationCodec struct {
}

func (FactorySpecGithubConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactorySpecGithubConfiguration)(ptr) == nil
}

func (FactorySpecGithubConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactorySpecGithubConfiguration)(ptr)
	var objs []FactorySpecGithubConfiguration
	if obj != nil {
		objs = []FactorySpecGithubConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecGithubConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactorySpecGithubConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactorySpecGithubConfiguration)(ptr) = FactorySpecGithubConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactorySpecGithubConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecGithubConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactorySpecGithubConfiguration)(ptr) = objs[0]
			} else {
				*(*FactorySpecGithubConfiguration)(ptr) = FactorySpecGithubConfiguration{}
			}
		} else {
			*(*FactorySpecGithubConfiguration)(ptr) = FactorySpecGithubConfiguration{}
		}
	default:
		iter.ReportError("decode FactorySpecGithubConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactorySpecIdentityCodec struct {
}

func (FactorySpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactorySpecIdentity)(ptr) == nil
}

func (FactorySpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactorySpecIdentity)(ptr)
	var objs []FactorySpecIdentity
	if obj != nil {
		objs = []FactorySpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactorySpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactorySpecIdentity)(ptr) = FactorySpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactorySpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactorySpecIdentity)(ptr) = objs[0]
			} else {
				*(*FactorySpecIdentity)(ptr) = FactorySpecIdentity{}
			}
		} else {
			*(*FactorySpecIdentity)(ptr) = FactorySpecIdentity{}
		}
	default:
		iter.ReportError("decode FactorySpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactorySpecVstsConfigurationCodec struct {
}

func (FactorySpecVstsConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactorySpecVstsConfiguration)(ptr) == nil
}

func (FactorySpecVstsConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactorySpecVstsConfiguration)(ptr)
	var objs []FactorySpecVstsConfiguration
	if obj != nil {
		objs = []FactorySpecVstsConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecVstsConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactorySpecVstsConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactorySpecVstsConfiguration)(ptr) = FactorySpecVstsConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactorySpecVstsConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactorySpecVstsConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactorySpecVstsConfiguration)(ptr) = objs[0]
			} else {
				*(*FactorySpecVstsConfiguration)(ptr) = FactorySpecVstsConfiguration{}
			}
		} else {
			*(*FactorySpecVstsConfiguration)(ptr) = FactorySpecVstsConfiguration{}
		}
	default:
		iter.ReportError("decode FactorySpecVstsConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetDelimitedTextSpecAzureBlobStorageLocationCodec struct {
}

func (FactoryDatasetDelimitedTextSpecAzureBlobStorageLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation)(ptr) == nil
}

func (FactoryDatasetDelimitedTextSpecAzureBlobStorageLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation)(ptr)
	var objs []FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation
	if obj != nil {
		objs = []FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetDelimitedTextSpecAzureBlobStorageLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}
			}
		} else {
			*(*FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation{}
		}
	default:
		iter.ReportError("decode FactoryDatasetDelimitedTextSpecAzureBlobStorageLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetDelimitedTextSpecHttpServerLocationCodec struct {
}

func (FactoryDatasetDelimitedTextSpecHttpServerLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetDelimitedTextSpecHttpServerLocation)(ptr) == nil
}

func (FactoryDatasetDelimitedTextSpecHttpServerLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetDelimitedTextSpecHttpServerLocation)(ptr)
	var objs []FactoryDatasetDelimitedTextSpecHttpServerLocation
	if obj != nil {
		objs = []FactoryDatasetDelimitedTextSpecHttpServerLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecHttpServerLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetDelimitedTextSpecHttpServerLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetDelimitedTextSpecHttpServerLocation)(ptr) = FactoryDatasetDelimitedTextSpecHttpServerLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetDelimitedTextSpecHttpServerLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetDelimitedTextSpecHttpServerLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetDelimitedTextSpecHttpServerLocation)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetDelimitedTextSpecHttpServerLocation)(ptr) = FactoryDatasetDelimitedTextSpecHttpServerLocation{}
			}
		} else {
			*(*FactoryDatasetDelimitedTextSpecHttpServerLocation)(ptr) = FactoryDatasetDelimitedTextSpecHttpServerLocation{}
		}
	default:
		iter.ReportError("decode FactoryDatasetDelimitedTextSpecHttpServerLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetJSONSpecAzureBlobStorageLocationCodec struct {
}

func (FactoryDatasetJSONSpecAzureBlobStorageLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetJSONSpecAzureBlobStorageLocation)(ptr) == nil
}

func (FactoryDatasetJSONSpecAzureBlobStorageLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetJSONSpecAzureBlobStorageLocation)(ptr)
	var objs []FactoryDatasetJSONSpecAzureBlobStorageLocation
	if obj != nil {
		objs = []FactoryDatasetJSONSpecAzureBlobStorageLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecAzureBlobStorageLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetJSONSpecAzureBlobStorageLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetJSONSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetJSONSpecAzureBlobStorageLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetJSONSpecAzureBlobStorageLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecAzureBlobStorageLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetJSONSpecAzureBlobStorageLocation)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetJSONSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetJSONSpecAzureBlobStorageLocation{}
			}
		} else {
			*(*FactoryDatasetJSONSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetJSONSpecAzureBlobStorageLocation{}
		}
	default:
		iter.ReportError("decode FactoryDatasetJSONSpecAzureBlobStorageLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetJSONSpecHttpServerLocationCodec struct {
}

func (FactoryDatasetJSONSpecHttpServerLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetJSONSpecHttpServerLocation)(ptr) == nil
}

func (FactoryDatasetJSONSpecHttpServerLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetJSONSpecHttpServerLocation)(ptr)
	var objs []FactoryDatasetJSONSpecHttpServerLocation
	if obj != nil {
		objs = []FactoryDatasetJSONSpecHttpServerLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecHttpServerLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetJSONSpecHttpServerLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetJSONSpecHttpServerLocation)(ptr) = FactoryDatasetJSONSpecHttpServerLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetJSONSpecHttpServerLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetJSONSpecHttpServerLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetJSONSpecHttpServerLocation)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetJSONSpecHttpServerLocation)(ptr) = FactoryDatasetJSONSpecHttpServerLocation{}
			}
		} else {
			*(*FactoryDatasetJSONSpecHttpServerLocation)(ptr) = FactoryDatasetJSONSpecHttpServerLocation{}
		}
	default:
		iter.ReportError("decode FactoryDatasetJSONSpecHttpServerLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetParquetSpecAzureBlobStorageLocationCodec struct {
}

func (FactoryDatasetParquetSpecAzureBlobStorageLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetParquetSpecAzureBlobStorageLocation)(ptr) == nil
}

func (FactoryDatasetParquetSpecAzureBlobStorageLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetParquetSpecAzureBlobStorageLocation)(ptr)
	var objs []FactoryDatasetParquetSpecAzureBlobStorageLocation
	if obj != nil {
		objs = []FactoryDatasetParquetSpecAzureBlobStorageLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecAzureBlobStorageLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetParquetSpecAzureBlobStorageLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetParquetSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetParquetSpecAzureBlobStorageLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetParquetSpecAzureBlobStorageLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecAzureBlobStorageLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetParquetSpecAzureBlobStorageLocation)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetParquetSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetParquetSpecAzureBlobStorageLocation{}
			}
		} else {
			*(*FactoryDatasetParquetSpecAzureBlobStorageLocation)(ptr) = FactoryDatasetParquetSpecAzureBlobStorageLocation{}
		}
	default:
		iter.ReportError("decode FactoryDatasetParquetSpecAzureBlobStorageLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryDatasetParquetSpecHttpServerLocationCodec struct {
}

func (FactoryDatasetParquetSpecHttpServerLocationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryDatasetParquetSpecHttpServerLocation)(ptr) == nil
}

func (FactoryDatasetParquetSpecHttpServerLocationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryDatasetParquetSpecHttpServerLocation)(ptr)
	var objs []FactoryDatasetParquetSpecHttpServerLocation
	if obj != nil {
		objs = []FactoryDatasetParquetSpecHttpServerLocation{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecHttpServerLocation{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryDatasetParquetSpecHttpServerLocationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryDatasetParquetSpecHttpServerLocation)(ptr) = FactoryDatasetParquetSpecHttpServerLocation{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryDatasetParquetSpecHttpServerLocation

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryDatasetParquetSpecHttpServerLocation{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryDatasetParquetSpecHttpServerLocation)(ptr) = objs[0]
			} else {
				*(*FactoryDatasetParquetSpecHttpServerLocation)(ptr) = FactoryDatasetParquetSpecHttpServerLocation{}
			}
		} else {
			*(*FactoryDatasetParquetSpecHttpServerLocation)(ptr) = FactoryDatasetParquetSpecHttpServerLocation{}
		}
	default:
		iter.ReportError("decode FactoryDatasetParquetSpecHttpServerLocation", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryIntegrationRuntimeAzureSsisSpecCatalogInfoCodec struct {
}

func (FactoryIntegrationRuntimeAzureSsisSpecCatalogInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo)(ptr) == nil
}

func (FactoryIntegrationRuntimeAzureSsisSpecCatalogInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo)(ptr)
	var objs []FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo
	if obj != nil {
		objs = []FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryIntegrationRuntimeAzureSsisSpecCatalogInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo)(ptr) = objs[0]
			} else {
				*(*FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}
			}
		} else {
			*(*FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo{}
		}
	default:
		iter.ReportError("decode FactoryIntegrationRuntimeAzureSsisSpecCatalogInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScriptCodec struct {
}

func (FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScriptCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript)(ptr) == nil
}

func (FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScriptCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript)(ptr)
	var objs []FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript
	if obj != nil {
		objs = []FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScriptCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript)(ptr) = objs[0]
			} else {
				*(*FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}
			}
		} else {
			*(*FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript{}
		}
	default:
		iter.ReportError("decode FactoryIntegrationRuntimeAzureSsisSpecCustomSetupScript", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryIntegrationRuntimeAzureSsisSpecVnetIntegrationCodec struct {
}

func (FactoryIntegrationRuntimeAzureSsisSpecVnetIntegrationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration)(ptr) == nil
}

func (FactoryIntegrationRuntimeAzureSsisSpecVnetIntegrationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration)(ptr)
	var objs []FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration
	if obj != nil {
		objs = []FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryIntegrationRuntimeAzureSsisSpecVnetIntegrationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration)(ptr) = objs[0]
			} else {
				*(*FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}
			}
		} else {
			*(*FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration)(ptr) = FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration{}
		}
	default:
		iter.ReportError("decode FactoryIntegrationRuntimeAzureSsisSpecVnetIntegration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryIntegrationRuntimeManagedSpecCatalogInfoCodec struct {
}

func (FactoryIntegrationRuntimeManagedSpecCatalogInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryIntegrationRuntimeManagedSpecCatalogInfo)(ptr) == nil
}

func (FactoryIntegrationRuntimeManagedSpecCatalogInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryIntegrationRuntimeManagedSpecCatalogInfo)(ptr)
	var objs []FactoryIntegrationRuntimeManagedSpecCatalogInfo
	if obj != nil {
		objs = []FactoryIntegrationRuntimeManagedSpecCatalogInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCatalogInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryIntegrationRuntimeManagedSpecCatalogInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryIntegrationRuntimeManagedSpecCatalogInfo)(ptr) = FactoryIntegrationRuntimeManagedSpecCatalogInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryIntegrationRuntimeManagedSpecCatalogInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCatalogInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryIntegrationRuntimeManagedSpecCatalogInfo)(ptr) = objs[0]
			} else {
				*(*FactoryIntegrationRuntimeManagedSpecCatalogInfo)(ptr) = FactoryIntegrationRuntimeManagedSpecCatalogInfo{}
			}
		} else {
			*(*FactoryIntegrationRuntimeManagedSpecCatalogInfo)(ptr) = FactoryIntegrationRuntimeManagedSpecCatalogInfo{}
		}
	default:
		iter.ReportError("decode FactoryIntegrationRuntimeManagedSpecCatalogInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryIntegrationRuntimeManagedSpecCustomSetupScriptCodec struct {
}

func (FactoryIntegrationRuntimeManagedSpecCustomSetupScriptCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryIntegrationRuntimeManagedSpecCustomSetupScript)(ptr) == nil
}

func (FactoryIntegrationRuntimeManagedSpecCustomSetupScriptCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryIntegrationRuntimeManagedSpecCustomSetupScript)(ptr)
	var objs []FactoryIntegrationRuntimeManagedSpecCustomSetupScript
	if obj != nil {
		objs = []FactoryIntegrationRuntimeManagedSpecCustomSetupScript{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryIntegrationRuntimeManagedSpecCustomSetupScriptCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryIntegrationRuntimeManagedSpecCustomSetupScript)(ptr) = FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryIntegrationRuntimeManagedSpecCustomSetupScript

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryIntegrationRuntimeManagedSpecCustomSetupScript)(ptr) = objs[0]
			} else {
				*(*FactoryIntegrationRuntimeManagedSpecCustomSetupScript)(ptr) = FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}
			}
		} else {
			*(*FactoryIntegrationRuntimeManagedSpecCustomSetupScript)(ptr) = FactoryIntegrationRuntimeManagedSpecCustomSetupScript{}
		}
	default:
		iter.ReportError("decode FactoryIntegrationRuntimeManagedSpecCustomSetupScript", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryIntegrationRuntimeManagedSpecVnetIntegrationCodec struct {
}

func (FactoryIntegrationRuntimeManagedSpecVnetIntegrationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryIntegrationRuntimeManagedSpecVnetIntegration)(ptr) == nil
}

func (FactoryIntegrationRuntimeManagedSpecVnetIntegrationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryIntegrationRuntimeManagedSpecVnetIntegration)(ptr)
	var objs []FactoryIntegrationRuntimeManagedSpecVnetIntegration
	if obj != nil {
		objs = []FactoryIntegrationRuntimeManagedSpecVnetIntegration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecVnetIntegration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryIntegrationRuntimeManagedSpecVnetIntegrationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryIntegrationRuntimeManagedSpecVnetIntegration)(ptr) = FactoryIntegrationRuntimeManagedSpecVnetIntegration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryIntegrationRuntimeManagedSpecVnetIntegration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryIntegrationRuntimeManagedSpecVnetIntegration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryIntegrationRuntimeManagedSpecVnetIntegration)(ptr) = objs[0]
			} else {
				*(*FactoryIntegrationRuntimeManagedSpecVnetIntegration)(ptr) = FactoryIntegrationRuntimeManagedSpecVnetIntegration{}
			}
		} else {
			*(*FactoryIntegrationRuntimeManagedSpecVnetIntegration)(ptr) = FactoryIntegrationRuntimeManagedSpecVnetIntegration{}
		}
	default:
		iter.ReportError("decode FactoryIntegrationRuntimeManagedSpecVnetIntegration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceAzureDatabricksSpecInstancePoolCodec struct {
}

func (FactoryLinkedServiceAzureDatabricksSpecInstancePoolCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceAzureDatabricksSpecInstancePool)(ptr) == nil
}

func (FactoryLinkedServiceAzureDatabricksSpecInstancePoolCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceAzureDatabricksSpecInstancePool)(ptr)
	var objs []FactoryLinkedServiceAzureDatabricksSpecInstancePool
	if obj != nil {
		objs = []FactoryLinkedServiceAzureDatabricksSpecInstancePool{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecInstancePool{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceAzureDatabricksSpecInstancePoolCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceAzureDatabricksSpecInstancePool)(ptr) = FactoryLinkedServiceAzureDatabricksSpecInstancePool{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceAzureDatabricksSpecInstancePool

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecInstancePool{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceAzureDatabricksSpecInstancePool)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceAzureDatabricksSpecInstancePool)(ptr) = FactoryLinkedServiceAzureDatabricksSpecInstancePool{}
			}
		} else {
			*(*FactoryLinkedServiceAzureDatabricksSpecInstancePool)(ptr) = FactoryLinkedServiceAzureDatabricksSpecInstancePool{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceAzureDatabricksSpecInstancePool", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceAzureDatabricksSpecKeyVaultPasswordCodec struct {
}

func (FactoryLinkedServiceAzureDatabricksSpecKeyVaultPasswordCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword)(ptr) == nil
}

func (FactoryLinkedServiceAzureDatabricksSpecKeyVaultPasswordCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword)(ptr)
	var objs []FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword
	if obj != nil {
		objs = []FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceAzureDatabricksSpecKeyVaultPasswordCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}
			}
		} else {
			*(*FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceAzureDatabricksSpecKeyVaultPassword", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceAzureDatabricksSpecNewClusterConfigCodec struct {
}

func (FactoryLinkedServiceAzureDatabricksSpecNewClusterConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig)(ptr) == nil
}

func (FactoryLinkedServiceAzureDatabricksSpecNewClusterConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig)(ptr)
	var objs []FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig
	if obj != nil {
		objs = []FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceAzureDatabricksSpecNewClusterConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig)(ptr) = FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig)(ptr) = FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}
			}
		} else {
			*(*FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig)(ptr) = FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceAzureDatabricksSpecNewClusterConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceAzureFileStorageSpecKeyVaultPasswordCodec struct {
}

func (FactoryLinkedServiceAzureFileStorageSpecKeyVaultPasswordCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword)(ptr) == nil
}

func (FactoryLinkedServiceAzureFileStorageSpecKeyVaultPasswordCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword)(ptr)
	var objs []FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword
	if obj != nil {
		objs = []FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceAzureFileStorageSpecKeyVaultPasswordCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}
			}
		} else {
			*(*FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceAzureFileStorageSpecKeyVaultPassword", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPasswordCodec struct {
}

func (FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPasswordCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword)(ptr) == nil
}

func (FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPasswordCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword)(ptr)
	var objs []FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword
	if obj != nil {
		objs = []FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPasswordCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}
			}
		} else {
			*(*FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceAzureSQLDatabaseSpecKeyVaultPassword", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceSnowflakeSpecKeyVaultPasswordCodec struct {
}

func (FactoryLinkedServiceSnowflakeSpecKeyVaultPasswordCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceSnowflakeSpecKeyVaultPassword)(ptr) == nil
}

func (FactoryLinkedServiceSnowflakeSpecKeyVaultPasswordCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceSnowflakeSpecKeyVaultPassword)(ptr)
	var objs []FactoryLinkedServiceSnowflakeSpecKeyVaultPassword
	if obj != nil {
		objs = []FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceSnowflakeSpecKeyVaultPasswordCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceSnowflakeSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceSnowflakeSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceSnowflakeSpecKeyVaultPassword)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceSnowflakeSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}
			}
		} else {
			*(*FactoryLinkedServiceSnowflakeSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSnowflakeSpecKeyVaultPassword{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceSnowflakeSpecKeyVaultPassword", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceSQLServerSpecKeyVaultPasswordCodec struct {
}

func (FactoryLinkedServiceSQLServerSpecKeyVaultPasswordCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceSQLServerSpecKeyVaultPassword)(ptr) == nil
}

func (FactoryLinkedServiceSQLServerSpecKeyVaultPasswordCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceSQLServerSpecKeyVaultPassword)(ptr)
	var objs []FactoryLinkedServiceSQLServerSpecKeyVaultPassword
	if obj != nil {
		objs = []FactoryLinkedServiceSQLServerSpecKeyVaultPassword{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceSQLServerSpecKeyVaultPasswordCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceSQLServerSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceSQLServerSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceSQLServerSpecKeyVaultPassword)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceSQLServerSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}
			}
		} else {
			*(*FactoryLinkedServiceSQLServerSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSQLServerSpecKeyVaultPassword{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceSQLServerSpecKeyVaultPassword", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type FactoryLinkedServiceSynapseSpecKeyVaultPasswordCodec struct {
}

func (FactoryLinkedServiceSynapseSpecKeyVaultPasswordCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*FactoryLinkedServiceSynapseSpecKeyVaultPassword)(ptr) == nil
}

func (FactoryLinkedServiceSynapseSpecKeyVaultPasswordCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*FactoryLinkedServiceSynapseSpecKeyVaultPassword)(ptr)
	var objs []FactoryLinkedServiceSynapseSpecKeyVaultPassword
	if obj != nil {
		objs = []FactoryLinkedServiceSynapseSpecKeyVaultPassword{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSynapseSpecKeyVaultPassword{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (FactoryLinkedServiceSynapseSpecKeyVaultPasswordCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*FactoryLinkedServiceSynapseSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSynapseSpecKeyVaultPassword{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []FactoryLinkedServiceSynapseSpecKeyVaultPassword

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(FactoryLinkedServiceSynapseSpecKeyVaultPassword{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*FactoryLinkedServiceSynapseSpecKeyVaultPassword)(ptr) = objs[0]
			} else {
				*(*FactoryLinkedServiceSynapseSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSynapseSpecKeyVaultPassword{}
			}
		} else {
			*(*FactoryLinkedServiceSynapseSpecKeyVaultPassword)(ptr) = FactoryLinkedServiceSynapseSpecKeyVaultPassword{}
		}
	default:
		iter.ReportError("decode FactoryLinkedServiceSynapseSpecKeyVaultPassword", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ShareSpecSnapshotScheduleCodec struct {
}

func (ShareSpecSnapshotScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ShareSpecSnapshotSchedule)(ptr) == nil
}

func (ShareSpecSnapshotScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ShareSpecSnapshotSchedule)(ptr)
	var objs []ShareSpecSnapshotSchedule
	if obj != nil {
		objs = []ShareSpecSnapshotSchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareSpecSnapshotSchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ShareSpecSnapshotScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ShareSpecSnapshotSchedule)(ptr) = ShareSpecSnapshotSchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ShareSpecSnapshotSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareSpecSnapshotSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ShareSpecSnapshotSchedule)(ptr) = objs[0]
			} else {
				*(*ShareSpecSnapshotSchedule)(ptr) = ShareSpecSnapshotSchedule{}
			}
		} else {
			*(*ShareSpecSnapshotSchedule)(ptr) = ShareSpecSnapshotSchedule{}
		}
	default:
		iter.ReportError("decode ShareSpecSnapshotSchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ShareAccountSpecIdentityCodec struct {
}

func (ShareAccountSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ShareAccountSpecIdentity)(ptr) == nil
}

func (ShareAccountSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ShareAccountSpecIdentity)(ptr)
	var objs []ShareAccountSpecIdentity
	if obj != nil {
		objs = []ShareAccountSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareAccountSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ShareAccountSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ShareAccountSpecIdentity)(ptr) = ShareAccountSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ShareAccountSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareAccountSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ShareAccountSpecIdentity)(ptr) = objs[0]
			} else {
				*(*ShareAccountSpecIdentity)(ptr) = ShareAccountSpecIdentity{}
			}
		} else {
			*(*ShareAccountSpecIdentity)(ptr) = ShareAccountSpecIdentity{}
		}
	default:
		iter.ReportError("decode ShareAccountSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ShareDatasetBlobStorageSpecStorageAccountCodec struct {
}

func (ShareDatasetBlobStorageSpecStorageAccountCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ShareDatasetBlobStorageSpecStorageAccount)(ptr) == nil
}

func (ShareDatasetBlobStorageSpecStorageAccountCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ShareDatasetBlobStorageSpecStorageAccount)(ptr)
	var objs []ShareDatasetBlobStorageSpecStorageAccount
	if obj != nil {
		objs = []ShareDatasetBlobStorageSpecStorageAccount{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareDatasetBlobStorageSpecStorageAccount{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ShareDatasetBlobStorageSpecStorageAccountCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ShareDatasetBlobStorageSpecStorageAccount)(ptr) = ShareDatasetBlobStorageSpecStorageAccount{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ShareDatasetBlobStorageSpecStorageAccount

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ShareDatasetBlobStorageSpecStorageAccount{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ShareDatasetBlobStorageSpecStorageAccount)(ptr) = objs[0]
			} else {
				*(*ShareDatasetBlobStorageSpecStorageAccount)(ptr) = ShareDatasetBlobStorageSpecStorageAccount{}
			}
		} else {
			*(*ShareDatasetBlobStorageSpecStorageAccount)(ptr) = ShareDatasetBlobStorageSpecStorageAccount{}
		}
	default:
		iter.ReportError("decode ShareDatasetBlobStorageSpecStorageAccount", "unexpected JSON type")
	}
}
