/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(DomainSpecInputMappingDefaultValues{}).Type1()):                              DomainSpecInputMappingDefaultValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DomainSpecInputMappingFields{}).Type1()):                                     DomainSpecInputMappingFieldsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecAdvancedFilter{}).Type1()):                              EventSubscriptionSpecAdvancedFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecAzureFunctionEndpoint{}).Type1()):                       EventSubscriptionSpecAzureFunctionEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecEventhubEndpoint{}).Type1()):                            EventSubscriptionSpecEventhubEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecHybridConnectionEndpoint{}).Type1()):                    EventSubscriptionSpecHybridConnectionEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecRetryPolicy{}).Type1()):                                 EventSubscriptionSpecRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecStorageBlobDeadLetterDestination{}).Type1()):            EventSubscriptionSpecStorageBlobDeadLetterDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecStorageQueueEndpoint{}).Type1()):                        EventSubscriptionSpecStorageQueueEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecSubjectFilter{}).Type1()):                               EventSubscriptionSpecSubjectFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecWebhookEndpoint{}).Type1()):                             EventSubscriptionSpecWebhookEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecAdvancedFilter{}).Type1()):                   SystemTopicEventSubscriptionSpecAdvancedFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecAzureFunctionEndpoint{}).Type1()):            SystemTopicEventSubscriptionSpecAzureFunctionEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecRetryPolicy{}).Type1()):                      SystemTopicEventSubscriptionSpecRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination{}).Type1()): SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecStorageQueueEndpoint{}).Type1()):             SystemTopicEventSubscriptionSpecStorageQueueEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecSubjectFilter{}).Type1()):                    SystemTopicEventSubscriptionSpecSubjectFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecWebhookEndpoint{}).Type1()):                  SystemTopicEventSubscriptionSpecWebhookEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecInputMappingDefaultValues{}).Type1()):                               TopicSpecInputMappingDefaultValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecInputMappingFields{}).Type1()):                                      TopicSpecInputMappingFieldsCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(DomainSpecInputMappingDefaultValues{}).Type1()):                              DomainSpecInputMappingDefaultValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DomainSpecInputMappingFields{}).Type1()):                                     DomainSpecInputMappingFieldsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecAdvancedFilter{}).Type1()):                              EventSubscriptionSpecAdvancedFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecAzureFunctionEndpoint{}).Type1()):                       EventSubscriptionSpecAzureFunctionEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecEventhubEndpoint{}).Type1()):                            EventSubscriptionSpecEventhubEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecHybridConnectionEndpoint{}).Type1()):                    EventSubscriptionSpecHybridConnectionEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecRetryPolicy{}).Type1()):                                 EventSubscriptionSpecRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecStorageBlobDeadLetterDestination{}).Type1()):            EventSubscriptionSpecStorageBlobDeadLetterDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecStorageQueueEndpoint{}).Type1()):                        EventSubscriptionSpecStorageQueueEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecSubjectFilter{}).Type1()):                               EventSubscriptionSpecSubjectFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecWebhookEndpoint{}).Type1()):                             EventSubscriptionSpecWebhookEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecAdvancedFilter{}).Type1()):                   SystemTopicEventSubscriptionSpecAdvancedFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecAzureFunctionEndpoint{}).Type1()):            SystemTopicEventSubscriptionSpecAzureFunctionEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecRetryPolicy{}).Type1()):                      SystemTopicEventSubscriptionSpecRetryPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination{}).Type1()): SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestinationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecStorageQueueEndpoint{}).Type1()):             SystemTopicEventSubscriptionSpecStorageQueueEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecSubjectFilter{}).Type1()):                    SystemTopicEventSubscriptionSpecSubjectFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecWebhookEndpoint{}).Type1()):                  SystemTopicEventSubscriptionSpecWebhookEndpointCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecInputMappingDefaultValues{}).Type1()):                               TopicSpecInputMappingDefaultValuesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecInputMappingFields{}).Type1()):                                      TopicSpecInputMappingFieldsCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type DomainSpecInputMappingDefaultValuesCodec struct {
}

func (DomainSpecInputMappingDefaultValuesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DomainSpecInputMappingDefaultValues)(ptr) == nil
}

func (DomainSpecInputMappingDefaultValuesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DomainSpecInputMappingDefaultValues)(ptr)
	var objs []DomainSpecInputMappingDefaultValues
	if obj != nil {
		objs = []DomainSpecInputMappingDefaultValues{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainSpecInputMappingDefaultValues{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DomainSpecInputMappingDefaultValuesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DomainSpecInputMappingDefaultValues)(ptr) = DomainSpecInputMappingDefaultValues{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DomainSpecInputMappingDefaultValues

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainSpecInputMappingDefaultValues{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DomainSpecInputMappingDefaultValues)(ptr) = objs[0]
			} else {
				*(*DomainSpecInputMappingDefaultValues)(ptr) = DomainSpecInputMappingDefaultValues{}
			}
		} else {
			*(*DomainSpecInputMappingDefaultValues)(ptr) = DomainSpecInputMappingDefaultValues{}
		}
	default:
		iter.ReportError("decode DomainSpecInputMappingDefaultValues", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DomainSpecInputMappingFieldsCodec struct {
}

func (DomainSpecInputMappingFieldsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DomainSpecInputMappingFields)(ptr) == nil
}

func (DomainSpecInputMappingFieldsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DomainSpecInputMappingFields)(ptr)
	var objs []DomainSpecInputMappingFields
	if obj != nil {
		objs = []DomainSpecInputMappingFields{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainSpecInputMappingFields{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DomainSpecInputMappingFieldsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DomainSpecInputMappingFields)(ptr) = DomainSpecInputMappingFields{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DomainSpecInputMappingFields

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DomainSpecInputMappingFields{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DomainSpecInputMappingFields)(ptr) = objs[0]
			} else {
				*(*DomainSpecInputMappingFields)(ptr) = DomainSpecInputMappingFields{}
			}
		} else {
			*(*DomainSpecInputMappingFields)(ptr) = DomainSpecInputMappingFields{}
		}
	default:
		iter.ReportError("decode DomainSpecInputMappingFields", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventSubscriptionSpecAdvancedFilterCodec struct {
}

func (EventSubscriptionSpecAdvancedFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventSubscriptionSpecAdvancedFilter)(ptr) == nil
}

func (EventSubscriptionSpecAdvancedFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventSubscriptionSpecAdvancedFilter)(ptr)
	var objs []EventSubscriptionSpecAdvancedFilter
	if obj != nil {
		objs = []EventSubscriptionSpecAdvancedFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecAdvancedFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventSubscriptionSpecAdvancedFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventSubscriptionSpecAdvancedFilter)(ptr) = EventSubscriptionSpecAdvancedFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventSubscriptionSpecAdvancedFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecAdvancedFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventSubscriptionSpecAdvancedFilter)(ptr) = objs[0]
			} else {
				*(*EventSubscriptionSpecAdvancedFilter)(ptr) = EventSubscriptionSpecAdvancedFilter{}
			}
		} else {
			*(*EventSubscriptionSpecAdvancedFilter)(ptr) = EventSubscriptionSpecAdvancedFilter{}
		}
	default:
		iter.ReportError("decode EventSubscriptionSpecAdvancedFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventSubscriptionSpecAzureFunctionEndpointCodec struct {
}

func (EventSubscriptionSpecAzureFunctionEndpointCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventSubscriptionSpecAzureFunctionEndpoint)(ptr) == nil
}

func (EventSubscriptionSpecAzureFunctionEndpointCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventSubscriptionSpecAzureFunctionEndpoint)(ptr)
	var objs []EventSubscriptionSpecAzureFunctionEndpoint
	if obj != nil {
		objs = []EventSubscriptionSpecAzureFunctionEndpoint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecAzureFunctionEndpoint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventSubscriptionSpecAzureFunctionEndpointCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventSubscriptionSpecAzureFunctionEndpoint)(ptr) = EventSubscriptionSpecAzureFunctionEndpoint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventSubscriptionSpecAzureFunctionEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecAzureFunctionEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventSubscriptionSpecAzureFunctionEndpoint)(ptr) = objs[0]
			} else {
				*(*EventSubscriptionSpecAzureFunctionEndpoint)(ptr) = EventSubscriptionSpecAzureFunctionEndpoint{}
			}
		} else {
			*(*EventSubscriptionSpecAzureFunctionEndpoint)(ptr) = EventSubscriptionSpecAzureFunctionEndpoint{}
		}
	default:
		iter.ReportError("decode EventSubscriptionSpecAzureFunctionEndpoint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventSubscriptionSpecEventhubEndpointCodec struct {
}

func (EventSubscriptionSpecEventhubEndpointCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventSubscriptionSpecEventhubEndpoint)(ptr) == nil
}

func (EventSubscriptionSpecEventhubEndpointCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventSubscriptionSpecEventhubEndpoint)(ptr)
	var objs []EventSubscriptionSpecEventhubEndpoint
	if obj != nil {
		objs = []EventSubscriptionSpecEventhubEndpoint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecEventhubEndpoint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventSubscriptionSpecEventhubEndpointCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventSubscriptionSpecEventhubEndpoint)(ptr) = EventSubscriptionSpecEventhubEndpoint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventSubscriptionSpecEventhubEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecEventhubEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventSubscriptionSpecEventhubEndpoint)(ptr) = objs[0]
			} else {
				*(*EventSubscriptionSpecEventhubEndpoint)(ptr) = EventSubscriptionSpecEventhubEndpoint{}
			}
		} else {
			*(*EventSubscriptionSpecEventhubEndpoint)(ptr) = EventSubscriptionSpecEventhubEndpoint{}
		}
	default:
		iter.ReportError("decode EventSubscriptionSpecEventhubEndpoint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventSubscriptionSpecHybridConnectionEndpointCodec struct {
}

func (EventSubscriptionSpecHybridConnectionEndpointCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventSubscriptionSpecHybridConnectionEndpoint)(ptr) == nil
}

func (EventSubscriptionSpecHybridConnectionEndpointCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventSubscriptionSpecHybridConnectionEndpoint)(ptr)
	var objs []EventSubscriptionSpecHybridConnectionEndpoint
	if obj != nil {
		objs = []EventSubscriptionSpecHybridConnectionEndpoint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecHybridConnectionEndpoint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventSubscriptionSpecHybridConnectionEndpointCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventSubscriptionSpecHybridConnectionEndpoint)(ptr) = EventSubscriptionSpecHybridConnectionEndpoint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventSubscriptionSpecHybridConnectionEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecHybridConnectionEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventSubscriptionSpecHybridConnectionEndpoint)(ptr) = objs[0]
			} else {
				*(*EventSubscriptionSpecHybridConnectionEndpoint)(ptr) = EventSubscriptionSpecHybridConnectionEndpoint{}
			}
		} else {
			*(*EventSubscriptionSpecHybridConnectionEndpoint)(ptr) = EventSubscriptionSpecHybridConnectionEndpoint{}
		}
	default:
		iter.ReportError("decode EventSubscriptionSpecHybridConnectionEndpoint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventSubscriptionSpecRetryPolicyCodec struct {
}

func (EventSubscriptionSpecRetryPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventSubscriptionSpecRetryPolicy)(ptr) == nil
}

func (EventSubscriptionSpecRetryPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventSubscriptionSpecRetryPolicy)(ptr)
	var objs []EventSubscriptionSpecRetryPolicy
	if obj != nil {
		objs = []EventSubscriptionSpecRetryPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecRetryPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventSubscriptionSpecRetryPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventSubscriptionSpecRetryPolicy)(ptr) = EventSubscriptionSpecRetryPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventSubscriptionSpecRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventSubscriptionSpecRetryPolicy)(ptr) = objs[0]
			} else {
				*(*EventSubscriptionSpecRetryPolicy)(ptr) = EventSubscriptionSpecRetryPolicy{}
			}
		} else {
			*(*EventSubscriptionSpecRetryPolicy)(ptr) = EventSubscriptionSpecRetryPolicy{}
		}
	default:
		iter.ReportError("decode EventSubscriptionSpecRetryPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventSubscriptionSpecStorageBlobDeadLetterDestinationCodec struct {
}

func (EventSubscriptionSpecStorageBlobDeadLetterDestinationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) == nil
}

func (EventSubscriptionSpecStorageBlobDeadLetterDestinationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr)
	var objs []EventSubscriptionSpecStorageBlobDeadLetterDestination
	if obj != nil {
		objs = []EventSubscriptionSpecStorageBlobDeadLetterDestination{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecStorageBlobDeadLetterDestination{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventSubscriptionSpecStorageBlobDeadLetterDestinationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) = EventSubscriptionSpecStorageBlobDeadLetterDestination{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventSubscriptionSpecStorageBlobDeadLetterDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecStorageBlobDeadLetterDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) = objs[0]
			} else {
				*(*EventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) = EventSubscriptionSpecStorageBlobDeadLetterDestination{}
			}
		} else {
			*(*EventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) = EventSubscriptionSpecStorageBlobDeadLetterDestination{}
		}
	default:
		iter.ReportError("decode EventSubscriptionSpecStorageBlobDeadLetterDestination", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventSubscriptionSpecStorageQueueEndpointCodec struct {
}

func (EventSubscriptionSpecStorageQueueEndpointCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventSubscriptionSpecStorageQueueEndpoint)(ptr) == nil
}

func (EventSubscriptionSpecStorageQueueEndpointCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventSubscriptionSpecStorageQueueEndpoint)(ptr)
	var objs []EventSubscriptionSpecStorageQueueEndpoint
	if obj != nil {
		objs = []EventSubscriptionSpecStorageQueueEndpoint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecStorageQueueEndpoint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventSubscriptionSpecStorageQueueEndpointCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventSubscriptionSpecStorageQueueEndpoint)(ptr) = EventSubscriptionSpecStorageQueueEndpoint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventSubscriptionSpecStorageQueueEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecStorageQueueEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventSubscriptionSpecStorageQueueEndpoint)(ptr) = objs[0]
			} else {
				*(*EventSubscriptionSpecStorageQueueEndpoint)(ptr) = EventSubscriptionSpecStorageQueueEndpoint{}
			}
		} else {
			*(*EventSubscriptionSpecStorageQueueEndpoint)(ptr) = EventSubscriptionSpecStorageQueueEndpoint{}
		}
	default:
		iter.ReportError("decode EventSubscriptionSpecStorageQueueEndpoint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventSubscriptionSpecSubjectFilterCodec struct {
}

func (EventSubscriptionSpecSubjectFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventSubscriptionSpecSubjectFilter)(ptr) == nil
}

func (EventSubscriptionSpecSubjectFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventSubscriptionSpecSubjectFilter)(ptr)
	var objs []EventSubscriptionSpecSubjectFilter
	if obj != nil {
		objs = []EventSubscriptionSpecSubjectFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecSubjectFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventSubscriptionSpecSubjectFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventSubscriptionSpecSubjectFilter)(ptr) = EventSubscriptionSpecSubjectFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventSubscriptionSpecSubjectFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecSubjectFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventSubscriptionSpecSubjectFilter)(ptr) = objs[0]
			} else {
				*(*EventSubscriptionSpecSubjectFilter)(ptr) = EventSubscriptionSpecSubjectFilter{}
			}
		} else {
			*(*EventSubscriptionSpecSubjectFilter)(ptr) = EventSubscriptionSpecSubjectFilter{}
		}
	default:
		iter.ReportError("decode EventSubscriptionSpecSubjectFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type EventSubscriptionSpecWebhookEndpointCodec struct {
}

func (EventSubscriptionSpecWebhookEndpointCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*EventSubscriptionSpecWebhookEndpoint)(ptr) == nil
}

func (EventSubscriptionSpecWebhookEndpointCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*EventSubscriptionSpecWebhookEndpoint)(ptr)
	var objs []EventSubscriptionSpecWebhookEndpoint
	if obj != nil {
		objs = []EventSubscriptionSpecWebhookEndpoint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecWebhookEndpoint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (EventSubscriptionSpecWebhookEndpointCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*EventSubscriptionSpecWebhookEndpoint)(ptr) = EventSubscriptionSpecWebhookEndpoint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []EventSubscriptionSpecWebhookEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(EventSubscriptionSpecWebhookEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*EventSubscriptionSpecWebhookEndpoint)(ptr) = objs[0]
			} else {
				*(*EventSubscriptionSpecWebhookEndpoint)(ptr) = EventSubscriptionSpecWebhookEndpoint{}
			}
		} else {
			*(*EventSubscriptionSpecWebhookEndpoint)(ptr) = EventSubscriptionSpecWebhookEndpoint{}
		}
	default:
		iter.ReportError("decode EventSubscriptionSpecWebhookEndpoint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SystemTopicEventSubscriptionSpecAdvancedFilterCodec struct {
}

func (SystemTopicEventSubscriptionSpecAdvancedFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SystemTopicEventSubscriptionSpecAdvancedFilter)(ptr) == nil
}

func (SystemTopicEventSubscriptionSpecAdvancedFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SystemTopicEventSubscriptionSpecAdvancedFilter)(ptr)
	var objs []SystemTopicEventSubscriptionSpecAdvancedFilter
	if obj != nil {
		objs = []SystemTopicEventSubscriptionSpecAdvancedFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecAdvancedFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SystemTopicEventSubscriptionSpecAdvancedFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SystemTopicEventSubscriptionSpecAdvancedFilter)(ptr) = SystemTopicEventSubscriptionSpecAdvancedFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SystemTopicEventSubscriptionSpecAdvancedFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecAdvancedFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SystemTopicEventSubscriptionSpecAdvancedFilter)(ptr) = objs[0]
			} else {
				*(*SystemTopicEventSubscriptionSpecAdvancedFilter)(ptr) = SystemTopicEventSubscriptionSpecAdvancedFilter{}
			}
		} else {
			*(*SystemTopicEventSubscriptionSpecAdvancedFilter)(ptr) = SystemTopicEventSubscriptionSpecAdvancedFilter{}
		}
	default:
		iter.ReportError("decode SystemTopicEventSubscriptionSpecAdvancedFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SystemTopicEventSubscriptionSpecAzureFunctionEndpointCodec struct {
}

func (SystemTopicEventSubscriptionSpecAzureFunctionEndpointCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SystemTopicEventSubscriptionSpecAzureFunctionEndpoint)(ptr) == nil
}

func (SystemTopicEventSubscriptionSpecAzureFunctionEndpointCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SystemTopicEventSubscriptionSpecAzureFunctionEndpoint)(ptr)
	var objs []SystemTopicEventSubscriptionSpecAzureFunctionEndpoint
	if obj != nil {
		objs = []SystemTopicEventSubscriptionSpecAzureFunctionEndpoint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecAzureFunctionEndpoint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SystemTopicEventSubscriptionSpecAzureFunctionEndpointCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SystemTopicEventSubscriptionSpecAzureFunctionEndpoint)(ptr) = SystemTopicEventSubscriptionSpecAzureFunctionEndpoint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SystemTopicEventSubscriptionSpecAzureFunctionEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecAzureFunctionEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SystemTopicEventSubscriptionSpecAzureFunctionEndpoint)(ptr) = objs[0]
			} else {
				*(*SystemTopicEventSubscriptionSpecAzureFunctionEndpoint)(ptr) = SystemTopicEventSubscriptionSpecAzureFunctionEndpoint{}
			}
		} else {
			*(*SystemTopicEventSubscriptionSpecAzureFunctionEndpoint)(ptr) = SystemTopicEventSubscriptionSpecAzureFunctionEndpoint{}
		}
	default:
		iter.ReportError("decode SystemTopicEventSubscriptionSpecAzureFunctionEndpoint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SystemTopicEventSubscriptionSpecRetryPolicyCodec struct {
}

func (SystemTopicEventSubscriptionSpecRetryPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SystemTopicEventSubscriptionSpecRetryPolicy)(ptr) == nil
}

func (SystemTopicEventSubscriptionSpecRetryPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SystemTopicEventSubscriptionSpecRetryPolicy)(ptr)
	var objs []SystemTopicEventSubscriptionSpecRetryPolicy
	if obj != nil {
		objs = []SystemTopicEventSubscriptionSpecRetryPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecRetryPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SystemTopicEventSubscriptionSpecRetryPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SystemTopicEventSubscriptionSpecRetryPolicy)(ptr) = SystemTopicEventSubscriptionSpecRetryPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SystemTopicEventSubscriptionSpecRetryPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecRetryPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SystemTopicEventSubscriptionSpecRetryPolicy)(ptr) = objs[0]
			} else {
				*(*SystemTopicEventSubscriptionSpecRetryPolicy)(ptr) = SystemTopicEventSubscriptionSpecRetryPolicy{}
			}
		} else {
			*(*SystemTopicEventSubscriptionSpecRetryPolicy)(ptr) = SystemTopicEventSubscriptionSpecRetryPolicy{}
		}
	default:
		iter.ReportError("decode SystemTopicEventSubscriptionSpecRetryPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestinationCodec struct {
}

func (SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestinationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) == nil
}

func (SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestinationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr)
	var objs []SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination
	if obj != nil {
		objs = []SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestinationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) = SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) = objs[0]
			} else {
				*(*SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) = SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination{}
			}
		} else {
			*(*SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination)(ptr) = SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination{}
		}
	default:
		iter.ReportError("decode SystemTopicEventSubscriptionSpecStorageBlobDeadLetterDestination", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SystemTopicEventSubscriptionSpecStorageQueueEndpointCodec struct {
}

func (SystemTopicEventSubscriptionSpecStorageQueueEndpointCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SystemTopicEventSubscriptionSpecStorageQueueEndpoint)(ptr) == nil
}

func (SystemTopicEventSubscriptionSpecStorageQueueEndpointCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SystemTopicEventSubscriptionSpecStorageQueueEndpoint)(ptr)
	var objs []SystemTopicEventSubscriptionSpecStorageQueueEndpoint
	if obj != nil {
		objs = []SystemTopicEventSubscriptionSpecStorageQueueEndpoint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecStorageQueueEndpoint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SystemTopicEventSubscriptionSpecStorageQueueEndpointCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SystemTopicEventSubscriptionSpecStorageQueueEndpoint)(ptr) = SystemTopicEventSubscriptionSpecStorageQueueEndpoint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SystemTopicEventSubscriptionSpecStorageQueueEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecStorageQueueEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SystemTopicEventSubscriptionSpecStorageQueueEndpoint)(ptr) = objs[0]
			} else {
				*(*SystemTopicEventSubscriptionSpecStorageQueueEndpoint)(ptr) = SystemTopicEventSubscriptionSpecStorageQueueEndpoint{}
			}
		} else {
			*(*SystemTopicEventSubscriptionSpecStorageQueueEndpoint)(ptr) = SystemTopicEventSubscriptionSpecStorageQueueEndpoint{}
		}
	default:
		iter.ReportError("decode SystemTopicEventSubscriptionSpecStorageQueueEndpoint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SystemTopicEventSubscriptionSpecSubjectFilterCodec struct {
}

func (SystemTopicEventSubscriptionSpecSubjectFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SystemTopicEventSubscriptionSpecSubjectFilter)(ptr) == nil
}

func (SystemTopicEventSubscriptionSpecSubjectFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SystemTopicEventSubscriptionSpecSubjectFilter)(ptr)
	var objs []SystemTopicEventSubscriptionSpecSubjectFilter
	if obj != nil {
		objs = []SystemTopicEventSubscriptionSpecSubjectFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecSubjectFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SystemTopicEventSubscriptionSpecSubjectFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SystemTopicEventSubscriptionSpecSubjectFilter)(ptr) = SystemTopicEventSubscriptionSpecSubjectFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SystemTopicEventSubscriptionSpecSubjectFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecSubjectFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SystemTopicEventSubscriptionSpecSubjectFilter)(ptr) = objs[0]
			} else {
				*(*SystemTopicEventSubscriptionSpecSubjectFilter)(ptr) = SystemTopicEventSubscriptionSpecSubjectFilter{}
			}
		} else {
			*(*SystemTopicEventSubscriptionSpecSubjectFilter)(ptr) = SystemTopicEventSubscriptionSpecSubjectFilter{}
		}
	default:
		iter.ReportError("decode SystemTopicEventSubscriptionSpecSubjectFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SystemTopicEventSubscriptionSpecWebhookEndpointCodec struct {
}

func (SystemTopicEventSubscriptionSpecWebhookEndpointCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SystemTopicEventSubscriptionSpecWebhookEndpoint)(ptr) == nil
}

func (SystemTopicEventSubscriptionSpecWebhookEndpointCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SystemTopicEventSubscriptionSpecWebhookEndpoint)(ptr)
	var objs []SystemTopicEventSubscriptionSpecWebhookEndpoint
	if obj != nil {
		objs = []SystemTopicEventSubscriptionSpecWebhookEndpoint{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecWebhookEndpoint{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SystemTopicEventSubscriptionSpecWebhookEndpointCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SystemTopicEventSubscriptionSpecWebhookEndpoint)(ptr) = SystemTopicEventSubscriptionSpecWebhookEndpoint{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SystemTopicEventSubscriptionSpecWebhookEndpoint

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SystemTopicEventSubscriptionSpecWebhookEndpoint{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SystemTopicEventSubscriptionSpecWebhookEndpoint)(ptr) = objs[0]
			} else {
				*(*SystemTopicEventSubscriptionSpecWebhookEndpoint)(ptr) = SystemTopicEventSubscriptionSpecWebhookEndpoint{}
			}
		} else {
			*(*SystemTopicEventSubscriptionSpecWebhookEndpoint)(ptr) = SystemTopicEventSubscriptionSpecWebhookEndpoint{}
		}
	default:
		iter.ReportError("decode SystemTopicEventSubscriptionSpecWebhookEndpoint", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicSpecInputMappingDefaultValuesCodec struct {
}

func (TopicSpecInputMappingDefaultValuesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicSpecInputMappingDefaultValues)(ptr) == nil
}

func (TopicSpecInputMappingDefaultValuesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicSpecInputMappingDefaultValues)(ptr)
	var objs []TopicSpecInputMappingDefaultValues
	if obj != nil {
		objs = []TopicSpecInputMappingDefaultValues{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecInputMappingDefaultValues{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicSpecInputMappingDefaultValuesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicSpecInputMappingDefaultValues)(ptr) = TopicSpecInputMappingDefaultValues{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicSpecInputMappingDefaultValues

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecInputMappingDefaultValues{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicSpecInputMappingDefaultValues)(ptr) = objs[0]
			} else {
				*(*TopicSpecInputMappingDefaultValues)(ptr) = TopicSpecInputMappingDefaultValues{}
			}
		} else {
			*(*TopicSpecInputMappingDefaultValues)(ptr) = TopicSpecInputMappingDefaultValues{}
		}
	default:
		iter.ReportError("decode TopicSpecInputMappingDefaultValues", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type TopicSpecInputMappingFieldsCodec struct {
}

func (TopicSpecInputMappingFieldsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*TopicSpecInputMappingFields)(ptr) == nil
}

func (TopicSpecInputMappingFieldsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*TopicSpecInputMappingFields)(ptr)
	var objs []TopicSpecInputMappingFields
	if obj != nil {
		objs = []TopicSpecInputMappingFields{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecInputMappingFields{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (TopicSpecInputMappingFieldsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*TopicSpecInputMappingFields)(ptr) = TopicSpecInputMappingFields{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []TopicSpecInputMappingFields

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(TopicSpecInputMappingFields{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*TopicSpecInputMappingFields)(ptr) = objs[0]
			} else {
				*(*TopicSpecInputMappingFields)(ptr) = TopicSpecInputMappingFields{}
			}
		} else {
			*(*TopicSpecInputMappingFields)(ptr) = TopicSpecInputMappingFields{}
		}
	default:
		iter.ReportError("decode TopicSpecInputMappingFields", "unexpected JSON type")
	}
}
