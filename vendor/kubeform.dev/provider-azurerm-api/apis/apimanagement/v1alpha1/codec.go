/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration{}).Type1()): ApiManagementSpecAdditionalLocationVirtualNetworkConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecHostnameConfiguration{}).Type1()):                         ApiManagementSpecHostnameConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecIdentity{}).Type1()):                                      ApiManagementSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecPolicy{}).Type1()):                                        ApiManagementSpecPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecProtocols{}).Type1()):                                     ApiManagementSpecProtocolsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSecurity{}).Type1()):                                      ApiManagementSpecSecurityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignIn{}).Type1()):                                        ApiManagementSpecSignInCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignUp{}).Type1()):                                        ApiManagementSpecSignUpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignUpTermsOfService{}).Type1()):                          ApiManagementSpecSignUpTermsOfServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecTenantAccess{}).Type1()):                                  ApiManagementSpecTenantAccessCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecVirtualNetworkConfiguration{}).Type1()):                   ApiManagementSpecVirtualNetworkConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecImport{}).Type1()):                                                  ApiSpecImportCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecImportWsdlSelector{}).Type1()):                                      ApiSpecImportWsdlSelectorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecOauth2Authorization{}).Type1()):                                     ApiSpecOauth2AuthorizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecOpenidAuthentication{}).Type1()):                                    ApiSpecOpenidAuthenticationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecSubscriptionKeyParameterNames{}).Type1()):                           ApiSpecSubscriptionKeyParameterNamesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendRequest{}).Type1()):                                ApiDiagnosticSpecBackendRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendResponse{}).Type1()):                               ApiDiagnosticSpecBackendResponseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendRequest{}).Type1()):                               ApiDiagnosticSpecFrontendRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendResponse{}).Type1()):                              ApiDiagnosticSpecFrontendResponseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiOperationSpecRequest{}).Type1()):                                        ApiOperationSpecRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecCredentials{}).Type1()):                                         BackendSpecCredentialsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecCredentialsAuthorization{}).Type1()):                            BackendSpecCredentialsAuthorizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecProxy{}).Type1()):                                               BackendSpecProxyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecServiceFabricCluster{}).Type1()):                                BackendSpecServiceFabricClusterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecTls{}).Type1()):                                                 BackendSpecTlsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendRequest{}).Type1()):                                   DiagnosticSpecBackendRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendResponse{}).Type1()):                                  DiagnosticSpecBackendResponseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendRequest{}).Type1()):                                  DiagnosticSpecFrontendRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendResponse{}).Type1()):                                 DiagnosticSpecFrontendResponseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LoggerSpecApplicationInsights{}).Type1()):                                  LoggerSpecApplicationInsightsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LoggerSpecEventhub{}).Type1()):                                             LoggerSpecEventhubCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration{}).Type1()): ApiManagementSpecAdditionalLocationVirtualNetworkConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecHostnameConfiguration{}).Type1()):                         ApiManagementSpecHostnameConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecIdentity{}).Type1()):                                      ApiManagementSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecPolicy{}).Type1()):                                        ApiManagementSpecPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecProtocols{}).Type1()):                                     ApiManagementSpecProtocolsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSecurity{}).Type1()):                                      ApiManagementSpecSecurityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignIn{}).Type1()):                                        ApiManagementSpecSignInCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignUp{}).Type1()):                                        ApiManagementSpecSignUpCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignUpTermsOfService{}).Type1()):                          ApiManagementSpecSignUpTermsOfServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecTenantAccess{}).Type1()):                                  ApiManagementSpecTenantAccessCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecVirtualNetworkConfiguration{}).Type1()):                   ApiManagementSpecVirtualNetworkConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecImport{}).Type1()):                                                  ApiSpecImportCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecImportWsdlSelector{}).Type1()):                                      ApiSpecImportWsdlSelectorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecOauth2Authorization{}).Type1()):                                     ApiSpecOauth2AuthorizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecOpenidAuthentication{}).Type1()):                                    ApiSpecOpenidAuthenticationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecSubscriptionKeyParameterNames{}).Type1()):                           ApiSpecSubscriptionKeyParameterNamesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendRequest{}).Type1()):                                ApiDiagnosticSpecBackendRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendResponse{}).Type1()):                               ApiDiagnosticSpecBackendResponseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendRequest{}).Type1()):                               ApiDiagnosticSpecFrontendRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendResponse{}).Type1()):                              ApiDiagnosticSpecFrontendResponseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ApiOperationSpecRequest{}).Type1()):                                        ApiOperationSpecRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecCredentials{}).Type1()):                                         BackendSpecCredentialsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecCredentialsAuthorization{}).Type1()):                            BackendSpecCredentialsAuthorizationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecProxy{}).Type1()):                                               BackendSpecProxyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecServiceFabricCluster{}).Type1()):                                BackendSpecServiceFabricClusterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecTls{}).Type1()):                                                 BackendSpecTlsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendRequest{}).Type1()):                                   DiagnosticSpecBackendRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendResponse{}).Type1()):                                  DiagnosticSpecBackendResponseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendRequest{}).Type1()):                                  DiagnosticSpecFrontendRequestCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendResponse{}).Type1()):                                 DiagnosticSpecFrontendResponseCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LoggerSpecApplicationInsights{}).Type1()):                                  LoggerSpecApplicationInsightsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LoggerSpecEventhub{}).Type1()):                                             LoggerSpecEventhubCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type ApiManagementSpecAdditionalLocationVirtualNetworkConfigurationCodec struct {
}

func (ApiManagementSpecAdditionalLocationVirtualNetworkConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration)(ptr) == nil
}

func (ApiManagementSpecAdditionalLocationVirtualNetworkConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration)(ptr)
	var objs []ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration
	if obj != nil {
		objs = []ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiManagementSpecAdditionalLocationVirtualNetworkConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration)(ptr) = ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration)(ptr) = objs[0]
			} else {
				*(*ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration)(ptr) = ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration{}
			}
		} else {
			*(*ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration)(ptr) = ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration{}
		}
	default:
		iter.ReportError("decode ApiManagementSpecAdditionalLocationVirtualNetworkConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiManagementSpecHostnameConfigurationCodec struct {
}

func (ApiManagementSpecHostnameConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiManagementSpecHostnameConfiguration)(ptr) == nil
}

func (ApiManagementSpecHostnameConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiManagementSpecHostnameConfiguration)(ptr)
	var objs []ApiManagementSpecHostnameConfiguration
	if obj != nil {
		objs = []ApiManagementSpecHostnameConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecHostnameConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiManagementSpecHostnameConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiManagementSpecHostnameConfiguration)(ptr) = ApiManagementSpecHostnameConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiManagementSpecHostnameConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecHostnameConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiManagementSpecHostnameConfiguration)(ptr) = objs[0]
			} else {
				*(*ApiManagementSpecHostnameConfiguration)(ptr) = ApiManagementSpecHostnameConfiguration{}
			}
		} else {
			*(*ApiManagementSpecHostnameConfiguration)(ptr) = ApiManagementSpecHostnameConfiguration{}
		}
	default:
		iter.ReportError("decode ApiManagementSpecHostnameConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiManagementSpecIdentityCodec struct {
}

func (ApiManagementSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiManagementSpecIdentity)(ptr) == nil
}

func (ApiManagementSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiManagementSpecIdentity)(ptr)
	var objs []ApiManagementSpecIdentity
	if obj != nil {
		objs = []ApiManagementSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiManagementSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiManagementSpecIdentity)(ptr) = ApiManagementSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiManagementSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiManagementSpecIdentity)(ptr) = objs[0]
			} else {
				*(*ApiManagementSpecIdentity)(ptr) = ApiManagementSpecIdentity{}
			}
		} else {
			*(*ApiManagementSpecIdentity)(ptr) = ApiManagementSpecIdentity{}
		}
	default:
		iter.ReportError("decode ApiManagementSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiManagementSpecPolicyCodec struct {
}

func (ApiManagementSpecPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiManagementSpecPolicy)(ptr) == nil
}

func (ApiManagementSpecPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiManagementSpecPolicy)(ptr)
	var objs []ApiManagementSpecPolicy
	if obj != nil {
		objs = []ApiManagementSpecPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiManagementSpecPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiManagementSpecPolicy)(ptr) = ApiManagementSpecPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiManagementSpecPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiManagementSpecPolicy)(ptr) = objs[0]
			} else {
				*(*ApiManagementSpecPolicy)(ptr) = ApiManagementSpecPolicy{}
			}
		} else {
			*(*ApiManagementSpecPolicy)(ptr) = ApiManagementSpecPolicy{}
		}
	default:
		iter.ReportError("decode ApiManagementSpecPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiManagementSpecProtocolsCodec struct {
}

func (ApiManagementSpecProtocolsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiManagementSpecProtocols)(ptr) == nil
}

func (ApiManagementSpecProtocolsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiManagementSpecProtocols)(ptr)
	var objs []ApiManagementSpecProtocols
	if obj != nil {
		objs = []ApiManagementSpecProtocols{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecProtocols{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiManagementSpecProtocolsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiManagementSpecProtocols)(ptr) = ApiManagementSpecProtocols{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiManagementSpecProtocols

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecProtocols{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiManagementSpecProtocols)(ptr) = objs[0]
			} else {
				*(*ApiManagementSpecProtocols)(ptr) = ApiManagementSpecProtocols{}
			}
		} else {
			*(*ApiManagementSpecProtocols)(ptr) = ApiManagementSpecProtocols{}
		}
	default:
		iter.ReportError("decode ApiManagementSpecProtocols", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiManagementSpecSecurityCodec struct {
}

func (ApiManagementSpecSecurityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiManagementSpecSecurity)(ptr) == nil
}

func (ApiManagementSpecSecurityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiManagementSpecSecurity)(ptr)
	var objs []ApiManagementSpecSecurity
	if obj != nil {
		objs = []ApiManagementSpecSecurity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSecurity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiManagementSpecSecurityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiManagementSpecSecurity)(ptr) = ApiManagementSpecSecurity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiManagementSpecSecurity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSecurity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiManagementSpecSecurity)(ptr) = objs[0]
			} else {
				*(*ApiManagementSpecSecurity)(ptr) = ApiManagementSpecSecurity{}
			}
		} else {
			*(*ApiManagementSpecSecurity)(ptr) = ApiManagementSpecSecurity{}
		}
	default:
		iter.ReportError("decode ApiManagementSpecSecurity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiManagementSpecSignInCodec struct {
}

func (ApiManagementSpecSignInCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiManagementSpecSignIn)(ptr) == nil
}

func (ApiManagementSpecSignInCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiManagementSpecSignIn)(ptr)
	var objs []ApiManagementSpecSignIn
	if obj != nil {
		objs = []ApiManagementSpecSignIn{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignIn{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiManagementSpecSignInCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiManagementSpecSignIn)(ptr) = ApiManagementSpecSignIn{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiManagementSpecSignIn

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignIn{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiManagementSpecSignIn)(ptr) = objs[0]
			} else {
				*(*ApiManagementSpecSignIn)(ptr) = ApiManagementSpecSignIn{}
			}
		} else {
			*(*ApiManagementSpecSignIn)(ptr) = ApiManagementSpecSignIn{}
		}
	default:
		iter.ReportError("decode ApiManagementSpecSignIn", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiManagementSpecSignUpCodec struct {
}

func (ApiManagementSpecSignUpCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiManagementSpecSignUp)(ptr) == nil
}

func (ApiManagementSpecSignUpCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiManagementSpecSignUp)(ptr)
	var objs []ApiManagementSpecSignUp
	if obj != nil {
		objs = []ApiManagementSpecSignUp{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignUp{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiManagementSpecSignUpCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiManagementSpecSignUp)(ptr) = ApiManagementSpecSignUp{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiManagementSpecSignUp

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignUp{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiManagementSpecSignUp)(ptr) = objs[0]
			} else {
				*(*ApiManagementSpecSignUp)(ptr) = ApiManagementSpecSignUp{}
			}
		} else {
			*(*ApiManagementSpecSignUp)(ptr) = ApiManagementSpecSignUp{}
		}
	default:
		iter.ReportError("decode ApiManagementSpecSignUp", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiManagementSpecSignUpTermsOfServiceCodec struct {
}

func (ApiManagementSpecSignUpTermsOfServiceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiManagementSpecSignUpTermsOfService)(ptr) == nil
}

func (ApiManagementSpecSignUpTermsOfServiceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiManagementSpecSignUpTermsOfService)(ptr)
	var objs []ApiManagementSpecSignUpTermsOfService
	if obj != nil {
		objs = []ApiManagementSpecSignUpTermsOfService{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignUpTermsOfService{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiManagementSpecSignUpTermsOfServiceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiManagementSpecSignUpTermsOfService)(ptr) = ApiManagementSpecSignUpTermsOfService{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiManagementSpecSignUpTermsOfService

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecSignUpTermsOfService{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiManagementSpecSignUpTermsOfService)(ptr) = objs[0]
			} else {
				*(*ApiManagementSpecSignUpTermsOfService)(ptr) = ApiManagementSpecSignUpTermsOfService{}
			}
		} else {
			*(*ApiManagementSpecSignUpTermsOfService)(ptr) = ApiManagementSpecSignUpTermsOfService{}
		}
	default:
		iter.ReportError("decode ApiManagementSpecSignUpTermsOfService", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiManagementSpecTenantAccessCodec struct {
}

func (ApiManagementSpecTenantAccessCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiManagementSpecTenantAccess)(ptr) == nil
}

func (ApiManagementSpecTenantAccessCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiManagementSpecTenantAccess)(ptr)
	var objs []ApiManagementSpecTenantAccess
	if obj != nil {
		objs = []ApiManagementSpecTenantAccess{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecTenantAccess{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiManagementSpecTenantAccessCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiManagementSpecTenantAccess)(ptr) = ApiManagementSpecTenantAccess{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiManagementSpecTenantAccess

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecTenantAccess{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiManagementSpecTenantAccess)(ptr) = objs[0]
			} else {
				*(*ApiManagementSpecTenantAccess)(ptr) = ApiManagementSpecTenantAccess{}
			}
		} else {
			*(*ApiManagementSpecTenantAccess)(ptr) = ApiManagementSpecTenantAccess{}
		}
	default:
		iter.ReportError("decode ApiManagementSpecTenantAccess", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiManagementSpecVirtualNetworkConfigurationCodec struct {
}

func (ApiManagementSpecVirtualNetworkConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiManagementSpecVirtualNetworkConfiguration)(ptr) == nil
}

func (ApiManagementSpecVirtualNetworkConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiManagementSpecVirtualNetworkConfiguration)(ptr)
	var objs []ApiManagementSpecVirtualNetworkConfiguration
	if obj != nil {
		objs = []ApiManagementSpecVirtualNetworkConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecVirtualNetworkConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiManagementSpecVirtualNetworkConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiManagementSpecVirtualNetworkConfiguration)(ptr) = ApiManagementSpecVirtualNetworkConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiManagementSpecVirtualNetworkConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiManagementSpecVirtualNetworkConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiManagementSpecVirtualNetworkConfiguration)(ptr) = objs[0]
			} else {
				*(*ApiManagementSpecVirtualNetworkConfiguration)(ptr) = ApiManagementSpecVirtualNetworkConfiguration{}
			}
		} else {
			*(*ApiManagementSpecVirtualNetworkConfiguration)(ptr) = ApiManagementSpecVirtualNetworkConfiguration{}
		}
	default:
		iter.ReportError("decode ApiManagementSpecVirtualNetworkConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiSpecImportCodec struct {
}

func (ApiSpecImportCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiSpecImport)(ptr) == nil
}

func (ApiSpecImportCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiSpecImport)(ptr)
	var objs []ApiSpecImport
	if obj != nil {
		objs = []ApiSpecImport{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecImport{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiSpecImportCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiSpecImport)(ptr) = ApiSpecImport{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiSpecImport

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecImport{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiSpecImport)(ptr) = objs[0]
			} else {
				*(*ApiSpecImport)(ptr) = ApiSpecImport{}
			}
		} else {
			*(*ApiSpecImport)(ptr) = ApiSpecImport{}
		}
	default:
		iter.ReportError("decode ApiSpecImport", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiSpecImportWsdlSelectorCodec struct {
}

func (ApiSpecImportWsdlSelectorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiSpecImportWsdlSelector)(ptr) == nil
}

func (ApiSpecImportWsdlSelectorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiSpecImportWsdlSelector)(ptr)
	var objs []ApiSpecImportWsdlSelector
	if obj != nil {
		objs = []ApiSpecImportWsdlSelector{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecImportWsdlSelector{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiSpecImportWsdlSelectorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiSpecImportWsdlSelector)(ptr) = ApiSpecImportWsdlSelector{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiSpecImportWsdlSelector

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecImportWsdlSelector{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiSpecImportWsdlSelector)(ptr) = objs[0]
			} else {
				*(*ApiSpecImportWsdlSelector)(ptr) = ApiSpecImportWsdlSelector{}
			}
		} else {
			*(*ApiSpecImportWsdlSelector)(ptr) = ApiSpecImportWsdlSelector{}
		}
	default:
		iter.ReportError("decode ApiSpecImportWsdlSelector", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiSpecOauth2AuthorizationCodec struct {
}

func (ApiSpecOauth2AuthorizationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiSpecOauth2Authorization)(ptr) == nil
}

func (ApiSpecOauth2AuthorizationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiSpecOauth2Authorization)(ptr)
	var objs []ApiSpecOauth2Authorization
	if obj != nil {
		objs = []ApiSpecOauth2Authorization{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecOauth2Authorization{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiSpecOauth2AuthorizationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiSpecOauth2Authorization)(ptr) = ApiSpecOauth2Authorization{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiSpecOauth2Authorization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecOauth2Authorization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiSpecOauth2Authorization)(ptr) = objs[0]
			} else {
				*(*ApiSpecOauth2Authorization)(ptr) = ApiSpecOauth2Authorization{}
			}
		} else {
			*(*ApiSpecOauth2Authorization)(ptr) = ApiSpecOauth2Authorization{}
		}
	default:
		iter.ReportError("decode ApiSpecOauth2Authorization", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiSpecOpenidAuthenticationCodec struct {
}

func (ApiSpecOpenidAuthenticationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiSpecOpenidAuthentication)(ptr) == nil
}

func (ApiSpecOpenidAuthenticationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiSpecOpenidAuthentication)(ptr)
	var objs []ApiSpecOpenidAuthentication
	if obj != nil {
		objs = []ApiSpecOpenidAuthentication{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecOpenidAuthentication{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiSpecOpenidAuthenticationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiSpecOpenidAuthentication)(ptr) = ApiSpecOpenidAuthentication{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiSpecOpenidAuthentication

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecOpenidAuthentication{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiSpecOpenidAuthentication)(ptr) = objs[0]
			} else {
				*(*ApiSpecOpenidAuthentication)(ptr) = ApiSpecOpenidAuthentication{}
			}
		} else {
			*(*ApiSpecOpenidAuthentication)(ptr) = ApiSpecOpenidAuthentication{}
		}
	default:
		iter.ReportError("decode ApiSpecOpenidAuthentication", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiSpecSubscriptionKeyParameterNamesCodec struct {
}

func (ApiSpecSubscriptionKeyParameterNamesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiSpecSubscriptionKeyParameterNames)(ptr) == nil
}

func (ApiSpecSubscriptionKeyParameterNamesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiSpecSubscriptionKeyParameterNames)(ptr)
	var objs []ApiSpecSubscriptionKeyParameterNames
	if obj != nil {
		objs = []ApiSpecSubscriptionKeyParameterNames{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecSubscriptionKeyParameterNames{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiSpecSubscriptionKeyParameterNamesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiSpecSubscriptionKeyParameterNames)(ptr) = ApiSpecSubscriptionKeyParameterNames{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiSpecSubscriptionKeyParameterNames

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiSpecSubscriptionKeyParameterNames{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiSpecSubscriptionKeyParameterNames)(ptr) = objs[0]
			} else {
				*(*ApiSpecSubscriptionKeyParameterNames)(ptr) = ApiSpecSubscriptionKeyParameterNames{}
			}
		} else {
			*(*ApiSpecSubscriptionKeyParameterNames)(ptr) = ApiSpecSubscriptionKeyParameterNames{}
		}
	default:
		iter.ReportError("decode ApiSpecSubscriptionKeyParameterNames", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiDiagnosticSpecBackendRequestCodec struct {
}

func (ApiDiagnosticSpecBackendRequestCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiDiagnosticSpecBackendRequest)(ptr) == nil
}

func (ApiDiagnosticSpecBackendRequestCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiDiagnosticSpecBackendRequest)(ptr)
	var objs []ApiDiagnosticSpecBackendRequest
	if obj != nil {
		objs = []ApiDiagnosticSpecBackendRequest{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendRequest{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiDiagnosticSpecBackendRequestCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiDiagnosticSpecBackendRequest)(ptr) = ApiDiagnosticSpecBackendRequest{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiDiagnosticSpecBackendRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiDiagnosticSpecBackendRequest)(ptr) = objs[0]
			} else {
				*(*ApiDiagnosticSpecBackendRequest)(ptr) = ApiDiagnosticSpecBackendRequest{}
			}
		} else {
			*(*ApiDiagnosticSpecBackendRequest)(ptr) = ApiDiagnosticSpecBackendRequest{}
		}
	default:
		iter.ReportError("decode ApiDiagnosticSpecBackendRequest", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiDiagnosticSpecBackendResponseCodec struct {
}

func (ApiDiagnosticSpecBackendResponseCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiDiagnosticSpecBackendResponse)(ptr) == nil
}

func (ApiDiagnosticSpecBackendResponseCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiDiagnosticSpecBackendResponse)(ptr)
	var objs []ApiDiagnosticSpecBackendResponse
	if obj != nil {
		objs = []ApiDiagnosticSpecBackendResponse{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendResponse{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiDiagnosticSpecBackendResponseCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiDiagnosticSpecBackendResponse)(ptr) = ApiDiagnosticSpecBackendResponse{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiDiagnosticSpecBackendResponse

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecBackendResponse{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiDiagnosticSpecBackendResponse)(ptr) = objs[0]
			} else {
				*(*ApiDiagnosticSpecBackendResponse)(ptr) = ApiDiagnosticSpecBackendResponse{}
			}
		} else {
			*(*ApiDiagnosticSpecBackendResponse)(ptr) = ApiDiagnosticSpecBackendResponse{}
		}
	default:
		iter.ReportError("decode ApiDiagnosticSpecBackendResponse", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiDiagnosticSpecFrontendRequestCodec struct {
}

func (ApiDiagnosticSpecFrontendRequestCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiDiagnosticSpecFrontendRequest)(ptr) == nil
}

func (ApiDiagnosticSpecFrontendRequestCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiDiagnosticSpecFrontendRequest)(ptr)
	var objs []ApiDiagnosticSpecFrontendRequest
	if obj != nil {
		objs = []ApiDiagnosticSpecFrontendRequest{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendRequest{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiDiagnosticSpecFrontendRequestCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiDiagnosticSpecFrontendRequest)(ptr) = ApiDiagnosticSpecFrontendRequest{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiDiagnosticSpecFrontendRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiDiagnosticSpecFrontendRequest)(ptr) = objs[0]
			} else {
				*(*ApiDiagnosticSpecFrontendRequest)(ptr) = ApiDiagnosticSpecFrontendRequest{}
			}
		} else {
			*(*ApiDiagnosticSpecFrontendRequest)(ptr) = ApiDiagnosticSpecFrontendRequest{}
		}
	default:
		iter.ReportError("decode ApiDiagnosticSpecFrontendRequest", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiDiagnosticSpecFrontendResponseCodec struct {
}

func (ApiDiagnosticSpecFrontendResponseCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiDiagnosticSpecFrontendResponse)(ptr) == nil
}

func (ApiDiagnosticSpecFrontendResponseCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiDiagnosticSpecFrontendResponse)(ptr)
	var objs []ApiDiagnosticSpecFrontendResponse
	if obj != nil {
		objs = []ApiDiagnosticSpecFrontendResponse{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendResponse{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiDiagnosticSpecFrontendResponseCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiDiagnosticSpecFrontendResponse)(ptr) = ApiDiagnosticSpecFrontendResponse{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiDiagnosticSpecFrontendResponse

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiDiagnosticSpecFrontendResponse{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiDiagnosticSpecFrontendResponse)(ptr) = objs[0]
			} else {
				*(*ApiDiagnosticSpecFrontendResponse)(ptr) = ApiDiagnosticSpecFrontendResponse{}
			}
		} else {
			*(*ApiDiagnosticSpecFrontendResponse)(ptr) = ApiDiagnosticSpecFrontendResponse{}
		}
	default:
		iter.ReportError("decode ApiDiagnosticSpecFrontendResponse", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ApiOperationSpecRequestCodec struct {
}

func (ApiOperationSpecRequestCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ApiOperationSpecRequest)(ptr) == nil
}

func (ApiOperationSpecRequestCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ApiOperationSpecRequest)(ptr)
	var objs []ApiOperationSpecRequest
	if obj != nil {
		objs = []ApiOperationSpecRequest{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiOperationSpecRequest{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ApiOperationSpecRequestCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ApiOperationSpecRequest)(ptr) = ApiOperationSpecRequest{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ApiOperationSpecRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ApiOperationSpecRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ApiOperationSpecRequest)(ptr) = objs[0]
			} else {
				*(*ApiOperationSpecRequest)(ptr) = ApiOperationSpecRequest{}
			}
		} else {
			*(*ApiOperationSpecRequest)(ptr) = ApiOperationSpecRequest{}
		}
	default:
		iter.ReportError("decode ApiOperationSpecRequest", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendSpecCredentialsCodec struct {
}

func (BackendSpecCredentialsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendSpecCredentials)(ptr) == nil
}

func (BackendSpecCredentialsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendSpecCredentials)(ptr)
	var objs []BackendSpecCredentials
	if obj != nil {
		objs = []BackendSpecCredentials{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecCredentials{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendSpecCredentialsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendSpecCredentials)(ptr) = BackendSpecCredentials{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendSpecCredentials

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecCredentials{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendSpecCredentials)(ptr) = objs[0]
			} else {
				*(*BackendSpecCredentials)(ptr) = BackendSpecCredentials{}
			}
		} else {
			*(*BackendSpecCredentials)(ptr) = BackendSpecCredentials{}
		}
	default:
		iter.ReportError("decode BackendSpecCredentials", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendSpecCredentialsAuthorizationCodec struct {
}

func (BackendSpecCredentialsAuthorizationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendSpecCredentialsAuthorization)(ptr) == nil
}

func (BackendSpecCredentialsAuthorizationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendSpecCredentialsAuthorization)(ptr)
	var objs []BackendSpecCredentialsAuthorization
	if obj != nil {
		objs = []BackendSpecCredentialsAuthorization{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecCredentialsAuthorization{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendSpecCredentialsAuthorizationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendSpecCredentialsAuthorization)(ptr) = BackendSpecCredentialsAuthorization{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendSpecCredentialsAuthorization

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecCredentialsAuthorization{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendSpecCredentialsAuthorization)(ptr) = objs[0]
			} else {
				*(*BackendSpecCredentialsAuthorization)(ptr) = BackendSpecCredentialsAuthorization{}
			}
		} else {
			*(*BackendSpecCredentialsAuthorization)(ptr) = BackendSpecCredentialsAuthorization{}
		}
	default:
		iter.ReportError("decode BackendSpecCredentialsAuthorization", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendSpecProxyCodec struct {
}

func (BackendSpecProxyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendSpecProxy)(ptr) == nil
}

func (BackendSpecProxyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendSpecProxy)(ptr)
	var objs []BackendSpecProxy
	if obj != nil {
		objs = []BackendSpecProxy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecProxy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendSpecProxyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendSpecProxy)(ptr) = BackendSpecProxy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendSpecProxy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecProxy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendSpecProxy)(ptr) = objs[0]
			} else {
				*(*BackendSpecProxy)(ptr) = BackendSpecProxy{}
			}
		} else {
			*(*BackendSpecProxy)(ptr) = BackendSpecProxy{}
		}
	default:
		iter.ReportError("decode BackendSpecProxy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendSpecServiceFabricClusterCodec struct {
}

func (BackendSpecServiceFabricClusterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendSpecServiceFabricCluster)(ptr) == nil
}

func (BackendSpecServiceFabricClusterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendSpecServiceFabricCluster)(ptr)
	var objs []BackendSpecServiceFabricCluster
	if obj != nil {
		objs = []BackendSpecServiceFabricCluster{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecServiceFabricCluster{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendSpecServiceFabricClusterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendSpecServiceFabricCluster)(ptr) = BackendSpecServiceFabricCluster{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendSpecServiceFabricCluster

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecServiceFabricCluster{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendSpecServiceFabricCluster)(ptr) = objs[0]
			} else {
				*(*BackendSpecServiceFabricCluster)(ptr) = BackendSpecServiceFabricCluster{}
			}
		} else {
			*(*BackendSpecServiceFabricCluster)(ptr) = BackendSpecServiceFabricCluster{}
		}
	default:
		iter.ReportError("decode BackendSpecServiceFabricCluster", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BackendSpecTlsCodec struct {
}

func (BackendSpecTlsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BackendSpecTls)(ptr) == nil
}

func (BackendSpecTlsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BackendSpecTls)(ptr)
	var objs []BackendSpecTls
	if obj != nil {
		objs = []BackendSpecTls{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecTls{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BackendSpecTlsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BackendSpecTls)(ptr) = BackendSpecTls{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BackendSpecTls

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BackendSpecTls{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BackendSpecTls)(ptr) = objs[0]
			} else {
				*(*BackendSpecTls)(ptr) = BackendSpecTls{}
			}
		} else {
			*(*BackendSpecTls)(ptr) = BackendSpecTls{}
		}
	default:
		iter.ReportError("decode BackendSpecTls", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiagnosticSpecBackendRequestCodec struct {
}

func (DiagnosticSpecBackendRequestCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiagnosticSpecBackendRequest)(ptr) == nil
}

func (DiagnosticSpecBackendRequestCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiagnosticSpecBackendRequest)(ptr)
	var objs []DiagnosticSpecBackendRequest
	if obj != nil {
		objs = []DiagnosticSpecBackendRequest{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendRequest{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiagnosticSpecBackendRequestCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiagnosticSpecBackendRequest)(ptr) = DiagnosticSpecBackendRequest{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiagnosticSpecBackendRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiagnosticSpecBackendRequest)(ptr) = objs[0]
			} else {
				*(*DiagnosticSpecBackendRequest)(ptr) = DiagnosticSpecBackendRequest{}
			}
		} else {
			*(*DiagnosticSpecBackendRequest)(ptr) = DiagnosticSpecBackendRequest{}
		}
	default:
		iter.ReportError("decode DiagnosticSpecBackendRequest", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiagnosticSpecBackendResponseCodec struct {
}

func (DiagnosticSpecBackendResponseCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiagnosticSpecBackendResponse)(ptr) == nil
}

func (DiagnosticSpecBackendResponseCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiagnosticSpecBackendResponse)(ptr)
	var objs []DiagnosticSpecBackendResponse
	if obj != nil {
		objs = []DiagnosticSpecBackendResponse{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendResponse{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiagnosticSpecBackendResponseCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiagnosticSpecBackendResponse)(ptr) = DiagnosticSpecBackendResponse{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiagnosticSpecBackendResponse

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecBackendResponse{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiagnosticSpecBackendResponse)(ptr) = objs[0]
			} else {
				*(*DiagnosticSpecBackendResponse)(ptr) = DiagnosticSpecBackendResponse{}
			}
		} else {
			*(*DiagnosticSpecBackendResponse)(ptr) = DiagnosticSpecBackendResponse{}
		}
	default:
		iter.ReportError("decode DiagnosticSpecBackendResponse", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiagnosticSpecFrontendRequestCodec struct {
}

func (DiagnosticSpecFrontendRequestCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiagnosticSpecFrontendRequest)(ptr) == nil
}

func (DiagnosticSpecFrontendRequestCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiagnosticSpecFrontendRequest)(ptr)
	var objs []DiagnosticSpecFrontendRequest
	if obj != nil {
		objs = []DiagnosticSpecFrontendRequest{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendRequest{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiagnosticSpecFrontendRequestCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiagnosticSpecFrontendRequest)(ptr) = DiagnosticSpecFrontendRequest{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiagnosticSpecFrontendRequest

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendRequest{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiagnosticSpecFrontendRequest)(ptr) = objs[0]
			} else {
				*(*DiagnosticSpecFrontendRequest)(ptr) = DiagnosticSpecFrontendRequest{}
			}
		} else {
			*(*DiagnosticSpecFrontendRequest)(ptr) = DiagnosticSpecFrontendRequest{}
		}
	default:
		iter.ReportError("decode DiagnosticSpecFrontendRequest", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiagnosticSpecFrontendResponseCodec struct {
}

func (DiagnosticSpecFrontendResponseCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiagnosticSpecFrontendResponse)(ptr) == nil
}

func (DiagnosticSpecFrontendResponseCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiagnosticSpecFrontendResponse)(ptr)
	var objs []DiagnosticSpecFrontendResponse
	if obj != nil {
		objs = []DiagnosticSpecFrontendResponse{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendResponse{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiagnosticSpecFrontendResponseCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiagnosticSpecFrontendResponse)(ptr) = DiagnosticSpecFrontendResponse{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiagnosticSpecFrontendResponse

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSpecFrontendResponse{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiagnosticSpecFrontendResponse)(ptr) = objs[0]
			} else {
				*(*DiagnosticSpecFrontendResponse)(ptr) = DiagnosticSpecFrontendResponse{}
			}
		} else {
			*(*DiagnosticSpecFrontendResponse)(ptr) = DiagnosticSpecFrontendResponse{}
		}
	default:
		iter.ReportError("decode DiagnosticSpecFrontendResponse", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LoggerSpecApplicationInsightsCodec struct {
}

func (LoggerSpecApplicationInsightsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LoggerSpecApplicationInsights)(ptr) == nil
}

func (LoggerSpecApplicationInsightsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LoggerSpecApplicationInsights)(ptr)
	var objs []LoggerSpecApplicationInsights
	if obj != nil {
		objs = []LoggerSpecApplicationInsights{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoggerSpecApplicationInsights{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LoggerSpecApplicationInsightsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LoggerSpecApplicationInsights)(ptr) = LoggerSpecApplicationInsights{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LoggerSpecApplicationInsights

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoggerSpecApplicationInsights{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LoggerSpecApplicationInsights)(ptr) = objs[0]
			} else {
				*(*LoggerSpecApplicationInsights)(ptr) = LoggerSpecApplicationInsights{}
			}
		} else {
			*(*LoggerSpecApplicationInsights)(ptr) = LoggerSpecApplicationInsights{}
		}
	default:
		iter.ReportError("decode LoggerSpecApplicationInsights", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LoggerSpecEventhubCodec struct {
}

func (LoggerSpecEventhubCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LoggerSpecEventhub)(ptr) == nil
}

func (LoggerSpecEventhubCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LoggerSpecEventhub)(ptr)
	var objs []LoggerSpecEventhub
	if obj != nil {
		objs = []LoggerSpecEventhub{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoggerSpecEventhub{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LoggerSpecEventhubCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LoggerSpecEventhub)(ptr) = LoggerSpecEventhub{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LoggerSpecEventhub

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LoggerSpecEventhub{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LoggerSpecEventhub)(ptr) = objs[0]
			} else {
				*(*LoggerSpecEventhub)(ptr) = LoggerSpecEventhub{}
			}
		} else {
			*(*LoggerSpecEventhub)(ptr) = LoggerSpecEventhub{}
		}
	default:
		iter.ReportError("decode LoggerSpecEventhub", "unexpected JSON type")
	}
}
