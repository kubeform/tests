/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecComponentVersion{}).Type1()):                             HadoopClusterSpecComponentVersionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecGateway{}).Type1()):                                      HadoopClusterSpecGatewayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecMetastores{}).Type1()):                                   HadoopClusterSpecMetastoresCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecMetastoresAmbari{}).Type1()):                             HadoopClusterSpecMetastoresAmbariCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecMetastoresHive{}).Type1()):                               HadoopClusterSpecMetastoresHiveCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecMetastoresOozie{}).Type1()):                              HadoopClusterSpecMetastoresOozieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecMonitor{}).Type1()):                                      HadoopClusterSpecMonitorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecNetwork{}).Type1()):                                      HadoopClusterSpecNetworkCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRoles{}).Type1()):                                        HadoopClusterSpecRolesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesEdgeNode{}).Type1()):                                HadoopClusterSpecRolesEdgeNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesHeadNode{}).Type1()):                                HadoopClusterSpecRolesHeadNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesWorkerNode{}).Type1()):                              HadoopClusterSpecRolesWorkerNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesWorkerNodeAutoscale{}).Type1()):                     HadoopClusterSpecRolesWorkerNodeAutoscaleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesWorkerNodeAutoscaleCapacity{}).Type1()):             HadoopClusterSpecRolesWorkerNodeAutoscaleCapacityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesWorkerNodeAutoscaleRecurrence{}).Type1()):           HadoopClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesZookeeperNode{}).Type1()):                           HadoopClusterSpecRolesZookeeperNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecStorageAccountGen2{}).Type1()):                           HadoopClusterSpecStorageAccountGen2Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecComponentVersion{}).Type1()):                              HbaseClusterSpecComponentVersionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecGateway{}).Type1()):                                       HbaseClusterSpecGatewayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecMetastores{}).Type1()):                                    HbaseClusterSpecMetastoresCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecMetastoresAmbari{}).Type1()):                              HbaseClusterSpecMetastoresAmbariCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecMetastoresHive{}).Type1()):                                HbaseClusterSpecMetastoresHiveCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecMetastoresOozie{}).Type1()):                               HbaseClusterSpecMetastoresOozieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecMonitor{}).Type1()):                                       HbaseClusterSpecMonitorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRoles{}).Type1()):                                         HbaseClusterSpecRolesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRolesHeadNode{}).Type1()):                                 HbaseClusterSpecRolesHeadNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRolesWorkerNode{}).Type1()):                               HbaseClusterSpecRolesWorkerNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRolesWorkerNodeAutoscale{}).Type1()):                      HbaseClusterSpecRolesWorkerNodeAutoscaleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRolesWorkerNodeAutoscaleRecurrence{}).Type1()):            HbaseClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRolesZookeeperNode{}).Type1()):                            HbaseClusterSpecRolesZookeeperNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecStorageAccountGen2{}).Type1()):                            HbaseClusterSpecStorageAccountGen2Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecComponentVersion{}).Type1()):                   InteractiveQueryClusterSpecComponentVersionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecGateway{}).Type1()):                            InteractiveQueryClusterSpecGatewayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecMetastores{}).Type1()):                         InteractiveQueryClusterSpecMetastoresCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecMetastoresAmbari{}).Type1()):                   InteractiveQueryClusterSpecMetastoresAmbariCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecMetastoresHive{}).Type1()):                     InteractiveQueryClusterSpecMetastoresHiveCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecMetastoresOozie{}).Type1()):                    InteractiveQueryClusterSpecMetastoresOozieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecMonitor{}).Type1()):                            InteractiveQueryClusterSpecMonitorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecNetwork{}).Type1()):                            InteractiveQueryClusterSpecNetworkCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRoles{}).Type1()):                              InteractiveQueryClusterSpecRolesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesHeadNode{}).Type1()):                      InteractiveQueryClusterSpecRolesHeadNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesWorkerNode{}).Type1()):                    InteractiveQueryClusterSpecRolesWorkerNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesWorkerNodeAutoscale{}).Type1()):           InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCapacity{}).Type1()):   InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCapacityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleRecurrence{}).Type1()): InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesZookeeperNode{}).Type1()):                 InteractiveQueryClusterSpecRolesZookeeperNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecStorageAccountGen2{}).Type1()):                 InteractiveQueryClusterSpecStorageAccountGen2Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecComponentVersion{}).Type1()):                              KafkaClusterSpecComponentVersionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecGateway{}).Type1()):                                       KafkaClusterSpecGatewayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecMetastores{}).Type1()):                                    KafkaClusterSpecMetastoresCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecMetastoresAmbari{}).Type1()):                              KafkaClusterSpecMetastoresAmbariCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecMetastoresHive{}).Type1()):                                KafkaClusterSpecMetastoresHiveCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecMetastoresOozie{}).Type1()):                               KafkaClusterSpecMetastoresOozieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecMonitor{}).Type1()):                                       KafkaClusterSpecMonitorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRestProxy{}).Type1()):                                     KafkaClusterSpecRestProxyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRoles{}).Type1()):                                         KafkaClusterSpecRolesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRolesHeadNode{}).Type1()):                                 KafkaClusterSpecRolesHeadNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRolesKafkaManagementNode{}).Type1()):                      KafkaClusterSpecRolesKafkaManagementNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRolesWorkerNode{}).Type1()):                               KafkaClusterSpecRolesWorkerNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRolesZookeeperNode{}).Type1()):                            KafkaClusterSpecRolesZookeeperNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecStorageAccountGen2{}).Type1()):                            KafkaClusterSpecStorageAccountGen2Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecGateway{}).Type1()):                                  MlServicesClusterSpecGatewayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecRoles{}).Type1()):                                    MlServicesClusterSpecRolesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecRolesEdgeNode{}).Type1()):                            MlServicesClusterSpecRolesEdgeNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecRolesHeadNode{}).Type1()):                            MlServicesClusterSpecRolesHeadNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecRolesWorkerNode{}).Type1()):                          MlServicesClusterSpecRolesWorkerNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecRolesZookeeperNode{}).Type1()):                       MlServicesClusterSpecRolesZookeeperNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecGateway{}).Type1()):                                     RserverClusterSpecGatewayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecRoles{}).Type1()):                                       RserverClusterSpecRolesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecRolesEdgeNode{}).Type1()):                               RserverClusterSpecRolesEdgeNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecRolesHeadNode{}).Type1()):                               RserverClusterSpecRolesHeadNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecRolesWorkerNode{}).Type1()):                             RserverClusterSpecRolesWorkerNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecRolesZookeeperNode{}).Type1()):                          RserverClusterSpecRolesZookeeperNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecComponentVersion{}).Type1()):                              SparkClusterSpecComponentVersionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecGateway{}).Type1()):                                       SparkClusterSpecGatewayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecMetastores{}).Type1()):                                    SparkClusterSpecMetastoresCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecMetastoresAmbari{}).Type1()):                              SparkClusterSpecMetastoresAmbariCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecMetastoresHive{}).Type1()):                                SparkClusterSpecMetastoresHiveCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecMetastoresOozie{}).Type1()):                               SparkClusterSpecMetastoresOozieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecMonitor{}).Type1()):                                       SparkClusterSpecMonitorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecNetwork{}).Type1()):                                       SparkClusterSpecNetworkCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRoles{}).Type1()):                                         SparkClusterSpecRolesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesHeadNode{}).Type1()):                                 SparkClusterSpecRolesHeadNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesWorkerNode{}).Type1()):                               SparkClusterSpecRolesWorkerNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesWorkerNodeAutoscale{}).Type1()):                      SparkClusterSpecRolesWorkerNodeAutoscaleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesWorkerNodeAutoscaleCapacity{}).Type1()):              SparkClusterSpecRolesWorkerNodeAutoscaleCapacityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesWorkerNodeAutoscaleRecurrence{}).Type1()):            SparkClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesZookeeperNode{}).Type1()):                            SparkClusterSpecRolesZookeeperNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecStorageAccountGen2{}).Type1()):                            SparkClusterSpecStorageAccountGen2Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecComponentVersion{}).Type1()):                              StormClusterSpecComponentVersionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecGateway{}).Type1()):                                       StormClusterSpecGatewayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecMetastores{}).Type1()):                                    StormClusterSpecMetastoresCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecMetastoresAmbari{}).Type1()):                              StormClusterSpecMetastoresAmbariCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecMetastoresHive{}).Type1()):                                StormClusterSpecMetastoresHiveCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecMetastoresOozie{}).Type1()):                               StormClusterSpecMetastoresOozieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecMonitor{}).Type1()):                                       StormClusterSpecMonitorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecRoles{}).Type1()):                                         StormClusterSpecRolesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecRolesHeadNode{}).Type1()):                                 StormClusterSpecRolesHeadNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecRolesWorkerNode{}).Type1()):                               StormClusterSpecRolesWorkerNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecRolesZookeeperNode{}).Type1()):                            StormClusterSpecRolesZookeeperNodeCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecComponentVersion{}).Type1()):                             HadoopClusterSpecComponentVersionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecGateway{}).Type1()):                                      HadoopClusterSpecGatewayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecMetastores{}).Type1()):                                   HadoopClusterSpecMetastoresCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecMetastoresAmbari{}).Type1()):                             HadoopClusterSpecMetastoresAmbariCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecMetastoresHive{}).Type1()):                               HadoopClusterSpecMetastoresHiveCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecMetastoresOozie{}).Type1()):                              HadoopClusterSpecMetastoresOozieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecMonitor{}).Type1()):                                      HadoopClusterSpecMonitorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecNetwork{}).Type1()):                                      HadoopClusterSpecNetworkCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRoles{}).Type1()):                                        HadoopClusterSpecRolesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesEdgeNode{}).Type1()):                                HadoopClusterSpecRolesEdgeNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesHeadNode{}).Type1()):                                HadoopClusterSpecRolesHeadNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesWorkerNode{}).Type1()):                              HadoopClusterSpecRolesWorkerNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesWorkerNodeAutoscale{}).Type1()):                     HadoopClusterSpecRolesWorkerNodeAutoscaleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesWorkerNodeAutoscaleCapacity{}).Type1()):             HadoopClusterSpecRolesWorkerNodeAutoscaleCapacityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesWorkerNodeAutoscaleRecurrence{}).Type1()):           HadoopClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesZookeeperNode{}).Type1()):                           HadoopClusterSpecRolesZookeeperNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecStorageAccountGen2{}).Type1()):                           HadoopClusterSpecStorageAccountGen2Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecComponentVersion{}).Type1()):                              HbaseClusterSpecComponentVersionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecGateway{}).Type1()):                                       HbaseClusterSpecGatewayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecMetastores{}).Type1()):                                    HbaseClusterSpecMetastoresCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecMetastoresAmbari{}).Type1()):                              HbaseClusterSpecMetastoresAmbariCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecMetastoresHive{}).Type1()):                                HbaseClusterSpecMetastoresHiveCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecMetastoresOozie{}).Type1()):                               HbaseClusterSpecMetastoresOozieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecMonitor{}).Type1()):                                       HbaseClusterSpecMonitorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRoles{}).Type1()):                                         HbaseClusterSpecRolesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRolesHeadNode{}).Type1()):                                 HbaseClusterSpecRolesHeadNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRolesWorkerNode{}).Type1()):                               HbaseClusterSpecRolesWorkerNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRolesWorkerNodeAutoscale{}).Type1()):                      HbaseClusterSpecRolesWorkerNodeAutoscaleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRolesWorkerNodeAutoscaleRecurrence{}).Type1()):            HbaseClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRolesZookeeperNode{}).Type1()):                            HbaseClusterSpecRolesZookeeperNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecStorageAccountGen2{}).Type1()):                            HbaseClusterSpecStorageAccountGen2Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecComponentVersion{}).Type1()):                   InteractiveQueryClusterSpecComponentVersionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecGateway{}).Type1()):                            InteractiveQueryClusterSpecGatewayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecMetastores{}).Type1()):                         InteractiveQueryClusterSpecMetastoresCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecMetastoresAmbari{}).Type1()):                   InteractiveQueryClusterSpecMetastoresAmbariCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecMetastoresHive{}).Type1()):                     InteractiveQueryClusterSpecMetastoresHiveCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecMetastoresOozie{}).Type1()):                    InteractiveQueryClusterSpecMetastoresOozieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecMonitor{}).Type1()):                            InteractiveQueryClusterSpecMonitorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecNetwork{}).Type1()):                            InteractiveQueryClusterSpecNetworkCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRoles{}).Type1()):                              InteractiveQueryClusterSpecRolesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesHeadNode{}).Type1()):                      InteractiveQueryClusterSpecRolesHeadNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesWorkerNode{}).Type1()):                    InteractiveQueryClusterSpecRolesWorkerNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesWorkerNodeAutoscale{}).Type1()):           InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCapacity{}).Type1()):   InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCapacityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleRecurrence{}).Type1()): InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesZookeeperNode{}).Type1()):                 InteractiveQueryClusterSpecRolesZookeeperNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecStorageAccountGen2{}).Type1()):                 InteractiveQueryClusterSpecStorageAccountGen2Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecComponentVersion{}).Type1()):                              KafkaClusterSpecComponentVersionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecGateway{}).Type1()):                                       KafkaClusterSpecGatewayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecMetastores{}).Type1()):                                    KafkaClusterSpecMetastoresCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecMetastoresAmbari{}).Type1()):                              KafkaClusterSpecMetastoresAmbariCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecMetastoresHive{}).Type1()):                                KafkaClusterSpecMetastoresHiveCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecMetastoresOozie{}).Type1()):                               KafkaClusterSpecMetastoresOozieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecMonitor{}).Type1()):                                       KafkaClusterSpecMonitorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRestProxy{}).Type1()):                                     KafkaClusterSpecRestProxyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRoles{}).Type1()):                                         KafkaClusterSpecRolesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRolesHeadNode{}).Type1()):                                 KafkaClusterSpecRolesHeadNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRolesKafkaManagementNode{}).Type1()):                      KafkaClusterSpecRolesKafkaManagementNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRolesWorkerNode{}).Type1()):                               KafkaClusterSpecRolesWorkerNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRolesZookeeperNode{}).Type1()):                            KafkaClusterSpecRolesZookeeperNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecStorageAccountGen2{}).Type1()):                            KafkaClusterSpecStorageAccountGen2Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecGateway{}).Type1()):                                  MlServicesClusterSpecGatewayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecRoles{}).Type1()):                                    MlServicesClusterSpecRolesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecRolesEdgeNode{}).Type1()):                            MlServicesClusterSpecRolesEdgeNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecRolesHeadNode{}).Type1()):                            MlServicesClusterSpecRolesHeadNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecRolesWorkerNode{}).Type1()):                          MlServicesClusterSpecRolesWorkerNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecRolesZookeeperNode{}).Type1()):                       MlServicesClusterSpecRolesZookeeperNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecGateway{}).Type1()):                                     RserverClusterSpecGatewayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecRoles{}).Type1()):                                       RserverClusterSpecRolesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecRolesEdgeNode{}).Type1()):                               RserverClusterSpecRolesEdgeNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecRolesHeadNode{}).Type1()):                               RserverClusterSpecRolesHeadNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecRolesWorkerNode{}).Type1()):                             RserverClusterSpecRolesWorkerNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecRolesZookeeperNode{}).Type1()):                          RserverClusterSpecRolesZookeeperNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecComponentVersion{}).Type1()):                              SparkClusterSpecComponentVersionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecGateway{}).Type1()):                                       SparkClusterSpecGatewayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecMetastores{}).Type1()):                                    SparkClusterSpecMetastoresCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecMetastoresAmbari{}).Type1()):                              SparkClusterSpecMetastoresAmbariCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecMetastoresHive{}).Type1()):                                SparkClusterSpecMetastoresHiveCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecMetastoresOozie{}).Type1()):                               SparkClusterSpecMetastoresOozieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecMonitor{}).Type1()):                                       SparkClusterSpecMonitorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecNetwork{}).Type1()):                                       SparkClusterSpecNetworkCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRoles{}).Type1()):                                         SparkClusterSpecRolesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesHeadNode{}).Type1()):                                 SparkClusterSpecRolesHeadNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesWorkerNode{}).Type1()):                               SparkClusterSpecRolesWorkerNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesWorkerNodeAutoscale{}).Type1()):                      SparkClusterSpecRolesWorkerNodeAutoscaleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesWorkerNodeAutoscaleCapacity{}).Type1()):              SparkClusterSpecRolesWorkerNodeAutoscaleCapacityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesWorkerNodeAutoscaleRecurrence{}).Type1()):            SparkClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesZookeeperNode{}).Type1()):                            SparkClusterSpecRolesZookeeperNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecStorageAccountGen2{}).Type1()):                            SparkClusterSpecStorageAccountGen2Codec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecComponentVersion{}).Type1()):                              StormClusterSpecComponentVersionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecGateway{}).Type1()):                                       StormClusterSpecGatewayCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecMetastores{}).Type1()):                                    StormClusterSpecMetastoresCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecMetastoresAmbari{}).Type1()):                              StormClusterSpecMetastoresAmbariCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecMetastoresHive{}).Type1()):                                StormClusterSpecMetastoresHiveCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecMetastoresOozie{}).Type1()):                               StormClusterSpecMetastoresOozieCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecMonitor{}).Type1()):                                       StormClusterSpecMonitorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecRoles{}).Type1()):                                         StormClusterSpecRolesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecRolesHeadNode{}).Type1()):                                 StormClusterSpecRolesHeadNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecRolesWorkerNode{}).Type1()):                               StormClusterSpecRolesWorkerNodeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecRolesZookeeperNode{}).Type1()):                            StormClusterSpecRolesZookeeperNodeCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type HadoopClusterSpecComponentVersionCodec struct {
}

func (HadoopClusterSpecComponentVersionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HadoopClusterSpecComponentVersion)(ptr) == nil
}

func (HadoopClusterSpecComponentVersionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HadoopClusterSpecComponentVersion)(ptr)
	var objs []HadoopClusterSpecComponentVersion
	if obj != nil {
		objs = []HadoopClusterSpecComponentVersion{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecComponentVersion{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HadoopClusterSpecComponentVersionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HadoopClusterSpecComponentVersion)(ptr) = HadoopClusterSpecComponentVersion{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HadoopClusterSpecComponentVersion

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecComponentVersion{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HadoopClusterSpecComponentVersion)(ptr) = objs[0]
			} else {
				*(*HadoopClusterSpecComponentVersion)(ptr) = HadoopClusterSpecComponentVersion{}
			}
		} else {
			*(*HadoopClusterSpecComponentVersion)(ptr) = HadoopClusterSpecComponentVersion{}
		}
	default:
		iter.ReportError("decode HadoopClusterSpecComponentVersion", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HadoopClusterSpecGatewayCodec struct {
}

func (HadoopClusterSpecGatewayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HadoopClusterSpecGateway)(ptr) == nil
}

func (HadoopClusterSpecGatewayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HadoopClusterSpecGateway)(ptr)
	var objs []HadoopClusterSpecGateway
	if obj != nil {
		objs = []HadoopClusterSpecGateway{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecGateway{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HadoopClusterSpecGatewayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HadoopClusterSpecGateway)(ptr) = HadoopClusterSpecGateway{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HadoopClusterSpecGateway

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecGateway{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HadoopClusterSpecGateway)(ptr) = objs[0]
			} else {
				*(*HadoopClusterSpecGateway)(ptr) = HadoopClusterSpecGateway{}
			}
		} else {
			*(*HadoopClusterSpecGateway)(ptr) = HadoopClusterSpecGateway{}
		}
	default:
		iter.ReportError("decode HadoopClusterSpecGateway", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HadoopClusterSpecMetastoresCodec struct {
}

func (HadoopClusterSpecMetastoresCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HadoopClusterSpecMetastores)(ptr) == nil
}

func (HadoopClusterSpecMetastoresCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HadoopClusterSpecMetastores)(ptr)
	var objs []HadoopClusterSpecMetastores
	if obj != nil {
		objs = []HadoopClusterSpecMetastores{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecMetastores{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HadoopClusterSpecMetastoresCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HadoopClusterSpecMetastores)(ptr) = HadoopClusterSpecMetastores{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HadoopClusterSpecMetastores

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecMetastores{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HadoopClusterSpecMetastores)(ptr) = objs[0]
			} else {
				*(*HadoopClusterSpecMetastores)(ptr) = HadoopClusterSpecMetastores{}
			}
		} else {
			*(*HadoopClusterSpecMetastores)(ptr) = HadoopClusterSpecMetastores{}
		}
	default:
		iter.ReportError("decode HadoopClusterSpecMetastores", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HadoopClusterSpecMetastoresAmbariCodec struct {
}

func (HadoopClusterSpecMetastoresAmbariCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HadoopClusterSpecMetastoresAmbari)(ptr) == nil
}

func (HadoopClusterSpecMetastoresAmbariCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HadoopClusterSpecMetastoresAmbari)(ptr)
	var objs []HadoopClusterSpecMetastoresAmbari
	if obj != nil {
		objs = []HadoopClusterSpecMetastoresAmbari{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecMetastoresAmbari{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HadoopClusterSpecMetastoresAmbariCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HadoopClusterSpecMetastoresAmbari)(ptr) = HadoopClusterSpecMetastoresAmbari{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HadoopClusterSpecMetastoresAmbari

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecMetastoresAmbari{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HadoopClusterSpecMetastoresAmbari)(ptr) = objs[0]
			} else {
				*(*HadoopClusterSpecMetastoresAmbari)(ptr) = HadoopClusterSpecMetastoresAmbari{}
			}
		} else {
			*(*HadoopClusterSpecMetastoresAmbari)(ptr) = HadoopClusterSpecMetastoresAmbari{}
		}
	default:
		iter.ReportError("decode HadoopClusterSpecMetastoresAmbari", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HadoopClusterSpecMetastoresHiveCodec struct {
}

func (HadoopClusterSpecMetastoresHiveCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HadoopClusterSpecMetastoresHive)(ptr) == nil
}

func (HadoopClusterSpecMetastoresHiveCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HadoopClusterSpecMetastoresHive)(ptr)
	var objs []HadoopClusterSpecMetastoresHive
	if obj != nil {
		objs = []HadoopClusterSpecMetastoresHive{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecMetastoresHive{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HadoopClusterSpecMetastoresHiveCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HadoopClusterSpecMetastoresHive)(ptr) = HadoopClusterSpecMetastoresHive{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HadoopClusterSpecMetastoresHive

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecMetastoresHive{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HadoopClusterSpecMetastoresHive)(ptr) = objs[0]
			} else {
				*(*HadoopClusterSpecMetastoresHive)(ptr) = HadoopClusterSpecMetastoresHive{}
			}
		} else {
			*(*HadoopClusterSpecMetastoresHive)(ptr) = HadoopClusterSpecMetastoresHive{}
		}
	default:
		iter.ReportError("decode HadoopClusterSpecMetastoresHive", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HadoopClusterSpecMetastoresOozieCodec struct {
}

func (HadoopClusterSpecMetastoresOozieCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HadoopClusterSpecMetastoresOozie)(ptr) == nil
}

func (HadoopClusterSpecMetastoresOozieCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HadoopClusterSpecMetastoresOozie)(ptr)
	var objs []HadoopClusterSpecMetastoresOozie
	if obj != nil {
		objs = []HadoopClusterSpecMetastoresOozie{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecMetastoresOozie{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HadoopClusterSpecMetastoresOozieCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HadoopClusterSpecMetastoresOozie)(ptr) = HadoopClusterSpecMetastoresOozie{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HadoopClusterSpecMetastoresOozie

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecMetastoresOozie{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HadoopClusterSpecMetastoresOozie)(ptr) = objs[0]
			} else {
				*(*HadoopClusterSpecMetastoresOozie)(ptr) = HadoopClusterSpecMetastoresOozie{}
			}
		} else {
			*(*HadoopClusterSpecMetastoresOozie)(ptr) = HadoopClusterSpecMetastoresOozie{}
		}
	default:
		iter.ReportError("decode HadoopClusterSpecMetastoresOozie", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HadoopClusterSpecMonitorCodec struct {
}

func (HadoopClusterSpecMonitorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HadoopClusterSpecMonitor)(ptr) == nil
}

func (HadoopClusterSpecMonitorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HadoopClusterSpecMonitor)(ptr)
	var objs []HadoopClusterSpecMonitor
	if obj != nil {
		objs = []HadoopClusterSpecMonitor{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecMonitor{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HadoopClusterSpecMonitorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HadoopClusterSpecMonitor)(ptr) = HadoopClusterSpecMonitor{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HadoopClusterSpecMonitor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecMonitor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HadoopClusterSpecMonitor)(ptr) = objs[0]
			} else {
				*(*HadoopClusterSpecMonitor)(ptr) = HadoopClusterSpecMonitor{}
			}
		} else {
			*(*HadoopClusterSpecMonitor)(ptr) = HadoopClusterSpecMonitor{}
		}
	default:
		iter.ReportError("decode HadoopClusterSpecMonitor", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HadoopClusterSpecNetworkCodec struct {
}

func (HadoopClusterSpecNetworkCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HadoopClusterSpecNetwork)(ptr) == nil
}

func (HadoopClusterSpecNetworkCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HadoopClusterSpecNetwork)(ptr)
	var objs []HadoopClusterSpecNetwork
	if obj != nil {
		objs = []HadoopClusterSpecNetwork{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecNetwork{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HadoopClusterSpecNetworkCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HadoopClusterSpecNetwork)(ptr) = HadoopClusterSpecNetwork{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HadoopClusterSpecNetwork

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecNetwork{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HadoopClusterSpecNetwork)(ptr) = objs[0]
			} else {
				*(*HadoopClusterSpecNetwork)(ptr) = HadoopClusterSpecNetwork{}
			}
		} else {
			*(*HadoopClusterSpecNetwork)(ptr) = HadoopClusterSpecNetwork{}
		}
	default:
		iter.ReportError("decode HadoopClusterSpecNetwork", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HadoopClusterSpecRolesCodec struct {
}

func (HadoopClusterSpecRolesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HadoopClusterSpecRoles)(ptr) == nil
}

func (HadoopClusterSpecRolesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HadoopClusterSpecRoles)(ptr)
	var objs []HadoopClusterSpecRoles
	if obj != nil {
		objs = []HadoopClusterSpecRoles{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRoles{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HadoopClusterSpecRolesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HadoopClusterSpecRoles)(ptr) = HadoopClusterSpecRoles{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HadoopClusterSpecRoles

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRoles{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HadoopClusterSpecRoles)(ptr) = objs[0]
			} else {
				*(*HadoopClusterSpecRoles)(ptr) = HadoopClusterSpecRoles{}
			}
		} else {
			*(*HadoopClusterSpecRoles)(ptr) = HadoopClusterSpecRoles{}
		}
	default:
		iter.ReportError("decode HadoopClusterSpecRoles", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HadoopClusterSpecRolesEdgeNodeCodec struct {
}

func (HadoopClusterSpecRolesEdgeNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HadoopClusterSpecRolesEdgeNode)(ptr) == nil
}

func (HadoopClusterSpecRolesEdgeNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HadoopClusterSpecRolesEdgeNode)(ptr)
	var objs []HadoopClusterSpecRolesEdgeNode
	if obj != nil {
		objs = []HadoopClusterSpecRolesEdgeNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesEdgeNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HadoopClusterSpecRolesEdgeNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HadoopClusterSpecRolesEdgeNode)(ptr) = HadoopClusterSpecRolesEdgeNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HadoopClusterSpecRolesEdgeNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesEdgeNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HadoopClusterSpecRolesEdgeNode)(ptr) = objs[0]
			} else {
				*(*HadoopClusterSpecRolesEdgeNode)(ptr) = HadoopClusterSpecRolesEdgeNode{}
			}
		} else {
			*(*HadoopClusterSpecRolesEdgeNode)(ptr) = HadoopClusterSpecRolesEdgeNode{}
		}
	default:
		iter.ReportError("decode HadoopClusterSpecRolesEdgeNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HadoopClusterSpecRolesHeadNodeCodec struct {
}

func (HadoopClusterSpecRolesHeadNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HadoopClusterSpecRolesHeadNode)(ptr) == nil
}

func (HadoopClusterSpecRolesHeadNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HadoopClusterSpecRolesHeadNode)(ptr)
	var objs []HadoopClusterSpecRolesHeadNode
	if obj != nil {
		objs = []HadoopClusterSpecRolesHeadNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesHeadNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HadoopClusterSpecRolesHeadNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HadoopClusterSpecRolesHeadNode)(ptr) = HadoopClusterSpecRolesHeadNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HadoopClusterSpecRolesHeadNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesHeadNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HadoopClusterSpecRolesHeadNode)(ptr) = objs[0]
			} else {
				*(*HadoopClusterSpecRolesHeadNode)(ptr) = HadoopClusterSpecRolesHeadNode{}
			}
		} else {
			*(*HadoopClusterSpecRolesHeadNode)(ptr) = HadoopClusterSpecRolesHeadNode{}
		}
	default:
		iter.ReportError("decode HadoopClusterSpecRolesHeadNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HadoopClusterSpecRolesWorkerNodeCodec struct {
}

func (HadoopClusterSpecRolesWorkerNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HadoopClusterSpecRolesWorkerNode)(ptr) == nil
}

func (HadoopClusterSpecRolesWorkerNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HadoopClusterSpecRolesWorkerNode)(ptr)
	var objs []HadoopClusterSpecRolesWorkerNode
	if obj != nil {
		objs = []HadoopClusterSpecRolesWorkerNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesWorkerNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HadoopClusterSpecRolesWorkerNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HadoopClusterSpecRolesWorkerNode)(ptr) = HadoopClusterSpecRolesWorkerNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HadoopClusterSpecRolesWorkerNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesWorkerNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HadoopClusterSpecRolesWorkerNode)(ptr) = objs[0]
			} else {
				*(*HadoopClusterSpecRolesWorkerNode)(ptr) = HadoopClusterSpecRolesWorkerNode{}
			}
		} else {
			*(*HadoopClusterSpecRolesWorkerNode)(ptr) = HadoopClusterSpecRolesWorkerNode{}
		}
	default:
		iter.ReportError("decode HadoopClusterSpecRolesWorkerNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HadoopClusterSpecRolesWorkerNodeAutoscaleCodec struct {
}

func (HadoopClusterSpecRolesWorkerNodeAutoscaleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HadoopClusterSpecRolesWorkerNodeAutoscale)(ptr) == nil
}

func (HadoopClusterSpecRolesWorkerNodeAutoscaleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HadoopClusterSpecRolesWorkerNodeAutoscale)(ptr)
	var objs []HadoopClusterSpecRolesWorkerNodeAutoscale
	if obj != nil {
		objs = []HadoopClusterSpecRolesWorkerNodeAutoscale{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesWorkerNodeAutoscale{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HadoopClusterSpecRolesWorkerNodeAutoscaleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HadoopClusterSpecRolesWorkerNodeAutoscale)(ptr) = HadoopClusterSpecRolesWorkerNodeAutoscale{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HadoopClusterSpecRolesWorkerNodeAutoscale

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesWorkerNodeAutoscale{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HadoopClusterSpecRolesWorkerNodeAutoscale)(ptr) = objs[0]
			} else {
				*(*HadoopClusterSpecRolesWorkerNodeAutoscale)(ptr) = HadoopClusterSpecRolesWorkerNodeAutoscale{}
			}
		} else {
			*(*HadoopClusterSpecRolesWorkerNodeAutoscale)(ptr) = HadoopClusterSpecRolesWorkerNodeAutoscale{}
		}
	default:
		iter.ReportError("decode HadoopClusterSpecRolesWorkerNodeAutoscale", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HadoopClusterSpecRolesWorkerNodeAutoscaleCapacityCodec struct {
}

func (HadoopClusterSpecRolesWorkerNodeAutoscaleCapacityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HadoopClusterSpecRolesWorkerNodeAutoscaleCapacity)(ptr) == nil
}

func (HadoopClusterSpecRolesWorkerNodeAutoscaleCapacityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HadoopClusterSpecRolesWorkerNodeAutoscaleCapacity)(ptr)
	var objs []HadoopClusterSpecRolesWorkerNodeAutoscaleCapacity
	if obj != nil {
		objs = []HadoopClusterSpecRolesWorkerNodeAutoscaleCapacity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesWorkerNodeAutoscaleCapacity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HadoopClusterSpecRolesWorkerNodeAutoscaleCapacityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HadoopClusterSpecRolesWorkerNodeAutoscaleCapacity)(ptr) = HadoopClusterSpecRolesWorkerNodeAutoscaleCapacity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HadoopClusterSpecRolesWorkerNodeAutoscaleCapacity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesWorkerNodeAutoscaleCapacity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HadoopClusterSpecRolesWorkerNodeAutoscaleCapacity)(ptr) = objs[0]
			} else {
				*(*HadoopClusterSpecRolesWorkerNodeAutoscaleCapacity)(ptr) = HadoopClusterSpecRolesWorkerNodeAutoscaleCapacity{}
			}
		} else {
			*(*HadoopClusterSpecRolesWorkerNodeAutoscaleCapacity)(ptr) = HadoopClusterSpecRolesWorkerNodeAutoscaleCapacity{}
		}
	default:
		iter.ReportError("decode HadoopClusterSpecRolesWorkerNodeAutoscaleCapacity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HadoopClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec struct {
}

func (HadoopClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HadoopClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr) == nil
}

func (HadoopClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HadoopClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr)
	var objs []HadoopClusterSpecRolesWorkerNodeAutoscaleRecurrence
	if obj != nil {
		objs = []HadoopClusterSpecRolesWorkerNodeAutoscaleRecurrence{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesWorkerNodeAutoscaleRecurrence{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HadoopClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HadoopClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr) = HadoopClusterSpecRolesWorkerNodeAutoscaleRecurrence{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HadoopClusterSpecRolesWorkerNodeAutoscaleRecurrence

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesWorkerNodeAutoscaleRecurrence{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HadoopClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr) = objs[0]
			} else {
				*(*HadoopClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr) = HadoopClusterSpecRolesWorkerNodeAutoscaleRecurrence{}
			}
		} else {
			*(*HadoopClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr) = HadoopClusterSpecRolesWorkerNodeAutoscaleRecurrence{}
		}
	default:
		iter.ReportError("decode HadoopClusterSpecRolesWorkerNodeAutoscaleRecurrence", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HadoopClusterSpecRolesZookeeperNodeCodec struct {
}

func (HadoopClusterSpecRolesZookeeperNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HadoopClusterSpecRolesZookeeperNode)(ptr) == nil
}

func (HadoopClusterSpecRolesZookeeperNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HadoopClusterSpecRolesZookeeperNode)(ptr)
	var objs []HadoopClusterSpecRolesZookeeperNode
	if obj != nil {
		objs = []HadoopClusterSpecRolesZookeeperNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesZookeeperNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HadoopClusterSpecRolesZookeeperNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HadoopClusterSpecRolesZookeeperNode)(ptr) = HadoopClusterSpecRolesZookeeperNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HadoopClusterSpecRolesZookeeperNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecRolesZookeeperNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HadoopClusterSpecRolesZookeeperNode)(ptr) = objs[0]
			} else {
				*(*HadoopClusterSpecRolesZookeeperNode)(ptr) = HadoopClusterSpecRolesZookeeperNode{}
			}
		} else {
			*(*HadoopClusterSpecRolesZookeeperNode)(ptr) = HadoopClusterSpecRolesZookeeperNode{}
		}
	default:
		iter.ReportError("decode HadoopClusterSpecRolesZookeeperNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HadoopClusterSpecStorageAccountGen2Codec struct {
}

func (HadoopClusterSpecStorageAccountGen2Codec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HadoopClusterSpecStorageAccountGen2)(ptr) == nil
}

func (HadoopClusterSpecStorageAccountGen2Codec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HadoopClusterSpecStorageAccountGen2)(ptr)
	var objs []HadoopClusterSpecStorageAccountGen2
	if obj != nil {
		objs = []HadoopClusterSpecStorageAccountGen2{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecStorageAccountGen2{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HadoopClusterSpecStorageAccountGen2Codec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HadoopClusterSpecStorageAccountGen2)(ptr) = HadoopClusterSpecStorageAccountGen2{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HadoopClusterSpecStorageAccountGen2

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HadoopClusterSpecStorageAccountGen2{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HadoopClusterSpecStorageAccountGen2)(ptr) = objs[0]
			} else {
				*(*HadoopClusterSpecStorageAccountGen2)(ptr) = HadoopClusterSpecStorageAccountGen2{}
			}
		} else {
			*(*HadoopClusterSpecStorageAccountGen2)(ptr) = HadoopClusterSpecStorageAccountGen2{}
		}
	default:
		iter.ReportError("decode HadoopClusterSpecStorageAccountGen2", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HbaseClusterSpecComponentVersionCodec struct {
}

func (HbaseClusterSpecComponentVersionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HbaseClusterSpecComponentVersion)(ptr) == nil
}

func (HbaseClusterSpecComponentVersionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HbaseClusterSpecComponentVersion)(ptr)
	var objs []HbaseClusterSpecComponentVersion
	if obj != nil {
		objs = []HbaseClusterSpecComponentVersion{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecComponentVersion{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HbaseClusterSpecComponentVersionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HbaseClusterSpecComponentVersion)(ptr) = HbaseClusterSpecComponentVersion{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HbaseClusterSpecComponentVersion

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecComponentVersion{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HbaseClusterSpecComponentVersion)(ptr) = objs[0]
			} else {
				*(*HbaseClusterSpecComponentVersion)(ptr) = HbaseClusterSpecComponentVersion{}
			}
		} else {
			*(*HbaseClusterSpecComponentVersion)(ptr) = HbaseClusterSpecComponentVersion{}
		}
	default:
		iter.ReportError("decode HbaseClusterSpecComponentVersion", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HbaseClusterSpecGatewayCodec struct {
}

func (HbaseClusterSpecGatewayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HbaseClusterSpecGateway)(ptr) == nil
}

func (HbaseClusterSpecGatewayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HbaseClusterSpecGateway)(ptr)
	var objs []HbaseClusterSpecGateway
	if obj != nil {
		objs = []HbaseClusterSpecGateway{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecGateway{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HbaseClusterSpecGatewayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HbaseClusterSpecGateway)(ptr) = HbaseClusterSpecGateway{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HbaseClusterSpecGateway

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecGateway{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HbaseClusterSpecGateway)(ptr) = objs[0]
			} else {
				*(*HbaseClusterSpecGateway)(ptr) = HbaseClusterSpecGateway{}
			}
		} else {
			*(*HbaseClusterSpecGateway)(ptr) = HbaseClusterSpecGateway{}
		}
	default:
		iter.ReportError("decode HbaseClusterSpecGateway", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HbaseClusterSpecMetastoresCodec struct {
}

func (HbaseClusterSpecMetastoresCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HbaseClusterSpecMetastores)(ptr) == nil
}

func (HbaseClusterSpecMetastoresCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HbaseClusterSpecMetastores)(ptr)
	var objs []HbaseClusterSpecMetastores
	if obj != nil {
		objs = []HbaseClusterSpecMetastores{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecMetastores{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HbaseClusterSpecMetastoresCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HbaseClusterSpecMetastores)(ptr) = HbaseClusterSpecMetastores{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HbaseClusterSpecMetastores

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecMetastores{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HbaseClusterSpecMetastores)(ptr) = objs[0]
			} else {
				*(*HbaseClusterSpecMetastores)(ptr) = HbaseClusterSpecMetastores{}
			}
		} else {
			*(*HbaseClusterSpecMetastores)(ptr) = HbaseClusterSpecMetastores{}
		}
	default:
		iter.ReportError("decode HbaseClusterSpecMetastores", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HbaseClusterSpecMetastoresAmbariCodec struct {
}

func (HbaseClusterSpecMetastoresAmbariCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HbaseClusterSpecMetastoresAmbari)(ptr) == nil
}

func (HbaseClusterSpecMetastoresAmbariCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HbaseClusterSpecMetastoresAmbari)(ptr)
	var objs []HbaseClusterSpecMetastoresAmbari
	if obj != nil {
		objs = []HbaseClusterSpecMetastoresAmbari{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecMetastoresAmbari{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HbaseClusterSpecMetastoresAmbariCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HbaseClusterSpecMetastoresAmbari)(ptr) = HbaseClusterSpecMetastoresAmbari{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HbaseClusterSpecMetastoresAmbari

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecMetastoresAmbari{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HbaseClusterSpecMetastoresAmbari)(ptr) = objs[0]
			} else {
				*(*HbaseClusterSpecMetastoresAmbari)(ptr) = HbaseClusterSpecMetastoresAmbari{}
			}
		} else {
			*(*HbaseClusterSpecMetastoresAmbari)(ptr) = HbaseClusterSpecMetastoresAmbari{}
		}
	default:
		iter.ReportError("decode HbaseClusterSpecMetastoresAmbari", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HbaseClusterSpecMetastoresHiveCodec struct {
}

func (HbaseClusterSpecMetastoresHiveCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HbaseClusterSpecMetastoresHive)(ptr) == nil
}

func (HbaseClusterSpecMetastoresHiveCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HbaseClusterSpecMetastoresHive)(ptr)
	var objs []HbaseClusterSpecMetastoresHive
	if obj != nil {
		objs = []HbaseClusterSpecMetastoresHive{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecMetastoresHive{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HbaseClusterSpecMetastoresHiveCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HbaseClusterSpecMetastoresHive)(ptr) = HbaseClusterSpecMetastoresHive{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HbaseClusterSpecMetastoresHive

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecMetastoresHive{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HbaseClusterSpecMetastoresHive)(ptr) = objs[0]
			} else {
				*(*HbaseClusterSpecMetastoresHive)(ptr) = HbaseClusterSpecMetastoresHive{}
			}
		} else {
			*(*HbaseClusterSpecMetastoresHive)(ptr) = HbaseClusterSpecMetastoresHive{}
		}
	default:
		iter.ReportError("decode HbaseClusterSpecMetastoresHive", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HbaseClusterSpecMetastoresOozieCodec struct {
}

func (HbaseClusterSpecMetastoresOozieCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HbaseClusterSpecMetastoresOozie)(ptr) == nil
}

func (HbaseClusterSpecMetastoresOozieCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HbaseClusterSpecMetastoresOozie)(ptr)
	var objs []HbaseClusterSpecMetastoresOozie
	if obj != nil {
		objs = []HbaseClusterSpecMetastoresOozie{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecMetastoresOozie{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HbaseClusterSpecMetastoresOozieCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HbaseClusterSpecMetastoresOozie)(ptr) = HbaseClusterSpecMetastoresOozie{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HbaseClusterSpecMetastoresOozie

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecMetastoresOozie{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HbaseClusterSpecMetastoresOozie)(ptr) = objs[0]
			} else {
				*(*HbaseClusterSpecMetastoresOozie)(ptr) = HbaseClusterSpecMetastoresOozie{}
			}
		} else {
			*(*HbaseClusterSpecMetastoresOozie)(ptr) = HbaseClusterSpecMetastoresOozie{}
		}
	default:
		iter.ReportError("decode HbaseClusterSpecMetastoresOozie", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HbaseClusterSpecMonitorCodec struct {
}

func (HbaseClusterSpecMonitorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HbaseClusterSpecMonitor)(ptr) == nil
}

func (HbaseClusterSpecMonitorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HbaseClusterSpecMonitor)(ptr)
	var objs []HbaseClusterSpecMonitor
	if obj != nil {
		objs = []HbaseClusterSpecMonitor{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecMonitor{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HbaseClusterSpecMonitorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HbaseClusterSpecMonitor)(ptr) = HbaseClusterSpecMonitor{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HbaseClusterSpecMonitor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecMonitor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HbaseClusterSpecMonitor)(ptr) = objs[0]
			} else {
				*(*HbaseClusterSpecMonitor)(ptr) = HbaseClusterSpecMonitor{}
			}
		} else {
			*(*HbaseClusterSpecMonitor)(ptr) = HbaseClusterSpecMonitor{}
		}
	default:
		iter.ReportError("decode HbaseClusterSpecMonitor", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HbaseClusterSpecRolesCodec struct {
}

func (HbaseClusterSpecRolesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HbaseClusterSpecRoles)(ptr) == nil
}

func (HbaseClusterSpecRolesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HbaseClusterSpecRoles)(ptr)
	var objs []HbaseClusterSpecRoles
	if obj != nil {
		objs = []HbaseClusterSpecRoles{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRoles{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HbaseClusterSpecRolesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HbaseClusterSpecRoles)(ptr) = HbaseClusterSpecRoles{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HbaseClusterSpecRoles

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRoles{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HbaseClusterSpecRoles)(ptr) = objs[0]
			} else {
				*(*HbaseClusterSpecRoles)(ptr) = HbaseClusterSpecRoles{}
			}
		} else {
			*(*HbaseClusterSpecRoles)(ptr) = HbaseClusterSpecRoles{}
		}
	default:
		iter.ReportError("decode HbaseClusterSpecRoles", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HbaseClusterSpecRolesHeadNodeCodec struct {
}

func (HbaseClusterSpecRolesHeadNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HbaseClusterSpecRolesHeadNode)(ptr) == nil
}

func (HbaseClusterSpecRolesHeadNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HbaseClusterSpecRolesHeadNode)(ptr)
	var objs []HbaseClusterSpecRolesHeadNode
	if obj != nil {
		objs = []HbaseClusterSpecRolesHeadNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRolesHeadNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HbaseClusterSpecRolesHeadNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HbaseClusterSpecRolesHeadNode)(ptr) = HbaseClusterSpecRolesHeadNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HbaseClusterSpecRolesHeadNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRolesHeadNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HbaseClusterSpecRolesHeadNode)(ptr) = objs[0]
			} else {
				*(*HbaseClusterSpecRolesHeadNode)(ptr) = HbaseClusterSpecRolesHeadNode{}
			}
		} else {
			*(*HbaseClusterSpecRolesHeadNode)(ptr) = HbaseClusterSpecRolesHeadNode{}
		}
	default:
		iter.ReportError("decode HbaseClusterSpecRolesHeadNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HbaseClusterSpecRolesWorkerNodeCodec struct {
}

func (HbaseClusterSpecRolesWorkerNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HbaseClusterSpecRolesWorkerNode)(ptr) == nil
}

func (HbaseClusterSpecRolesWorkerNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HbaseClusterSpecRolesWorkerNode)(ptr)
	var objs []HbaseClusterSpecRolesWorkerNode
	if obj != nil {
		objs = []HbaseClusterSpecRolesWorkerNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRolesWorkerNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HbaseClusterSpecRolesWorkerNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HbaseClusterSpecRolesWorkerNode)(ptr) = HbaseClusterSpecRolesWorkerNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HbaseClusterSpecRolesWorkerNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRolesWorkerNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HbaseClusterSpecRolesWorkerNode)(ptr) = objs[0]
			} else {
				*(*HbaseClusterSpecRolesWorkerNode)(ptr) = HbaseClusterSpecRolesWorkerNode{}
			}
		} else {
			*(*HbaseClusterSpecRolesWorkerNode)(ptr) = HbaseClusterSpecRolesWorkerNode{}
		}
	default:
		iter.ReportError("decode HbaseClusterSpecRolesWorkerNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HbaseClusterSpecRolesWorkerNodeAutoscaleCodec struct {
}

func (HbaseClusterSpecRolesWorkerNodeAutoscaleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HbaseClusterSpecRolesWorkerNodeAutoscale)(ptr) == nil
}

func (HbaseClusterSpecRolesWorkerNodeAutoscaleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HbaseClusterSpecRolesWorkerNodeAutoscale)(ptr)
	var objs []HbaseClusterSpecRolesWorkerNodeAutoscale
	if obj != nil {
		objs = []HbaseClusterSpecRolesWorkerNodeAutoscale{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRolesWorkerNodeAutoscale{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HbaseClusterSpecRolesWorkerNodeAutoscaleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HbaseClusterSpecRolesWorkerNodeAutoscale)(ptr) = HbaseClusterSpecRolesWorkerNodeAutoscale{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HbaseClusterSpecRolesWorkerNodeAutoscale

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRolesWorkerNodeAutoscale{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HbaseClusterSpecRolesWorkerNodeAutoscale)(ptr) = objs[0]
			} else {
				*(*HbaseClusterSpecRolesWorkerNodeAutoscale)(ptr) = HbaseClusterSpecRolesWorkerNodeAutoscale{}
			}
		} else {
			*(*HbaseClusterSpecRolesWorkerNodeAutoscale)(ptr) = HbaseClusterSpecRolesWorkerNodeAutoscale{}
		}
	default:
		iter.ReportError("decode HbaseClusterSpecRolesWorkerNodeAutoscale", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HbaseClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec struct {
}

func (HbaseClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HbaseClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr) == nil
}

func (HbaseClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HbaseClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr)
	var objs []HbaseClusterSpecRolesWorkerNodeAutoscaleRecurrence
	if obj != nil {
		objs = []HbaseClusterSpecRolesWorkerNodeAutoscaleRecurrence{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRolesWorkerNodeAutoscaleRecurrence{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HbaseClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HbaseClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr) = HbaseClusterSpecRolesWorkerNodeAutoscaleRecurrence{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HbaseClusterSpecRolesWorkerNodeAutoscaleRecurrence

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRolesWorkerNodeAutoscaleRecurrence{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HbaseClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr) = objs[0]
			} else {
				*(*HbaseClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr) = HbaseClusterSpecRolesWorkerNodeAutoscaleRecurrence{}
			}
		} else {
			*(*HbaseClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr) = HbaseClusterSpecRolesWorkerNodeAutoscaleRecurrence{}
		}
	default:
		iter.ReportError("decode HbaseClusterSpecRolesWorkerNodeAutoscaleRecurrence", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HbaseClusterSpecRolesZookeeperNodeCodec struct {
}

func (HbaseClusterSpecRolesZookeeperNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HbaseClusterSpecRolesZookeeperNode)(ptr) == nil
}

func (HbaseClusterSpecRolesZookeeperNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HbaseClusterSpecRolesZookeeperNode)(ptr)
	var objs []HbaseClusterSpecRolesZookeeperNode
	if obj != nil {
		objs = []HbaseClusterSpecRolesZookeeperNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRolesZookeeperNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HbaseClusterSpecRolesZookeeperNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HbaseClusterSpecRolesZookeeperNode)(ptr) = HbaseClusterSpecRolesZookeeperNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HbaseClusterSpecRolesZookeeperNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecRolesZookeeperNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HbaseClusterSpecRolesZookeeperNode)(ptr) = objs[0]
			} else {
				*(*HbaseClusterSpecRolesZookeeperNode)(ptr) = HbaseClusterSpecRolesZookeeperNode{}
			}
		} else {
			*(*HbaseClusterSpecRolesZookeeperNode)(ptr) = HbaseClusterSpecRolesZookeeperNode{}
		}
	default:
		iter.ReportError("decode HbaseClusterSpecRolesZookeeperNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HbaseClusterSpecStorageAccountGen2Codec struct {
}

func (HbaseClusterSpecStorageAccountGen2Codec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HbaseClusterSpecStorageAccountGen2)(ptr) == nil
}

func (HbaseClusterSpecStorageAccountGen2Codec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HbaseClusterSpecStorageAccountGen2)(ptr)
	var objs []HbaseClusterSpecStorageAccountGen2
	if obj != nil {
		objs = []HbaseClusterSpecStorageAccountGen2{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecStorageAccountGen2{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HbaseClusterSpecStorageAccountGen2Codec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HbaseClusterSpecStorageAccountGen2)(ptr) = HbaseClusterSpecStorageAccountGen2{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HbaseClusterSpecStorageAccountGen2

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HbaseClusterSpecStorageAccountGen2{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HbaseClusterSpecStorageAccountGen2)(ptr) = objs[0]
			} else {
				*(*HbaseClusterSpecStorageAccountGen2)(ptr) = HbaseClusterSpecStorageAccountGen2{}
			}
		} else {
			*(*HbaseClusterSpecStorageAccountGen2)(ptr) = HbaseClusterSpecStorageAccountGen2{}
		}
	default:
		iter.ReportError("decode HbaseClusterSpecStorageAccountGen2", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InteractiveQueryClusterSpecComponentVersionCodec struct {
}

func (InteractiveQueryClusterSpecComponentVersionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InteractiveQueryClusterSpecComponentVersion)(ptr) == nil
}

func (InteractiveQueryClusterSpecComponentVersionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InteractiveQueryClusterSpecComponentVersion)(ptr)
	var objs []InteractiveQueryClusterSpecComponentVersion
	if obj != nil {
		objs = []InteractiveQueryClusterSpecComponentVersion{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecComponentVersion{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InteractiveQueryClusterSpecComponentVersionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InteractiveQueryClusterSpecComponentVersion)(ptr) = InteractiveQueryClusterSpecComponentVersion{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InteractiveQueryClusterSpecComponentVersion

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecComponentVersion{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InteractiveQueryClusterSpecComponentVersion)(ptr) = objs[0]
			} else {
				*(*InteractiveQueryClusterSpecComponentVersion)(ptr) = InteractiveQueryClusterSpecComponentVersion{}
			}
		} else {
			*(*InteractiveQueryClusterSpecComponentVersion)(ptr) = InteractiveQueryClusterSpecComponentVersion{}
		}
	default:
		iter.ReportError("decode InteractiveQueryClusterSpecComponentVersion", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InteractiveQueryClusterSpecGatewayCodec struct {
}

func (InteractiveQueryClusterSpecGatewayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InteractiveQueryClusterSpecGateway)(ptr) == nil
}

func (InteractiveQueryClusterSpecGatewayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InteractiveQueryClusterSpecGateway)(ptr)
	var objs []InteractiveQueryClusterSpecGateway
	if obj != nil {
		objs = []InteractiveQueryClusterSpecGateway{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecGateway{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InteractiveQueryClusterSpecGatewayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InteractiveQueryClusterSpecGateway)(ptr) = InteractiveQueryClusterSpecGateway{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InteractiveQueryClusterSpecGateway

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecGateway{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InteractiveQueryClusterSpecGateway)(ptr) = objs[0]
			} else {
				*(*InteractiveQueryClusterSpecGateway)(ptr) = InteractiveQueryClusterSpecGateway{}
			}
		} else {
			*(*InteractiveQueryClusterSpecGateway)(ptr) = InteractiveQueryClusterSpecGateway{}
		}
	default:
		iter.ReportError("decode InteractiveQueryClusterSpecGateway", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InteractiveQueryClusterSpecMetastoresCodec struct {
}

func (InteractiveQueryClusterSpecMetastoresCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InteractiveQueryClusterSpecMetastores)(ptr) == nil
}

func (InteractiveQueryClusterSpecMetastoresCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InteractiveQueryClusterSpecMetastores)(ptr)
	var objs []InteractiveQueryClusterSpecMetastores
	if obj != nil {
		objs = []InteractiveQueryClusterSpecMetastores{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecMetastores{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InteractiveQueryClusterSpecMetastoresCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InteractiveQueryClusterSpecMetastores)(ptr) = InteractiveQueryClusterSpecMetastores{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InteractiveQueryClusterSpecMetastores

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecMetastores{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InteractiveQueryClusterSpecMetastores)(ptr) = objs[0]
			} else {
				*(*InteractiveQueryClusterSpecMetastores)(ptr) = InteractiveQueryClusterSpecMetastores{}
			}
		} else {
			*(*InteractiveQueryClusterSpecMetastores)(ptr) = InteractiveQueryClusterSpecMetastores{}
		}
	default:
		iter.ReportError("decode InteractiveQueryClusterSpecMetastores", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InteractiveQueryClusterSpecMetastoresAmbariCodec struct {
}

func (InteractiveQueryClusterSpecMetastoresAmbariCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InteractiveQueryClusterSpecMetastoresAmbari)(ptr) == nil
}

func (InteractiveQueryClusterSpecMetastoresAmbariCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InteractiveQueryClusterSpecMetastoresAmbari)(ptr)
	var objs []InteractiveQueryClusterSpecMetastoresAmbari
	if obj != nil {
		objs = []InteractiveQueryClusterSpecMetastoresAmbari{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecMetastoresAmbari{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InteractiveQueryClusterSpecMetastoresAmbariCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InteractiveQueryClusterSpecMetastoresAmbari)(ptr) = InteractiveQueryClusterSpecMetastoresAmbari{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InteractiveQueryClusterSpecMetastoresAmbari

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecMetastoresAmbari{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InteractiveQueryClusterSpecMetastoresAmbari)(ptr) = objs[0]
			} else {
				*(*InteractiveQueryClusterSpecMetastoresAmbari)(ptr) = InteractiveQueryClusterSpecMetastoresAmbari{}
			}
		} else {
			*(*InteractiveQueryClusterSpecMetastoresAmbari)(ptr) = InteractiveQueryClusterSpecMetastoresAmbari{}
		}
	default:
		iter.ReportError("decode InteractiveQueryClusterSpecMetastoresAmbari", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InteractiveQueryClusterSpecMetastoresHiveCodec struct {
}

func (InteractiveQueryClusterSpecMetastoresHiveCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InteractiveQueryClusterSpecMetastoresHive)(ptr) == nil
}

func (InteractiveQueryClusterSpecMetastoresHiveCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InteractiveQueryClusterSpecMetastoresHive)(ptr)
	var objs []InteractiveQueryClusterSpecMetastoresHive
	if obj != nil {
		objs = []InteractiveQueryClusterSpecMetastoresHive{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecMetastoresHive{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InteractiveQueryClusterSpecMetastoresHiveCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InteractiveQueryClusterSpecMetastoresHive)(ptr) = InteractiveQueryClusterSpecMetastoresHive{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InteractiveQueryClusterSpecMetastoresHive

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecMetastoresHive{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InteractiveQueryClusterSpecMetastoresHive)(ptr) = objs[0]
			} else {
				*(*InteractiveQueryClusterSpecMetastoresHive)(ptr) = InteractiveQueryClusterSpecMetastoresHive{}
			}
		} else {
			*(*InteractiveQueryClusterSpecMetastoresHive)(ptr) = InteractiveQueryClusterSpecMetastoresHive{}
		}
	default:
		iter.ReportError("decode InteractiveQueryClusterSpecMetastoresHive", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InteractiveQueryClusterSpecMetastoresOozieCodec struct {
}

func (InteractiveQueryClusterSpecMetastoresOozieCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InteractiveQueryClusterSpecMetastoresOozie)(ptr) == nil
}

func (InteractiveQueryClusterSpecMetastoresOozieCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InteractiveQueryClusterSpecMetastoresOozie)(ptr)
	var objs []InteractiveQueryClusterSpecMetastoresOozie
	if obj != nil {
		objs = []InteractiveQueryClusterSpecMetastoresOozie{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecMetastoresOozie{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InteractiveQueryClusterSpecMetastoresOozieCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InteractiveQueryClusterSpecMetastoresOozie)(ptr) = InteractiveQueryClusterSpecMetastoresOozie{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InteractiveQueryClusterSpecMetastoresOozie

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecMetastoresOozie{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InteractiveQueryClusterSpecMetastoresOozie)(ptr) = objs[0]
			} else {
				*(*InteractiveQueryClusterSpecMetastoresOozie)(ptr) = InteractiveQueryClusterSpecMetastoresOozie{}
			}
		} else {
			*(*InteractiveQueryClusterSpecMetastoresOozie)(ptr) = InteractiveQueryClusterSpecMetastoresOozie{}
		}
	default:
		iter.ReportError("decode InteractiveQueryClusterSpecMetastoresOozie", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InteractiveQueryClusterSpecMonitorCodec struct {
}

func (InteractiveQueryClusterSpecMonitorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InteractiveQueryClusterSpecMonitor)(ptr) == nil
}

func (InteractiveQueryClusterSpecMonitorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InteractiveQueryClusterSpecMonitor)(ptr)
	var objs []InteractiveQueryClusterSpecMonitor
	if obj != nil {
		objs = []InteractiveQueryClusterSpecMonitor{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecMonitor{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InteractiveQueryClusterSpecMonitorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InteractiveQueryClusterSpecMonitor)(ptr) = InteractiveQueryClusterSpecMonitor{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InteractiveQueryClusterSpecMonitor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecMonitor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InteractiveQueryClusterSpecMonitor)(ptr) = objs[0]
			} else {
				*(*InteractiveQueryClusterSpecMonitor)(ptr) = InteractiveQueryClusterSpecMonitor{}
			}
		} else {
			*(*InteractiveQueryClusterSpecMonitor)(ptr) = InteractiveQueryClusterSpecMonitor{}
		}
	default:
		iter.ReportError("decode InteractiveQueryClusterSpecMonitor", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InteractiveQueryClusterSpecNetworkCodec struct {
}

func (InteractiveQueryClusterSpecNetworkCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InteractiveQueryClusterSpecNetwork)(ptr) == nil
}

func (InteractiveQueryClusterSpecNetworkCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InteractiveQueryClusterSpecNetwork)(ptr)
	var objs []InteractiveQueryClusterSpecNetwork
	if obj != nil {
		objs = []InteractiveQueryClusterSpecNetwork{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecNetwork{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InteractiveQueryClusterSpecNetworkCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InteractiveQueryClusterSpecNetwork)(ptr) = InteractiveQueryClusterSpecNetwork{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InteractiveQueryClusterSpecNetwork

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecNetwork{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InteractiveQueryClusterSpecNetwork)(ptr) = objs[0]
			} else {
				*(*InteractiveQueryClusterSpecNetwork)(ptr) = InteractiveQueryClusterSpecNetwork{}
			}
		} else {
			*(*InteractiveQueryClusterSpecNetwork)(ptr) = InteractiveQueryClusterSpecNetwork{}
		}
	default:
		iter.ReportError("decode InteractiveQueryClusterSpecNetwork", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InteractiveQueryClusterSpecRolesCodec struct {
}

func (InteractiveQueryClusterSpecRolesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InteractiveQueryClusterSpecRoles)(ptr) == nil
}

func (InteractiveQueryClusterSpecRolesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InteractiveQueryClusterSpecRoles)(ptr)
	var objs []InteractiveQueryClusterSpecRoles
	if obj != nil {
		objs = []InteractiveQueryClusterSpecRoles{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRoles{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InteractiveQueryClusterSpecRolesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InteractiveQueryClusterSpecRoles)(ptr) = InteractiveQueryClusterSpecRoles{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InteractiveQueryClusterSpecRoles

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRoles{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InteractiveQueryClusterSpecRoles)(ptr) = objs[0]
			} else {
				*(*InteractiveQueryClusterSpecRoles)(ptr) = InteractiveQueryClusterSpecRoles{}
			}
		} else {
			*(*InteractiveQueryClusterSpecRoles)(ptr) = InteractiveQueryClusterSpecRoles{}
		}
	default:
		iter.ReportError("decode InteractiveQueryClusterSpecRoles", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InteractiveQueryClusterSpecRolesHeadNodeCodec struct {
}

func (InteractiveQueryClusterSpecRolesHeadNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InteractiveQueryClusterSpecRolesHeadNode)(ptr) == nil
}

func (InteractiveQueryClusterSpecRolesHeadNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InteractiveQueryClusterSpecRolesHeadNode)(ptr)
	var objs []InteractiveQueryClusterSpecRolesHeadNode
	if obj != nil {
		objs = []InteractiveQueryClusterSpecRolesHeadNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesHeadNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InteractiveQueryClusterSpecRolesHeadNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InteractiveQueryClusterSpecRolesHeadNode)(ptr) = InteractiveQueryClusterSpecRolesHeadNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InteractiveQueryClusterSpecRolesHeadNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesHeadNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InteractiveQueryClusterSpecRolesHeadNode)(ptr) = objs[0]
			} else {
				*(*InteractiveQueryClusterSpecRolesHeadNode)(ptr) = InteractiveQueryClusterSpecRolesHeadNode{}
			}
		} else {
			*(*InteractiveQueryClusterSpecRolesHeadNode)(ptr) = InteractiveQueryClusterSpecRolesHeadNode{}
		}
	default:
		iter.ReportError("decode InteractiveQueryClusterSpecRolesHeadNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InteractiveQueryClusterSpecRolesWorkerNodeCodec struct {
}

func (InteractiveQueryClusterSpecRolesWorkerNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InteractiveQueryClusterSpecRolesWorkerNode)(ptr) == nil
}

func (InteractiveQueryClusterSpecRolesWorkerNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InteractiveQueryClusterSpecRolesWorkerNode)(ptr)
	var objs []InteractiveQueryClusterSpecRolesWorkerNode
	if obj != nil {
		objs = []InteractiveQueryClusterSpecRolesWorkerNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesWorkerNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InteractiveQueryClusterSpecRolesWorkerNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InteractiveQueryClusterSpecRolesWorkerNode)(ptr) = InteractiveQueryClusterSpecRolesWorkerNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InteractiveQueryClusterSpecRolesWorkerNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesWorkerNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InteractiveQueryClusterSpecRolesWorkerNode)(ptr) = objs[0]
			} else {
				*(*InteractiveQueryClusterSpecRolesWorkerNode)(ptr) = InteractiveQueryClusterSpecRolesWorkerNode{}
			}
		} else {
			*(*InteractiveQueryClusterSpecRolesWorkerNode)(ptr) = InteractiveQueryClusterSpecRolesWorkerNode{}
		}
	default:
		iter.ReportError("decode InteractiveQueryClusterSpecRolesWorkerNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCodec struct {
}

func (InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InteractiveQueryClusterSpecRolesWorkerNodeAutoscale)(ptr) == nil
}

func (InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InteractiveQueryClusterSpecRolesWorkerNodeAutoscale)(ptr)
	var objs []InteractiveQueryClusterSpecRolesWorkerNodeAutoscale
	if obj != nil {
		objs = []InteractiveQueryClusterSpecRolesWorkerNodeAutoscale{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesWorkerNodeAutoscale{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InteractiveQueryClusterSpecRolesWorkerNodeAutoscale)(ptr) = InteractiveQueryClusterSpecRolesWorkerNodeAutoscale{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InteractiveQueryClusterSpecRolesWorkerNodeAutoscale

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesWorkerNodeAutoscale{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InteractiveQueryClusterSpecRolesWorkerNodeAutoscale)(ptr) = objs[0]
			} else {
				*(*InteractiveQueryClusterSpecRolesWorkerNodeAutoscale)(ptr) = InteractiveQueryClusterSpecRolesWorkerNodeAutoscale{}
			}
		} else {
			*(*InteractiveQueryClusterSpecRolesWorkerNodeAutoscale)(ptr) = InteractiveQueryClusterSpecRolesWorkerNodeAutoscale{}
		}
	default:
		iter.ReportError("decode InteractiveQueryClusterSpecRolesWorkerNodeAutoscale", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCapacityCodec struct {
}

func (InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCapacityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCapacity)(ptr) == nil
}

func (InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCapacityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCapacity)(ptr)
	var objs []InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCapacity
	if obj != nil {
		objs = []InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCapacity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCapacity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCapacityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCapacity)(ptr) = InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCapacity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCapacity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCapacity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCapacity)(ptr) = objs[0]
			} else {
				*(*InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCapacity)(ptr) = InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCapacity{}
			}
		} else {
			*(*InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCapacity)(ptr) = InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCapacity{}
		}
	default:
		iter.ReportError("decode InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleCapacity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec struct {
}

func (InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr) == nil
}

func (InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr)
	var objs []InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleRecurrence
	if obj != nil {
		objs = []InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleRecurrence{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleRecurrence{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr) = InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleRecurrence{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleRecurrence

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleRecurrence{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr) = objs[0]
			} else {
				*(*InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr) = InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleRecurrence{}
			}
		} else {
			*(*InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr) = InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleRecurrence{}
		}
	default:
		iter.ReportError("decode InteractiveQueryClusterSpecRolesWorkerNodeAutoscaleRecurrence", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InteractiveQueryClusterSpecRolesZookeeperNodeCodec struct {
}

func (InteractiveQueryClusterSpecRolesZookeeperNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InteractiveQueryClusterSpecRolesZookeeperNode)(ptr) == nil
}

func (InteractiveQueryClusterSpecRolesZookeeperNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InteractiveQueryClusterSpecRolesZookeeperNode)(ptr)
	var objs []InteractiveQueryClusterSpecRolesZookeeperNode
	if obj != nil {
		objs = []InteractiveQueryClusterSpecRolesZookeeperNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesZookeeperNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InteractiveQueryClusterSpecRolesZookeeperNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InteractiveQueryClusterSpecRolesZookeeperNode)(ptr) = InteractiveQueryClusterSpecRolesZookeeperNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InteractiveQueryClusterSpecRolesZookeeperNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecRolesZookeeperNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InteractiveQueryClusterSpecRolesZookeeperNode)(ptr) = objs[0]
			} else {
				*(*InteractiveQueryClusterSpecRolesZookeeperNode)(ptr) = InteractiveQueryClusterSpecRolesZookeeperNode{}
			}
		} else {
			*(*InteractiveQueryClusterSpecRolesZookeeperNode)(ptr) = InteractiveQueryClusterSpecRolesZookeeperNode{}
		}
	default:
		iter.ReportError("decode InteractiveQueryClusterSpecRolesZookeeperNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type InteractiveQueryClusterSpecStorageAccountGen2Codec struct {
}

func (InteractiveQueryClusterSpecStorageAccountGen2Codec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*InteractiveQueryClusterSpecStorageAccountGen2)(ptr) == nil
}

func (InteractiveQueryClusterSpecStorageAccountGen2Codec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*InteractiveQueryClusterSpecStorageAccountGen2)(ptr)
	var objs []InteractiveQueryClusterSpecStorageAccountGen2
	if obj != nil {
		objs = []InteractiveQueryClusterSpecStorageAccountGen2{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecStorageAccountGen2{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (InteractiveQueryClusterSpecStorageAccountGen2Codec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*InteractiveQueryClusterSpecStorageAccountGen2)(ptr) = InteractiveQueryClusterSpecStorageAccountGen2{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []InteractiveQueryClusterSpecStorageAccountGen2

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(InteractiveQueryClusterSpecStorageAccountGen2{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*InteractiveQueryClusterSpecStorageAccountGen2)(ptr) = objs[0]
			} else {
				*(*InteractiveQueryClusterSpecStorageAccountGen2)(ptr) = InteractiveQueryClusterSpecStorageAccountGen2{}
			}
		} else {
			*(*InteractiveQueryClusterSpecStorageAccountGen2)(ptr) = InteractiveQueryClusterSpecStorageAccountGen2{}
		}
	default:
		iter.ReportError("decode InteractiveQueryClusterSpecStorageAccountGen2", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KafkaClusterSpecComponentVersionCodec struct {
}

func (KafkaClusterSpecComponentVersionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KafkaClusterSpecComponentVersion)(ptr) == nil
}

func (KafkaClusterSpecComponentVersionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KafkaClusterSpecComponentVersion)(ptr)
	var objs []KafkaClusterSpecComponentVersion
	if obj != nil {
		objs = []KafkaClusterSpecComponentVersion{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecComponentVersion{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KafkaClusterSpecComponentVersionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KafkaClusterSpecComponentVersion)(ptr) = KafkaClusterSpecComponentVersion{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KafkaClusterSpecComponentVersion

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecComponentVersion{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KafkaClusterSpecComponentVersion)(ptr) = objs[0]
			} else {
				*(*KafkaClusterSpecComponentVersion)(ptr) = KafkaClusterSpecComponentVersion{}
			}
		} else {
			*(*KafkaClusterSpecComponentVersion)(ptr) = KafkaClusterSpecComponentVersion{}
		}
	default:
		iter.ReportError("decode KafkaClusterSpecComponentVersion", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KafkaClusterSpecGatewayCodec struct {
}

func (KafkaClusterSpecGatewayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KafkaClusterSpecGateway)(ptr) == nil
}

func (KafkaClusterSpecGatewayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KafkaClusterSpecGateway)(ptr)
	var objs []KafkaClusterSpecGateway
	if obj != nil {
		objs = []KafkaClusterSpecGateway{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecGateway{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KafkaClusterSpecGatewayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KafkaClusterSpecGateway)(ptr) = KafkaClusterSpecGateway{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KafkaClusterSpecGateway

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecGateway{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KafkaClusterSpecGateway)(ptr) = objs[0]
			} else {
				*(*KafkaClusterSpecGateway)(ptr) = KafkaClusterSpecGateway{}
			}
		} else {
			*(*KafkaClusterSpecGateway)(ptr) = KafkaClusterSpecGateway{}
		}
	default:
		iter.ReportError("decode KafkaClusterSpecGateway", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KafkaClusterSpecMetastoresCodec struct {
}

func (KafkaClusterSpecMetastoresCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KafkaClusterSpecMetastores)(ptr) == nil
}

func (KafkaClusterSpecMetastoresCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KafkaClusterSpecMetastores)(ptr)
	var objs []KafkaClusterSpecMetastores
	if obj != nil {
		objs = []KafkaClusterSpecMetastores{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecMetastores{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KafkaClusterSpecMetastoresCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KafkaClusterSpecMetastores)(ptr) = KafkaClusterSpecMetastores{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KafkaClusterSpecMetastores

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecMetastores{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KafkaClusterSpecMetastores)(ptr) = objs[0]
			} else {
				*(*KafkaClusterSpecMetastores)(ptr) = KafkaClusterSpecMetastores{}
			}
		} else {
			*(*KafkaClusterSpecMetastores)(ptr) = KafkaClusterSpecMetastores{}
		}
	default:
		iter.ReportError("decode KafkaClusterSpecMetastores", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KafkaClusterSpecMetastoresAmbariCodec struct {
}

func (KafkaClusterSpecMetastoresAmbariCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KafkaClusterSpecMetastoresAmbari)(ptr) == nil
}

func (KafkaClusterSpecMetastoresAmbariCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KafkaClusterSpecMetastoresAmbari)(ptr)
	var objs []KafkaClusterSpecMetastoresAmbari
	if obj != nil {
		objs = []KafkaClusterSpecMetastoresAmbari{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecMetastoresAmbari{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KafkaClusterSpecMetastoresAmbariCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KafkaClusterSpecMetastoresAmbari)(ptr) = KafkaClusterSpecMetastoresAmbari{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KafkaClusterSpecMetastoresAmbari

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecMetastoresAmbari{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KafkaClusterSpecMetastoresAmbari)(ptr) = objs[0]
			} else {
				*(*KafkaClusterSpecMetastoresAmbari)(ptr) = KafkaClusterSpecMetastoresAmbari{}
			}
		} else {
			*(*KafkaClusterSpecMetastoresAmbari)(ptr) = KafkaClusterSpecMetastoresAmbari{}
		}
	default:
		iter.ReportError("decode KafkaClusterSpecMetastoresAmbari", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KafkaClusterSpecMetastoresHiveCodec struct {
}

func (KafkaClusterSpecMetastoresHiveCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KafkaClusterSpecMetastoresHive)(ptr) == nil
}

func (KafkaClusterSpecMetastoresHiveCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KafkaClusterSpecMetastoresHive)(ptr)
	var objs []KafkaClusterSpecMetastoresHive
	if obj != nil {
		objs = []KafkaClusterSpecMetastoresHive{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecMetastoresHive{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KafkaClusterSpecMetastoresHiveCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KafkaClusterSpecMetastoresHive)(ptr) = KafkaClusterSpecMetastoresHive{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KafkaClusterSpecMetastoresHive

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecMetastoresHive{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KafkaClusterSpecMetastoresHive)(ptr) = objs[0]
			} else {
				*(*KafkaClusterSpecMetastoresHive)(ptr) = KafkaClusterSpecMetastoresHive{}
			}
		} else {
			*(*KafkaClusterSpecMetastoresHive)(ptr) = KafkaClusterSpecMetastoresHive{}
		}
	default:
		iter.ReportError("decode KafkaClusterSpecMetastoresHive", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KafkaClusterSpecMetastoresOozieCodec struct {
}

func (KafkaClusterSpecMetastoresOozieCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KafkaClusterSpecMetastoresOozie)(ptr) == nil
}

func (KafkaClusterSpecMetastoresOozieCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KafkaClusterSpecMetastoresOozie)(ptr)
	var objs []KafkaClusterSpecMetastoresOozie
	if obj != nil {
		objs = []KafkaClusterSpecMetastoresOozie{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecMetastoresOozie{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KafkaClusterSpecMetastoresOozieCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KafkaClusterSpecMetastoresOozie)(ptr) = KafkaClusterSpecMetastoresOozie{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KafkaClusterSpecMetastoresOozie

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecMetastoresOozie{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KafkaClusterSpecMetastoresOozie)(ptr) = objs[0]
			} else {
				*(*KafkaClusterSpecMetastoresOozie)(ptr) = KafkaClusterSpecMetastoresOozie{}
			}
		} else {
			*(*KafkaClusterSpecMetastoresOozie)(ptr) = KafkaClusterSpecMetastoresOozie{}
		}
	default:
		iter.ReportError("decode KafkaClusterSpecMetastoresOozie", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KafkaClusterSpecMonitorCodec struct {
}

func (KafkaClusterSpecMonitorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KafkaClusterSpecMonitor)(ptr) == nil
}

func (KafkaClusterSpecMonitorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KafkaClusterSpecMonitor)(ptr)
	var objs []KafkaClusterSpecMonitor
	if obj != nil {
		objs = []KafkaClusterSpecMonitor{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecMonitor{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KafkaClusterSpecMonitorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KafkaClusterSpecMonitor)(ptr) = KafkaClusterSpecMonitor{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KafkaClusterSpecMonitor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecMonitor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KafkaClusterSpecMonitor)(ptr) = objs[0]
			} else {
				*(*KafkaClusterSpecMonitor)(ptr) = KafkaClusterSpecMonitor{}
			}
		} else {
			*(*KafkaClusterSpecMonitor)(ptr) = KafkaClusterSpecMonitor{}
		}
	default:
		iter.ReportError("decode KafkaClusterSpecMonitor", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KafkaClusterSpecRestProxyCodec struct {
}

func (KafkaClusterSpecRestProxyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KafkaClusterSpecRestProxy)(ptr) == nil
}

func (KafkaClusterSpecRestProxyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KafkaClusterSpecRestProxy)(ptr)
	var objs []KafkaClusterSpecRestProxy
	if obj != nil {
		objs = []KafkaClusterSpecRestProxy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRestProxy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KafkaClusterSpecRestProxyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KafkaClusterSpecRestProxy)(ptr) = KafkaClusterSpecRestProxy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KafkaClusterSpecRestProxy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRestProxy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KafkaClusterSpecRestProxy)(ptr) = objs[0]
			} else {
				*(*KafkaClusterSpecRestProxy)(ptr) = KafkaClusterSpecRestProxy{}
			}
		} else {
			*(*KafkaClusterSpecRestProxy)(ptr) = KafkaClusterSpecRestProxy{}
		}
	default:
		iter.ReportError("decode KafkaClusterSpecRestProxy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KafkaClusterSpecRolesCodec struct {
}

func (KafkaClusterSpecRolesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KafkaClusterSpecRoles)(ptr) == nil
}

func (KafkaClusterSpecRolesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KafkaClusterSpecRoles)(ptr)
	var objs []KafkaClusterSpecRoles
	if obj != nil {
		objs = []KafkaClusterSpecRoles{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRoles{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KafkaClusterSpecRolesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KafkaClusterSpecRoles)(ptr) = KafkaClusterSpecRoles{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KafkaClusterSpecRoles

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRoles{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KafkaClusterSpecRoles)(ptr) = objs[0]
			} else {
				*(*KafkaClusterSpecRoles)(ptr) = KafkaClusterSpecRoles{}
			}
		} else {
			*(*KafkaClusterSpecRoles)(ptr) = KafkaClusterSpecRoles{}
		}
	default:
		iter.ReportError("decode KafkaClusterSpecRoles", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KafkaClusterSpecRolesHeadNodeCodec struct {
}

func (KafkaClusterSpecRolesHeadNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KafkaClusterSpecRolesHeadNode)(ptr) == nil
}

func (KafkaClusterSpecRolesHeadNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KafkaClusterSpecRolesHeadNode)(ptr)
	var objs []KafkaClusterSpecRolesHeadNode
	if obj != nil {
		objs = []KafkaClusterSpecRolesHeadNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRolesHeadNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KafkaClusterSpecRolesHeadNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KafkaClusterSpecRolesHeadNode)(ptr) = KafkaClusterSpecRolesHeadNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KafkaClusterSpecRolesHeadNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRolesHeadNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KafkaClusterSpecRolesHeadNode)(ptr) = objs[0]
			} else {
				*(*KafkaClusterSpecRolesHeadNode)(ptr) = KafkaClusterSpecRolesHeadNode{}
			}
		} else {
			*(*KafkaClusterSpecRolesHeadNode)(ptr) = KafkaClusterSpecRolesHeadNode{}
		}
	default:
		iter.ReportError("decode KafkaClusterSpecRolesHeadNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KafkaClusterSpecRolesKafkaManagementNodeCodec struct {
}

func (KafkaClusterSpecRolesKafkaManagementNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KafkaClusterSpecRolesKafkaManagementNode)(ptr) == nil
}

func (KafkaClusterSpecRolesKafkaManagementNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KafkaClusterSpecRolesKafkaManagementNode)(ptr)
	var objs []KafkaClusterSpecRolesKafkaManagementNode
	if obj != nil {
		objs = []KafkaClusterSpecRolesKafkaManagementNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRolesKafkaManagementNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KafkaClusterSpecRolesKafkaManagementNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KafkaClusterSpecRolesKafkaManagementNode)(ptr) = KafkaClusterSpecRolesKafkaManagementNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KafkaClusterSpecRolesKafkaManagementNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRolesKafkaManagementNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KafkaClusterSpecRolesKafkaManagementNode)(ptr) = objs[0]
			} else {
				*(*KafkaClusterSpecRolesKafkaManagementNode)(ptr) = KafkaClusterSpecRolesKafkaManagementNode{}
			}
		} else {
			*(*KafkaClusterSpecRolesKafkaManagementNode)(ptr) = KafkaClusterSpecRolesKafkaManagementNode{}
		}
	default:
		iter.ReportError("decode KafkaClusterSpecRolesKafkaManagementNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KafkaClusterSpecRolesWorkerNodeCodec struct {
}

func (KafkaClusterSpecRolesWorkerNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KafkaClusterSpecRolesWorkerNode)(ptr) == nil
}

func (KafkaClusterSpecRolesWorkerNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KafkaClusterSpecRolesWorkerNode)(ptr)
	var objs []KafkaClusterSpecRolesWorkerNode
	if obj != nil {
		objs = []KafkaClusterSpecRolesWorkerNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRolesWorkerNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KafkaClusterSpecRolesWorkerNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KafkaClusterSpecRolesWorkerNode)(ptr) = KafkaClusterSpecRolesWorkerNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KafkaClusterSpecRolesWorkerNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRolesWorkerNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KafkaClusterSpecRolesWorkerNode)(ptr) = objs[0]
			} else {
				*(*KafkaClusterSpecRolesWorkerNode)(ptr) = KafkaClusterSpecRolesWorkerNode{}
			}
		} else {
			*(*KafkaClusterSpecRolesWorkerNode)(ptr) = KafkaClusterSpecRolesWorkerNode{}
		}
	default:
		iter.ReportError("decode KafkaClusterSpecRolesWorkerNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KafkaClusterSpecRolesZookeeperNodeCodec struct {
}

func (KafkaClusterSpecRolesZookeeperNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KafkaClusterSpecRolesZookeeperNode)(ptr) == nil
}

func (KafkaClusterSpecRolesZookeeperNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KafkaClusterSpecRolesZookeeperNode)(ptr)
	var objs []KafkaClusterSpecRolesZookeeperNode
	if obj != nil {
		objs = []KafkaClusterSpecRolesZookeeperNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRolesZookeeperNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KafkaClusterSpecRolesZookeeperNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KafkaClusterSpecRolesZookeeperNode)(ptr) = KafkaClusterSpecRolesZookeeperNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KafkaClusterSpecRolesZookeeperNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecRolesZookeeperNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KafkaClusterSpecRolesZookeeperNode)(ptr) = objs[0]
			} else {
				*(*KafkaClusterSpecRolesZookeeperNode)(ptr) = KafkaClusterSpecRolesZookeeperNode{}
			}
		} else {
			*(*KafkaClusterSpecRolesZookeeperNode)(ptr) = KafkaClusterSpecRolesZookeeperNode{}
		}
	default:
		iter.ReportError("decode KafkaClusterSpecRolesZookeeperNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type KafkaClusterSpecStorageAccountGen2Codec struct {
}

func (KafkaClusterSpecStorageAccountGen2Codec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*KafkaClusterSpecStorageAccountGen2)(ptr) == nil
}

func (KafkaClusterSpecStorageAccountGen2Codec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*KafkaClusterSpecStorageAccountGen2)(ptr)
	var objs []KafkaClusterSpecStorageAccountGen2
	if obj != nil {
		objs = []KafkaClusterSpecStorageAccountGen2{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecStorageAccountGen2{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (KafkaClusterSpecStorageAccountGen2Codec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*KafkaClusterSpecStorageAccountGen2)(ptr) = KafkaClusterSpecStorageAccountGen2{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []KafkaClusterSpecStorageAccountGen2

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(KafkaClusterSpecStorageAccountGen2{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*KafkaClusterSpecStorageAccountGen2)(ptr) = objs[0]
			} else {
				*(*KafkaClusterSpecStorageAccountGen2)(ptr) = KafkaClusterSpecStorageAccountGen2{}
			}
		} else {
			*(*KafkaClusterSpecStorageAccountGen2)(ptr) = KafkaClusterSpecStorageAccountGen2{}
		}
	default:
		iter.ReportError("decode KafkaClusterSpecStorageAccountGen2", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MlServicesClusterSpecGatewayCodec struct {
}

func (MlServicesClusterSpecGatewayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MlServicesClusterSpecGateway)(ptr) == nil
}

func (MlServicesClusterSpecGatewayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MlServicesClusterSpecGateway)(ptr)
	var objs []MlServicesClusterSpecGateway
	if obj != nil {
		objs = []MlServicesClusterSpecGateway{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecGateway{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MlServicesClusterSpecGatewayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MlServicesClusterSpecGateway)(ptr) = MlServicesClusterSpecGateway{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MlServicesClusterSpecGateway

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecGateway{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MlServicesClusterSpecGateway)(ptr) = objs[0]
			} else {
				*(*MlServicesClusterSpecGateway)(ptr) = MlServicesClusterSpecGateway{}
			}
		} else {
			*(*MlServicesClusterSpecGateway)(ptr) = MlServicesClusterSpecGateway{}
		}
	default:
		iter.ReportError("decode MlServicesClusterSpecGateway", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MlServicesClusterSpecRolesCodec struct {
}

func (MlServicesClusterSpecRolesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MlServicesClusterSpecRoles)(ptr) == nil
}

func (MlServicesClusterSpecRolesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MlServicesClusterSpecRoles)(ptr)
	var objs []MlServicesClusterSpecRoles
	if obj != nil {
		objs = []MlServicesClusterSpecRoles{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecRoles{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MlServicesClusterSpecRolesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MlServicesClusterSpecRoles)(ptr) = MlServicesClusterSpecRoles{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MlServicesClusterSpecRoles

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecRoles{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MlServicesClusterSpecRoles)(ptr) = objs[0]
			} else {
				*(*MlServicesClusterSpecRoles)(ptr) = MlServicesClusterSpecRoles{}
			}
		} else {
			*(*MlServicesClusterSpecRoles)(ptr) = MlServicesClusterSpecRoles{}
		}
	default:
		iter.ReportError("decode MlServicesClusterSpecRoles", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MlServicesClusterSpecRolesEdgeNodeCodec struct {
}

func (MlServicesClusterSpecRolesEdgeNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MlServicesClusterSpecRolesEdgeNode)(ptr) == nil
}

func (MlServicesClusterSpecRolesEdgeNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MlServicesClusterSpecRolesEdgeNode)(ptr)
	var objs []MlServicesClusterSpecRolesEdgeNode
	if obj != nil {
		objs = []MlServicesClusterSpecRolesEdgeNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecRolesEdgeNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MlServicesClusterSpecRolesEdgeNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MlServicesClusterSpecRolesEdgeNode)(ptr) = MlServicesClusterSpecRolesEdgeNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MlServicesClusterSpecRolesEdgeNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecRolesEdgeNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MlServicesClusterSpecRolesEdgeNode)(ptr) = objs[0]
			} else {
				*(*MlServicesClusterSpecRolesEdgeNode)(ptr) = MlServicesClusterSpecRolesEdgeNode{}
			}
		} else {
			*(*MlServicesClusterSpecRolesEdgeNode)(ptr) = MlServicesClusterSpecRolesEdgeNode{}
		}
	default:
		iter.ReportError("decode MlServicesClusterSpecRolesEdgeNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MlServicesClusterSpecRolesHeadNodeCodec struct {
}

func (MlServicesClusterSpecRolesHeadNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MlServicesClusterSpecRolesHeadNode)(ptr) == nil
}

func (MlServicesClusterSpecRolesHeadNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MlServicesClusterSpecRolesHeadNode)(ptr)
	var objs []MlServicesClusterSpecRolesHeadNode
	if obj != nil {
		objs = []MlServicesClusterSpecRolesHeadNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecRolesHeadNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MlServicesClusterSpecRolesHeadNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MlServicesClusterSpecRolesHeadNode)(ptr) = MlServicesClusterSpecRolesHeadNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MlServicesClusterSpecRolesHeadNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecRolesHeadNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MlServicesClusterSpecRolesHeadNode)(ptr) = objs[0]
			} else {
				*(*MlServicesClusterSpecRolesHeadNode)(ptr) = MlServicesClusterSpecRolesHeadNode{}
			}
		} else {
			*(*MlServicesClusterSpecRolesHeadNode)(ptr) = MlServicesClusterSpecRolesHeadNode{}
		}
	default:
		iter.ReportError("decode MlServicesClusterSpecRolesHeadNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MlServicesClusterSpecRolesWorkerNodeCodec struct {
}

func (MlServicesClusterSpecRolesWorkerNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MlServicesClusterSpecRolesWorkerNode)(ptr) == nil
}

func (MlServicesClusterSpecRolesWorkerNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MlServicesClusterSpecRolesWorkerNode)(ptr)
	var objs []MlServicesClusterSpecRolesWorkerNode
	if obj != nil {
		objs = []MlServicesClusterSpecRolesWorkerNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecRolesWorkerNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MlServicesClusterSpecRolesWorkerNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MlServicesClusterSpecRolesWorkerNode)(ptr) = MlServicesClusterSpecRolesWorkerNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MlServicesClusterSpecRolesWorkerNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecRolesWorkerNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MlServicesClusterSpecRolesWorkerNode)(ptr) = objs[0]
			} else {
				*(*MlServicesClusterSpecRolesWorkerNode)(ptr) = MlServicesClusterSpecRolesWorkerNode{}
			}
		} else {
			*(*MlServicesClusterSpecRolesWorkerNode)(ptr) = MlServicesClusterSpecRolesWorkerNode{}
		}
	default:
		iter.ReportError("decode MlServicesClusterSpecRolesWorkerNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MlServicesClusterSpecRolesZookeeperNodeCodec struct {
}

func (MlServicesClusterSpecRolesZookeeperNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MlServicesClusterSpecRolesZookeeperNode)(ptr) == nil
}

func (MlServicesClusterSpecRolesZookeeperNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MlServicesClusterSpecRolesZookeeperNode)(ptr)
	var objs []MlServicesClusterSpecRolesZookeeperNode
	if obj != nil {
		objs = []MlServicesClusterSpecRolesZookeeperNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecRolesZookeeperNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MlServicesClusterSpecRolesZookeeperNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MlServicesClusterSpecRolesZookeeperNode)(ptr) = MlServicesClusterSpecRolesZookeeperNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MlServicesClusterSpecRolesZookeeperNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MlServicesClusterSpecRolesZookeeperNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MlServicesClusterSpecRolesZookeeperNode)(ptr) = objs[0]
			} else {
				*(*MlServicesClusterSpecRolesZookeeperNode)(ptr) = MlServicesClusterSpecRolesZookeeperNode{}
			}
		} else {
			*(*MlServicesClusterSpecRolesZookeeperNode)(ptr) = MlServicesClusterSpecRolesZookeeperNode{}
		}
	default:
		iter.ReportError("decode MlServicesClusterSpecRolesZookeeperNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RserverClusterSpecGatewayCodec struct {
}

func (RserverClusterSpecGatewayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RserverClusterSpecGateway)(ptr) == nil
}

func (RserverClusterSpecGatewayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RserverClusterSpecGateway)(ptr)
	var objs []RserverClusterSpecGateway
	if obj != nil {
		objs = []RserverClusterSpecGateway{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecGateway{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RserverClusterSpecGatewayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RserverClusterSpecGateway)(ptr) = RserverClusterSpecGateway{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RserverClusterSpecGateway

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecGateway{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RserverClusterSpecGateway)(ptr) = objs[0]
			} else {
				*(*RserverClusterSpecGateway)(ptr) = RserverClusterSpecGateway{}
			}
		} else {
			*(*RserverClusterSpecGateway)(ptr) = RserverClusterSpecGateway{}
		}
	default:
		iter.ReportError("decode RserverClusterSpecGateway", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RserverClusterSpecRolesCodec struct {
}

func (RserverClusterSpecRolesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RserverClusterSpecRoles)(ptr) == nil
}

func (RserverClusterSpecRolesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RserverClusterSpecRoles)(ptr)
	var objs []RserverClusterSpecRoles
	if obj != nil {
		objs = []RserverClusterSpecRoles{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecRoles{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RserverClusterSpecRolesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RserverClusterSpecRoles)(ptr) = RserverClusterSpecRoles{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RserverClusterSpecRoles

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecRoles{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RserverClusterSpecRoles)(ptr) = objs[0]
			} else {
				*(*RserverClusterSpecRoles)(ptr) = RserverClusterSpecRoles{}
			}
		} else {
			*(*RserverClusterSpecRoles)(ptr) = RserverClusterSpecRoles{}
		}
	default:
		iter.ReportError("decode RserverClusterSpecRoles", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RserverClusterSpecRolesEdgeNodeCodec struct {
}

func (RserverClusterSpecRolesEdgeNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RserverClusterSpecRolesEdgeNode)(ptr) == nil
}

func (RserverClusterSpecRolesEdgeNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RserverClusterSpecRolesEdgeNode)(ptr)
	var objs []RserverClusterSpecRolesEdgeNode
	if obj != nil {
		objs = []RserverClusterSpecRolesEdgeNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecRolesEdgeNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RserverClusterSpecRolesEdgeNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RserverClusterSpecRolesEdgeNode)(ptr) = RserverClusterSpecRolesEdgeNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RserverClusterSpecRolesEdgeNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecRolesEdgeNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RserverClusterSpecRolesEdgeNode)(ptr) = objs[0]
			} else {
				*(*RserverClusterSpecRolesEdgeNode)(ptr) = RserverClusterSpecRolesEdgeNode{}
			}
		} else {
			*(*RserverClusterSpecRolesEdgeNode)(ptr) = RserverClusterSpecRolesEdgeNode{}
		}
	default:
		iter.ReportError("decode RserverClusterSpecRolesEdgeNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RserverClusterSpecRolesHeadNodeCodec struct {
}

func (RserverClusterSpecRolesHeadNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RserverClusterSpecRolesHeadNode)(ptr) == nil
}

func (RserverClusterSpecRolesHeadNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RserverClusterSpecRolesHeadNode)(ptr)
	var objs []RserverClusterSpecRolesHeadNode
	if obj != nil {
		objs = []RserverClusterSpecRolesHeadNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecRolesHeadNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RserverClusterSpecRolesHeadNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RserverClusterSpecRolesHeadNode)(ptr) = RserverClusterSpecRolesHeadNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RserverClusterSpecRolesHeadNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecRolesHeadNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RserverClusterSpecRolesHeadNode)(ptr) = objs[0]
			} else {
				*(*RserverClusterSpecRolesHeadNode)(ptr) = RserverClusterSpecRolesHeadNode{}
			}
		} else {
			*(*RserverClusterSpecRolesHeadNode)(ptr) = RserverClusterSpecRolesHeadNode{}
		}
	default:
		iter.ReportError("decode RserverClusterSpecRolesHeadNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RserverClusterSpecRolesWorkerNodeCodec struct {
}

func (RserverClusterSpecRolesWorkerNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RserverClusterSpecRolesWorkerNode)(ptr) == nil
}

func (RserverClusterSpecRolesWorkerNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RserverClusterSpecRolesWorkerNode)(ptr)
	var objs []RserverClusterSpecRolesWorkerNode
	if obj != nil {
		objs = []RserverClusterSpecRolesWorkerNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecRolesWorkerNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RserverClusterSpecRolesWorkerNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RserverClusterSpecRolesWorkerNode)(ptr) = RserverClusterSpecRolesWorkerNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RserverClusterSpecRolesWorkerNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecRolesWorkerNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RserverClusterSpecRolesWorkerNode)(ptr) = objs[0]
			} else {
				*(*RserverClusterSpecRolesWorkerNode)(ptr) = RserverClusterSpecRolesWorkerNode{}
			}
		} else {
			*(*RserverClusterSpecRolesWorkerNode)(ptr) = RserverClusterSpecRolesWorkerNode{}
		}
	default:
		iter.ReportError("decode RserverClusterSpecRolesWorkerNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RserverClusterSpecRolesZookeeperNodeCodec struct {
}

func (RserverClusterSpecRolesZookeeperNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RserverClusterSpecRolesZookeeperNode)(ptr) == nil
}

func (RserverClusterSpecRolesZookeeperNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RserverClusterSpecRolesZookeeperNode)(ptr)
	var objs []RserverClusterSpecRolesZookeeperNode
	if obj != nil {
		objs = []RserverClusterSpecRolesZookeeperNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecRolesZookeeperNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RserverClusterSpecRolesZookeeperNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RserverClusterSpecRolesZookeeperNode)(ptr) = RserverClusterSpecRolesZookeeperNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RserverClusterSpecRolesZookeeperNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RserverClusterSpecRolesZookeeperNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RserverClusterSpecRolesZookeeperNode)(ptr) = objs[0]
			} else {
				*(*RserverClusterSpecRolesZookeeperNode)(ptr) = RserverClusterSpecRolesZookeeperNode{}
			}
		} else {
			*(*RserverClusterSpecRolesZookeeperNode)(ptr) = RserverClusterSpecRolesZookeeperNode{}
		}
	default:
		iter.ReportError("decode RserverClusterSpecRolesZookeeperNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SparkClusterSpecComponentVersionCodec struct {
}

func (SparkClusterSpecComponentVersionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SparkClusterSpecComponentVersion)(ptr) == nil
}

func (SparkClusterSpecComponentVersionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SparkClusterSpecComponentVersion)(ptr)
	var objs []SparkClusterSpecComponentVersion
	if obj != nil {
		objs = []SparkClusterSpecComponentVersion{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecComponentVersion{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SparkClusterSpecComponentVersionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SparkClusterSpecComponentVersion)(ptr) = SparkClusterSpecComponentVersion{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SparkClusterSpecComponentVersion

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecComponentVersion{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SparkClusterSpecComponentVersion)(ptr) = objs[0]
			} else {
				*(*SparkClusterSpecComponentVersion)(ptr) = SparkClusterSpecComponentVersion{}
			}
		} else {
			*(*SparkClusterSpecComponentVersion)(ptr) = SparkClusterSpecComponentVersion{}
		}
	default:
		iter.ReportError("decode SparkClusterSpecComponentVersion", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SparkClusterSpecGatewayCodec struct {
}

func (SparkClusterSpecGatewayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SparkClusterSpecGateway)(ptr) == nil
}

func (SparkClusterSpecGatewayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SparkClusterSpecGateway)(ptr)
	var objs []SparkClusterSpecGateway
	if obj != nil {
		objs = []SparkClusterSpecGateway{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecGateway{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SparkClusterSpecGatewayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SparkClusterSpecGateway)(ptr) = SparkClusterSpecGateway{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SparkClusterSpecGateway

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecGateway{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SparkClusterSpecGateway)(ptr) = objs[0]
			} else {
				*(*SparkClusterSpecGateway)(ptr) = SparkClusterSpecGateway{}
			}
		} else {
			*(*SparkClusterSpecGateway)(ptr) = SparkClusterSpecGateway{}
		}
	default:
		iter.ReportError("decode SparkClusterSpecGateway", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SparkClusterSpecMetastoresCodec struct {
}

func (SparkClusterSpecMetastoresCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SparkClusterSpecMetastores)(ptr) == nil
}

func (SparkClusterSpecMetastoresCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SparkClusterSpecMetastores)(ptr)
	var objs []SparkClusterSpecMetastores
	if obj != nil {
		objs = []SparkClusterSpecMetastores{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecMetastores{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SparkClusterSpecMetastoresCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SparkClusterSpecMetastores)(ptr) = SparkClusterSpecMetastores{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SparkClusterSpecMetastores

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecMetastores{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SparkClusterSpecMetastores)(ptr) = objs[0]
			} else {
				*(*SparkClusterSpecMetastores)(ptr) = SparkClusterSpecMetastores{}
			}
		} else {
			*(*SparkClusterSpecMetastores)(ptr) = SparkClusterSpecMetastores{}
		}
	default:
		iter.ReportError("decode SparkClusterSpecMetastores", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SparkClusterSpecMetastoresAmbariCodec struct {
}

func (SparkClusterSpecMetastoresAmbariCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SparkClusterSpecMetastoresAmbari)(ptr) == nil
}

func (SparkClusterSpecMetastoresAmbariCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SparkClusterSpecMetastoresAmbari)(ptr)
	var objs []SparkClusterSpecMetastoresAmbari
	if obj != nil {
		objs = []SparkClusterSpecMetastoresAmbari{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecMetastoresAmbari{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SparkClusterSpecMetastoresAmbariCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SparkClusterSpecMetastoresAmbari)(ptr) = SparkClusterSpecMetastoresAmbari{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SparkClusterSpecMetastoresAmbari

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecMetastoresAmbari{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SparkClusterSpecMetastoresAmbari)(ptr) = objs[0]
			} else {
				*(*SparkClusterSpecMetastoresAmbari)(ptr) = SparkClusterSpecMetastoresAmbari{}
			}
		} else {
			*(*SparkClusterSpecMetastoresAmbari)(ptr) = SparkClusterSpecMetastoresAmbari{}
		}
	default:
		iter.ReportError("decode SparkClusterSpecMetastoresAmbari", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SparkClusterSpecMetastoresHiveCodec struct {
}

func (SparkClusterSpecMetastoresHiveCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SparkClusterSpecMetastoresHive)(ptr) == nil
}

func (SparkClusterSpecMetastoresHiveCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SparkClusterSpecMetastoresHive)(ptr)
	var objs []SparkClusterSpecMetastoresHive
	if obj != nil {
		objs = []SparkClusterSpecMetastoresHive{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecMetastoresHive{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SparkClusterSpecMetastoresHiveCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SparkClusterSpecMetastoresHive)(ptr) = SparkClusterSpecMetastoresHive{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SparkClusterSpecMetastoresHive

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecMetastoresHive{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SparkClusterSpecMetastoresHive)(ptr) = objs[0]
			} else {
				*(*SparkClusterSpecMetastoresHive)(ptr) = SparkClusterSpecMetastoresHive{}
			}
		} else {
			*(*SparkClusterSpecMetastoresHive)(ptr) = SparkClusterSpecMetastoresHive{}
		}
	default:
		iter.ReportError("decode SparkClusterSpecMetastoresHive", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SparkClusterSpecMetastoresOozieCodec struct {
}

func (SparkClusterSpecMetastoresOozieCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SparkClusterSpecMetastoresOozie)(ptr) == nil
}

func (SparkClusterSpecMetastoresOozieCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SparkClusterSpecMetastoresOozie)(ptr)
	var objs []SparkClusterSpecMetastoresOozie
	if obj != nil {
		objs = []SparkClusterSpecMetastoresOozie{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecMetastoresOozie{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SparkClusterSpecMetastoresOozieCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SparkClusterSpecMetastoresOozie)(ptr) = SparkClusterSpecMetastoresOozie{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SparkClusterSpecMetastoresOozie

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecMetastoresOozie{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SparkClusterSpecMetastoresOozie)(ptr) = objs[0]
			} else {
				*(*SparkClusterSpecMetastoresOozie)(ptr) = SparkClusterSpecMetastoresOozie{}
			}
		} else {
			*(*SparkClusterSpecMetastoresOozie)(ptr) = SparkClusterSpecMetastoresOozie{}
		}
	default:
		iter.ReportError("decode SparkClusterSpecMetastoresOozie", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SparkClusterSpecMonitorCodec struct {
}

func (SparkClusterSpecMonitorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SparkClusterSpecMonitor)(ptr) == nil
}

func (SparkClusterSpecMonitorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SparkClusterSpecMonitor)(ptr)
	var objs []SparkClusterSpecMonitor
	if obj != nil {
		objs = []SparkClusterSpecMonitor{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecMonitor{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SparkClusterSpecMonitorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SparkClusterSpecMonitor)(ptr) = SparkClusterSpecMonitor{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SparkClusterSpecMonitor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecMonitor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SparkClusterSpecMonitor)(ptr) = objs[0]
			} else {
				*(*SparkClusterSpecMonitor)(ptr) = SparkClusterSpecMonitor{}
			}
		} else {
			*(*SparkClusterSpecMonitor)(ptr) = SparkClusterSpecMonitor{}
		}
	default:
		iter.ReportError("decode SparkClusterSpecMonitor", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SparkClusterSpecNetworkCodec struct {
}

func (SparkClusterSpecNetworkCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SparkClusterSpecNetwork)(ptr) == nil
}

func (SparkClusterSpecNetworkCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SparkClusterSpecNetwork)(ptr)
	var objs []SparkClusterSpecNetwork
	if obj != nil {
		objs = []SparkClusterSpecNetwork{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecNetwork{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SparkClusterSpecNetworkCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SparkClusterSpecNetwork)(ptr) = SparkClusterSpecNetwork{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SparkClusterSpecNetwork

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecNetwork{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SparkClusterSpecNetwork)(ptr) = objs[0]
			} else {
				*(*SparkClusterSpecNetwork)(ptr) = SparkClusterSpecNetwork{}
			}
		} else {
			*(*SparkClusterSpecNetwork)(ptr) = SparkClusterSpecNetwork{}
		}
	default:
		iter.ReportError("decode SparkClusterSpecNetwork", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SparkClusterSpecRolesCodec struct {
}

func (SparkClusterSpecRolesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SparkClusterSpecRoles)(ptr) == nil
}

func (SparkClusterSpecRolesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SparkClusterSpecRoles)(ptr)
	var objs []SparkClusterSpecRoles
	if obj != nil {
		objs = []SparkClusterSpecRoles{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRoles{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SparkClusterSpecRolesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SparkClusterSpecRoles)(ptr) = SparkClusterSpecRoles{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SparkClusterSpecRoles

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRoles{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SparkClusterSpecRoles)(ptr) = objs[0]
			} else {
				*(*SparkClusterSpecRoles)(ptr) = SparkClusterSpecRoles{}
			}
		} else {
			*(*SparkClusterSpecRoles)(ptr) = SparkClusterSpecRoles{}
		}
	default:
		iter.ReportError("decode SparkClusterSpecRoles", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SparkClusterSpecRolesHeadNodeCodec struct {
}

func (SparkClusterSpecRolesHeadNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SparkClusterSpecRolesHeadNode)(ptr) == nil
}

func (SparkClusterSpecRolesHeadNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SparkClusterSpecRolesHeadNode)(ptr)
	var objs []SparkClusterSpecRolesHeadNode
	if obj != nil {
		objs = []SparkClusterSpecRolesHeadNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesHeadNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SparkClusterSpecRolesHeadNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SparkClusterSpecRolesHeadNode)(ptr) = SparkClusterSpecRolesHeadNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SparkClusterSpecRolesHeadNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesHeadNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SparkClusterSpecRolesHeadNode)(ptr) = objs[0]
			} else {
				*(*SparkClusterSpecRolesHeadNode)(ptr) = SparkClusterSpecRolesHeadNode{}
			}
		} else {
			*(*SparkClusterSpecRolesHeadNode)(ptr) = SparkClusterSpecRolesHeadNode{}
		}
	default:
		iter.ReportError("decode SparkClusterSpecRolesHeadNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SparkClusterSpecRolesWorkerNodeCodec struct {
}

func (SparkClusterSpecRolesWorkerNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SparkClusterSpecRolesWorkerNode)(ptr) == nil
}

func (SparkClusterSpecRolesWorkerNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SparkClusterSpecRolesWorkerNode)(ptr)
	var objs []SparkClusterSpecRolesWorkerNode
	if obj != nil {
		objs = []SparkClusterSpecRolesWorkerNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesWorkerNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SparkClusterSpecRolesWorkerNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SparkClusterSpecRolesWorkerNode)(ptr) = SparkClusterSpecRolesWorkerNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SparkClusterSpecRolesWorkerNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesWorkerNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SparkClusterSpecRolesWorkerNode)(ptr) = objs[0]
			} else {
				*(*SparkClusterSpecRolesWorkerNode)(ptr) = SparkClusterSpecRolesWorkerNode{}
			}
		} else {
			*(*SparkClusterSpecRolesWorkerNode)(ptr) = SparkClusterSpecRolesWorkerNode{}
		}
	default:
		iter.ReportError("decode SparkClusterSpecRolesWorkerNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SparkClusterSpecRolesWorkerNodeAutoscaleCodec struct {
}

func (SparkClusterSpecRolesWorkerNodeAutoscaleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SparkClusterSpecRolesWorkerNodeAutoscale)(ptr) == nil
}

func (SparkClusterSpecRolesWorkerNodeAutoscaleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SparkClusterSpecRolesWorkerNodeAutoscale)(ptr)
	var objs []SparkClusterSpecRolesWorkerNodeAutoscale
	if obj != nil {
		objs = []SparkClusterSpecRolesWorkerNodeAutoscale{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesWorkerNodeAutoscale{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SparkClusterSpecRolesWorkerNodeAutoscaleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SparkClusterSpecRolesWorkerNodeAutoscale)(ptr) = SparkClusterSpecRolesWorkerNodeAutoscale{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SparkClusterSpecRolesWorkerNodeAutoscale

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesWorkerNodeAutoscale{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SparkClusterSpecRolesWorkerNodeAutoscale)(ptr) = objs[0]
			} else {
				*(*SparkClusterSpecRolesWorkerNodeAutoscale)(ptr) = SparkClusterSpecRolesWorkerNodeAutoscale{}
			}
		} else {
			*(*SparkClusterSpecRolesWorkerNodeAutoscale)(ptr) = SparkClusterSpecRolesWorkerNodeAutoscale{}
		}
	default:
		iter.ReportError("decode SparkClusterSpecRolesWorkerNodeAutoscale", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SparkClusterSpecRolesWorkerNodeAutoscaleCapacityCodec struct {
}

func (SparkClusterSpecRolesWorkerNodeAutoscaleCapacityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SparkClusterSpecRolesWorkerNodeAutoscaleCapacity)(ptr) == nil
}

func (SparkClusterSpecRolesWorkerNodeAutoscaleCapacityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SparkClusterSpecRolesWorkerNodeAutoscaleCapacity)(ptr)
	var objs []SparkClusterSpecRolesWorkerNodeAutoscaleCapacity
	if obj != nil {
		objs = []SparkClusterSpecRolesWorkerNodeAutoscaleCapacity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesWorkerNodeAutoscaleCapacity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SparkClusterSpecRolesWorkerNodeAutoscaleCapacityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SparkClusterSpecRolesWorkerNodeAutoscaleCapacity)(ptr) = SparkClusterSpecRolesWorkerNodeAutoscaleCapacity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SparkClusterSpecRolesWorkerNodeAutoscaleCapacity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesWorkerNodeAutoscaleCapacity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SparkClusterSpecRolesWorkerNodeAutoscaleCapacity)(ptr) = objs[0]
			} else {
				*(*SparkClusterSpecRolesWorkerNodeAutoscaleCapacity)(ptr) = SparkClusterSpecRolesWorkerNodeAutoscaleCapacity{}
			}
		} else {
			*(*SparkClusterSpecRolesWorkerNodeAutoscaleCapacity)(ptr) = SparkClusterSpecRolesWorkerNodeAutoscaleCapacity{}
		}
	default:
		iter.ReportError("decode SparkClusterSpecRolesWorkerNodeAutoscaleCapacity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SparkClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec struct {
}

func (SparkClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SparkClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr) == nil
}

func (SparkClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SparkClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr)
	var objs []SparkClusterSpecRolesWorkerNodeAutoscaleRecurrence
	if obj != nil {
		objs = []SparkClusterSpecRolesWorkerNodeAutoscaleRecurrence{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesWorkerNodeAutoscaleRecurrence{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SparkClusterSpecRolesWorkerNodeAutoscaleRecurrenceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SparkClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr) = SparkClusterSpecRolesWorkerNodeAutoscaleRecurrence{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SparkClusterSpecRolesWorkerNodeAutoscaleRecurrence

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesWorkerNodeAutoscaleRecurrence{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SparkClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr) = objs[0]
			} else {
				*(*SparkClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr) = SparkClusterSpecRolesWorkerNodeAutoscaleRecurrence{}
			}
		} else {
			*(*SparkClusterSpecRolesWorkerNodeAutoscaleRecurrence)(ptr) = SparkClusterSpecRolesWorkerNodeAutoscaleRecurrence{}
		}
	default:
		iter.ReportError("decode SparkClusterSpecRolesWorkerNodeAutoscaleRecurrence", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SparkClusterSpecRolesZookeeperNodeCodec struct {
}

func (SparkClusterSpecRolesZookeeperNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SparkClusterSpecRolesZookeeperNode)(ptr) == nil
}

func (SparkClusterSpecRolesZookeeperNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SparkClusterSpecRolesZookeeperNode)(ptr)
	var objs []SparkClusterSpecRolesZookeeperNode
	if obj != nil {
		objs = []SparkClusterSpecRolesZookeeperNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesZookeeperNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SparkClusterSpecRolesZookeeperNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SparkClusterSpecRolesZookeeperNode)(ptr) = SparkClusterSpecRolesZookeeperNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SparkClusterSpecRolesZookeeperNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecRolesZookeeperNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SparkClusterSpecRolesZookeeperNode)(ptr) = objs[0]
			} else {
				*(*SparkClusterSpecRolesZookeeperNode)(ptr) = SparkClusterSpecRolesZookeeperNode{}
			}
		} else {
			*(*SparkClusterSpecRolesZookeeperNode)(ptr) = SparkClusterSpecRolesZookeeperNode{}
		}
	default:
		iter.ReportError("decode SparkClusterSpecRolesZookeeperNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SparkClusterSpecStorageAccountGen2Codec struct {
}

func (SparkClusterSpecStorageAccountGen2Codec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SparkClusterSpecStorageAccountGen2)(ptr) == nil
}

func (SparkClusterSpecStorageAccountGen2Codec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SparkClusterSpecStorageAccountGen2)(ptr)
	var objs []SparkClusterSpecStorageAccountGen2
	if obj != nil {
		objs = []SparkClusterSpecStorageAccountGen2{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecStorageAccountGen2{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SparkClusterSpecStorageAccountGen2Codec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SparkClusterSpecStorageAccountGen2)(ptr) = SparkClusterSpecStorageAccountGen2{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SparkClusterSpecStorageAccountGen2

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SparkClusterSpecStorageAccountGen2{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SparkClusterSpecStorageAccountGen2)(ptr) = objs[0]
			} else {
				*(*SparkClusterSpecStorageAccountGen2)(ptr) = SparkClusterSpecStorageAccountGen2{}
			}
		} else {
			*(*SparkClusterSpecStorageAccountGen2)(ptr) = SparkClusterSpecStorageAccountGen2{}
		}
	default:
		iter.ReportError("decode SparkClusterSpecStorageAccountGen2", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StormClusterSpecComponentVersionCodec struct {
}

func (StormClusterSpecComponentVersionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StormClusterSpecComponentVersion)(ptr) == nil
}

func (StormClusterSpecComponentVersionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StormClusterSpecComponentVersion)(ptr)
	var objs []StormClusterSpecComponentVersion
	if obj != nil {
		objs = []StormClusterSpecComponentVersion{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecComponentVersion{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StormClusterSpecComponentVersionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StormClusterSpecComponentVersion)(ptr) = StormClusterSpecComponentVersion{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StormClusterSpecComponentVersion

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecComponentVersion{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StormClusterSpecComponentVersion)(ptr) = objs[0]
			} else {
				*(*StormClusterSpecComponentVersion)(ptr) = StormClusterSpecComponentVersion{}
			}
		} else {
			*(*StormClusterSpecComponentVersion)(ptr) = StormClusterSpecComponentVersion{}
		}
	default:
		iter.ReportError("decode StormClusterSpecComponentVersion", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StormClusterSpecGatewayCodec struct {
}

func (StormClusterSpecGatewayCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StormClusterSpecGateway)(ptr) == nil
}

func (StormClusterSpecGatewayCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StormClusterSpecGateway)(ptr)
	var objs []StormClusterSpecGateway
	if obj != nil {
		objs = []StormClusterSpecGateway{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecGateway{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StormClusterSpecGatewayCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StormClusterSpecGateway)(ptr) = StormClusterSpecGateway{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StormClusterSpecGateway

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecGateway{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StormClusterSpecGateway)(ptr) = objs[0]
			} else {
				*(*StormClusterSpecGateway)(ptr) = StormClusterSpecGateway{}
			}
		} else {
			*(*StormClusterSpecGateway)(ptr) = StormClusterSpecGateway{}
		}
	default:
		iter.ReportError("decode StormClusterSpecGateway", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StormClusterSpecMetastoresCodec struct {
}

func (StormClusterSpecMetastoresCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StormClusterSpecMetastores)(ptr) == nil
}

func (StormClusterSpecMetastoresCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StormClusterSpecMetastores)(ptr)
	var objs []StormClusterSpecMetastores
	if obj != nil {
		objs = []StormClusterSpecMetastores{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecMetastores{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StormClusterSpecMetastoresCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StormClusterSpecMetastores)(ptr) = StormClusterSpecMetastores{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StormClusterSpecMetastores

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecMetastores{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StormClusterSpecMetastores)(ptr) = objs[0]
			} else {
				*(*StormClusterSpecMetastores)(ptr) = StormClusterSpecMetastores{}
			}
		} else {
			*(*StormClusterSpecMetastores)(ptr) = StormClusterSpecMetastores{}
		}
	default:
		iter.ReportError("decode StormClusterSpecMetastores", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StormClusterSpecMetastoresAmbariCodec struct {
}

func (StormClusterSpecMetastoresAmbariCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StormClusterSpecMetastoresAmbari)(ptr) == nil
}

func (StormClusterSpecMetastoresAmbariCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StormClusterSpecMetastoresAmbari)(ptr)
	var objs []StormClusterSpecMetastoresAmbari
	if obj != nil {
		objs = []StormClusterSpecMetastoresAmbari{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecMetastoresAmbari{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StormClusterSpecMetastoresAmbariCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StormClusterSpecMetastoresAmbari)(ptr) = StormClusterSpecMetastoresAmbari{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StormClusterSpecMetastoresAmbari

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecMetastoresAmbari{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StormClusterSpecMetastoresAmbari)(ptr) = objs[0]
			} else {
				*(*StormClusterSpecMetastoresAmbari)(ptr) = StormClusterSpecMetastoresAmbari{}
			}
		} else {
			*(*StormClusterSpecMetastoresAmbari)(ptr) = StormClusterSpecMetastoresAmbari{}
		}
	default:
		iter.ReportError("decode StormClusterSpecMetastoresAmbari", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StormClusterSpecMetastoresHiveCodec struct {
}

func (StormClusterSpecMetastoresHiveCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StormClusterSpecMetastoresHive)(ptr) == nil
}

func (StormClusterSpecMetastoresHiveCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StormClusterSpecMetastoresHive)(ptr)
	var objs []StormClusterSpecMetastoresHive
	if obj != nil {
		objs = []StormClusterSpecMetastoresHive{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecMetastoresHive{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StormClusterSpecMetastoresHiveCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StormClusterSpecMetastoresHive)(ptr) = StormClusterSpecMetastoresHive{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StormClusterSpecMetastoresHive

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecMetastoresHive{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StormClusterSpecMetastoresHive)(ptr) = objs[0]
			} else {
				*(*StormClusterSpecMetastoresHive)(ptr) = StormClusterSpecMetastoresHive{}
			}
		} else {
			*(*StormClusterSpecMetastoresHive)(ptr) = StormClusterSpecMetastoresHive{}
		}
	default:
		iter.ReportError("decode StormClusterSpecMetastoresHive", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StormClusterSpecMetastoresOozieCodec struct {
}

func (StormClusterSpecMetastoresOozieCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StormClusterSpecMetastoresOozie)(ptr) == nil
}

func (StormClusterSpecMetastoresOozieCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StormClusterSpecMetastoresOozie)(ptr)
	var objs []StormClusterSpecMetastoresOozie
	if obj != nil {
		objs = []StormClusterSpecMetastoresOozie{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecMetastoresOozie{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StormClusterSpecMetastoresOozieCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StormClusterSpecMetastoresOozie)(ptr) = StormClusterSpecMetastoresOozie{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StormClusterSpecMetastoresOozie

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecMetastoresOozie{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StormClusterSpecMetastoresOozie)(ptr) = objs[0]
			} else {
				*(*StormClusterSpecMetastoresOozie)(ptr) = StormClusterSpecMetastoresOozie{}
			}
		} else {
			*(*StormClusterSpecMetastoresOozie)(ptr) = StormClusterSpecMetastoresOozie{}
		}
	default:
		iter.ReportError("decode StormClusterSpecMetastoresOozie", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StormClusterSpecMonitorCodec struct {
}

func (StormClusterSpecMonitorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StormClusterSpecMonitor)(ptr) == nil
}

func (StormClusterSpecMonitorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StormClusterSpecMonitor)(ptr)
	var objs []StormClusterSpecMonitor
	if obj != nil {
		objs = []StormClusterSpecMonitor{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecMonitor{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StormClusterSpecMonitorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StormClusterSpecMonitor)(ptr) = StormClusterSpecMonitor{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StormClusterSpecMonitor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecMonitor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StormClusterSpecMonitor)(ptr) = objs[0]
			} else {
				*(*StormClusterSpecMonitor)(ptr) = StormClusterSpecMonitor{}
			}
		} else {
			*(*StormClusterSpecMonitor)(ptr) = StormClusterSpecMonitor{}
		}
	default:
		iter.ReportError("decode StormClusterSpecMonitor", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StormClusterSpecRolesCodec struct {
}

func (StormClusterSpecRolesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StormClusterSpecRoles)(ptr) == nil
}

func (StormClusterSpecRolesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StormClusterSpecRoles)(ptr)
	var objs []StormClusterSpecRoles
	if obj != nil {
		objs = []StormClusterSpecRoles{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecRoles{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StormClusterSpecRolesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StormClusterSpecRoles)(ptr) = StormClusterSpecRoles{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StormClusterSpecRoles

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecRoles{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StormClusterSpecRoles)(ptr) = objs[0]
			} else {
				*(*StormClusterSpecRoles)(ptr) = StormClusterSpecRoles{}
			}
		} else {
			*(*StormClusterSpecRoles)(ptr) = StormClusterSpecRoles{}
		}
	default:
		iter.ReportError("decode StormClusterSpecRoles", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StormClusterSpecRolesHeadNodeCodec struct {
}

func (StormClusterSpecRolesHeadNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StormClusterSpecRolesHeadNode)(ptr) == nil
}

func (StormClusterSpecRolesHeadNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StormClusterSpecRolesHeadNode)(ptr)
	var objs []StormClusterSpecRolesHeadNode
	if obj != nil {
		objs = []StormClusterSpecRolesHeadNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecRolesHeadNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StormClusterSpecRolesHeadNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StormClusterSpecRolesHeadNode)(ptr) = StormClusterSpecRolesHeadNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StormClusterSpecRolesHeadNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecRolesHeadNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StormClusterSpecRolesHeadNode)(ptr) = objs[0]
			} else {
				*(*StormClusterSpecRolesHeadNode)(ptr) = StormClusterSpecRolesHeadNode{}
			}
		} else {
			*(*StormClusterSpecRolesHeadNode)(ptr) = StormClusterSpecRolesHeadNode{}
		}
	default:
		iter.ReportError("decode StormClusterSpecRolesHeadNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StormClusterSpecRolesWorkerNodeCodec struct {
}

func (StormClusterSpecRolesWorkerNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StormClusterSpecRolesWorkerNode)(ptr) == nil
}

func (StormClusterSpecRolesWorkerNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StormClusterSpecRolesWorkerNode)(ptr)
	var objs []StormClusterSpecRolesWorkerNode
	if obj != nil {
		objs = []StormClusterSpecRolesWorkerNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecRolesWorkerNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StormClusterSpecRolesWorkerNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StormClusterSpecRolesWorkerNode)(ptr) = StormClusterSpecRolesWorkerNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StormClusterSpecRolesWorkerNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecRolesWorkerNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StormClusterSpecRolesWorkerNode)(ptr) = objs[0]
			} else {
				*(*StormClusterSpecRolesWorkerNode)(ptr) = StormClusterSpecRolesWorkerNode{}
			}
		} else {
			*(*StormClusterSpecRolesWorkerNode)(ptr) = StormClusterSpecRolesWorkerNode{}
		}
	default:
		iter.ReportError("decode StormClusterSpecRolesWorkerNode", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type StormClusterSpecRolesZookeeperNodeCodec struct {
}

func (StormClusterSpecRolesZookeeperNodeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*StormClusterSpecRolesZookeeperNode)(ptr) == nil
}

func (StormClusterSpecRolesZookeeperNodeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*StormClusterSpecRolesZookeeperNode)(ptr)
	var objs []StormClusterSpecRolesZookeeperNode
	if obj != nil {
		objs = []StormClusterSpecRolesZookeeperNode{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecRolesZookeeperNode{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (StormClusterSpecRolesZookeeperNodeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*StormClusterSpecRolesZookeeperNode)(ptr) = StormClusterSpecRolesZookeeperNode{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []StormClusterSpecRolesZookeeperNode

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(StormClusterSpecRolesZookeeperNode{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*StormClusterSpecRolesZookeeperNode)(ptr) = objs[0]
			} else {
				*(*StormClusterSpecRolesZookeeperNode)(ptr) = StormClusterSpecRolesZookeeperNode{}
			}
		} else {
			*(*StormClusterSpecRolesZookeeperNode)(ptr) = StormClusterSpecRolesZookeeperNode{}
		}
	default:
		iter.ReportError("decode StormClusterSpecRolesZookeeperNode", "unexpected JSON type")
	}
}
