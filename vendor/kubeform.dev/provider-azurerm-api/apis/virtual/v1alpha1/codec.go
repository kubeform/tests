/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(DesktopHostPoolSpecRegistrationInfo{}).Type1()):                                          DesktopHostPoolSpecRegistrationInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HubConnectionSpecRouting{}).Type1()):                                                     HubConnectionSpecRoutingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HubConnectionSpecRoutingPropagatedRouteTable{}).Type1()):                                 HubConnectionSpecRoutingPropagatedRouteTableCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecAdditionalCapabilities{}).Type1()):                                            MachineSpecAdditionalCapabilitiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecBootDiagnostics{}).Type1()):                                                   MachineSpecBootDiagnosticsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecIdentity{}).Type1()):                                                          MachineSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecOsProfile{}).Type1()):                                                         MachineSpecOsProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecOsProfileLinuxConfig{}).Type1()):                                              MachineSpecOsProfileLinuxConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecOsProfileWindowsConfig{}).Type1()):                                            MachineSpecOsProfileWindowsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecPlan{}).Type1()):                                                              MachineSpecPlanCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecStorageImageReference{}).Type1()):                                             MachineSpecStorageImageReferenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecStorageOsDisk{}).Type1()):                                                     MachineSpecStorageOsDiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineConfigurationPolicyAssignmentSpecConfiguration{}).Type1()):                        MachineConfigurationPolicyAssignmentSpecConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecBootDiagnostics{}).Type1()):                                           MachineScaleSetSpecBootDiagnosticsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecIdentity{}).Type1()):                                                  MachineScaleSetSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecNetworkProfileDnsSettings{}).Type1()):                                 MachineScaleSetSpecNetworkProfileDnsSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecNetworkProfileIpConfigurationPublicIPAddressConfiguration{}).Type1()): MachineScaleSetSpecNetworkProfileIpConfigurationPublicIPAddressConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecOsProfile{}).Type1()):                                                 MachineScaleSetSpecOsProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecOsProfileLinuxConfig{}).Type1()):                                      MachineScaleSetSpecOsProfileLinuxConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecOsProfileWindowsConfig{}).Type1()):                                    MachineScaleSetSpecOsProfileWindowsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecPlan{}).Type1()):                                                      MachineScaleSetSpecPlanCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecRollingUpgradePolicy{}).Type1()):                                      MachineScaleSetSpecRollingUpgradePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecSku{}).Type1()):                                                       MachineScaleSetSpecSkuCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecStorageProfileImageReference{}).Type1()):                              MachineScaleSetSpecStorageProfileImageReferenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecStorageProfileOsDisk{}).Type1()):                                      MachineScaleSetSpecStorageProfileOsDiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkSpecDdosProtectionPlan{}).Type1()):                                                NetworkSpecDdosProtectionPlanCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkGatewaySpecBgpSettings{}).Type1()):                                                NetworkGatewaySpecBgpSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkGatewaySpecCustomRoute{}).Type1()):                                                NetworkGatewaySpecCustomRouteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkGatewaySpecVpnClientConfiguration{}).Type1()):                                     NetworkGatewaySpecVpnClientConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkGatewayConnectionSpecIpsecPolicy{}).Type1()):                                      NetworkGatewayConnectionSpecIpsecPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkGatewayConnectionSpecTrafficSelectorPolicy{}).Type1()):                            NetworkGatewayConnectionSpecTrafficSelectorPolicyCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(DesktopHostPoolSpecRegistrationInfo{}).Type1()):                                          DesktopHostPoolSpecRegistrationInfoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HubConnectionSpecRouting{}).Type1()):                                                     HubConnectionSpecRoutingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(HubConnectionSpecRoutingPropagatedRouteTable{}).Type1()):                                 HubConnectionSpecRoutingPropagatedRouteTableCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecAdditionalCapabilities{}).Type1()):                                            MachineSpecAdditionalCapabilitiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecBootDiagnostics{}).Type1()):                                                   MachineSpecBootDiagnosticsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecIdentity{}).Type1()):                                                          MachineSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecOsProfile{}).Type1()):                                                         MachineSpecOsProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecOsProfileLinuxConfig{}).Type1()):                                              MachineSpecOsProfileLinuxConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecOsProfileWindowsConfig{}).Type1()):                                            MachineSpecOsProfileWindowsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecPlan{}).Type1()):                                                              MachineSpecPlanCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecStorageImageReference{}).Type1()):                                             MachineSpecStorageImageReferenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecStorageOsDisk{}).Type1()):                                                     MachineSpecStorageOsDiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineConfigurationPolicyAssignmentSpecConfiguration{}).Type1()):                        MachineConfigurationPolicyAssignmentSpecConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecBootDiagnostics{}).Type1()):                                           MachineScaleSetSpecBootDiagnosticsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecIdentity{}).Type1()):                                                  MachineScaleSetSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecNetworkProfileDnsSettings{}).Type1()):                                 MachineScaleSetSpecNetworkProfileDnsSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecNetworkProfileIpConfigurationPublicIPAddressConfiguration{}).Type1()): MachineScaleSetSpecNetworkProfileIpConfigurationPublicIPAddressConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecOsProfile{}).Type1()):                                                 MachineScaleSetSpecOsProfileCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecOsProfileLinuxConfig{}).Type1()):                                      MachineScaleSetSpecOsProfileLinuxConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecOsProfileWindowsConfig{}).Type1()):                                    MachineScaleSetSpecOsProfileWindowsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecPlan{}).Type1()):                                                      MachineScaleSetSpecPlanCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecRollingUpgradePolicy{}).Type1()):                                      MachineScaleSetSpecRollingUpgradePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecSku{}).Type1()):                                                       MachineScaleSetSpecSkuCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecStorageProfileImageReference{}).Type1()):                              MachineScaleSetSpecStorageProfileImageReferenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecStorageProfileOsDisk{}).Type1()):                                      MachineScaleSetSpecStorageProfileOsDiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkSpecDdosProtectionPlan{}).Type1()):                                                NetworkSpecDdosProtectionPlanCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkGatewaySpecBgpSettings{}).Type1()):                                                NetworkGatewaySpecBgpSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkGatewaySpecCustomRoute{}).Type1()):                                                NetworkGatewaySpecCustomRouteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkGatewaySpecVpnClientConfiguration{}).Type1()):                                     NetworkGatewaySpecVpnClientConfigurationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkGatewayConnectionSpecIpsecPolicy{}).Type1()):                                      NetworkGatewayConnectionSpecIpsecPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(NetworkGatewayConnectionSpecTrafficSelectorPolicy{}).Type1()):                            NetworkGatewayConnectionSpecTrafficSelectorPolicyCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type DesktopHostPoolSpecRegistrationInfoCodec struct {
}

func (DesktopHostPoolSpecRegistrationInfoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DesktopHostPoolSpecRegistrationInfo)(ptr) == nil
}

func (DesktopHostPoolSpecRegistrationInfoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DesktopHostPoolSpecRegistrationInfo)(ptr)
	var objs []DesktopHostPoolSpecRegistrationInfo
	if obj != nil {
		objs = []DesktopHostPoolSpecRegistrationInfo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DesktopHostPoolSpecRegistrationInfo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DesktopHostPoolSpecRegistrationInfoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DesktopHostPoolSpecRegistrationInfo)(ptr) = DesktopHostPoolSpecRegistrationInfo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DesktopHostPoolSpecRegistrationInfo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DesktopHostPoolSpecRegistrationInfo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DesktopHostPoolSpecRegistrationInfo)(ptr) = objs[0]
			} else {
				*(*DesktopHostPoolSpecRegistrationInfo)(ptr) = DesktopHostPoolSpecRegistrationInfo{}
			}
		} else {
			*(*DesktopHostPoolSpecRegistrationInfo)(ptr) = DesktopHostPoolSpecRegistrationInfo{}
		}
	default:
		iter.ReportError("decode DesktopHostPoolSpecRegistrationInfo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HubConnectionSpecRoutingCodec struct {
}

func (HubConnectionSpecRoutingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HubConnectionSpecRouting)(ptr) == nil
}

func (HubConnectionSpecRoutingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HubConnectionSpecRouting)(ptr)
	var objs []HubConnectionSpecRouting
	if obj != nil {
		objs = []HubConnectionSpecRouting{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HubConnectionSpecRouting{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HubConnectionSpecRoutingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HubConnectionSpecRouting)(ptr) = HubConnectionSpecRouting{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HubConnectionSpecRouting

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HubConnectionSpecRouting{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HubConnectionSpecRouting)(ptr) = objs[0]
			} else {
				*(*HubConnectionSpecRouting)(ptr) = HubConnectionSpecRouting{}
			}
		} else {
			*(*HubConnectionSpecRouting)(ptr) = HubConnectionSpecRouting{}
		}
	default:
		iter.ReportError("decode HubConnectionSpecRouting", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type HubConnectionSpecRoutingPropagatedRouteTableCodec struct {
}

func (HubConnectionSpecRoutingPropagatedRouteTableCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*HubConnectionSpecRoutingPropagatedRouteTable)(ptr) == nil
}

func (HubConnectionSpecRoutingPropagatedRouteTableCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*HubConnectionSpecRoutingPropagatedRouteTable)(ptr)
	var objs []HubConnectionSpecRoutingPropagatedRouteTable
	if obj != nil {
		objs = []HubConnectionSpecRoutingPropagatedRouteTable{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HubConnectionSpecRoutingPropagatedRouteTable{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (HubConnectionSpecRoutingPropagatedRouteTableCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*HubConnectionSpecRoutingPropagatedRouteTable)(ptr) = HubConnectionSpecRoutingPropagatedRouteTable{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []HubConnectionSpecRoutingPropagatedRouteTable

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(HubConnectionSpecRoutingPropagatedRouteTable{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*HubConnectionSpecRoutingPropagatedRouteTable)(ptr) = objs[0]
			} else {
				*(*HubConnectionSpecRoutingPropagatedRouteTable)(ptr) = HubConnectionSpecRoutingPropagatedRouteTable{}
			}
		} else {
			*(*HubConnectionSpecRoutingPropagatedRouteTable)(ptr) = HubConnectionSpecRoutingPropagatedRouteTable{}
		}
	default:
		iter.ReportError("decode HubConnectionSpecRoutingPropagatedRouteTable", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MachineSpecAdditionalCapabilitiesCodec struct {
}

func (MachineSpecAdditionalCapabilitiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MachineSpecAdditionalCapabilities)(ptr) == nil
}

func (MachineSpecAdditionalCapabilitiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MachineSpecAdditionalCapabilities)(ptr)
	var objs []MachineSpecAdditionalCapabilities
	if obj != nil {
		objs = []MachineSpecAdditionalCapabilities{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecAdditionalCapabilities{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MachineSpecAdditionalCapabilitiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MachineSpecAdditionalCapabilities)(ptr) = MachineSpecAdditionalCapabilities{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MachineSpecAdditionalCapabilities

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecAdditionalCapabilities{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MachineSpecAdditionalCapabilities)(ptr) = objs[0]
			} else {
				*(*MachineSpecAdditionalCapabilities)(ptr) = MachineSpecAdditionalCapabilities{}
			}
		} else {
			*(*MachineSpecAdditionalCapabilities)(ptr) = MachineSpecAdditionalCapabilities{}
		}
	default:
		iter.ReportError("decode MachineSpecAdditionalCapabilities", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MachineSpecBootDiagnosticsCodec struct {
}

func (MachineSpecBootDiagnosticsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MachineSpecBootDiagnostics)(ptr) == nil
}

func (MachineSpecBootDiagnosticsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MachineSpecBootDiagnostics)(ptr)
	var objs []MachineSpecBootDiagnostics
	if obj != nil {
		objs = []MachineSpecBootDiagnostics{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecBootDiagnostics{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MachineSpecBootDiagnosticsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MachineSpecBootDiagnostics)(ptr) = MachineSpecBootDiagnostics{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MachineSpecBootDiagnostics

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecBootDiagnostics{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MachineSpecBootDiagnostics)(ptr) = objs[0]
			} else {
				*(*MachineSpecBootDiagnostics)(ptr) = MachineSpecBootDiagnostics{}
			}
		} else {
			*(*MachineSpecBootDiagnostics)(ptr) = MachineSpecBootDiagnostics{}
		}
	default:
		iter.ReportError("decode MachineSpecBootDiagnostics", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MachineSpecIdentityCodec struct {
}

func (MachineSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MachineSpecIdentity)(ptr) == nil
}

func (MachineSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MachineSpecIdentity)(ptr)
	var objs []MachineSpecIdentity
	if obj != nil {
		objs = []MachineSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MachineSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MachineSpecIdentity)(ptr) = MachineSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MachineSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MachineSpecIdentity)(ptr) = objs[0]
			} else {
				*(*MachineSpecIdentity)(ptr) = MachineSpecIdentity{}
			}
		} else {
			*(*MachineSpecIdentity)(ptr) = MachineSpecIdentity{}
		}
	default:
		iter.ReportError("decode MachineSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MachineSpecOsProfileCodec struct {
}

func (MachineSpecOsProfileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MachineSpecOsProfile)(ptr) == nil
}

func (MachineSpecOsProfileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MachineSpecOsProfile)(ptr)
	var objs []MachineSpecOsProfile
	if obj != nil {
		objs = []MachineSpecOsProfile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecOsProfile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MachineSpecOsProfileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MachineSpecOsProfile)(ptr) = MachineSpecOsProfile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MachineSpecOsProfile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecOsProfile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MachineSpecOsProfile)(ptr) = objs[0]
			} else {
				*(*MachineSpecOsProfile)(ptr) = MachineSpecOsProfile{}
			}
		} else {
			*(*MachineSpecOsProfile)(ptr) = MachineSpecOsProfile{}
		}
	default:
		iter.ReportError("decode MachineSpecOsProfile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MachineSpecOsProfileLinuxConfigCodec struct {
}

func (MachineSpecOsProfileLinuxConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MachineSpecOsProfileLinuxConfig)(ptr) == nil
}

func (MachineSpecOsProfileLinuxConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MachineSpecOsProfileLinuxConfig)(ptr)
	var objs []MachineSpecOsProfileLinuxConfig
	if obj != nil {
		objs = []MachineSpecOsProfileLinuxConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecOsProfileLinuxConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MachineSpecOsProfileLinuxConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MachineSpecOsProfileLinuxConfig)(ptr) = MachineSpecOsProfileLinuxConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MachineSpecOsProfileLinuxConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecOsProfileLinuxConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MachineSpecOsProfileLinuxConfig)(ptr) = objs[0]
			} else {
				*(*MachineSpecOsProfileLinuxConfig)(ptr) = MachineSpecOsProfileLinuxConfig{}
			}
		} else {
			*(*MachineSpecOsProfileLinuxConfig)(ptr) = MachineSpecOsProfileLinuxConfig{}
		}
	default:
		iter.ReportError("decode MachineSpecOsProfileLinuxConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MachineSpecOsProfileWindowsConfigCodec struct {
}

func (MachineSpecOsProfileWindowsConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MachineSpecOsProfileWindowsConfig)(ptr) == nil
}

func (MachineSpecOsProfileWindowsConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MachineSpecOsProfileWindowsConfig)(ptr)
	var objs []MachineSpecOsProfileWindowsConfig
	if obj != nil {
		objs = []MachineSpecOsProfileWindowsConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecOsProfileWindowsConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MachineSpecOsProfileWindowsConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MachineSpecOsProfileWindowsConfig)(ptr) = MachineSpecOsProfileWindowsConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MachineSpecOsProfileWindowsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecOsProfileWindowsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MachineSpecOsProfileWindowsConfig)(ptr) = objs[0]
			} else {
				*(*MachineSpecOsProfileWindowsConfig)(ptr) = MachineSpecOsProfileWindowsConfig{}
			}
		} else {
			*(*MachineSpecOsProfileWindowsConfig)(ptr) = MachineSpecOsProfileWindowsConfig{}
		}
	default:
		iter.ReportError("decode MachineSpecOsProfileWindowsConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MachineSpecPlanCodec struct {
}

func (MachineSpecPlanCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MachineSpecPlan)(ptr) == nil
}

func (MachineSpecPlanCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MachineSpecPlan)(ptr)
	var objs []MachineSpecPlan
	if obj != nil {
		objs = []MachineSpecPlan{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecPlan{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MachineSpecPlanCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MachineSpecPlan)(ptr) = MachineSpecPlan{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MachineSpecPlan

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecPlan{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MachineSpecPlan)(ptr) = objs[0]
			} else {
				*(*MachineSpecPlan)(ptr) = MachineSpecPlan{}
			}
		} else {
			*(*MachineSpecPlan)(ptr) = MachineSpecPlan{}
		}
	default:
		iter.ReportError("decode MachineSpecPlan", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MachineSpecStorageImageReferenceCodec struct {
}

func (MachineSpecStorageImageReferenceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MachineSpecStorageImageReference)(ptr) == nil
}

func (MachineSpecStorageImageReferenceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MachineSpecStorageImageReference)(ptr)
	var objs []MachineSpecStorageImageReference
	if obj != nil {
		objs = []MachineSpecStorageImageReference{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecStorageImageReference{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MachineSpecStorageImageReferenceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MachineSpecStorageImageReference)(ptr) = MachineSpecStorageImageReference{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MachineSpecStorageImageReference

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecStorageImageReference{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MachineSpecStorageImageReference)(ptr) = objs[0]
			} else {
				*(*MachineSpecStorageImageReference)(ptr) = MachineSpecStorageImageReference{}
			}
		} else {
			*(*MachineSpecStorageImageReference)(ptr) = MachineSpecStorageImageReference{}
		}
	default:
		iter.ReportError("decode MachineSpecStorageImageReference", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MachineSpecStorageOsDiskCodec struct {
}

func (MachineSpecStorageOsDiskCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MachineSpecStorageOsDisk)(ptr) == nil
}

func (MachineSpecStorageOsDiskCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MachineSpecStorageOsDisk)(ptr)
	var objs []MachineSpecStorageOsDisk
	if obj != nil {
		objs = []MachineSpecStorageOsDisk{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecStorageOsDisk{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MachineSpecStorageOsDiskCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MachineSpecStorageOsDisk)(ptr) = MachineSpecStorageOsDisk{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MachineSpecStorageOsDisk

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineSpecStorageOsDisk{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MachineSpecStorageOsDisk)(ptr) = objs[0]
			} else {
				*(*MachineSpecStorageOsDisk)(ptr) = MachineSpecStorageOsDisk{}
			}
		} else {
			*(*MachineSpecStorageOsDisk)(ptr) = MachineSpecStorageOsDisk{}
		}
	default:
		iter.ReportError("decode MachineSpecStorageOsDisk", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MachineConfigurationPolicyAssignmentSpecConfigurationCodec struct {
}

func (MachineConfigurationPolicyAssignmentSpecConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MachineConfigurationPolicyAssignmentSpecConfiguration)(ptr) == nil
}

func (MachineConfigurationPolicyAssignmentSpecConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MachineConfigurationPolicyAssignmentSpecConfiguration)(ptr)
	var objs []MachineConfigurationPolicyAssignmentSpecConfiguration
	if obj != nil {
		objs = []MachineConfigurationPolicyAssignmentSpecConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineConfigurationPolicyAssignmentSpecConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MachineConfigurationPolicyAssignmentSpecConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MachineConfigurationPolicyAssignmentSpecConfiguration)(ptr) = MachineConfigurationPolicyAssignmentSpecConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MachineConfigurationPolicyAssignmentSpecConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineConfigurationPolicyAssignmentSpecConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MachineConfigurationPolicyAssignmentSpecConfiguration)(ptr) = objs[0]
			} else {
				*(*MachineConfigurationPolicyAssignmentSpecConfiguration)(ptr) = MachineConfigurationPolicyAssignmentSpecConfiguration{}
			}
		} else {
			*(*MachineConfigurationPolicyAssignmentSpecConfiguration)(ptr) = MachineConfigurationPolicyAssignmentSpecConfiguration{}
		}
	default:
		iter.ReportError("decode MachineConfigurationPolicyAssignmentSpecConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MachineScaleSetSpecBootDiagnosticsCodec struct {
}

func (MachineScaleSetSpecBootDiagnosticsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MachineScaleSetSpecBootDiagnostics)(ptr) == nil
}

func (MachineScaleSetSpecBootDiagnosticsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MachineScaleSetSpecBootDiagnostics)(ptr)
	var objs []MachineScaleSetSpecBootDiagnostics
	if obj != nil {
		objs = []MachineScaleSetSpecBootDiagnostics{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecBootDiagnostics{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MachineScaleSetSpecBootDiagnosticsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MachineScaleSetSpecBootDiagnostics)(ptr) = MachineScaleSetSpecBootDiagnostics{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MachineScaleSetSpecBootDiagnostics

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecBootDiagnostics{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MachineScaleSetSpecBootDiagnostics)(ptr) = objs[0]
			} else {
				*(*MachineScaleSetSpecBootDiagnostics)(ptr) = MachineScaleSetSpecBootDiagnostics{}
			}
		} else {
			*(*MachineScaleSetSpecBootDiagnostics)(ptr) = MachineScaleSetSpecBootDiagnostics{}
		}
	default:
		iter.ReportError("decode MachineScaleSetSpecBootDiagnostics", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MachineScaleSetSpecIdentityCodec struct {
}

func (MachineScaleSetSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MachineScaleSetSpecIdentity)(ptr) == nil
}

func (MachineScaleSetSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MachineScaleSetSpecIdentity)(ptr)
	var objs []MachineScaleSetSpecIdentity
	if obj != nil {
		objs = []MachineScaleSetSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MachineScaleSetSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MachineScaleSetSpecIdentity)(ptr) = MachineScaleSetSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MachineScaleSetSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MachineScaleSetSpecIdentity)(ptr) = objs[0]
			} else {
				*(*MachineScaleSetSpecIdentity)(ptr) = MachineScaleSetSpecIdentity{}
			}
		} else {
			*(*MachineScaleSetSpecIdentity)(ptr) = MachineScaleSetSpecIdentity{}
		}
	default:
		iter.ReportError("decode MachineScaleSetSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MachineScaleSetSpecNetworkProfileDnsSettingsCodec struct {
}

func (MachineScaleSetSpecNetworkProfileDnsSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MachineScaleSetSpecNetworkProfileDnsSettings)(ptr) == nil
}

func (MachineScaleSetSpecNetworkProfileDnsSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MachineScaleSetSpecNetworkProfileDnsSettings)(ptr)
	var objs []MachineScaleSetSpecNetworkProfileDnsSettings
	if obj != nil {
		objs = []MachineScaleSetSpecNetworkProfileDnsSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecNetworkProfileDnsSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MachineScaleSetSpecNetworkProfileDnsSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MachineScaleSetSpecNetworkProfileDnsSettings)(ptr) = MachineScaleSetSpecNetworkProfileDnsSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MachineScaleSetSpecNetworkProfileDnsSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecNetworkProfileDnsSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MachineScaleSetSpecNetworkProfileDnsSettings)(ptr) = objs[0]
			} else {
				*(*MachineScaleSetSpecNetworkProfileDnsSettings)(ptr) = MachineScaleSetSpecNetworkProfileDnsSettings{}
			}
		} else {
			*(*MachineScaleSetSpecNetworkProfileDnsSettings)(ptr) = MachineScaleSetSpecNetworkProfileDnsSettings{}
		}
	default:
		iter.ReportError("decode MachineScaleSetSpecNetworkProfileDnsSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MachineScaleSetSpecNetworkProfileIpConfigurationPublicIPAddressConfigurationCodec struct {
}

func (MachineScaleSetSpecNetworkProfileIpConfigurationPublicIPAddressConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MachineScaleSetSpecNetworkProfileIpConfigurationPublicIPAddressConfiguration)(ptr) == nil
}

func (MachineScaleSetSpecNetworkProfileIpConfigurationPublicIPAddressConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MachineScaleSetSpecNetworkProfileIpConfigurationPublicIPAddressConfiguration)(ptr)
	var objs []MachineScaleSetSpecNetworkProfileIpConfigurationPublicIPAddressConfiguration
	if obj != nil {
		objs = []MachineScaleSetSpecNetworkProfileIpConfigurationPublicIPAddressConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecNetworkProfileIpConfigurationPublicIPAddressConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MachineScaleSetSpecNetworkProfileIpConfigurationPublicIPAddressConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MachineScaleSetSpecNetworkProfileIpConfigurationPublicIPAddressConfiguration)(ptr) = MachineScaleSetSpecNetworkProfileIpConfigurationPublicIPAddressConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MachineScaleSetSpecNetworkProfileIpConfigurationPublicIPAddressConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecNetworkProfileIpConfigurationPublicIPAddressConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MachineScaleSetSpecNetworkProfileIpConfigurationPublicIPAddressConfiguration)(ptr) = objs[0]
			} else {
				*(*MachineScaleSetSpecNetworkProfileIpConfigurationPublicIPAddressConfiguration)(ptr) = MachineScaleSetSpecNetworkProfileIpConfigurationPublicIPAddressConfiguration{}
			}
		} else {
			*(*MachineScaleSetSpecNetworkProfileIpConfigurationPublicIPAddressConfiguration)(ptr) = MachineScaleSetSpecNetworkProfileIpConfigurationPublicIPAddressConfiguration{}
		}
	default:
		iter.ReportError("decode MachineScaleSetSpecNetworkProfileIpConfigurationPublicIPAddressConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MachineScaleSetSpecOsProfileCodec struct {
}

func (MachineScaleSetSpecOsProfileCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MachineScaleSetSpecOsProfile)(ptr) == nil
}

func (MachineScaleSetSpecOsProfileCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MachineScaleSetSpecOsProfile)(ptr)
	var objs []MachineScaleSetSpecOsProfile
	if obj != nil {
		objs = []MachineScaleSetSpecOsProfile{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecOsProfile{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MachineScaleSetSpecOsProfileCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MachineScaleSetSpecOsProfile)(ptr) = MachineScaleSetSpecOsProfile{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MachineScaleSetSpecOsProfile

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecOsProfile{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MachineScaleSetSpecOsProfile)(ptr) = objs[0]
			} else {
				*(*MachineScaleSetSpecOsProfile)(ptr) = MachineScaleSetSpecOsProfile{}
			}
		} else {
			*(*MachineScaleSetSpecOsProfile)(ptr) = MachineScaleSetSpecOsProfile{}
		}
	default:
		iter.ReportError("decode MachineScaleSetSpecOsProfile", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MachineScaleSetSpecOsProfileLinuxConfigCodec struct {
}

func (MachineScaleSetSpecOsProfileLinuxConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MachineScaleSetSpecOsProfileLinuxConfig)(ptr) == nil
}

func (MachineScaleSetSpecOsProfileLinuxConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MachineScaleSetSpecOsProfileLinuxConfig)(ptr)
	var objs []MachineScaleSetSpecOsProfileLinuxConfig
	if obj != nil {
		objs = []MachineScaleSetSpecOsProfileLinuxConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecOsProfileLinuxConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MachineScaleSetSpecOsProfileLinuxConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MachineScaleSetSpecOsProfileLinuxConfig)(ptr) = MachineScaleSetSpecOsProfileLinuxConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MachineScaleSetSpecOsProfileLinuxConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecOsProfileLinuxConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MachineScaleSetSpecOsProfileLinuxConfig)(ptr) = objs[0]
			} else {
				*(*MachineScaleSetSpecOsProfileLinuxConfig)(ptr) = MachineScaleSetSpecOsProfileLinuxConfig{}
			}
		} else {
			*(*MachineScaleSetSpecOsProfileLinuxConfig)(ptr) = MachineScaleSetSpecOsProfileLinuxConfig{}
		}
	default:
		iter.ReportError("decode MachineScaleSetSpecOsProfileLinuxConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MachineScaleSetSpecOsProfileWindowsConfigCodec struct {
}

func (MachineScaleSetSpecOsProfileWindowsConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MachineScaleSetSpecOsProfileWindowsConfig)(ptr) == nil
}

func (MachineScaleSetSpecOsProfileWindowsConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MachineScaleSetSpecOsProfileWindowsConfig)(ptr)
	var objs []MachineScaleSetSpecOsProfileWindowsConfig
	if obj != nil {
		objs = []MachineScaleSetSpecOsProfileWindowsConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecOsProfileWindowsConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MachineScaleSetSpecOsProfileWindowsConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MachineScaleSetSpecOsProfileWindowsConfig)(ptr) = MachineScaleSetSpecOsProfileWindowsConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MachineScaleSetSpecOsProfileWindowsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecOsProfileWindowsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MachineScaleSetSpecOsProfileWindowsConfig)(ptr) = objs[0]
			} else {
				*(*MachineScaleSetSpecOsProfileWindowsConfig)(ptr) = MachineScaleSetSpecOsProfileWindowsConfig{}
			}
		} else {
			*(*MachineScaleSetSpecOsProfileWindowsConfig)(ptr) = MachineScaleSetSpecOsProfileWindowsConfig{}
		}
	default:
		iter.ReportError("decode MachineScaleSetSpecOsProfileWindowsConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MachineScaleSetSpecPlanCodec struct {
}

func (MachineScaleSetSpecPlanCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MachineScaleSetSpecPlan)(ptr) == nil
}

func (MachineScaleSetSpecPlanCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MachineScaleSetSpecPlan)(ptr)
	var objs []MachineScaleSetSpecPlan
	if obj != nil {
		objs = []MachineScaleSetSpecPlan{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecPlan{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MachineScaleSetSpecPlanCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MachineScaleSetSpecPlan)(ptr) = MachineScaleSetSpecPlan{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MachineScaleSetSpecPlan

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecPlan{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MachineScaleSetSpecPlan)(ptr) = objs[0]
			} else {
				*(*MachineScaleSetSpecPlan)(ptr) = MachineScaleSetSpecPlan{}
			}
		} else {
			*(*MachineScaleSetSpecPlan)(ptr) = MachineScaleSetSpecPlan{}
		}
	default:
		iter.ReportError("decode MachineScaleSetSpecPlan", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MachineScaleSetSpecRollingUpgradePolicyCodec struct {
}

func (MachineScaleSetSpecRollingUpgradePolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MachineScaleSetSpecRollingUpgradePolicy)(ptr) == nil
}

func (MachineScaleSetSpecRollingUpgradePolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MachineScaleSetSpecRollingUpgradePolicy)(ptr)
	var objs []MachineScaleSetSpecRollingUpgradePolicy
	if obj != nil {
		objs = []MachineScaleSetSpecRollingUpgradePolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecRollingUpgradePolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MachineScaleSetSpecRollingUpgradePolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MachineScaleSetSpecRollingUpgradePolicy)(ptr) = MachineScaleSetSpecRollingUpgradePolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MachineScaleSetSpecRollingUpgradePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecRollingUpgradePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MachineScaleSetSpecRollingUpgradePolicy)(ptr) = objs[0]
			} else {
				*(*MachineScaleSetSpecRollingUpgradePolicy)(ptr) = MachineScaleSetSpecRollingUpgradePolicy{}
			}
		} else {
			*(*MachineScaleSetSpecRollingUpgradePolicy)(ptr) = MachineScaleSetSpecRollingUpgradePolicy{}
		}
	default:
		iter.ReportError("decode MachineScaleSetSpecRollingUpgradePolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MachineScaleSetSpecSkuCodec struct {
}

func (MachineScaleSetSpecSkuCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MachineScaleSetSpecSku)(ptr) == nil
}

func (MachineScaleSetSpecSkuCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MachineScaleSetSpecSku)(ptr)
	var objs []MachineScaleSetSpecSku
	if obj != nil {
		objs = []MachineScaleSetSpecSku{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecSku{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MachineScaleSetSpecSkuCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MachineScaleSetSpecSku)(ptr) = MachineScaleSetSpecSku{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MachineScaleSetSpecSku

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecSku{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MachineScaleSetSpecSku)(ptr) = objs[0]
			} else {
				*(*MachineScaleSetSpecSku)(ptr) = MachineScaleSetSpecSku{}
			}
		} else {
			*(*MachineScaleSetSpecSku)(ptr) = MachineScaleSetSpecSku{}
		}
	default:
		iter.ReportError("decode MachineScaleSetSpecSku", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MachineScaleSetSpecStorageProfileImageReferenceCodec struct {
}

func (MachineScaleSetSpecStorageProfileImageReferenceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MachineScaleSetSpecStorageProfileImageReference)(ptr) == nil
}

func (MachineScaleSetSpecStorageProfileImageReferenceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MachineScaleSetSpecStorageProfileImageReference)(ptr)
	var objs []MachineScaleSetSpecStorageProfileImageReference
	if obj != nil {
		objs = []MachineScaleSetSpecStorageProfileImageReference{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecStorageProfileImageReference{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MachineScaleSetSpecStorageProfileImageReferenceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MachineScaleSetSpecStorageProfileImageReference)(ptr) = MachineScaleSetSpecStorageProfileImageReference{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MachineScaleSetSpecStorageProfileImageReference

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecStorageProfileImageReference{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MachineScaleSetSpecStorageProfileImageReference)(ptr) = objs[0]
			} else {
				*(*MachineScaleSetSpecStorageProfileImageReference)(ptr) = MachineScaleSetSpecStorageProfileImageReference{}
			}
		} else {
			*(*MachineScaleSetSpecStorageProfileImageReference)(ptr) = MachineScaleSetSpecStorageProfileImageReference{}
		}
	default:
		iter.ReportError("decode MachineScaleSetSpecStorageProfileImageReference", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MachineScaleSetSpecStorageProfileOsDiskCodec struct {
}

func (MachineScaleSetSpecStorageProfileOsDiskCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MachineScaleSetSpecStorageProfileOsDisk)(ptr) == nil
}

func (MachineScaleSetSpecStorageProfileOsDiskCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MachineScaleSetSpecStorageProfileOsDisk)(ptr)
	var objs []MachineScaleSetSpecStorageProfileOsDisk
	if obj != nil {
		objs = []MachineScaleSetSpecStorageProfileOsDisk{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecStorageProfileOsDisk{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MachineScaleSetSpecStorageProfileOsDiskCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MachineScaleSetSpecStorageProfileOsDisk)(ptr) = MachineScaleSetSpecStorageProfileOsDisk{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MachineScaleSetSpecStorageProfileOsDisk

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MachineScaleSetSpecStorageProfileOsDisk{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MachineScaleSetSpecStorageProfileOsDisk)(ptr) = objs[0]
			} else {
				*(*MachineScaleSetSpecStorageProfileOsDisk)(ptr) = MachineScaleSetSpecStorageProfileOsDisk{}
			}
		} else {
			*(*MachineScaleSetSpecStorageProfileOsDisk)(ptr) = MachineScaleSetSpecStorageProfileOsDisk{}
		}
	default:
		iter.ReportError("decode MachineScaleSetSpecStorageProfileOsDisk", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NetworkSpecDdosProtectionPlanCodec struct {
}

func (NetworkSpecDdosProtectionPlanCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NetworkSpecDdosProtectionPlan)(ptr) == nil
}

func (NetworkSpecDdosProtectionPlanCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NetworkSpecDdosProtectionPlan)(ptr)
	var objs []NetworkSpecDdosProtectionPlan
	if obj != nil {
		objs = []NetworkSpecDdosProtectionPlan{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkSpecDdosProtectionPlan{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NetworkSpecDdosProtectionPlanCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NetworkSpecDdosProtectionPlan)(ptr) = NetworkSpecDdosProtectionPlan{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NetworkSpecDdosProtectionPlan

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkSpecDdosProtectionPlan{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NetworkSpecDdosProtectionPlan)(ptr) = objs[0]
			} else {
				*(*NetworkSpecDdosProtectionPlan)(ptr) = NetworkSpecDdosProtectionPlan{}
			}
		} else {
			*(*NetworkSpecDdosProtectionPlan)(ptr) = NetworkSpecDdosProtectionPlan{}
		}
	default:
		iter.ReportError("decode NetworkSpecDdosProtectionPlan", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NetworkGatewaySpecBgpSettingsCodec struct {
}

func (NetworkGatewaySpecBgpSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NetworkGatewaySpecBgpSettings)(ptr) == nil
}

func (NetworkGatewaySpecBgpSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NetworkGatewaySpecBgpSettings)(ptr)
	var objs []NetworkGatewaySpecBgpSettings
	if obj != nil {
		objs = []NetworkGatewaySpecBgpSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkGatewaySpecBgpSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NetworkGatewaySpecBgpSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NetworkGatewaySpecBgpSettings)(ptr) = NetworkGatewaySpecBgpSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NetworkGatewaySpecBgpSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkGatewaySpecBgpSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NetworkGatewaySpecBgpSettings)(ptr) = objs[0]
			} else {
				*(*NetworkGatewaySpecBgpSettings)(ptr) = NetworkGatewaySpecBgpSettings{}
			}
		} else {
			*(*NetworkGatewaySpecBgpSettings)(ptr) = NetworkGatewaySpecBgpSettings{}
		}
	default:
		iter.ReportError("decode NetworkGatewaySpecBgpSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NetworkGatewaySpecCustomRouteCodec struct {
}

func (NetworkGatewaySpecCustomRouteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NetworkGatewaySpecCustomRoute)(ptr) == nil
}

func (NetworkGatewaySpecCustomRouteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NetworkGatewaySpecCustomRoute)(ptr)
	var objs []NetworkGatewaySpecCustomRoute
	if obj != nil {
		objs = []NetworkGatewaySpecCustomRoute{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkGatewaySpecCustomRoute{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NetworkGatewaySpecCustomRouteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NetworkGatewaySpecCustomRoute)(ptr) = NetworkGatewaySpecCustomRoute{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NetworkGatewaySpecCustomRoute

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkGatewaySpecCustomRoute{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NetworkGatewaySpecCustomRoute)(ptr) = objs[0]
			} else {
				*(*NetworkGatewaySpecCustomRoute)(ptr) = NetworkGatewaySpecCustomRoute{}
			}
		} else {
			*(*NetworkGatewaySpecCustomRoute)(ptr) = NetworkGatewaySpecCustomRoute{}
		}
	default:
		iter.ReportError("decode NetworkGatewaySpecCustomRoute", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NetworkGatewaySpecVpnClientConfigurationCodec struct {
}

func (NetworkGatewaySpecVpnClientConfigurationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NetworkGatewaySpecVpnClientConfiguration)(ptr) == nil
}

func (NetworkGatewaySpecVpnClientConfigurationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NetworkGatewaySpecVpnClientConfiguration)(ptr)
	var objs []NetworkGatewaySpecVpnClientConfiguration
	if obj != nil {
		objs = []NetworkGatewaySpecVpnClientConfiguration{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkGatewaySpecVpnClientConfiguration{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NetworkGatewaySpecVpnClientConfigurationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NetworkGatewaySpecVpnClientConfiguration)(ptr) = NetworkGatewaySpecVpnClientConfiguration{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NetworkGatewaySpecVpnClientConfiguration

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkGatewaySpecVpnClientConfiguration{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NetworkGatewaySpecVpnClientConfiguration)(ptr) = objs[0]
			} else {
				*(*NetworkGatewaySpecVpnClientConfiguration)(ptr) = NetworkGatewaySpecVpnClientConfiguration{}
			}
		} else {
			*(*NetworkGatewaySpecVpnClientConfiguration)(ptr) = NetworkGatewaySpecVpnClientConfiguration{}
		}
	default:
		iter.ReportError("decode NetworkGatewaySpecVpnClientConfiguration", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NetworkGatewayConnectionSpecIpsecPolicyCodec struct {
}

func (NetworkGatewayConnectionSpecIpsecPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NetworkGatewayConnectionSpecIpsecPolicy)(ptr) == nil
}

func (NetworkGatewayConnectionSpecIpsecPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NetworkGatewayConnectionSpecIpsecPolicy)(ptr)
	var objs []NetworkGatewayConnectionSpecIpsecPolicy
	if obj != nil {
		objs = []NetworkGatewayConnectionSpecIpsecPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkGatewayConnectionSpecIpsecPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NetworkGatewayConnectionSpecIpsecPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NetworkGatewayConnectionSpecIpsecPolicy)(ptr) = NetworkGatewayConnectionSpecIpsecPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NetworkGatewayConnectionSpecIpsecPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkGatewayConnectionSpecIpsecPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NetworkGatewayConnectionSpecIpsecPolicy)(ptr) = objs[0]
			} else {
				*(*NetworkGatewayConnectionSpecIpsecPolicy)(ptr) = NetworkGatewayConnectionSpecIpsecPolicy{}
			}
		} else {
			*(*NetworkGatewayConnectionSpecIpsecPolicy)(ptr) = NetworkGatewayConnectionSpecIpsecPolicy{}
		}
	default:
		iter.ReportError("decode NetworkGatewayConnectionSpecIpsecPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type NetworkGatewayConnectionSpecTrafficSelectorPolicyCodec struct {
}

func (NetworkGatewayConnectionSpecTrafficSelectorPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*NetworkGatewayConnectionSpecTrafficSelectorPolicy)(ptr) == nil
}

func (NetworkGatewayConnectionSpecTrafficSelectorPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*NetworkGatewayConnectionSpecTrafficSelectorPolicy)(ptr)
	var objs []NetworkGatewayConnectionSpecTrafficSelectorPolicy
	if obj != nil {
		objs = []NetworkGatewayConnectionSpecTrafficSelectorPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkGatewayConnectionSpecTrafficSelectorPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (NetworkGatewayConnectionSpecTrafficSelectorPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*NetworkGatewayConnectionSpecTrafficSelectorPolicy)(ptr) = NetworkGatewayConnectionSpecTrafficSelectorPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []NetworkGatewayConnectionSpecTrafficSelectorPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(NetworkGatewayConnectionSpecTrafficSelectorPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*NetworkGatewayConnectionSpecTrafficSelectorPolicy)(ptr) = objs[0]
			} else {
				*(*NetworkGatewayConnectionSpecTrafficSelectorPolicy)(ptr) = NetworkGatewayConnectionSpecTrafficSelectorPolicy{}
			}
		} else {
			*(*NetworkGatewayConnectionSpecTrafficSelectorPolicy)(ptr) = NetworkGatewayConnectionSpecTrafficSelectorPolicy{}
		}
	default:
		iter.ReportError("decode NetworkGatewayConnectionSpecTrafficSelectorPolicy", "unexpected JSON type")
	}
}
