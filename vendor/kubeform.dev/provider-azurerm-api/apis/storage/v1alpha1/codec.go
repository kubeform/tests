/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecAzureFilesAuthentication{}).Type1()):                     AccountSpecAzureFilesAuthenticationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecAzureFilesAuthenticationActiveDirectory{}).Type1()):      AccountSpecAzureFilesAuthenticationActiveDirectoryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecBlobProperties{}).Type1()):                               AccountSpecBlobPropertiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecBlobPropertiesContainerDeleteRetentionPolicy{}).Type1()): AccountSpecBlobPropertiesContainerDeleteRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecBlobPropertiesDeleteRetentionPolicy{}).Type1()):          AccountSpecBlobPropertiesDeleteRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecCustomDomain{}).Type1()):                                 AccountSpecCustomDomainCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecIdentity{}).Type1()):                                     AccountSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecNetworkRules{}).Type1()):                                 AccountSpecNetworkRulesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecQueueProperties{}).Type1()):                              AccountSpecQueuePropertiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecQueuePropertiesHourMetrics{}).Type1()):                   AccountSpecQueuePropertiesHourMetricsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecQueuePropertiesLogging{}).Type1()):                       AccountSpecQueuePropertiesLoggingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecQueuePropertiesMinuteMetrics{}).Type1()):                 AccountSpecQueuePropertiesMinuteMetricsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecRouting{}).Type1()):                                      AccountSpecRoutingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecStaticWebsite{}).Type1()):                                AccountSpecStaticWebsiteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BlobInventoryPolicySpecRulesFilter{}).Type1()):                      BlobInventoryPolicySpecRulesFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementPolicySpecRuleActions{}).Type1()):                         ManagementPolicySpecRuleActionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementPolicySpecRuleActionsBaseBlob{}).Type1()):                 ManagementPolicySpecRuleActionsBaseBlobCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementPolicySpecRuleActionsSnapshot{}).Type1()):                 ManagementPolicySpecRuleActionsSnapshotCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementPolicySpecRuleActionsVersion{}).Type1()):                  ManagementPolicySpecRuleActionsVersionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementPolicySpecRuleFilters{}).Type1()):                         ManagementPolicySpecRuleFiltersCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecAzureFilesAuthentication{}).Type1()):                     AccountSpecAzureFilesAuthenticationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecAzureFilesAuthenticationActiveDirectory{}).Type1()):      AccountSpecAzureFilesAuthenticationActiveDirectoryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecBlobProperties{}).Type1()):                               AccountSpecBlobPropertiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecBlobPropertiesContainerDeleteRetentionPolicy{}).Type1()): AccountSpecBlobPropertiesContainerDeleteRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecBlobPropertiesDeleteRetentionPolicy{}).Type1()):          AccountSpecBlobPropertiesDeleteRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecCustomDomain{}).Type1()):                                 AccountSpecCustomDomainCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecIdentity{}).Type1()):                                     AccountSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecNetworkRules{}).Type1()):                                 AccountSpecNetworkRulesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecQueueProperties{}).Type1()):                              AccountSpecQueuePropertiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecQueuePropertiesHourMetrics{}).Type1()):                   AccountSpecQueuePropertiesHourMetricsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecQueuePropertiesLogging{}).Type1()):                       AccountSpecQueuePropertiesLoggingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecQueuePropertiesMinuteMetrics{}).Type1()):                 AccountSpecQueuePropertiesMinuteMetricsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecRouting{}).Type1()):                                      AccountSpecRoutingCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecStaticWebsite{}).Type1()):                                AccountSpecStaticWebsiteCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(BlobInventoryPolicySpecRulesFilter{}).Type1()):                      BlobInventoryPolicySpecRulesFilterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementPolicySpecRuleActions{}).Type1()):                         ManagementPolicySpecRuleActionsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementPolicySpecRuleActionsBaseBlob{}).Type1()):                 ManagementPolicySpecRuleActionsBaseBlobCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementPolicySpecRuleActionsSnapshot{}).Type1()):                 ManagementPolicySpecRuleActionsSnapshotCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementPolicySpecRuleActionsVersion{}).Type1()):                  ManagementPolicySpecRuleActionsVersionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ManagementPolicySpecRuleFilters{}).Type1()):                         ManagementPolicySpecRuleFiltersCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AccountSpecAzureFilesAuthenticationCodec struct {
}

func (AccountSpecAzureFilesAuthenticationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AccountSpecAzureFilesAuthentication)(ptr) == nil
}

func (AccountSpecAzureFilesAuthenticationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AccountSpecAzureFilesAuthentication)(ptr)
	var objs []AccountSpecAzureFilesAuthentication
	if obj != nil {
		objs = []AccountSpecAzureFilesAuthentication{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecAzureFilesAuthentication{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AccountSpecAzureFilesAuthenticationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AccountSpecAzureFilesAuthentication)(ptr) = AccountSpecAzureFilesAuthentication{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AccountSpecAzureFilesAuthentication

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecAzureFilesAuthentication{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AccountSpecAzureFilesAuthentication)(ptr) = objs[0]
			} else {
				*(*AccountSpecAzureFilesAuthentication)(ptr) = AccountSpecAzureFilesAuthentication{}
			}
		} else {
			*(*AccountSpecAzureFilesAuthentication)(ptr) = AccountSpecAzureFilesAuthentication{}
		}
	default:
		iter.ReportError("decode AccountSpecAzureFilesAuthentication", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AccountSpecAzureFilesAuthenticationActiveDirectoryCodec struct {
}

func (AccountSpecAzureFilesAuthenticationActiveDirectoryCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AccountSpecAzureFilesAuthenticationActiveDirectory)(ptr) == nil
}

func (AccountSpecAzureFilesAuthenticationActiveDirectoryCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AccountSpecAzureFilesAuthenticationActiveDirectory)(ptr)
	var objs []AccountSpecAzureFilesAuthenticationActiveDirectory
	if obj != nil {
		objs = []AccountSpecAzureFilesAuthenticationActiveDirectory{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecAzureFilesAuthenticationActiveDirectory{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AccountSpecAzureFilesAuthenticationActiveDirectoryCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AccountSpecAzureFilesAuthenticationActiveDirectory)(ptr) = AccountSpecAzureFilesAuthenticationActiveDirectory{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AccountSpecAzureFilesAuthenticationActiveDirectory

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecAzureFilesAuthenticationActiveDirectory{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AccountSpecAzureFilesAuthenticationActiveDirectory)(ptr) = objs[0]
			} else {
				*(*AccountSpecAzureFilesAuthenticationActiveDirectory)(ptr) = AccountSpecAzureFilesAuthenticationActiveDirectory{}
			}
		} else {
			*(*AccountSpecAzureFilesAuthenticationActiveDirectory)(ptr) = AccountSpecAzureFilesAuthenticationActiveDirectory{}
		}
	default:
		iter.ReportError("decode AccountSpecAzureFilesAuthenticationActiveDirectory", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AccountSpecBlobPropertiesCodec struct {
}

func (AccountSpecBlobPropertiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AccountSpecBlobProperties)(ptr) == nil
}

func (AccountSpecBlobPropertiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AccountSpecBlobProperties)(ptr)
	var objs []AccountSpecBlobProperties
	if obj != nil {
		objs = []AccountSpecBlobProperties{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecBlobProperties{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AccountSpecBlobPropertiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AccountSpecBlobProperties)(ptr) = AccountSpecBlobProperties{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AccountSpecBlobProperties

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecBlobProperties{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AccountSpecBlobProperties)(ptr) = objs[0]
			} else {
				*(*AccountSpecBlobProperties)(ptr) = AccountSpecBlobProperties{}
			}
		} else {
			*(*AccountSpecBlobProperties)(ptr) = AccountSpecBlobProperties{}
		}
	default:
		iter.ReportError("decode AccountSpecBlobProperties", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AccountSpecBlobPropertiesContainerDeleteRetentionPolicyCodec struct {
}

func (AccountSpecBlobPropertiesContainerDeleteRetentionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AccountSpecBlobPropertiesContainerDeleteRetentionPolicy)(ptr) == nil
}

func (AccountSpecBlobPropertiesContainerDeleteRetentionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AccountSpecBlobPropertiesContainerDeleteRetentionPolicy)(ptr)
	var objs []AccountSpecBlobPropertiesContainerDeleteRetentionPolicy
	if obj != nil {
		objs = []AccountSpecBlobPropertiesContainerDeleteRetentionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecBlobPropertiesContainerDeleteRetentionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AccountSpecBlobPropertiesContainerDeleteRetentionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AccountSpecBlobPropertiesContainerDeleteRetentionPolicy)(ptr) = AccountSpecBlobPropertiesContainerDeleteRetentionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AccountSpecBlobPropertiesContainerDeleteRetentionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecBlobPropertiesContainerDeleteRetentionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AccountSpecBlobPropertiesContainerDeleteRetentionPolicy)(ptr) = objs[0]
			} else {
				*(*AccountSpecBlobPropertiesContainerDeleteRetentionPolicy)(ptr) = AccountSpecBlobPropertiesContainerDeleteRetentionPolicy{}
			}
		} else {
			*(*AccountSpecBlobPropertiesContainerDeleteRetentionPolicy)(ptr) = AccountSpecBlobPropertiesContainerDeleteRetentionPolicy{}
		}
	default:
		iter.ReportError("decode AccountSpecBlobPropertiesContainerDeleteRetentionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AccountSpecBlobPropertiesDeleteRetentionPolicyCodec struct {
}

func (AccountSpecBlobPropertiesDeleteRetentionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AccountSpecBlobPropertiesDeleteRetentionPolicy)(ptr) == nil
}

func (AccountSpecBlobPropertiesDeleteRetentionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AccountSpecBlobPropertiesDeleteRetentionPolicy)(ptr)
	var objs []AccountSpecBlobPropertiesDeleteRetentionPolicy
	if obj != nil {
		objs = []AccountSpecBlobPropertiesDeleteRetentionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecBlobPropertiesDeleteRetentionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AccountSpecBlobPropertiesDeleteRetentionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AccountSpecBlobPropertiesDeleteRetentionPolicy)(ptr) = AccountSpecBlobPropertiesDeleteRetentionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AccountSpecBlobPropertiesDeleteRetentionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecBlobPropertiesDeleteRetentionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AccountSpecBlobPropertiesDeleteRetentionPolicy)(ptr) = objs[0]
			} else {
				*(*AccountSpecBlobPropertiesDeleteRetentionPolicy)(ptr) = AccountSpecBlobPropertiesDeleteRetentionPolicy{}
			}
		} else {
			*(*AccountSpecBlobPropertiesDeleteRetentionPolicy)(ptr) = AccountSpecBlobPropertiesDeleteRetentionPolicy{}
		}
	default:
		iter.ReportError("decode AccountSpecBlobPropertiesDeleteRetentionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AccountSpecCustomDomainCodec struct {
}

func (AccountSpecCustomDomainCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AccountSpecCustomDomain)(ptr) == nil
}

func (AccountSpecCustomDomainCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AccountSpecCustomDomain)(ptr)
	var objs []AccountSpecCustomDomain
	if obj != nil {
		objs = []AccountSpecCustomDomain{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecCustomDomain{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AccountSpecCustomDomainCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AccountSpecCustomDomain)(ptr) = AccountSpecCustomDomain{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AccountSpecCustomDomain

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecCustomDomain{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AccountSpecCustomDomain)(ptr) = objs[0]
			} else {
				*(*AccountSpecCustomDomain)(ptr) = AccountSpecCustomDomain{}
			}
		} else {
			*(*AccountSpecCustomDomain)(ptr) = AccountSpecCustomDomain{}
		}
	default:
		iter.ReportError("decode AccountSpecCustomDomain", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AccountSpecIdentityCodec struct {
}

func (AccountSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AccountSpecIdentity)(ptr) == nil
}

func (AccountSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AccountSpecIdentity)(ptr)
	var objs []AccountSpecIdentity
	if obj != nil {
		objs = []AccountSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AccountSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AccountSpecIdentity)(ptr) = AccountSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AccountSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AccountSpecIdentity)(ptr) = objs[0]
			} else {
				*(*AccountSpecIdentity)(ptr) = AccountSpecIdentity{}
			}
		} else {
			*(*AccountSpecIdentity)(ptr) = AccountSpecIdentity{}
		}
	default:
		iter.ReportError("decode AccountSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AccountSpecNetworkRulesCodec struct {
}

func (AccountSpecNetworkRulesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AccountSpecNetworkRules)(ptr) == nil
}

func (AccountSpecNetworkRulesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AccountSpecNetworkRules)(ptr)
	var objs []AccountSpecNetworkRules
	if obj != nil {
		objs = []AccountSpecNetworkRules{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecNetworkRules{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AccountSpecNetworkRulesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AccountSpecNetworkRules)(ptr) = AccountSpecNetworkRules{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AccountSpecNetworkRules

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecNetworkRules{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AccountSpecNetworkRules)(ptr) = objs[0]
			} else {
				*(*AccountSpecNetworkRules)(ptr) = AccountSpecNetworkRules{}
			}
		} else {
			*(*AccountSpecNetworkRules)(ptr) = AccountSpecNetworkRules{}
		}
	default:
		iter.ReportError("decode AccountSpecNetworkRules", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AccountSpecQueuePropertiesCodec struct {
}

func (AccountSpecQueuePropertiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AccountSpecQueueProperties)(ptr) == nil
}

func (AccountSpecQueuePropertiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AccountSpecQueueProperties)(ptr)
	var objs []AccountSpecQueueProperties
	if obj != nil {
		objs = []AccountSpecQueueProperties{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecQueueProperties{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AccountSpecQueuePropertiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AccountSpecQueueProperties)(ptr) = AccountSpecQueueProperties{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AccountSpecQueueProperties

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecQueueProperties{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AccountSpecQueueProperties)(ptr) = objs[0]
			} else {
				*(*AccountSpecQueueProperties)(ptr) = AccountSpecQueueProperties{}
			}
		} else {
			*(*AccountSpecQueueProperties)(ptr) = AccountSpecQueueProperties{}
		}
	default:
		iter.ReportError("decode AccountSpecQueueProperties", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AccountSpecQueuePropertiesHourMetricsCodec struct {
}

func (AccountSpecQueuePropertiesHourMetricsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AccountSpecQueuePropertiesHourMetrics)(ptr) == nil
}

func (AccountSpecQueuePropertiesHourMetricsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AccountSpecQueuePropertiesHourMetrics)(ptr)
	var objs []AccountSpecQueuePropertiesHourMetrics
	if obj != nil {
		objs = []AccountSpecQueuePropertiesHourMetrics{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecQueuePropertiesHourMetrics{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AccountSpecQueuePropertiesHourMetricsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AccountSpecQueuePropertiesHourMetrics)(ptr) = AccountSpecQueuePropertiesHourMetrics{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AccountSpecQueuePropertiesHourMetrics

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecQueuePropertiesHourMetrics{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AccountSpecQueuePropertiesHourMetrics)(ptr) = objs[0]
			} else {
				*(*AccountSpecQueuePropertiesHourMetrics)(ptr) = AccountSpecQueuePropertiesHourMetrics{}
			}
		} else {
			*(*AccountSpecQueuePropertiesHourMetrics)(ptr) = AccountSpecQueuePropertiesHourMetrics{}
		}
	default:
		iter.ReportError("decode AccountSpecQueuePropertiesHourMetrics", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AccountSpecQueuePropertiesLoggingCodec struct {
}

func (AccountSpecQueuePropertiesLoggingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AccountSpecQueuePropertiesLogging)(ptr) == nil
}

func (AccountSpecQueuePropertiesLoggingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AccountSpecQueuePropertiesLogging)(ptr)
	var objs []AccountSpecQueuePropertiesLogging
	if obj != nil {
		objs = []AccountSpecQueuePropertiesLogging{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecQueuePropertiesLogging{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AccountSpecQueuePropertiesLoggingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AccountSpecQueuePropertiesLogging)(ptr) = AccountSpecQueuePropertiesLogging{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AccountSpecQueuePropertiesLogging

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecQueuePropertiesLogging{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AccountSpecQueuePropertiesLogging)(ptr) = objs[0]
			} else {
				*(*AccountSpecQueuePropertiesLogging)(ptr) = AccountSpecQueuePropertiesLogging{}
			}
		} else {
			*(*AccountSpecQueuePropertiesLogging)(ptr) = AccountSpecQueuePropertiesLogging{}
		}
	default:
		iter.ReportError("decode AccountSpecQueuePropertiesLogging", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AccountSpecQueuePropertiesMinuteMetricsCodec struct {
}

func (AccountSpecQueuePropertiesMinuteMetricsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AccountSpecQueuePropertiesMinuteMetrics)(ptr) == nil
}

func (AccountSpecQueuePropertiesMinuteMetricsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AccountSpecQueuePropertiesMinuteMetrics)(ptr)
	var objs []AccountSpecQueuePropertiesMinuteMetrics
	if obj != nil {
		objs = []AccountSpecQueuePropertiesMinuteMetrics{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecQueuePropertiesMinuteMetrics{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AccountSpecQueuePropertiesMinuteMetricsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AccountSpecQueuePropertiesMinuteMetrics)(ptr) = AccountSpecQueuePropertiesMinuteMetrics{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AccountSpecQueuePropertiesMinuteMetrics

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecQueuePropertiesMinuteMetrics{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AccountSpecQueuePropertiesMinuteMetrics)(ptr) = objs[0]
			} else {
				*(*AccountSpecQueuePropertiesMinuteMetrics)(ptr) = AccountSpecQueuePropertiesMinuteMetrics{}
			}
		} else {
			*(*AccountSpecQueuePropertiesMinuteMetrics)(ptr) = AccountSpecQueuePropertiesMinuteMetrics{}
		}
	default:
		iter.ReportError("decode AccountSpecQueuePropertiesMinuteMetrics", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AccountSpecRoutingCodec struct {
}

func (AccountSpecRoutingCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AccountSpecRouting)(ptr) == nil
}

func (AccountSpecRoutingCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AccountSpecRouting)(ptr)
	var objs []AccountSpecRouting
	if obj != nil {
		objs = []AccountSpecRouting{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecRouting{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AccountSpecRoutingCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AccountSpecRouting)(ptr) = AccountSpecRouting{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AccountSpecRouting

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecRouting{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AccountSpecRouting)(ptr) = objs[0]
			} else {
				*(*AccountSpecRouting)(ptr) = AccountSpecRouting{}
			}
		} else {
			*(*AccountSpecRouting)(ptr) = AccountSpecRouting{}
		}
	default:
		iter.ReportError("decode AccountSpecRouting", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AccountSpecStaticWebsiteCodec struct {
}

func (AccountSpecStaticWebsiteCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AccountSpecStaticWebsite)(ptr) == nil
}

func (AccountSpecStaticWebsiteCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AccountSpecStaticWebsite)(ptr)
	var objs []AccountSpecStaticWebsite
	if obj != nil {
		objs = []AccountSpecStaticWebsite{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecStaticWebsite{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AccountSpecStaticWebsiteCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AccountSpecStaticWebsite)(ptr) = AccountSpecStaticWebsite{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AccountSpecStaticWebsite

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AccountSpecStaticWebsite{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AccountSpecStaticWebsite)(ptr) = objs[0]
			} else {
				*(*AccountSpecStaticWebsite)(ptr) = AccountSpecStaticWebsite{}
			}
		} else {
			*(*AccountSpecStaticWebsite)(ptr) = AccountSpecStaticWebsite{}
		}
	default:
		iter.ReportError("decode AccountSpecStaticWebsite", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type BlobInventoryPolicySpecRulesFilterCodec struct {
}

func (BlobInventoryPolicySpecRulesFilterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*BlobInventoryPolicySpecRulesFilter)(ptr) == nil
}

func (BlobInventoryPolicySpecRulesFilterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*BlobInventoryPolicySpecRulesFilter)(ptr)
	var objs []BlobInventoryPolicySpecRulesFilter
	if obj != nil {
		objs = []BlobInventoryPolicySpecRulesFilter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BlobInventoryPolicySpecRulesFilter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (BlobInventoryPolicySpecRulesFilterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*BlobInventoryPolicySpecRulesFilter)(ptr) = BlobInventoryPolicySpecRulesFilter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []BlobInventoryPolicySpecRulesFilter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(BlobInventoryPolicySpecRulesFilter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*BlobInventoryPolicySpecRulesFilter)(ptr) = objs[0]
			} else {
				*(*BlobInventoryPolicySpecRulesFilter)(ptr) = BlobInventoryPolicySpecRulesFilter{}
			}
		} else {
			*(*BlobInventoryPolicySpecRulesFilter)(ptr) = BlobInventoryPolicySpecRulesFilter{}
		}
	default:
		iter.ReportError("decode BlobInventoryPolicySpecRulesFilter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementPolicySpecRuleActionsCodec struct {
}

func (ManagementPolicySpecRuleActionsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementPolicySpecRuleActions)(ptr) == nil
}

func (ManagementPolicySpecRuleActionsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementPolicySpecRuleActions)(ptr)
	var objs []ManagementPolicySpecRuleActions
	if obj != nil {
		objs = []ManagementPolicySpecRuleActions{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementPolicySpecRuleActions{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementPolicySpecRuleActionsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementPolicySpecRuleActions)(ptr) = ManagementPolicySpecRuleActions{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementPolicySpecRuleActions

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementPolicySpecRuleActions{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementPolicySpecRuleActions)(ptr) = objs[0]
			} else {
				*(*ManagementPolicySpecRuleActions)(ptr) = ManagementPolicySpecRuleActions{}
			}
		} else {
			*(*ManagementPolicySpecRuleActions)(ptr) = ManagementPolicySpecRuleActions{}
		}
	default:
		iter.ReportError("decode ManagementPolicySpecRuleActions", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementPolicySpecRuleActionsBaseBlobCodec struct {
}

func (ManagementPolicySpecRuleActionsBaseBlobCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementPolicySpecRuleActionsBaseBlob)(ptr) == nil
}

func (ManagementPolicySpecRuleActionsBaseBlobCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementPolicySpecRuleActionsBaseBlob)(ptr)
	var objs []ManagementPolicySpecRuleActionsBaseBlob
	if obj != nil {
		objs = []ManagementPolicySpecRuleActionsBaseBlob{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementPolicySpecRuleActionsBaseBlob{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementPolicySpecRuleActionsBaseBlobCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementPolicySpecRuleActionsBaseBlob)(ptr) = ManagementPolicySpecRuleActionsBaseBlob{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementPolicySpecRuleActionsBaseBlob

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementPolicySpecRuleActionsBaseBlob{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementPolicySpecRuleActionsBaseBlob)(ptr) = objs[0]
			} else {
				*(*ManagementPolicySpecRuleActionsBaseBlob)(ptr) = ManagementPolicySpecRuleActionsBaseBlob{}
			}
		} else {
			*(*ManagementPolicySpecRuleActionsBaseBlob)(ptr) = ManagementPolicySpecRuleActionsBaseBlob{}
		}
	default:
		iter.ReportError("decode ManagementPolicySpecRuleActionsBaseBlob", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementPolicySpecRuleActionsSnapshotCodec struct {
}

func (ManagementPolicySpecRuleActionsSnapshotCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementPolicySpecRuleActionsSnapshot)(ptr) == nil
}

func (ManagementPolicySpecRuleActionsSnapshotCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementPolicySpecRuleActionsSnapshot)(ptr)
	var objs []ManagementPolicySpecRuleActionsSnapshot
	if obj != nil {
		objs = []ManagementPolicySpecRuleActionsSnapshot{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementPolicySpecRuleActionsSnapshot{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementPolicySpecRuleActionsSnapshotCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementPolicySpecRuleActionsSnapshot)(ptr) = ManagementPolicySpecRuleActionsSnapshot{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementPolicySpecRuleActionsSnapshot

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementPolicySpecRuleActionsSnapshot{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementPolicySpecRuleActionsSnapshot)(ptr) = objs[0]
			} else {
				*(*ManagementPolicySpecRuleActionsSnapshot)(ptr) = ManagementPolicySpecRuleActionsSnapshot{}
			}
		} else {
			*(*ManagementPolicySpecRuleActionsSnapshot)(ptr) = ManagementPolicySpecRuleActionsSnapshot{}
		}
	default:
		iter.ReportError("decode ManagementPolicySpecRuleActionsSnapshot", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementPolicySpecRuleActionsVersionCodec struct {
}

func (ManagementPolicySpecRuleActionsVersionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementPolicySpecRuleActionsVersion)(ptr) == nil
}

func (ManagementPolicySpecRuleActionsVersionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementPolicySpecRuleActionsVersion)(ptr)
	var objs []ManagementPolicySpecRuleActionsVersion
	if obj != nil {
		objs = []ManagementPolicySpecRuleActionsVersion{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementPolicySpecRuleActionsVersion{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementPolicySpecRuleActionsVersionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementPolicySpecRuleActionsVersion)(ptr) = ManagementPolicySpecRuleActionsVersion{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementPolicySpecRuleActionsVersion

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementPolicySpecRuleActionsVersion{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementPolicySpecRuleActionsVersion)(ptr) = objs[0]
			} else {
				*(*ManagementPolicySpecRuleActionsVersion)(ptr) = ManagementPolicySpecRuleActionsVersion{}
			}
		} else {
			*(*ManagementPolicySpecRuleActionsVersion)(ptr) = ManagementPolicySpecRuleActionsVersion{}
		}
	default:
		iter.ReportError("decode ManagementPolicySpecRuleActionsVersion", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ManagementPolicySpecRuleFiltersCodec struct {
}

func (ManagementPolicySpecRuleFiltersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ManagementPolicySpecRuleFilters)(ptr) == nil
}

func (ManagementPolicySpecRuleFiltersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ManagementPolicySpecRuleFilters)(ptr)
	var objs []ManagementPolicySpecRuleFilters
	if obj != nil {
		objs = []ManagementPolicySpecRuleFilters{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementPolicySpecRuleFilters{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ManagementPolicySpecRuleFiltersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ManagementPolicySpecRuleFilters)(ptr) = ManagementPolicySpecRuleFilters{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ManagementPolicySpecRuleFilters

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ManagementPolicySpecRuleFilters{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ManagementPolicySpecRuleFilters)(ptr) = objs[0]
			} else {
				*(*ManagementPolicySpecRuleFilters)(ptr) = ManagementPolicySpecRuleFilters{}
			}
		} else {
			*(*ManagementPolicySpecRuleFilters)(ptr) = ManagementPolicySpecRuleFilters{}
		}
	default:
		iter.ReportError("decode ManagementPolicySpecRuleFilters", "unexpected JSON type")
	}
}
