/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AadDiagnosticSettingSpecLogRetentionPolicy{}).Type1()):                            AadDiagnosticSettingSpecLogRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionGroupSpecWebhookReceiverAadAuth{}).Type1()):                                 ActionGroupSpecWebhookReceiverAadAuthCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecCondition{}).Type1()):                                    ActionRuleActionGroupSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionAlertContext{}).Type1()):                        ActionRuleActionGroupSpecConditionAlertContextCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionAlertRuleID{}).Type1()):                         ActionRuleActionGroupSpecConditionAlertRuleIDCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionDescription{}).Type1()):                         ActionRuleActionGroupSpecConditionDescriptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionMonitor{}).Type1()):                             ActionRuleActionGroupSpecConditionMonitorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionMonitorService{}).Type1()):                      ActionRuleActionGroupSpecConditionMonitorServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionSeverity{}).Type1()):                            ActionRuleActionGroupSpecConditionSeverityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionTargetResourceType{}).Type1()):                  ActionRuleActionGroupSpecConditionTargetResourceTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecScope{}).Type1()):                                        ActionRuleActionGroupSpecScopeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecCondition{}).Type1()):                                    ActionRuleSuppressionSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionAlertContext{}).Type1()):                        ActionRuleSuppressionSpecConditionAlertContextCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionAlertRuleID{}).Type1()):                         ActionRuleSuppressionSpecConditionAlertRuleIDCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionDescription{}).Type1()):                         ActionRuleSuppressionSpecConditionDescriptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionMonitor{}).Type1()):                             ActionRuleSuppressionSpecConditionMonitorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionMonitorService{}).Type1()):                      ActionRuleSuppressionSpecConditionMonitorServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionSeverity{}).Type1()):                            ActionRuleSuppressionSpecConditionSeverityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionTargetResourceType{}).Type1()):                  ActionRuleSuppressionSpecConditionTargetResourceTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecScope{}).Type1()):                                        ActionRuleSuppressionSpecScopeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecSuppression{}).Type1()):                                  ActionRuleSuppressionSpecSuppressionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecSuppressionSchedule{}).Type1()):                          ActionRuleSuppressionSpecSuppressionScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActivityLogAlertSpecCriteria{}).Type1()):                                          ActivityLogAlertSpecCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecNotification{}).Type1()):                                      AutoscaleSettingSpecNotificationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecNotificationEmail{}).Type1()):                                 AutoscaleSettingSpecNotificationEmailCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecProfileCapacity{}).Type1()):                                   AutoscaleSettingSpecProfileCapacityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecProfileFixedDate{}).Type1()):                                  AutoscaleSettingSpecProfileFixedDateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecProfileRecurrence{}).Type1()):                                 AutoscaleSettingSpecProfileRecurrenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecProfileRuleMetricTrigger{}).Type1()):                          AutoscaleSettingSpecProfileRuleMetricTriggerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecProfileRuleScaleAction{}).Type1()):                            AutoscaleSettingSpecProfileRuleScaleActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSettingSpecLogRetentionPolicy{}).Type1()):                               DiagnosticSettingSpecLogRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSettingSpecMetricRetentionPolicy{}).Type1()):                            DiagnosticSettingSpecMetricRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LogProfileSpecRetentionPolicy{}).Type1()):                                         LogProfileSpecRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MetricAlertSpecApplicationInsightsWebTestLocationAvailabilityCriteria{}).Type1()): MetricAlertSpecApplicationInsightsWebTestLocationAvailabilityCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MetricAlertSpecDynamicCriteria{}).Type1()):                                        MetricAlertSpecDynamicCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ScheduledQueryRulesAlertSpecAction{}).Type1()):                                    ScheduledQueryRulesAlertSpecActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ScheduledQueryRulesAlertSpecTrigger{}).Type1()):                                   ScheduledQueryRulesAlertSpecTriggerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ScheduledQueryRulesAlertSpecTriggerMetricTrigger{}).Type1()):                      ScheduledQueryRulesAlertSpecTriggerMetricTriggerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ScheduledQueryRulesLogSpecCriteria{}).Type1()):                                    ScheduledQueryRulesLogSpecCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SmartDetectorAlertRuleSpecActionGroup{}).Type1()):                                 SmartDetectorAlertRuleSpecActionGroupCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(AadDiagnosticSettingSpecLogRetentionPolicy{}).Type1()):                            AadDiagnosticSettingSpecLogRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionGroupSpecWebhookReceiverAadAuth{}).Type1()):                                 ActionGroupSpecWebhookReceiverAadAuthCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecCondition{}).Type1()):                                    ActionRuleActionGroupSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionAlertContext{}).Type1()):                        ActionRuleActionGroupSpecConditionAlertContextCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionAlertRuleID{}).Type1()):                         ActionRuleActionGroupSpecConditionAlertRuleIDCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionDescription{}).Type1()):                         ActionRuleActionGroupSpecConditionDescriptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionMonitor{}).Type1()):                             ActionRuleActionGroupSpecConditionMonitorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionMonitorService{}).Type1()):                      ActionRuleActionGroupSpecConditionMonitorServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionSeverity{}).Type1()):                            ActionRuleActionGroupSpecConditionSeverityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionTargetResourceType{}).Type1()):                  ActionRuleActionGroupSpecConditionTargetResourceTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecScope{}).Type1()):                                        ActionRuleActionGroupSpecScopeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecCondition{}).Type1()):                                    ActionRuleSuppressionSpecConditionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionAlertContext{}).Type1()):                        ActionRuleSuppressionSpecConditionAlertContextCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionAlertRuleID{}).Type1()):                         ActionRuleSuppressionSpecConditionAlertRuleIDCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionDescription{}).Type1()):                         ActionRuleSuppressionSpecConditionDescriptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionMonitor{}).Type1()):                             ActionRuleSuppressionSpecConditionMonitorCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionMonitorService{}).Type1()):                      ActionRuleSuppressionSpecConditionMonitorServiceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionSeverity{}).Type1()):                            ActionRuleSuppressionSpecConditionSeverityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionTargetResourceType{}).Type1()):                  ActionRuleSuppressionSpecConditionTargetResourceTypeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecScope{}).Type1()):                                        ActionRuleSuppressionSpecScopeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecSuppression{}).Type1()):                                  ActionRuleSuppressionSpecSuppressionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecSuppressionSchedule{}).Type1()):                          ActionRuleSuppressionSpecSuppressionScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ActivityLogAlertSpecCriteria{}).Type1()):                                          ActivityLogAlertSpecCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecNotification{}).Type1()):                                      AutoscaleSettingSpecNotificationCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecNotificationEmail{}).Type1()):                                 AutoscaleSettingSpecNotificationEmailCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecProfileCapacity{}).Type1()):                                   AutoscaleSettingSpecProfileCapacityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecProfileFixedDate{}).Type1()):                                  AutoscaleSettingSpecProfileFixedDateCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecProfileRecurrence{}).Type1()):                                 AutoscaleSettingSpecProfileRecurrenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecProfileRuleMetricTrigger{}).Type1()):                          AutoscaleSettingSpecProfileRuleMetricTriggerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecProfileRuleScaleAction{}).Type1()):                            AutoscaleSettingSpecProfileRuleScaleActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSettingSpecLogRetentionPolicy{}).Type1()):                               DiagnosticSettingSpecLogRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSettingSpecMetricRetentionPolicy{}).Type1()):                            DiagnosticSettingSpecMetricRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(LogProfileSpecRetentionPolicy{}).Type1()):                                         LogProfileSpecRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MetricAlertSpecApplicationInsightsWebTestLocationAvailabilityCriteria{}).Type1()): MetricAlertSpecApplicationInsightsWebTestLocationAvailabilityCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(MetricAlertSpecDynamicCriteria{}).Type1()):                                        MetricAlertSpecDynamicCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ScheduledQueryRulesAlertSpecAction{}).Type1()):                                    ScheduledQueryRulesAlertSpecActionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ScheduledQueryRulesAlertSpecTrigger{}).Type1()):                                   ScheduledQueryRulesAlertSpecTriggerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ScheduledQueryRulesAlertSpecTriggerMetricTrigger{}).Type1()):                      ScheduledQueryRulesAlertSpecTriggerMetricTriggerCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ScheduledQueryRulesLogSpecCriteria{}).Type1()):                                    ScheduledQueryRulesLogSpecCriteriaCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(SmartDetectorAlertRuleSpecActionGroup{}).Type1()):                                 SmartDetectorAlertRuleSpecActionGroupCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type AadDiagnosticSettingSpecLogRetentionPolicyCodec struct {
}

func (AadDiagnosticSettingSpecLogRetentionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AadDiagnosticSettingSpecLogRetentionPolicy)(ptr) == nil
}

func (AadDiagnosticSettingSpecLogRetentionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AadDiagnosticSettingSpecLogRetentionPolicy)(ptr)
	var objs []AadDiagnosticSettingSpecLogRetentionPolicy
	if obj != nil {
		objs = []AadDiagnosticSettingSpecLogRetentionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AadDiagnosticSettingSpecLogRetentionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AadDiagnosticSettingSpecLogRetentionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AadDiagnosticSettingSpecLogRetentionPolicy)(ptr) = AadDiagnosticSettingSpecLogRetentionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AadDiagnosticSettingSpecLogRetentionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AadDiagnosticSettingSpecLogRetentionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AadDiagnosticSettingSpecLogRetentionPolicy)(ptr) = objs[0]
			} else {
				*(*AadDiagnosticSettingSpecLogRetentionPolicy)(ptr) = AadDiagnosticSettingSpecLogRetentionPolicy{}
			}
		} else {
			*(*AadDiagnosticSettingSpecLogRetentionPolicy)(ptr) = AadDiagnosticSettingSpecLogRetentionPolicy{}
		}
	default:
		iter.ReportError("decode AadDiagnosticSettingSpecLogRetentionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ActionGroupSpecWebhookReceiverAadAuthCodec struct {
}

func (ActionGroupSpecWebhookReceiverAadAuthCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ActionGroupSpecWebhookReceiverAadAuth)(ptr) == nil
}

func (ActionGroupSpecWebhookReceiverAadAuthCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ActionGroupSpecWebhookReceiverAadAuth)(ptr)
	var objs []ActionGroupSpecWebhookReceiverAadAuth
	if obj != nil {
		objs = []ActionGroupSpecWebhookReceiverAadAuth{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionGroupSpecWebhookReceiverAadAuth{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ActionGroupSpecWebhookReceiverAadAuthCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ActionGroupSpecWebhookReceiverAadAuth)(ptr) = ActionGroupSpecWebhookReceiverAadAuth{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ActionGroupSpecWebhookReceiverAadAuth

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionGroupSpecWebhookReceiverAadAuth{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ActionGroupSpecWebhookReceiverAadAuth)(ptr) = objs[0]
			} else {
				*(*ActionGroupSpecWebhookReceiverAadAuth)(ptr) = ActionGroupSpecWebhookReceiverAadAuth{}
			}
		} else {
			*(*ActionGroupSpecWebhookReceiverAadAuth)(ptr) = ActionGroupSpecWebhookReceiverAadAuth{}
		}
	default:
		iter.ReportError("decode ActionGroupSpecWebhookReceiverAadAuth", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ActionRuleActionGroupSpecConditionCodec struct {
}

func (ActionRuleActionGroupSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ActionRuleActionGroupSpecCondition)(ptr) == nil
}

func (ActionRuleActionGroupSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ActionRuleActionGroupSpecCondition)(ptr)
	var objs []ActionRuleActionGroupSpecCondition
	if obj != nil {
		objs = []ActionRuleActionGroupSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ActionRuleActionGroupSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ActionRuleActionGroupSpecCondition)(ptr) = ActionRuleActionGroupSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ActionRuleActionGroupSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ActionRuleActionGroupSpecCondition)(ptr) = objs[0]
			} else {
				*(*ActionRuleActionGroupSpecCondition)(ptr) = ActionRuleActionGroupSpecCondition{}
			}
		} else {
			*(*ActionRuleActionGroupSpecCondition)(ptr) = ActionRuleActionGroupSpecCondition{}
		}
	default:
		iter.ReportError("decode ActionRuleActionGroupSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ActionRuleActionGroupSpecConditionAlertContextCodec struct {
}

func (ActionRuleActionGroupSpecConditionAlertContextCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ActionRuleActionGroupSpecConditionAlertContext)(ptr) == nil
}

func (ActionRuleActionGroupSpecConditionAlertContextCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ActionRuleActionGroupSpecConditionAlertContext)(ptr)
	var objs []ActionRuleActionGroupSpecConditionAlertContext
	if obj != nil {
		objs = []ActionRuleActionGroupSpecConditionAlertContext{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionAlertContext{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ActionRuleActionGroupSpecConditionAlertContextCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ActionRuleActionGroupSpecConditionAlertContext)(ptr) = ActionRuleActionGroupSpecConditionAlertContext{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ActionRuleActionGroupSpecConditionAlertContext

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionAlertContext{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ActionRuleActionGroupSpecConditionAlertContext)(ptr) = objs[0]
			} else {
				*(*ActionRuleActionGroupSpecConditionAlertContext)(ptr) = ActionRuleActionGroupSpecConditionAlertContext{}
			}
		} else {
			*(*ActionRuleActionGroupSpecConditionAlertContext)(ptr) = ActionRuleActionGroupSpecConditionAlertContext{}
		}
	default:
		iter.ReportError("decode ActionRuleActionGroupSpecConditionAlertContext", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ActionRuleActionGroupSpecConditionAlertRuleIDCodec struct {
}

func (ActionRuleActionGroupSpecConditionAlertRuleIDCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ActionRuleActionGroupSpecConditionAlertRuleID)(ptr) == nil
}

func (ActionRuleActionGroupSpecConditionAlertRuleIDCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ActionRuleActionGroupSpecConditionAlertRuleID)(ptr)
	var objs []ActionRuleActionGroupSpecConditionAlertRuleID
	if obj != nil {
		objs = []ActionRuleActionGroupSpecConditionAlertRuleID{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionAlertRuleID{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ActionRuleActionGroupSpecConditionAlertRuleIDCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ActionRuleActionGroupSpecConditionAlertRuleID)(ptr) = ActionRuleActionGroupSpecConditionAlertRuleID{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ActionRuleActionGroupSpecConditionAlertRuleID

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionAlertRuleID{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ActionRuleActionGroupSpecConditionAlertRuleID)(ptr) = objs[0]
			} else {
				*(*ActionRuleActionGroupSpecConditionAlertRuleID)(ptr) = ActionRuleActionGroupSpecConditionAlertRuleID{}
			}
		} else {
			*(*ActionRuleActionGroupSpecConditionAlertRuleID)(ptr) = ActionRuleActionGroupSpecConditionAlertRuleID{}
		}
	default:
		iter.ReportError("decode ActionRuleActionGroupSpecConditionAlertRuleID", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ActionRuleActionGroupSpecConditionDescriptionCodec struct {
}

func (ActionRuleActionGroupSpecConditionDescriptionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ActionRuleActionGroupSpecConditionDescription)(ptr) == nil
}

func (ActionRuleActionGroupSpecConditionDescriptionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ActionRuleActionGroupSpecConditionDescription)(ptr)
	var objs []ActionRuleActionGroupSpecConditionDescription
	if obj != nil {
		objs = []ActionRuleActionGroupSpecConditionDescription{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionDescription{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ActionRuleActionGroupSpecConditionDescriptionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ActionRuleActionGroupSpecConditionDescription)(ptr) = ActionRuleActionGroupSpecConditionDescription{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ActionRuleActionGroupSpecConditionDescription

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionDescription{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ActionRuleActionGroupSpecConditionDescription)(ptr) = objs[0]
			} else {
				*(*ActionRuleActionGroupSpecConditionDescription)(ptr) = ActionRuleActionGroupSpecConditionDescription{}
			}
		} else {
			*(*ActionRuleActionGroupSpecConditionDescription)(ptr) = ActionRuleActionGroupSpecConditionDescription{}
		}
	default:
		iter.ReportError("decode ActionRuleActionGroupSpecConditionDescription", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ActionRuleActionGroupSpecConditionMonitorCodec struct {
}

func (ActionRuleActionGroupSpecConditionMonitorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ActionRuleActionGroupSpecConditionMonitor)(ptr) == nil
}

func (ActionRuleActionGroupSpecConditionMonitorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ActionRuleActionGroupSpecConditionMonitor)(ptr)
	var objs []ActionRuleActionGroupSpecConditionMonitor
	if obj != nil {
		objs = []ActionRuleActionGroupSpecConditionMonitor{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionMonitor{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ActionRuleActionGroupSpecConditionMonitorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ActionRuleActionGroupSpecConditionMonitor)(ptr) = ActionRuleActionGroupSpecConditionMonitor{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ActionRuleActionGroupSpecConditionMonitor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionMonitor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ActionRuleActionGroupSpecConditionMonitor)(ptr) = objs[0]
			} else {
				*(*ActionRuleActionGroupSpecConditionMonitor)(ptr) = ActionRuleActionGroupSpecConditionMonitor{}
			}
		} else {
			*(*ActionRuleActionGroupSpecConditionMonitor)(ptr) = ActionRuleActionGroupSpecConditionMonitor{}
		}
	default:
		iter.ReportError("decode ActionRuleActionGroupSpecConditionMonitor", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ActionRuleActionGroupSpecConditionMonitorServiceCodec struct {
}

func (ActionRuleActionGroupSpecConditionMonitorServiceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ActionRuleActionGroupSpecConditionMonitorService)(ptr) == nil
}

func (ActionRuleActionGroupSpecConditionMonitorServiceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ActionRuleActionGroupSpecConditionMonitorService)(ptr)
	var objs []ActionRuleActionGroupSpecConditionMonitorService
	if obj != nil {
		objs = []ActionRuleActionGroupSpecConditionMonitorService{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionMonitorService{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ActionRuleActionGroupSpecConditionMonitorServiceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ActionRuleActionGroupSpecConditionMonitorService)(ptr) = ActionRuleActionGroupSpecConditionMonitorService{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ActionRuleActionGroupSpecConditionMonitorService

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionMonitorService{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ActionRuleActionGroupSpecConditionMonitorService)(ptr) = objs[0]
			} else {
				*(*ActionRuleActionGroupSpecConditionMonitorService)(ptr) = ActionRuleActionGroupSpecConditionMonitorService{}
			}
		} else {
			*(*ActionRuleActionGroupSpecConditionMonitorService)(ptr) = ActionRuleActionGroupSpecConditionMonitorService{}
		}
	default:
		iter.ReportError("decode ActionRuleActionGroupSpecConditionMonitorService", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ActionRuleActionGroupSpecConditionSeverityCodec struct {
}

func (ActionRuleActionGroupSpecConditionSeverityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ActionRuleActionGroupSpecConditionSeverity)(ptr) == nil
}

func (ActionRuleActionGroupSpecConditionSeverityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ActionRuleActionGroupSpecConditionSeverity)(ptr)
	var objs []ActionRuleActionGroupSpecConditionSeverity
	if obj != nil {
		objs = []ActionRuleActionGroupSpecConditionSeverity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionSeverity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ActionRuleActionGroupSpecConditionSeverityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ActionRuleActionGroupSpecConditionSeverity)(ptr) = ActionRuleActionGroupSpecConditionSeverity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ActionRuleActionGroupSpecConditionSeverity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionSeverity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ActionRuleActionGroupSpecConditionSeverity)(ptr) = objs[0]
			} else {
				*(*ActionRuleActionGroupSpecConditionSeverity)(ptr) = ActionRuleActionGroupSpecConditionSeverity{}
			}
		} else {
			*(*ActionRuleActionGroupSpecConditionSeverity)(ptr) = ActionRuleActionGroupSpecConditionSeverity{}
		}
	default:
		iter.ReportError("decode ActionRuleActionGroupSpecConditionSeverity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ActionRuleActionGroupSpecConditionTargetResourceTypeCodec struct {
}

func (ActionRuleActionGroupSpecConditionTargetResourceTypeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ActionRuleActionGroupSpecConditionTargetResourceType)(ptr) == nil
}

func (ActionRuleActionGroupSpecConditionTargetResourceTypeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ActionRuleActionGroupSpecConditionTargetResourceType)(ptr)
	var objs []ActionRuleActionGroupSpecConditionTargetResourceType
	if obj != nil {
		objs = []ActionRuleActionGroupSpecConditionTargetResourceType{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionTargetResourceType{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ActionRuleActionGroupSpecConditionTargetResourceTypeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ActionRuleActionGroupSpecConditionTargetResourceType)(ptr) = ActionRuleActionGroupSpecConditionTargetResourceType{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ActionRuleActionGroupSpecConditionTargetResourceType

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecConditionTargetResourceType{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ActionRuleActionGroupSpecConditionTargetResourceType)(ptr) = objs[0]
			} else {
				*(*ActionRuleActionGroupSpecConditionTargetResourceType)(ptr) = ActionRuleActionGroupSpecConditionTargetResourceType{}
			}
		} else {
			*(*ActionRuleActionGroupSpecConditionTargetResourceType)(ptr) = ActionRuleActionGroupSpecConditionTargetResourceType{}
		}
	default:
		iter.ReportError("decode ActionRuleActionGroupSpecConditionTargetResourceType", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ActionRuleActionGroupSpecScopeCodec struct {
}

func (ActionRuleActionGroupSpecScopeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ActionRuleActionGroupSpecScope)(ptr) == nil
}

func (ActionRuleActionGroupSpecScopeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ActionRuleActionGroupSpecScope)(ptr)
	var objs []ActionRuleActionGroupSpecScope
	if obj != nil {
		objs = []ActionRuleActionGroupSpecScope{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecScope{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ActionRuleActionGroupSpecScopeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ActionRuleActionGroupSpecScope)(ptr) = ActionRuleActionGroupSpecScope{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ActionRuleActionGroupSpecScope

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleActionGroupSpecScope{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ActionRuleActionGroupSpecScope)(ptr) = objs[0]
			} else {
				*(*ActionRuleActionGroupSpecScope)(ptr) = ActionRuleActionGroupSpecScope{}
			}
		} else {
			*(*ActionRuleActionGroupSpecScope)(ptr) = ActionRuleActionGroupSpecScope{}
		}
	default:
		iter.ReportError("decode ActionRuleActionGroupSpecScope", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ActionRuleSuppressionSpecConditionCodec struct {
}

func (ActionRuleSuppressionSpecConditionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ActionRuleSuppressionSpecCondition)(ptr) == nil
}

func (ActionRuleSuppressionSpecConditionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ActionRuleSuppressionSpecCondition)(ptr)
	var objs []ActionRuleSuppressionSpecCondition
	if obj != nil {
		objs = []ActionRuleSuppressionSpecCondition{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecCondition{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ActionRuleSuppressionSpecConditionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ActionRuleSuppressionSpecCondition)(ptr) = ActionRuleSuppressionSpecCondition{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ActionRuleSuppressionSpecCondition

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecCondition{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ActionRuleSuppressionSpecCondition)(ptr) = objs[0]
			} else {
				*(*ActionRuleSuppressionSpecCondition)(ptr) = ActionRuleSuppressionSpecCondition{}
			}
		} else {
			*(*ActionRuleSuppressionSpecCondition)(ptr) = ActionRuleSuppressionSpecCondition{}
		}
	default:
		iter.ReportError("decode ActionRuleSuppressionSpecCondition", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ActionRuleSuppressionSpecConditionAlertContextCodec struct {
}

func (ActionRuleSuppressionSpecConditionAlertContextCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ActionRuleSuppressionSpecConditionAlertContext)(ptr) == nil
}

func (ActionRuleSuppressionSpecConditionAlertContextCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ActionRuleSuppressionSpecConditionAlertContext)(ptr)
	var objs []ActionRuleSuppressionSpecConditionAlertContext
	if obj != nil {
		objs = []ActionRuleSuppressionSpecConditionAlertContext{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionAlertContext{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ActionRuleSuppressionSpecConditionAlertContextCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ActionRuleSuppressionSpecConditionAlertContext)(ptr) = ActionRuleSuppressionSpecConditionAlertContext{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ActionRuleSuppressionSpecConditionAlertContext

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionAlertContext{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ActionRuleSuppressionSpecConditionAlertContext)(ptr) = objs[0]
			} else {
				*(*ActionRuleSuppressionSpecConditionAlertContext)(ptr) = ActionRuleSuppressionSpecConditionAlertContext{}
			}
		} else {
			*(*ActionRuleSuppressionSpecConditionAlertContext)(ptr) = ActionRuleSuppressionSpecConditionAlertContext{}
		}
	default:
		iter.ReportError("decode ActionRuleSuppressionSpecConditionAlertContext", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ActionRuleSuppressionSpecConditionAlertRuleIDCodec struct {
}

func (ActionRuleSuppressionSpecConditionAlertRuleIDCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ActionRuleSuppressionSpecConditionAlertRuleID)(ptr) == nil
}

func (ActionRuleSuppressionSpecConditionAlertRuleIDCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ActionRuleSuppressionSpecConditionAlertRuleID)(ptr)
	var objs []ActionRuleSuppressionSpecConditionAlertRuleID
	if obj != nil {
		objs = []ActionRuleSuppressionSpecConditionAlertRuleID{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionAlertRuleID{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ActionRuleSuppressionSpecConditionAlertRuleIDCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ActionRuleSuppressionSpecConditionAlertRuleID)(ptr) = ActionRuleSuppressionSpecConditionAlertRuleID{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ActionRuleSuppressionSpecConditionAlertRuleID

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionAlertRuleID{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ActionRuleSuppressionSpecConditionAlertRuleID)(ptr) = objs[0]
			} else {
				*(*ActionRuleSuppressionSpecConditionAlertRuleID)(ptr) = ActionRuleSuppressionSpecConditionAlertRuleID{}
			}
		} else {
			*(*ActionRuleSuppressionSpecConditionAlertRuleID)(ptr) = ActionRuleSuppressionSpecConditionAlertRuleID{}
		}
	default:
		iter.ReportError("decode ActionRuleSuppressionSpecConditionAlertRuleID", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ActionRuleSuppressionSpecConditionDescriptionCodec struct {
}

func (ActionRuleSuppressionSpecConditionDescriptionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ActionRuleSuppressionSpecConditionDescription)(ptr) == nil
}

func (ActionRuleSuppressionSpecConditionDescriptionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ActionRuleSuppressionSpecConditionDescription)(ptr)
	var objs []ActionRuleSuppressionSpecConditionDescription
	if obj != nil {
		objs = []ActionRuleSuppressionSpecConditionDescription{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionDescription{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ActionRuleSuppressionSpecConditionDescriptionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ActionRuleSuppressionSpecConditionDescription)(ptr) = ActionRuleSuppressionSpecConditionDescription{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ActionRuleSuppressionSpecConditionDescription

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionDescription{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ActionRuleSuppressionSpecConditionDescription)(ptr) = objs[0]
			} else {
				*(*ActionRuleSuppressionSpecConditionDescription)(ptr) = ActionRuleSuppressionSpecConditionDescription{}
			}
		} else {
			*(*ActionRuleSuppressionSpecConditionDescription)(ptr) = ActionRuleSuppressionSpecConditionDescription{}
		}
	default:
		iter.ReportError("decode ActionRuleSuppressionSpecConditionDescription", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ActionRuleSuppressionSpecConditionMonitorCodec struct {
}

func (ActionRuleSuppressionSpecConditionMonitorCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ActionRuleSuppressionSpecConditionMonitor)(ptr) == nil
}

func (ActionRuleSuppressionSpecConditionMonitorCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ActionRuleSuppressionSpecConditionMonitor)(ptr)
	var objs []ActionRuleSuppressionSpecConditionMonitor
	if obj != nil {
		objs = []ActionRuleSuppressionSpecConditionMonitor{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionMonitor{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ActionRuleSuppressionSpecConditionMonitorCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ActionRuleSuppressionSpecConditionMonitor)(ptr) = ActionRuleSuppressionSpecConditionMonitor{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ActionRuleSuppressionSpecConditionMonitor

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionMonitor{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ActionRuleSuppressionSpecConditionMonitor)(ptr) = objs[0]
			} else {
				*(*ActionRuleSuppressionSpecConditionMonitor)(ptr) = ActionRuleSuppressionSpecConditionMonitor{}
			}
		} else {
			*(*ActionRuleSuppressionSpecConditionMonitor)(ptr) = ActionRuleSuppressionSpecConditionMonitor{}
		}
	default:
		iter.ReportError("decode ActionRuleSuppressionSpecConditionMonitor", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ActionRuleSuppressionSpecConditionMonitorServiceCodec struct {
}

func (ActionRuleSuppressionSpecConditionMonitorServiceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ActionRuleSuppressionSpecConditionMonitorService)(ptr) == nil
}

func (ActionRuleSuppressionSpecConditionMonitorServiceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ActionRuleSuppressionSpecConditionMonitorService)(ptr)
	var objs []ActionRuleSuppressionSpecConditionMonitorService
	if obj != nil {
		objs = []ActionRuleSuppressionSpecConditionMonitorService{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionMonitorService{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ActionRuleSuppressionSpecConditionMonitorServiceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ActionRuleSuppressionSpecConditionMonitorService)(ptr) = ActionRuleSuppressionSpecConditionMonitorService{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ActionRuleSuppressionSpecConditionMonitorService

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionMonitorService{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ActionRuleSuppressionSpecConditionMonitorService)(ptr) = objs[0]
			} else {
				*(*ActionRuleSuppressionSpecConditionMonitorService)(ptr) = ActionRuleSuppressionSpecConditionMonitorService{}
			}
		} else {
			*(*ActionRuleSuppressionSpecConditionMonitorService)(ptr) = ActionRuleSuppressionSpecConditionMonitorService{}
		}
	default:
		iter.ReportError("decode ActionRuleSuppressionSpecConditionMonitorService", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ActionRuleSuppressionSpecConditionSeverityCodec struct {
}

func (ActionRuleSuppressionSpecConditionSeverityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ActionRuleSuppressionSpecConditionSeverity)(ptr) == nil
}

func (ActionRuleSuppressionSpecConditionSeverityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ActionRuleSuppressionSpecConditionSeverity)(ptr)
	var objs []ActionRuleSuppressionSpecConditionSeverity
	if obj != nil {
		objs = []ActionRuleSuppressionSpecConditionSeverity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionSeverity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ActionRuleSuppressionSpecConditionSeverityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ActionRuleSuppressionSpecConditionSeverity)(ptr) = ActionRuleSuppressionSpecConditionSeverity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ActionRuleSuppressionSpecConditionSeverity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionSeverity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ActionRuleSuppressionSpecConditionSeverity)(ptr) = objs[0]
			} else {
				*(*ActionRuleSuppressionSpecConditionSeverity)(ptr) = ActionRuleSuppressionSpecConditionSeverity{}
			}
		} else {
			*(*ActionRuleSuppressionSpecConditionSeverity)(ptr) = ActionRuleSuppressionSpecConditionSeverity{}
		}
	default:
		iter.ReportError("decode ActionRuleSuppressionSpecConditionSeverity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ActionRuleSuppressionSpecConditionTargetResourceTypeCodec struct {
}

func (ActionRuleSuppressionSpecConditionTargetResourceTypeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ActionRuleSuppressionSpecConditionTargetResourceType)(ptr) == nil
}

func (ActionRuleSuppressionSpecConditionTargetResourceTypeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ActionRuleSuppressionSpecConditionTargetResourceType)(ptr)
	var objs []ActionRuleSuppressionSpecConditionTargetResourceType
	if obj != nil {
		objs = []ActionRuleSuppressionSpecConditionTargetResourceType{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionTargetResourceType{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ActionRuleSuppressionSpecConditionTargetResourceTypeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ActionRuleSuppressionSpecConditionTargetResourceType)(ptr) = ActionRuleSuppressionSpecConditionTargetResourceType{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ActionRuleSuppressionSpecConditionTargetResourceType

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecConditionTargetResourceType{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ActionRuleSuppressionSpecConditionTargetResourceType)(ptr) = objs[0]
			} else {
				*(*ActionRuleSuppressionSpecConditionTargetResourceType)(ptr) = ActionRuleSuppressionSpecConditionTargetResourceType{}
			}
		} else {
			*(*ActionRuleSuppressionSpecConditionTargetResourceType)(ptr) = ActionRuleSuppressionSpecConditionTargetResourceType{}
		}
	default:
		iter.ReportError("decode ActionRuleSuppressionSpecConditionTargetResourceType", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ActionRuleSuppressionSpecScopeCodec struct {
}

func (ActionRuleSuppressionSpecScopeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ActionRuleSuppressionSpecScope)(ptr) == nil
}

func (ActionRuleSuppressionSpecScopeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ActionRuleSuppressionSpecScope)(ptr)
	var objs []ActionRuleSuppressionSpecScope
	if obj != nil {
		objs = []ActionRuleSuppressionSpecScope{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecScope{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ActionRuleSuppressionSpecScopeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ActionRuleSuppressionSpecScope)(ptr) = ActionRuleSuppressionSpecScope{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ActionRuleSuppressionSpecScope

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecScope{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ActionRuleSuppressionSpecScope)(ptr) = objs[0]
			} else {
				*(*ActionRuleSuppressionSpecScope)(ptr) = ActionRuleSuppressionSpecScope{}
			}
		} else {
			*(*ActionRuleSuppressionSpecScope)(ptr) = ActionRuleSuppressionSpecScope{}
		}
	default:
		iter.ReportError("decode ActionRuleSuppressionSpecScope", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ActionRuleSuppressionSpecSuppressionCodec struct {
}

func (ActionRuleSuppressionSpecSuppressionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ActionRuleSuppressionSpecSuppression)(ptr) == nil
}

func (ActionRuleSuppressionSpecSuppressionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ActionRuleSuppressionSpecSuppression)(ptr)
	var objs []ActionRuleSuppressionSpecSuppression
	if obj != nil {
		objs = []ActionRuleSuppressionSpecSuppression{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecSuppression{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ActionRuleSuppressionSpecSuppressionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ActionRuleSuppressionSpecSuppression)(ptr) = ActionRuleSuppressionSpecSuppression{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ActionRuleSuppressionSpecSuppression

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecSuppression{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ActionRuleSuppressionSpecSuppression)(ptr) = objs[0]
			} else {
				*(*ActionRuleSuppressionSpecSuppression)(ptr) = ActionRuleSuppressionSpecSuppression{}
			}
		} else {
			*(*ActionRuleSuppressionSpecSuppression)(ptr) = ActionRuleSuppressionSpecSuppression{}
		}
	default:
		iter.ReportError("decode ActionRuleSuppressionSpecSuppression", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ActionRuleSuppressionSpecSuppressionScheduleCodec struct {
}

func (ActionRuleSuppressionSpecSuppressionScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ActionRuleSuppressionSpecSuppressionSchedule)(ptr) == nil
}

func (ActionRuleSuppressionSpecSuppressionScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ActionRuleSuppressionSpecSuppressionSchedule)(ptr)
	var objs []ActionRuleSuppressionSpecSuppressionSchedule
	if obj != nil {
		objs = []ActionRuleSuppressionSpecSuppressionSchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecSuppressionSchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ActionRuleSuppressionSpecSuppressionScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ActionRuleSuppressionSpecSuppressionSchedule)(ptr) = ActionRuleSuppressionSpecSuppressionSchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ActionRuleSuppressionSpecSuppressionSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActionRuleSuppressionSpecSuppressionSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ActionRuleSuppressionSpecSuppressionSchedule)(ptr) = objs[0]
			} else {
				*(*ActionRuleSuppressionSpecSuppressionSchedule)(ptr) = ActionRuleSuppressionSpecSuppressionSchedule{}
			}
		} else {
			*(*ActionRuleSuppressionSpecSuppressionSchedule)(ptr) = ActionRuleSuppressionSpecSuppressionSchedule{}
		}
	default:
		iter.ReportError("decode ActionRuleSuppressionSpecSuppressionSchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ActivityLogAlertSpecCriteriaCodec struct {
}

func (ActivityLogAlertSpecCriteriaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ActivityLogAlertSpecCriteria)(ptr) == nil
}

func (ActivityLogAlertSpecCriteriaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ActivityLogAlertSpecCriteria)(ptr)
	var objs []ActivityLogAlertSpecCriteria
	if obj != nil {
		objs = []ActivityLogAlertSpecCriteria{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActivityLogAlertSpecCriteria{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ActivityLogAlertSpecCriteriaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ActivityLogAlertSpecCriteria)(ptr) = ActivityLogAlertSpecCriteria{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ActivityLogAlertSpecCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ActivityLogAlertSpecCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ActivityLogAlertSpecCriteria)(ptr) = objs[0]
			} else {
				*(*ActivityLogAlertSpecCriteria)(ptr) = ActivityLogAlertSpecCriteria{}
			}
		} else {
			*(*ActivityLogAlertSpecCriteria)(ptr) = ActivityLogAlertSpecCriteria{}
		}
	default:
		iter.ReportError("decode ActivityLogAlertSpecCriteria", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoscaleSettingSpecNotificationCodec struct {
}

func (AutoscaleSettingSpecNotificationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscaleSettingSpecNotification)(ptr) == nil
}

func (AutoscaleSettingSpecNotificationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscaleSettingSpecNotification)(ptr)
	var objs []AutoscaleSettingSpecNotification
	if obj != nil {
		objs = []AutoscaleSettingSpecNotification{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecNotification{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscaleSettingSpecNotificationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscaleSettingSpecNotification)(ptr) = AutoscaleSettingSpecNotification{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscaleSettingSpecNotification

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecNotification{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscaleSettingSpecNotification)(ptr) = objs[0]
			} else {
				*(*AutoscaleSettingSpecNotification)(ptr) = AutoscaleSettingSpecNotification{}
			}
		} else {
			*(*AutoscaleSettingSpecNotification)(ptr) = AutoscaleSettingSpecNotification{}
		}
	default:
		iter.ReportError("decode AutoscaleSettingSpecNotification", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoscaleSettingSpecNotificationEmailCodec struct {
}

func (AutoscaleSettingSpecNotificationEmailCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscaleSettingSpecNotificationEmail)(ptr) == nil
}

func (AutoscaleSettingSpecNotificationEmailCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscaleSettingSpecNotificationEmail)(ptr)
	var objs []AutoscaleSettingSpecNotificationEmail
	if obj != nil {
		objs = []AutoscaleSettingSpecNotificationEmail{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecNotificationEmail{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscaleSettingSpecNotificationEmailCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscaleSettingSpecNotificationEmail)(ptr) = AutoscaleSettingSpecNotificationEmail{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscaleSettingSpecNotificationEmail

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecNotificationEmail{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscaleSettingSpecNotificationEmail)(ptr) = objs[0]
			} else {
				*(*AutoscaleSettingSpecNotificationEmail)(ptr) = AutoscaleSettingSpecNotificationEmail{}
			}
		} else {
			*(*AutoscaleSettingSpecNotificationEmail)(ptr) = AutoscaleSettingSpecNotificationEmail{}
		}
	default:
		iter.ReportError("decode AutoscaleSettingSpecNotificationEmail", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoscaleSettingSpecProfileCapacityCodec struct {
}

func (AutoscaleSettingSpecProfileCapacityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscaleSettingSpecProfileCapacity)(ptr) == nil
}

func (AutoscaleSettingSpecProfileCapacityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscaleSettingSpecProfileCapacity)(ptr)
	var objs []AutoscaleSettingSpecProfileCapacity
	if obj != nil {
		objs = []AutoscaleSettingSpecProfileCapacity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecProfileCapacity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscaleSettingSpecProfileCapacityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscaleSettingSpecProfileCapacity)(ptr) = AutoscaleSettingSpecProfileCapacity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscaleSettingSpecProfileCapacity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecProfileCapacity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscaleSettingSpecProfileCapacity)(ptr) = objs[0]
			} else {
				*(*AutoscaleSettingSpecProfileCapacity)(ptr) = AutoscaleSettingSpecProfileCapacity{}
			}
		} else {
			*(*AutoscaleSettingSpecProfileCapacity)(ptr) = AutoscaleSettingSpecProfileCapacity{}
		}
	default:
		iter.ReportError("decode AutoscaleSettingSpecProfileCapacity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoscaleSettingSpecProfileFixedDateCodec struct {
}

func (AutoscaleSettingSpecProfileFixedDateCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscaleSettingSpecProfileFixedDate)(ptr) == nil
}

func (AutoscaleSettingSpecProfileFixedDateCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscaleSettingSpecProfileFixedDate)(ptr)
	var objs []AutoscaleSettingSpecProfileFixedDate
	if obj != nil {
		objs = []AutoscaleSettingSpecProfileFixedDate{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecProfileFixedDate{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscaleSettingSpecProfileFixedDateCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscaleSettingSpecProfileFixedDate)(ptr) = AutoscaleSettingSpecProfileFixedDate{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscaleSettingSpecProfileFixedDate

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecProfileFixedDate{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscaleSettingSpecProfileFixedDate)(ptr) = objs[0]
			} else {
				*(*AutoscaleSettingSpecProfileFixedDate)(ptr) = AutoscaleSettingSpecProfileFixedDate{}
			}
		} else {
			*(*AutoscaleSettingSpecProfileFixedDate)(ptr) = AutoscaleSettingSpecProfileFixedDate{}
		}
	default:
		iter.ReportError("decode AutoscaleSettingSpecProfileFixedDate", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoscaleSettingSpecProfileRecurrenceCodec struct {
}

func (AutoscaleSettingSpecProfileRecurrenceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscaleSettingSpecProfileRecurrence)(ptr) == nil
}

func (AutoscaleSettingSpecProfileRecurrenceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscaleSettingSpecProfileRecurrence)(ptr)
	var objs []AutoscaleSettingSpecProfileRecurrence
	if obj != nil {
		objs = []AutoscaleSettingSpecProfileRecurrence{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecProfileRecurrence{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscaleSettingSpecProfileRecurrenceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscaleSettingSpecProfileRecurrence)(ptr) = AutoscaleSettingSpecProfileRecurrence{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscaleSettingSpecProfileRecurrence

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecProfileRecurrence{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscaleSettingSpecProfileRecurrence)(ptr) = objs[0]
			} else {
				*(*AutoscaleSettingSpecProfileRecurrence)(ptr) = AutoscaleSettingSpecProfileRecurrence{}
			}
		} else {
			*(*AutoscaleSettingSpecProfileRecurrence)(ptr) = AutoscaleSettingSpecProfileRecurrence{}
		}
	default:
		iter.ReportError("decode AutoscaleSettingSpecProfileRecurrence", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoscaleSettingSpecProfileRuleMetricTriggerCodec struct {
}

func (AutoscaleSettingSpecProfileRuleMetricTriggerCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscaleSettingSpecProfileRuleMetricTrigger)(ptr) == nil
}

func (AutoscaleSettingSpecProfileRuleMetricTriggerCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscaleSettingSpecProfileRuleMetricTrigger)(ptr)
	var objs []AutoscaleSettingSpecProfileRuleMetricTrigger
	if obj != nil {
		objs = []AutoscaleSettingSpecProfileRuleMetricTrigger{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecProfileRuleMetricTrigger{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscaleSettingSpecProfileRuleMetricTriggerCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscaleSettingSpecProfileRuleMetricTrigger)(ptr) = AutoscaleSettingSpecProfileRuleMetricTrigger{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscaleSettingSpecProfileRuleMetricTrigger

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecProfileRuleMetricTrigger{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscaleSettingSpecProfileRuleMetricTrigger)(ptr) = objs[0]
			} else {
				*(*AutoscaleSettingSpecProfileRuleMetricTrigger)(ptr) = AutoscaleSettingSpecProfileRuleMetricTrigger{}
			}
		} else {
			*(*AutoscaleSettingSpecProfileRuleMetricTrigger)(ptr) = AutoscaleSettingSpecProfileRuleMetricTrigger{}
		}
	default:
		iter.ReportError("decode AutoscaleSettingSpecProfileRuleMetricTrigger", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type AutoscaleSettingSpecProfileRuleScaleActionCodec struct {
}

func (AutoscaleSettingSpecProfileRuleScaleActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*AutoscaleSettingSpecProfileRuleScaleAction)(ptr) == nil
}

func (AutoscaleSettingSpecProfileRuleScaleActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*AutoscaleSettingSpecProfileRuleScaleAction)(ptr)
	var objs []AutoscaleSettingSpecProfileRuleScaleAction
	if obj != nil {
		objs = []AutoscaleSettingSpecProfileRuleScaleAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecProfileRuleScaleAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (AutoscaleSettingSpecProfileRuleScaleActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*AutoscaleSettingSpecProfileRuleScaleAction)(ptr) = AutoscaleSettingSpecProfileRuleScaleAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []AutoscaleSettingSpecProfileRuleScaleAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(AutoscaleSettingSpecProfileRuleScaleAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*AutoscaleSettingSpecProfileRuleScaleAction)(ptr) = objs[0]
			} else {
				*(*AutoscaleSettingSpecProfileRuleScaleAction)(ptr) = AutoscaleSettingSpecProfileRuleScaleAction{}
			}
		} else {
			*(*AutoscaleSettingSpecProfileRuleScaleAction)(ptr) = AutoscaleSettingSpecProfileRuleScaleAction{}
		}
	default:
		iter.ReportError("decode AutoscaleSettingSpecProfileRuleScaleAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiagnosticSettingSpecLogRetentionPolicyCodec struct {
}

func (DiagnosticSettingSpecLogRetentionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiagnosticSettingSpecLogRetentionPolicy)(ptr) == nil
}

func (DiagnosticSettingSpecLogRetentionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiagnosticSettingSpecLogRetentionPolicy)(ptr)
	var objs []DiagnosticSettingSpecLogRetentionPolicy
	if obj != nil {
		objs = []DiagnosticSettingSpecLogRetentionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSettingSpecLogRetentionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiagnosticSettingSpecLogRetentionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiagnosticSettingSpecLogRetentionPolicy)(ptr) = DiagnosticSettingSpecLogRetentionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiagnosticSettingSpecLogRetentionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSettingSpecLogRetentionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiagnosticSettingSpecLogRetentionPolicy)(ptr) = objs[0]
			} else {
				*(*DiagnosticSettingSpecLogRetentionPolicy)(ptr) = DiagnosticSettingSpecLogRetentionPolicy{}
			}
		} else {
			*(*DiagnosticSettingSpecLogRetentionPolicy)(ptr) = DiagnosticSettingSpecLogRetentionPolicy{}
		}
	default:
		iter.ReportError("decode DiagnosticSettingSpecLogRetentionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type DiagnosticSettingSpecMetricRetentionPolicyCodec struct {
}

func (DiagnosticSettingSpecMetricRetentionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*DiagnosticSettingSpecMetricRetentionPolicy)(ptr) == nil
}

func (DiagnosticSettingSpecMetricRetentionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*DiagnosticSettingSpecMetricRetentionPolicy)(ptr)
	var objs []DiagnosticSettingSpecMetricRetentionPolicy
	if obj != nil {
		objs = []DiagnosticSettingSpecMetricRetentionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSettingSpecMetricRetentionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (DiagnosticSettingSpecMetricRetentionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*DiagnosticSettingSpecMetricRetentionPolicy)(ptr) = DiagnosticSettingSpecMetricRetentionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []DiagnosticSettingSpecMetricRetentionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(DiagnosticSettingSpecMetricRetentionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*DiagnosticSettingSpecMetricRetentionPolicy)(ptr) = objs[0]
			} else {
				*(*DiagnosticSettingSpecMetricRetentionPolicy)(ptr) = DiagnosticSettingSpecMetricRetentionPolicy{}
			}
		} else {
			*(*DiagnosticSettingSpecMetricRetentionPolicy)(ptr) = DiagnosticSettingSpecMetricRetentionPolicy{}
		}
	default:
		iter.ReportError("decode DiagnosticSettingSpecMetricRetentionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type LogProfileSpecRetentionPolicyCodec struct {
}

func (LogProfileSpecRetentionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*LogProfileSpecRetentionPolicy)(ptr) == nil
}

func (LogProfileSpecRetentionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*LogProfileSpecRetentionPolicy)(ptr)
	var objs []LogProfileSpecRetentionPolicy
	if obj != nil {
		objs = []LogProfileSpecRetentionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LogProfileSpecRetentionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (LogProfileSpecRetentionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*LogProfileSpecRetentionPolicy)(ptr) = LogProfileSpecRetentionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []LogProfileSpecRetentionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(LogProfileSpecRetentionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*LogProfileSpecRetentionPolicy)(ptr) = objs[0]
			} else {
				*(*LogProfileSpecRetentionPolicy)(ptr) = LogProfileSpecRetentionPolicy{}
			}
		} else {
			*(*LogProfileSpecRetentionPolicy)(ptr) = LogProfileSpecRetentionPolicy{}
		}
	default:
		iter.ReportError("decode LogProfileSpecRetentionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MetricAlertSpecApplicationInsightsWebTestLocationAvailabilityCriteriaCodec struct {
}

func (MetricAlertSpecApplicationInsightsWebTestLocationAvailabilityCriteriaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MetricAlertSpecApplicationInsightsWebTestLocationAvailabilityCriteria)(ptr) == nil
}

func (MetricAlertSpecApplicationInsightsWebTestLocationAvailabilityCriteriaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MetricAlertSpecApplicationInsightsWebTestLocationAvailabilityCriteria)(ptr)
	var objs []MetricAlertSpecApplicationInsightsWebTestLocationAvailabilityCriteria
	if obj != nil {
		objs = []MetricAlertSpecApplicationInsightsWebTestLocationAvailabilityCriteria{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricAlertSpecApplicationInsightsWebTestLocationAvailabilityCriteria{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MetricAlertSpecApplicationInsightsWebTestLocationAvailabilityCriteriaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MetricAlertSpecApplicationInsightsWebTestLocationAvailabilityCriteria)(ptr) = MetricAlertSpecApplicationInsightsWebTestLocationAvailabilityCriteria{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MetricAlertSpecApplicationInsightsWebTestLocationAvailabilityCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricAlertSpecApplicationInsightsWebTestLocationAvailabilityCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MetricAlertSpecApplicationInsightsWebTestLocationAvailabilityCriteria)(ptr) = objs[0]
			} else {
				*(*MetricAlertSpecApplicationInsightsWebTestLocationAvailabilityCriteria)(ptr) = MetricAlertSpecApplicationInsightsWebTestLocationAvailabilityCriteria{}
			}
		} else {
			*(*MetricAlertSpecApplicationInsightsWebTestLocationAvailabilityCriteria)(ptr) = MetricAlertSpecApplicationInsightsWebTestLocationAvailabilityCriteria{}
		}
	default:
		iter.ReportError("decode MetricAlertSpecApplicationInsightsWebTestLocationAvailabilityCriteria", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type MetricAlertSpecDynamicCriteriaCodec struct {
}

func (MetricAlertSpecDynamicCriteriaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*MetricAlertSpecDynamicCriteria)(ptr) == nil
}

func (MetricAlertSpecDynamicCriteriaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*MetricAlertSpecDynamicCriteria)(ptr)
	var objs []MetricAlertSpecDynamicCriteria
	if obj != nil {
		objs = []MetricAlertSpecDynamicCriteria{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricAlertSpecDynamicCriteria{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (MetricAlertSpecDynamicCriteriaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*MetricAlertSpecDynamicCriteria)(ptr) = MetricAlertSpecDynamicCriteria{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []MetricAlertSpecDynamicCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(MetricAlertSpecDynamicCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*MetricAlertSpecDynamicCriteria)(ptr) = objs[0]
			} else {
				*(*MetricAlertSpecDynamicCriteria)(ptr) = MetricAlertSpecDynamicCriteria{}
			}
		} else {
			*(*MetricAlertSpecDynamicCriteria)(ptr) = MetricAlertSpecDynamicCriteria{}
		}
	default:
		iter.ReportError("decode MetricAlertSpecDynamicCriteria", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ScheduledQueryRulesAlertSpecActionCodec struct {
}

func (ScheduledQueryRulesAlertSpecActionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ScheduledQueryRulesAlertSpecAction)(ptr) == nil
}

func (ScheduledQueryRulesAlertSpecActionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ScheduledQueryRulesAlertSpecAction)(ptr)
	var objs []ScheduledQueryRulesAlertSpecAction
	if obj != nil {
		objs = []ScheduledQueryRulesAlertSpecAction{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ScheduledQueryRulesAlertSpecAction{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ScheduledQueryRulesAlertSpecActionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ScheduledQueryRulesAlertSpecAction)(ptr) = ScheduledQueryRulesAlertSpecAction{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ScheduledQueryRulesAlertSpecAction

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ScheduledQueryRulesAlertSpecAction{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ScheduledQueryRulesAlertSpecAction)(ptr) = objs[0]
			} else {
				*(*ScheduledQueryRulesAlertSpecAction)(ptr) = ScheduledQueryRulesAlertSpecAction{}
			}
		} else {
			*(*ScheduledQueryRulesAlertSpecAction)(ptr) = ScheduledQueryRulesAlertSpecAction{}
		}
	default:
		iter.ReportError("decode ScheduledQueryRulesAlertSpecAction", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ScheduledQueryRulesAlertSpecTriggerCodec struct {
}

func (ScheduledQueryRulesAlertSpecTriggerCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ScheduledQueryRulesAlertSpecTrigger)(ptr) == nil
}

func (ScheduledQueryRulesAlertSpecTriggerCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ScheduledQueryRulesAlertSpecTrigger)(ptr)
	var objs []ScheduledQueryRulesAlertSpecTrigger
	if obj != nil {
		objs = []ScheduledQueryRulesAlertSpecTrigger{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ScheduledQueryRulesAlertSpecTrigger{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ScheduledQueryRulesAlertSpecTriggerCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ScheduledQueryRulesAlertSpecTrigger)(ptr) = ScheduledQueryRulesAlertSpecTrigger{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ScheduledQueryRulesAlertSpecTrigger

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ScheduledQueryRulesAlertSpecTrigger{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ScheduledQueryRulesAlertSpecTrigger)(ptr) = objs[0]
			} else {
				*(*ScheduledQueryRulesAlertSpecTrigger)(ptr) = ScheduledQueryRulesAlertSpecTrigger{}
			}
		} else {
			*(*ScheduledQueryRulesAlertSpecTrigger)(ptr) = ScheduledQueryRulesAlertSpecTrigger{}
		}
	default:
		iter.ReportError("decode ScheduledQueryRulesAlertSpecTrigger", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ScheduledQueryRulesAlertSpecTriggerMetricTriggerCodec struct {
}

func (ScheduledQueryRulesAlertSpecTriggerMetricTriggerCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ScheduledQueryRulesAlertSpecTriggerMetricTrigger)(ptr) == nil
}

func (ScheduledQueryRulesAlertSpecTriggerMetricTriggerCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ScheduledQueryRulesAlertSpecTriggerMetricTrigger)(ptr)
	var objs []ScheduledQueryRulesAlertSpecTriggerMetricTrigger
	if obj != nil {
		objs = []ScheduledQueryRulesAlertSpecTriggerMetricTrigger{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ScheduledQueryRulesAlertSpecTriggerMetricTrigger{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ScheduledQueryRulesAlertSpecTriggerMetricTriggerCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ScheduledQueryRulesAlertSpecTriggerMetricTrigger)(ptr) = ScheduledQueryRulesAlertSpecTriggerMetricTrigger{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ScheduledQueryRulesAlertSpecTriggerMetricTrigger

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ScheduledQueryRulesAlertSpecTriggerMetricTrigger{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ScheduledQueryRulesAlertSpecTriggerMetricTrigger)(ptr) = objs[0]
			} else {
				*(*ScheduledQueryRulesAlertSpecTriggerMetricTrigger)(ptr) = ScheduledQueryRulesAlertSpecTriggerMetricTrigger{}
			}
		} else {
			*(*ScheduledQueryRulesAlertSpecTriggerMetricTrigger)(ptr) = ScheduledQueryRulesAlertSpecTriggerMetricTrigger{}
		}
	default:
		iter.ReportError("decode ScheduledQueryRulesAlertSpecTriggerMetricTrigger", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ScheduledQueryRulesLogSpecCriteriaCodec struct {
}

func (ScheduledQueryRulesLogSpecCriteriaCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ScheduledQueryRulesLogSpecCriteria)(ptr) == nil
}

func (ScheduledQueryRulesLogSpecCriteriaCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ScheduledQueryRulesLogSpecCriteria)(ptr)
	var objs []ScheduledQueryRulesLogSpecCriteria
	if obj != nil {
		objs = []ScheduledQueryRulesLogSpecCriteria{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ScheduledQueryRulesLogSpecCriteria{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ScheduledQueryRulesLogSpecCriteriaCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ScheduledQueryRulesLogSpecCriteria)(ptr) = ScheduledQueryRulesLogSpecCriteria{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ScheduledQueryRulesLogSpecCriteria

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ScheduledQueryRulesLogSpecCriteria{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ScheduledQueryRulesLogSpecCriteria)(ptr) = objs[0]
			} else {
				*(*ScheduledQueryRulesLogSpecCriteria)(ptr) = ScheduledQueryRulesLogSpecCriteria{}
			}
		} else {
			*(*ScheduledQueryRulesLogSpecCriteria)(ptr) = ScheduledQueryRulesLogSpecCriteria{}
		}
	default:
		iter.ReportError("decode ScheduledQueryRulesLogSpecCriteria", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type SmartDetectorAlertRuleSpecActionGroupCodec struct {
}

func (SmartDetectorAlertRuleSpecActionGroupCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*SmartDetectorAlertRuleSpecActionGroup)(ptr) == nil
}

func (SmartDetectorAlertRuleSpecActionGroupCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*SmartDetectorAlertRuleSpecActionGroup)(ptr)
	var objs []SmartDetectorAlertRuleSpecActionGroup
	if obj != nil {
		objs = []SmartDetectorAlertRuleSpecActionGroup{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SmartDetectorAlertRuleSpecActionGroup{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (SmartDetectorAlertRuleSpecActionGroupCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*SmartDetectorAlertRuleSpecActionGroup)(ptr) = SmartDetectorAlertRuleSpecActionGroup{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []SmartDetectorAlertRuleSpecActionGroup

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(SmartDetectorAlertRuleSpecActionGroup{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*SmartDetectorAlertRuleSpecActionGroup)(ptr) = objs[0]
			} else {
				*(*SmartDetectorAlertRuleSpecActionGroup)(ptr) = SmartDetectorAlertRuleSpecActionGroup{}
			}
		} else {
			*(*SmartDetectorAlertRuleSpecActionGroup)(ptr) = SmartDetectorAlertRuleSpecActionGroup{}
		}
	default:
		iter.ReportError("decode SmartDetectorAlertRuleSpecActionGroup", "unexpected JSON type")
	}
}
