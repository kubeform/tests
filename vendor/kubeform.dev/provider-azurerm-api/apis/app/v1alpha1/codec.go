/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigurationSpecIdentity{}).Type1()):                          ConfigurationSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettings{}).Type1()):                            ServiceSpecAuthSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettingsActiveDirectory{}).Type1()):             ServiceSpecAuthSettingsActiveDirectoryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettingsFacebook{}).Type1()):                    ServiceSpecAuthSettingsFacebookCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettingsGoogle{}).Type1()):                      ServiceSpecAuthSettingsGoogleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettingsMicrosoft{}).Type1()):                   ServiceSpecAuthSettingsMicrosoftCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettingsTwitter{}).Type1()):                     ServiceSpecAuthSettingsTwitterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecBackup{}).Type1()):                                  ServiceSpecBackupCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecBackupSchedule{}).Type1()):                          ServiceSpecBackupScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecIdentity{}).Type1()):                                ServiceSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogs{}).Type1()):                                    ServiceSpecLogsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogsApplicationLogs{}).Type1()):                     ServiceSpecLogsApplicationLogsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogsApplicationLogsAzureBlobStorage{}).Type1()):     ServiceSpecLogsApplicationLogsAzureBlobStorageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogsHttpLogs{}).Type1()):                            ServiceSpecLogsHttpLogsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogsHttpLogsAzureBlobStorage{}).Type1()):            ServiceSpecLogsHttpLogsAzureBlobStorageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogsHttpLogsFileSystem{}).Type1()):                  ServiceSpecLogsHttpLogsFileSystemCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecSiteConfig{}).Type1()):                              ServiceSpecSiteConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecSiteConfigCors{}).Type1()):                          ServiceSpecSiteConfigCorsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecSiteConfigIpRestrictionHeaders{}).Type1()):          ServiceSpecSiteConfigIpRestrictionHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecSiteConfigScmIPRestrictionHeaders{}).Type1()):       ServiceSpecSiteConfigScmIPRestrictionHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecSourceControl{}).Type1()):                           ServiceSpecSourceControlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServicePlanSpecSku{}).Type1()):                                 ServicePlanSpecSkuCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettings{}).Type1()):                        ServiceSlotSpecAuthSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettingsActiveDirectory{}).Type1()):         ServiceSlotSpecAuthSettingsActiveDirectoryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettingsFacebook{}).Type1()):                ServiceSlotSpecAuthSettingsFacebookCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettingsGoogle{}).Type1()):                  ServiceSlotSpecAuthSettingsGoogleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettingsMicrosoft{}).Type1()):               ServiceSlotSpecAuthSettingsMicrosoftCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettingsTwitter{}).Type1()):                 ServiceSlotSpecAuthSettingsTwitterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecIdentity{}).Type1()):                            ServiceSlotSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogs{}).Type1()):                                ServiceSlotSpecLogsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogsApplicationLogs{}).Type1()):                 ServiceSlotSpecLogsApplicationLogsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogsApplicationLogsAzureBlobStorage{}).Type1()): ServiceSlotSpecLogsApplicationLogsAzureBlobStorageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogsHttpLogs{}).Type1()):                        ServiceSlotSpecLogsHttpLogsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogsHttpLogsAzureBlobStorage{}).Type1()):        ServiceSlotSpecLogsHttpLogsAzureBlobStorageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogsHttpLogsFileSystem{}).Type1()):              ServiceSlotSpecLogsHttpLogsFileSystemCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecSiteConfig{}).Type1()):                          ServiceSlotSpecSiteConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecSiteConfigCors{}).Type1()):                      ServiceSlotSpecSiteConfigCorsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecSiteConfigIpRestrictionHeaders{}).Type1()):      ServiceSlotSpecSiteConfigIpRestrictionHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecSiteConfigScmIPRestrictionHeaders{}).Type1()):   ServiceSlotSpecSiteConfigScmIPRestrictionHeadersCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(ConfigurationSpecIdentity{}).Type1()):                          ConfigurationSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettings{}).Type1()):                            ServiceSpecAuthSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettingsActiveDirectory{}).Type1()):             ServiceSpecAuthSettingsActiveDirectoryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettingsFacebook{}).Type1()):                    ServiceSpecAuthSettingsFacebookCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettingsGoogle{}).Type1()):                      ServiceSpecAuthSettingsGoogleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettingsMicrosoft{}).Type1()):                   ServiceSpecAuthSettingsMicrosoftCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettingsTwitter{}).Type1()):                     ServiceSpecAuthSettingsTwitterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecBackup{}).Type1()):                                  ServiceSpecBackupCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecBackupSchedule{}).Type1()):                          ServiceSpecBackupScheduleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecIdentity{}).Type1()):                                ServiceSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogs{}).Type1()):                                    ServiceSpecLogsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogsApplicationLogs{}).Type1()):                     ServiceSpecLogsApplicationLogsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogsApplicationLogsAzureBlobStorage{}).Type1()):     ServiceSpecLogsApplicationLogsAzureBlobStorageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogsHttpLogs{}).Type1()):                            ServiceSpecLogsHttpLogsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogsHttpLogsAzureBlobStorage{}).Type1()):            ServiceSpecLogsHttpLogsAzureBlobStorageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogsHttpLogsFileSystem{}).Type1()):                  ServiceSpecLogsHttpLogsFileSystemCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecSiteConfig{}).Type1()):                              ServiceSpecSiteConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecSiteConfigCors{}).Type1()):                          ServiceSpecSiteConfigCorsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecSiteConfigIpRestrictionHeaders{}).Type1()):          ServiceSpecSiteConfigIpRestrictionHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecSiteConfigScmIPRestrictionHeaders{}).Type1()):       ServiceSpecSiteConfigScmIPRestrictionHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecSourceControl{}).Type1()):                           ServiceSpecSourceControlCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServicePlanSpecSku{}).Type1()):                                 ServicePlanSpecSkuCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettings{}).Type1()):                        ServiceSlotSpecAuthSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettingsActiveDirectory{}).Type1()):         ServiceSlotSpecAuthSettingsActiveDirectoryCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettingsFacebook{}).Type1()):                ServiceSlotSpecAuthSettingsFacebookCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettingsGoogle{}).Type1()):                  ServiceSlotSpecAuthSettingsGoogleCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettingsMicrosoft{}).Type1()):               ServiceSlotSpecAuthSettingsMicrosoftCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettingsTwitter{}).Type1()):                 ServiceSlotSpecAuthSettingsTwitterCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecIdentity{}).Type1()):                            ServiceSlotSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogs{}).Type1()):                                ServiceSlotSpecLogsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogsApplicationLogs{}).Type1()):                 ServiceSlotSpecLogsApplicationLogsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogsApplicationLogsAzureBlobStorage{}).Type1()): ServiceSlotSpecLogsApplicationLogsAzureBlobStorageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogsHttpLogs{}).Type1()):                        ServiceSlotSpecLogsHttpLogsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogsHttpLogsAzureBlobStorage{}).Type1()):        ServiceSlotSpecLogsHttpLogsAzureBlobStorageCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogsHttpLogsFileSystem{}).Type1()):              ServiceSlotSpecLogsHttpLogsFileSystemCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecSiteConfig{}).Type1()):                          ServiceSlotSpecSiteConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecSiteConfigCors{}).Type1()):                      ServiceSlotSpecSiteConfigCorsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecSiteConfigIpRestrictionHeaders{}).Type1()):      ServiceSlotSpecSiteConfigIpRestrictionHeadersCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecSiteConfigScmIPRestrictionHeaders{}).Type1()):   ServiceSlotSpecSiteConfigScmIPRestrictionHeadersCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type ConfigurationSpecIdentityCodec struct {
}

func (ConfigurationSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ConfigurationSpecIdentity)(ptr) == nil
}

func (ConfigurationSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ConfigurationSpecIdentity)(ptr)
	var objs []ConfigurationSpecIdentity
	if obj != nil {
		objs = []ConfigurationSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigurationSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ConfigurationSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ConfigurationSpecIdentity)(ptr) = ConfigurationSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ConfigurationSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ConfigurationSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ConfigurationSpecIdentity)(ptr) = objs[0]
			} else {
				*(*ConfigurationSpecIdentity)(ptr) = ConfigurationSpecIdentity{}
			}
		} else {
			*(*ConfigurationSpecIdentity)(ptr) = ConfigurationSpecIdentity{}
		}
	default:
		iter.ReportError("decode ConfigurationSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSpecAuthSettingsCodec struct {
}

func (ServiceSpecAuthSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSpecAuthSettings)(ptr) == nil
}

func (ServiceSpecAuthSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSpecAuthSettings)(ptr)
	var objs []ServiceSpecAuthSettings
	if obj != nil {
		objs = []ServiceSpecAuthSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSpecAuthSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSpecAuthSettings)(ptr) = ServiceSpecAuthSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSpecAuthSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSpecAuthSettings)(ptr) = objs[0]
			} else {
				*(*ServiceSpecAuthSettings)(ptr) = ServiceSpecAuthSettings{}
			}
		} else {
			*(*ServiceSpecAuthSettings)(ptr) = ServiceSpecAuthSettings{}
		}
	default:
		iter.ReportError("decode ServiceSpecAuthSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSpecAuthSettingsActiveDirectoryCodec struct {
}

func (ServiceSpecAuthSettingsActiveDirectoryCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSpecAuthSettingsActiveDirectory)(ptr) == nil
}

func (ServiceSpecAuthSettingsActiveDirectoryCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSpecAuthSettingsActiveDirectory)(ptr)
	var objs []ServiceSpecAuthSettingsActiveDirectory
	if obj != nil {
		objs = []ServiceSpecAuthSettingsActiveDirectory{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettingsActiveDirectory{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSpecAuthSettingsActiveDirectoryCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSpecAuthSettingsActiveDirectory)(ptr) = ServiceSpecAuthSettingsActiveDirectory{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSpecAuthSettingsActiveDirectory

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettingsActiveDirectory{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSpecAuthSettingsActiveDirectory)(ptr) = objs[0]
			} else {
				*(*ServiceSpecAuthSettingsActiveDirectory)(ptr) = ServiceSpecAuthSettingsActiveDirectory{}
			}
		} else {
			*(*ServiceSpecAuthSettingsActiveDirectory)(ptr) = ServiceSpecAuthSettingsActiveDirectory{}
		}
	default:
		iter.ReportError("decode ServiceSpecAuthSettingsActiveDirectory", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSpecAuthSettingsFacebookCodec struct {
}

func (ServiceSpecAuthSettingsFacebookCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSpecAuthSettingsFacebook)(ptr) == nil
}

func (ServiceSpecAuthSettingsFacebookCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSpecAuthSettingsFacebook)(ptr)
	var objs []ServiceSpecAuthSettingsFacebook
	if obj != nil {
		objs = []ServiceSpecAuthSettingsFacebook{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettingsFacebook{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSpecAuthSettingsFacebookCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSpecAuthSettingsFacebook)(ptr) = ServiceSpecAuthSettingsFacebook{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSpecAuthSettingsFacebook

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettingsFacebook{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSpecAuthSettingsFacebook)(ptr) = objs[0]
			} else {
				*(*ServiceSpecAuthSettingsFacebook)(ptr) = ServiceSpecAuthSettingsFacebook{}
			}
		} else {
			*(*ServiceSpecAuthSettingsFacebook)(ptr) = ServiceSpecAuthSettingsFacebook{}
		}
	default:
		iter.ReportError("decode ServiceSpecAuthSettingsFacebook", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSpecAuthSettingsGoogleCodec struct {
}

func (ServiceSpecAuthSettingsGoogleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSpecAuthSettingsGoogle)(ptr) == nil
}

func (ServiceSpecAuthSettingsGoogleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSpecAuthSettingsGoogle)(ptr)
	var objs []ServiceSpecAuthSettingsGoogle
	if obj != nil {
		objs = []ServiceSpecAuthSettingsGoogle{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettingsGoogle{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSpecAuthSettingsGoogleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSpecAuthSettingsGoogle)(ptr) = ServiceSpecAuthSettingsGoogle{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSpecAuthSettingsGoogle

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettingsGoogle{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSpecAuthSettingsGoogle)(ptr) = objs[0]
			} else {
				*(*ServiceSpecAuthSettingsGoogle)(ptr) = ServiceSpecAuthSettingsGoogle{}
			}
		} else {
			*(*ServiceSpecAuthSettingsGoogle)(ptr) = ServiceSpecAuthSettingsGoogle{}
		}
	default:
		iter.ReportError("decode ServiceSpecAuthSettingsGoogle", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSpecAuthSettingsMicrosoftCodec struct {
}

func (ServiceSpecAuthSettingsMicrosoftCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSpecAuthSettingsMicrosoft)(ptr) == nil
}

func (ServiceSpecAuthSettingsMicrosoftCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSpecAuthSettingsMicrosoft)(ptr)
	var objs []ServiceSpecAuthSettingsMicrosoft
	if obj != nil {
		objs = []ServiceSpecAuthSettingsMicrosoft{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettingsMicrosoft{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSpecAuthSettingsMicrosoftCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSpecAuthSettingsMicrosoft)(ptr) = ServiceSpecAuthSettingsMicrosoft{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSpecAuthSettingsMicrosoft

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettingsMicrosoft{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSpecAuthSettingsMicrosoft)(ptr) = objs[0]
			} else {
				*(*ServiceSpecAuthSettingsMicrosoft)(ptr) = ServiceSpecAuthSettingsMicrosoft{}
			}
		} else {
			*(*ServiceSpecAuthSettingsMicrosoft)(ptr) = ServiceSpecAuthSettingsMicrosoft{}
		}
	default:
		iter.ReportError("decode ServiceSpecAuthSettingsMicrosoft", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSpecAuthSettingsTwitterCodec struct {
}

func (ServiceSpecAuthSettingsTwitterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSpecAuthSettingsTwitter)(ptr) == nil
}

func (ServiceSpecAuthSettingsTwitterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSpecAuthSettingsTwitter)(ptr)
	var objs []ServiceSpecAuthSettingsTwitter
	if obj != nil {
		objs = []ServiceSpecAuthSettingsTwitter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettingsTwitter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSpecAuthSettingsTwitterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSpecAuthSettingsTwitter)(ptr) = ServiceSpecAuthSettingsTwitter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSpecAuthSettingsTwitter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecAuthSettingsTwitter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSpecAuthSettingsTwitter)(ptr) = objs[0]
			} else {
				*(*ServiceSpecAuthSettingsTwitter)(ptr) = ServiceSpecAuthSettingsTwitter{}
			}
		} else {
			*(*ServiceSpecAuthSettingsTwitter)(ptr) = ServiceSpecAuthSettingsTwitter{}
		}
	default:
		iter.ReportError("decode ServiceSpecAuthSettingsTwitter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSpecBackupCodec struct {
}

func (ServiceSpecBackupCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSpecBackup)(ptr) == nil
}

func (ServiceSpecBackupCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSpecBackup)(ptr)
	var objs []ServiceSpecBackup
	if obj != nil {
		objs = []ServiceSpecBackup{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecBackup{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSpecBackupCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSpecBackup)(ptr) = ServiceSpecBackup{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSpecBackup

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecBackup{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSpecBackup)(ptr) = objs[0]
			} else {
				*(*ServiceSpecBackup)(ptr) = ServiceSpecBackup{}
			}
		} else {
			*(*ServiceSpecBackup)(ptr) = ServiceSpecBackup{}
		}
	default:
		iter.ReportError("decode ServiceSpecBackup", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSpecBackupScheduleCodec struct {
}

func (ServiceSpecBackupScheduleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSpecBackupSchedule)(ptr) == nil
}

func (ServiceSpecBackupScheduleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSpecBackupSchedule)(ptr)
	var objs []ServiceSpecBackupSchedule
	if obj != nil {
		objs = []ServiceSpecBackupSchedule{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecBackupSchedule{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSpecBackupScheduleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSpecBackupSchedule)(ptr) = ServiceSpecBackupSchedule{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSpecBackupSchedule

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecBackupSchedule{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSpecBackupSchedule)(ptr) = objs[0]
			} else {
				*(*ServiceSpecBackupSchedule)(ptr) = ServiceSpecBackupSchedule{}
			}
		} else {
			*(*ServiceSpecBackupSchedule)(ptr) = ServiceSpecBackupSchedule{}
		}
	default:
		iter.ReportError("decode ServiceSpecBackupSchedule", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSpecIdentityCodec struct {
}

func (ServiceSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSpecIdentity)(ptr) == nil
}

func (ServiceSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSpecIdentity)(ptr)
	var objs []ServiceSpecIdentity
	if obj != nil {
		objs = []ServiceSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSpecIdentity)(ptr) = ServiceSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSpecIdentity)(ptr) = objs[0]
			} else {
				*(*ServiceSpecIdentity)(ptr) = ServiceSpecIdentity{}
			}
		} else {
			*(*ServiceSpecIdentity)(ptr) = ServiceSpecIdentity{}
		}
	default:
		iter.ReportError("decode ServiceSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSpecLogsCodec struct {
}

func (ServiceSpecLogsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSpecLogs)(ptr) == nil
}

func (ServiceSpecLogsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSpecLogs)(ptr)
	var objs []ServiceSpecLogs
	if obj != nil {
		objs = []ServiceSpecLogs{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogs{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSpecLogsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSpecLogs)(ptr) = ServiceSpecLogs{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSpecLogs

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogs{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSpecLogs)(ptr) = objs[0]
			} else {
				*(*ServiceSpecLogs)(ptr) = ServiceSpecLogs{}
			}
		} else {
			*(*ServiceSpecLogs)(ptr) = ServiceSpecLogs{}
		}
	default:
		iter.ReportError("decode ServiceSpecLogs", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSpecLogsApplicationLogsCodec struct {
}

func (ServiceSpecLogsApplicationLogsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSpecLogsApplicationLogs)(ptr) == nil
}

func (ServiceSpecLogsApplicationLogsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSpecLogsApplicationLogs)(ptr)
	var objs []ServiceSpecLogsApplicationLogs
	if obj != nil {
		objs = []ServiceSpecLogsApplicationLogs{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogsApplicationLogs{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSpecLogsApplicationLogsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSpecLogsApplicationLogs)(ptr) = ServiceSpecLogsApplicationLogs{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSpecLogsApplicationLogs

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogsApplicationLogs{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSpecLogsApplicationLogs)(ptr) = objs[0]
			} else {
				*(*ServiceSpecLogsApplicationLogs)(ptr) = ServiceSpecLogsApplicationLogs{}
			}
		} else {
			*(*ServiceSpecLogsApplicationLogs)(ptr) = ServiceSpecLogsApplicationLogs{}
		}
	default:
		iter.ReportError("decode ServiceSpecLogsApplicationLogs", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSpecLogsApplicationLogsAzureBlobStorageCodec struct {
}

func (ServiceSpecLogsApplicationLogsAzureBlobStorageCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSpecLogsApplicationLogsAzureBlobStorage)(ptr) == nil
}

func (ServiceSpecLogsApplicationLogsAzureBlobStorageCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSpecLogsApplicationLogsAzureBlobStorage)(ptr)
	var objs []ServiceSpecLogsApplicationLogsAzureBlobStorage
	if obj != nil {
		objs = []ServiceSpecLogsApplicationLogsAzureBlobStorage{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogsApplicationLogsAzureBlobStorage{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSpecLogsApplicationLogsAzureBlobStorageCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSpecLogsApplicationLogsAzureBlobStorage)(ptr) = ServiceSpecLogsApplicationLogsAzureBlobStorage{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSpecLogsApplicationLogsAzureBlobStorage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogsApplicationLogsAzureBlobStorage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSpecLogsApplicationLogsAzureBlobStorage)(ptr) = objs[0]
			} else {
				*(*ServiceSpecLogsApplicationLogsAzureBlobStorage)(ptr) = ServiceSpecLogsApplicationLogsAzureBlobStorage{}
			}
		} else {
			*(*ServiceSpecLogsApplicationLogsAzureBlobStorage)(ptr) = ServiceSpecLogsApplicationLogsAzureBlobStorage{}
		}
	default:
		iter.ReportError("decode ServiceSpecLogsApplicationLogsAzureBlobStorage", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSpecLogsHttpLogsCodec struct {
}

func (ServiceSpecLogsHttpLogsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSpecLogsHttpLogs)(ptr) == nil
}

func (ServiceSpecLogsHttpLogsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSpecLogsHttpLogs)(ptr)
	var objs []ServiceSpecLogsHttpLogs
	if obj != nil {
		objs = []ServiceSpecLogsHttpLogs{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogsHttpLogs{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSpecLogsHttpLogsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSpecLogsHttpLogs)(ptr) = ServiceSpecLogsHttpLogs{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSpecLogsHttpLogs

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogsHttpLogs{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSpecLogsHttpLogs)(ptr) = objs[0]
			} else {
				*(*ServiceSpecLogsHttpLogs)(ptr) = ServiceSpecLogsHttpLogs{}
			}
		} else {
			*(*ServiceSpecLogsHttpLogs)(ptr) = ServiceSpecLogsHttpLogs{}
		}
	default:
		iter.ReportError("decode ServiceSpecLogsHttpLogs", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSpecLogsHttpLogsAzureBlobStorageCodec struct {
}

func (ServiceSpecLogsHttpLogsAzureBlobStorageCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSpecLogsHttpLogsAzureBlobStorage)(ptr) == nil
}

func (ServiceSpecLogsHttpLogsAzureBlobStorageCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSpecLogsHttpLogsAzureBlobStorage)(ptr)
	var objs []ServiceSpecLogsHttpLogsAzureBlobStorage
	if obj != nil {
		objs = []ServiceSpecLogsHttpLogsAzureBlobStorage{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogsHttpLogsAzureBlobStorage{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSpecLogsHttpLogsAzureBlobStorageCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSpecLogsHttpLogsAzureBlobStorage)(ptr) = ServiceSpecLogsHttpLogsAzureBlobStorage{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSpecLogsHttpLogsAzureBlobStorage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogsHttpLogsAzureBlobStorage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSpecLogsHttpLogsAzureBlobStorage)(ptr) = objs[0]
			} else {
				*(*ServiceSpecLogsHttpLogsAzureBlobStorage)(ptr) = ServiceSpecLogsHttpLogsAzureBlobStorage{}
			}
		} else {
			*(*ServiceSpecLogsHttpLogsAzureBlobStorage)(ptr) = ServiceSpecLogsHttpLogsAzureBlobStorage{}
		}
	default:
		iter.ReportError("decode ServiceSpecLogsHttpLogsAzureBlobStorage", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSpecLogsHttpLogsFileSystemCodec struct {
}

func (ServiceSpecLogsHttpLogsFileSystemCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSpecLogsHttpLogsFileSystem)(ptr) == nil
}

func (ServiceSpecLogsHttpLogsFileSystemCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSpecLogsHttpLogsFileSystem)(ptr)
	var objs []ServiceSpecLogsHttpLogsFileSystem
	if obj != nil {
		objs = []ServiceSpecLogsHttpLogsFileSystem{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogsHttpLogsFileSystem{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSpecLogsHttpLogsFileSystemCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSpecLogsHttpLogsFileSystem)(ptr) = ServiceSpecLogsHttpLogsFileSystem{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSpecLogsHttpLogsFileSystem

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecLogsHttpLogsFileSystem{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSpecLogsHttpLogsFileSystem)(ptr) = objs[0]
			} else {
				*(*ServiceSpecLogsHttpLogsFileSystem)(ptr) = ServiceSpecLogsHttpLogsFileSystem{}
			}
		} else {
			*(*ServiceSpecLogsHttpLogsFileSystem)(ptr) = ServiceSpecLogsHttpLogsFileSystem{}
		}
	default:
		iter.ReportError("decode ServiceSpecLogsHttpLogsFileSystem", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSpecSiteConfigCodec struct {
}

func (ServiceSpecSiteConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSpecSiteConfig)(ptr) == nil
}

func (ServiceSpecSiteConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSpecSiteConfig)(ptr)
	var objs []ServiceSpecSiteConfig
	if obj != nil {
		objs = []ServiceSpecSiteConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecSiteConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSpecSiteConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSpecSiteConfig)(ptr) = ServiceSpecSiteConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSpecSiteConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecSiteConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSpecSiteConfig)(ptr) = objs[0]
			} else {
				*(*ServiceSpecSiteConfig)(ptr) = ServiceSpecSiteConfig{}
			}
		} else {
			*(*ServiceSpecSiteConfig)(ptr) = ServiceSpecSiteConfig{}
		}
	default:
		iter.ReportError("decode ServiceSpecSiteConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSpecSiteConfigCorsCodec struct {
}

func (ServiceSpecSiteConfigCorsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSpecSiteConfigCors)(ptr) == nil
}

func (ServiceSpecSiteConfigCorsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSpecSiteConfigCors)(ptr)
	var objs []ServiceSpecSiteConfigCors
	if obj != nil {
		objs = []ServiceSpecSiteConfigCors{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecSiteConfigCors{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSpecSiteConfigCorsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSpecSiteConfigCors)(ptr) = ServiceSpecSiteConfigCors{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSpecSiteConfigCors

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecSiteConfigCors{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSpecSiteConfigCors)(ptr) = objs[0]
			} else {
				*(*ServiceSpecSiteConfigCors)(ptr) = ServiceSpecSiteConfigCors{}
			}
		} else {
			*(*ServiceSpecSiteConfigCors)(ptr) = ServiceSpecSiteConfigCors{}
		}
	default:
		iter.ReportError("decode ServiceSpecSiteConfigCors", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSpecSiteConfigIpRestrictionHeadersCodec struct {
}

func (ServiceSpecSiteConfigIpRestrictionHeadersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSpecSiteConfigIpRestrictionHeaders)(ptr) == nil
}

func (ServiceSpecSiteConfigIpRestrictionHeadersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSpecSiteConfigIpRestrictionHeaders)(ptr)
	var objs []ServiceSpecSiteConfigIpRestrictionHeaders
	if obj != nil {
		objs = []ServiceSpecSiteConfigIpRestrictionHeaders{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecSiteConfigIpRestrictionHeaders{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSpecSiteConfigIpRestrictionHeadersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSpecSiteConfigIpRestrictionHeaders)(ptr) = ServiceSpecSiteConfigIpRestrictionHeaders{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSpecSiteConfigIpRestrictionHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecSiteConfigIpRestrictionHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSpecSiteConfigIpRestrictionHeaders)(ptr) = objs[0]
			} else {
				*(*ServiceSpecSiteConfigIpRestrictionHeaders)(ptr) = ServiceSpecSiteConfigIpRestrictionHeaders{}
			}
		} else {
			*(*ServiceSpecSiteConfigIpRestrictionHeaders)(ptr) = ServiceSpecSiteConfigIpRestrictionHeaders{}
		}
	default:
		iter.ReportError("decode ServiceSpecSiteConfigIpRestrictionHeaders", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSpecSiteConfigScmIPRestrictionHeadersCodec struct {
}

func (ServiceSpecSiteConfigScmIPRestrictionHeadersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSpecSiteConfigScmIPRestrictionHeaders)(ptr) == nil
}

func (ServiceSpecSiteConfigScmIPRestrictionHeadersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSpecSiteConfigScmIPRestrictionHeaders)(ptr)
	var objs []ServiceSpecSiteConfigScmIPRestrictionHeaders
	if obj != nil {
		objs = []ServiceSpecSiteConfigScmIPRestrictionHeaders{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecSiteConfigScmIPRestrictionHeaders{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSpecSiteConfigScmIPRestrictionHeadersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSpecSiteConfigScmIPRestrictionHeaders)(ptr) = ServiceSpecSiteConfigScmIPRestrictionHeaders{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSpecSiteConfigScmIPRestrictionHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecSiteConfigScmIPRestrictionHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSpecSiteConfigScmIPRestrictionHeaders)(ptr) = objs[0]
			} else {
				*(*ServiceSpecSiteConfigScmIPRestrictionHeaders)(ptr) = ServiceSpecSiteConfigScmIPRestrictionHeaders{}
			}
		} else {
			*(*ServiceSpecSiteConfigScmIPRestrictionHeaders)(ptr) = ServiceSpecSiteConfigScmIPRestrictionHeaders{}
		}
	default:
		iter.ReportError("decode ServiceSpecSiteConfigScmIPRestrictionHeaders", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSpecSourceControlCodec struct {
}

func (ServiceSpecSourceControlCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSpecSourceControl)(ptr) == nil
}

func (ServiceSpecSourceControlCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSpecSourceControl)(ptr)
	var objs []ServiceSpecSourceControl
	if obj != nil {
		objs = []ServiceSpecSourceControl{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecSourceControl{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSpecSourceControlCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSpecSourceControl)(ptr) = ServiceSpecSourceControl{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSpecSourceControl

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSpecSourceControl{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSpecSourceControl)(ptr) = objs[0]
			} else {
				*(*ServiceSpecSourceControl)(ptr) = ServiceSpecSourceControl{}
			}
		} else {
			*(*ServiceSpecSourceControl)(ptr) = ServiceSpecSourceControl{}
		}
	default:
		iter.ReportError("decode ServiceSpecSourceControl", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServicePlanSpecSkuCodec struct {
}

func (ServicePlanSpecSkuCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServicePlanSpecSku)(ptr) == nil
}

func (ServicePlanSpecSkuCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServicePlanSpecSku)(ptr)
	var objs []ServicePlanSpecSku
	if obj != nil {
		objs = []ServicePlanSpecSku{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServicePlanSpecSku{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServicePlanSpecSkuCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServicePlanSpecSku)(ptr) = ServicePlanSpecSku{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServicePlanSpecSku

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServicePlanSpecSku{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServicePlanSpecSku)(ptr) = objs[0]
			} else {
				*(*ServicePlanSpecSku)(ptr) = ServicePlanSpecSku{}
			}
		} else {
			*(*ServicePlanSpecSku)(ptr) = ServicePlanSpecSku{}
		}
	default:
		iter.ReportError("decode ServicePlanSpecSku", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSlotSpecAuthSettingsCodec struct {
}

func (ServiceSlotSpecAuthSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSlotSpecAuthSettings)(ptr) == nil
}

func (ServiceSlotSpecAuthSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSlotSpecAuthSettings)(ptr)
	var objs []ServiceSlotSpecAuthSettings
	if obj != nil {
		objs = []ServiceSlotSpecAuthSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSlotSpecAuthSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSlotSpecAuthSettings)(ptr) = ServiceSlotSpecAuthSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSlotSpecAuthSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSlotSpecAuthSettings)(ptr) = objs[0]
			} else {
				*(*ServiceSlotSpecAuthSettings)(ptr) = ServiceSlotSpecAuthSettings{}
			}
		} else {
			*(*ServiceSlotSpecAuthSettings)(ptr) = ServiceSlotSpecAuthSettings{}
		}
	default:
		iter.ReportError("decode ServiceSlotSpecAuthSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSlotSpecAuthSettingsActiveDirectoryCodec struct {
}

func (ServiceSlotSpecAuthSettingsActiveDirectoryCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSlotSpecAuthSettingsActiveDirectory)(ptr) == nil
}

func (ServiceSlotSpecAuthSettingsActiveDirectoryCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSlotSpecAuthSettingsActiveDirectory)(ptr)
	var objs []ServiceSlotSpecAuthSettingsActiveDirectory
	if obj != nil {
		objs = []ServiceSlotSpecAuthSettingsActiveDirectory{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettingsActiveDirectory{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSlotSpecAuthSettingsActiveDirectoryCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSlotSpecAuthSettingsActiveDirectory)(ptr) = ServiceSlotSpecAuthSettingsActiveDirectory{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSlotSpecAuthSettingsActiveDirectory

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettingsActiveDirectory{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSlotSpecAuthSettingsActiveDirectory)(ptr) = objs[0]
			} else {
				*(*ServiceSlotSpecAuthSettingsActiveDirectory)(ptr) = ServiceSlotSpecAuthSettingsActiveDirectory{}
			}
		} else {
			*(*ServiceSlotSpecAuthSettingsActiveDirectory)(ptr) = ServiceSlotSpecAuthSettingsActiveDirectory{}
		}
	default:
		iter.ReportError("decode ServiceSlotSpecAuthSettingsActiveDirectory", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSlotSpecAuthSettingsFacebookCodec struct {
}

func (ServiceSlotSpecAuthSettingsFacebookCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSlotSpecAuthSettingsFacebook)(ptr) == nil
}

func (ServiceSlotSpecAuthSettingsFacebookCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSlotSpecAuthSettingsFacebook)(ptr)
	var objs []ServiceSlotSpecAuthSettingsFacebook
	if obj != nil {
		objs = []ServiceSlotSpecAuthSettingsFacebook{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettingsFacebook{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSlotSpecAuthSettingsFacebookCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSlotSpecAuthSettingsFacebook)(ptr) = ServiceSlotSpecAuthSettingsFacebook{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSlotSpecAuthSettingsFacebook

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettingsFacebook{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSlotSpecAuthSettingsFacebook)(ptr) = objs[0]
			} else {
				*(*ServiceSlotSpecAuthSettingsFacebook)(ptr) = ServiceSlotSpecAuthSettingsFacebook{}
			}
		} else {
			*(*ServiceSlotSpecAuthSettingsFacebook)(ptr) = ServiceSlotSpecAuthSettingsFacebook{}
		}
	default:
		iter.ReportError("decode ServiceSlotSpecAuthSettingsFacebook", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSlotSpecAuthSettingsGoogleCodec struct {
}

func (ServiceSlotSpecAuthSettingsGoogleCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSlotSpecAuthSettingsGoogle)(ptr) == nil
}

func (ServiceSlotSpecAuthSettingsGoogleCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSlotSpecAuthSettingsGoogle)(ptr)
	var objs []ServiceSlotSpecAuthSettingsGoogle
	if obj != nil {
		objs = []ServiceSlotSpecAuthSettingsGoogle{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettingsGoogle{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSlotSpecAuthSettingsGoogleCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSlotSpecAuthSettingsGoogle)(ptr) = ServiceSlotSpecAuthSettingsGoogle{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSlotSpecAuthSettingsGoogle

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettingsGoogle{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSlotSpecAuthSettingsGoogle)(ptr) = objs[0]
			} else {
				*(*ServiceSlotSpecAuthSettingsGoogle)(ptr) = ServiceSlotSpecAuthSettingsGoogle{}
			}
		} else {
			*(*ServiceSlotSpecAuthSettingsGoogle)(ptr) = ServiceSlotSpecAuthSettingsGoogle{}
		}
	default:
		iter.ReportError("decode ServiceSlotSpecAuthSettingsGoogle", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSlotSpecAuthSettingsMicrosoftCodec struct {
}

func (ServiceSlotSpecAuthSettingsMicrosoftCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSlotSpecAuthSettingsMicrosoft)(ptr) == nil
}

func (ServiceSlotSpecAuthSettingsMicrosoftCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSlotSpecAuthSettingsMicrosoft)(ptr)
	var objs []ServiceSlotSpecAuthSettingsMicrosoft
	if obj != nil {
		objs = []ServiceSlotSpecAuthSettingsMicrosoft{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettingsMicrosoft{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSlotSpecAuthSettingsMicrosoftCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSlotSpecAuthSettingsMicrosoft)(ptr) = ServiceSlotSpecAuthSettingsMicrosoft{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSlotSpecAuthSettingsMicrosoft

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettingsMicrosoft{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSlotSpecAuthSettingsMicrosoft)(ptr) = objs[0]
			} else {
				*(*ServiceSlotSpecAuthSettingsMicrosoft)(ptr) = ServiceSlotSpecAuthSettingsMicrosoft{}
			}
		} else {
			*(*ServiceSlotSpecAuthSettingsMicrosoft)(ptr) = ServiceSlotSpecAuthSettingsMicrosoft{}
		}
	default:
		iter.ReportError("decode ServiceSlotSpecAuthSettingsMicrosoft", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSlotSpecAuthSettingsTwitterCodec struct {
}

func (ServiceSlotSpecAuthSettingsTwitterCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSlotSpecAuthSettingsTwitter)(ptr) == nil
}

func (ServiceSlotSpecAuthSettingsTwitterCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSlotSpecAuthSettingsTwitter)(ptr)
	var objs []ServiceSlotSpecAuthSettingsTwitter
	if obj != nil {
		objs = []ServiceSlotSpecAuthSettingsTwitter{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettingsTwitter{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSlotSpecAuthSettingsTwitterCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSlotSpecAuthSettingsTwitter)(ptr) = ServiceSlotSpecAuthSettingsTwitter{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSlotSpecAuthSettingsTwitter

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecAuthSettingsTwitter{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSlotSpecAuthSettingsTwitter)(ptr) = objs[0]
			} else {
				*(*ServiceSlotSpecAuthSettingsTwitter)(ptr) = ServiceSlotSpecAuthSettingsTwitter{}
			}
		} else {
			*(*ServiceSlotSpecAuthSettingsTwitter)(ptr) = ServiceSlotSpecAuthSettingsTwitter{}
		}
	default:
		iter.ReportError("decode ServiceSlotSpecAuthSettingsTwitter", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSlotSpecIdentityCodec struct {
}

func (ServiceSlotSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSlotSpecIdentity)(ptr) == nil
}

func (ServiceSlotSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSlotSpecIdentity)(ptr)
	var objs []ServiceSlotSpecIdentity
	if obj != nil {
		objs = []ServiceSlotSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSlotSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSlotSpecIdentity)(ptr) = ServiceSlotSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSlotSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSlotSpecIdentity)(ptr) = objs[0]
			} else {
				*(*ServiceSlotSpecIdentity)(ptr) = ServiceSlotSpecIdentity{}
			}
		} else {
			*(*ServiceSlotSpecIdentity)(ptr) = ServiceSlotSpecIdentity{}
		}
	default:
		iter.ReportError("decode ServiceSlotSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSlotSpecLogsCodec struct {
}

func (ServiceSlotSpecLogsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSlotSpecLogs)(ptr) == nil
}

func (ServiceSlotSpecLogsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSlotSpecLogs)(ptr)
	var objs []ServiceSlotSpecLogs
	if obj != nil {
		objs = []ServiceSlotSpecLogs{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogs{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSlotSpecLogsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSlotSpecLogs)(ptr) = ServiceSlotSpecLogs{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSlotSpecLogs

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogs{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSlotSpecLogs)(ptr) = objs[0]
			} else {
				*(*ServiceSlotSpecLogs)(ptr) = ServiceSlotSpecLogs{}
			}
		} else {
			*(*ServiceSlotSpecLogs)(ptr) = ServiceSlotSpecLogs{}
		}
	default:
		iter.ReportError("decode ServiceSlotSpecLogs", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSlotSpecLogsApplicationLogsCodec struct {
}

func (ServiceSlotSpecLogsApplicationLogsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSlotSpecLogsApplicationLogs)(ptr) == nil
}

func (ServiceSlotSpecLogsApplicationLogsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSlotSpecLogsApplicationLogs)(ptr)
	var objs []ServiceSlotSpecLogsApplicationLogs
	if obj != nil {
		objs = []ServiceSlotSpecLogsApplicationLogs{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogsApplicationLogs{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSlotSpecLogsApplicationLogsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSlotSpecLogsApplicationLogs)(ptr) = ServiceSlotSpecLogsApplicationLogs{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSlotSpecLogsApplicationLogs

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogsApplicationLogs{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSlotSpecLogsApplicationLogs)(ptr) = objs[0]
			} else {
				*(*ServiceSlotSpecLogsApplicationLogs)(ptr) = ServiceSlotSpecLogsApplicationLogs{}
			}
		} else {
			*(*ServiceSlotSpecLogsApplicationLogs)(ptr) = ServiceSlotSpecLogsApplicationLogs{}
		}
	default:
		iter.ReportError("decode ServiceSlotSpecLogsApplicationLogs", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSlotSpecLogsApplicationLogsAzureBlobStorageCodec struct {
}

func (ServiceSlotSpecLogsApplicationLogsAzureBlobStorageCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSlotSpecLogsApplicationLogsAzureBlobStorage)(ptr) == nil
}

func (ServiceSlotSpecLogsApplicationLogsAzureBlobStorageCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSlotSpecLogsApplicationLogsAzureBlobStorage)(ptr)
	var objs []ServiceSlotSpecLogsApplicationLogsAzureBlobStorage
	if obj != nil {
		objs = []ServiceSlotSpecLogsApplicationLogsAzureBlobStorage{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogsApplicationLogsAzureBlobStorage{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSlotSpecLogsApplicationLogsAzureBlobStorageCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSlotSpecLogsApplicationLogsAzureBlobStorage)(ptr) = ServiceSlotSpecLogsApplicationLogsAzureBlobStorage{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSlotSpecLogsApplicationLogsAzureBlobStorage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogsApplicationLogsAzureBlobStorage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSlotSpecLogsApplicationLogsAzureBlobStorage)(ptr) = objs[0]
			} else {
				*(*ServiceSlotSpecLogsApplicationLogsAzureBlobStorage)(ptr) = ServiceSlotSpecLogsApplicationLogsAzureBlobStorage{}
			}
		} else {
			*(*ServiceSlotSpecLogsApplicationLogsAzureBlobStorage)(ptr) = ServiceSlotSpecLogsApplicationLogsAzureBlobStorage{}
		}
	default:
		iter.ReportError("decode ServiceSlotSpecLogsApplicationLogsAzureBlobStorage", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSlotSpecLogsHttpLogsCodec struct {
}

func (ServiceSlotSpecLogsHttpLogsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSlotSpecLogsHttpLogs)(ptr) == nil
}

func (ServiceSlotSpecLogsHttpLogsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSlotSpecLogsHttpLogs)(ptr)
	var objs []ServiceSlotSpecLogsHttpLogs
	if obj != nil {
		objs = []ServiceSlotSpecLogsHttpLogs{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogsHttpLogs{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSlotSpecLogsHttpLogsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSlotSpecLogsHttpLogs)(ptr) = ServiceSlotSpecLogsHttpLogs{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSlotSpecLogsHttpLogs

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogsHttpLogs{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSlotSpecLogsHttpLogs)(ptr) = objs[0]
			} else {
				*(*ServiceSlotSpecLogsHttpLogs)(ptr) = ServiceSlotSpecLogsHttpLogs{}
			}
		} else {
			*(*ServiceSlotSpecLogsHttpLogs)(ptr) = ServiceSlotSpecLogsHttpLogs{}
		}
	default:
		iter.ReportError("decode ServiceSlotSpecLogsHttpLogs", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSlotSpecLogsHttpLogsAzureBlobStorageCodec struct {
}

func (ServiceSlotSpecLogsHttpLogsAzureBlobStorageCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSlotSpecLogsHttpLogsAzureBlobStorage)(ptr) == nil
}

func (ServiceSlotSpecLogsHttpLogsAzureBlobStorageCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSlotSpecLogsHttpLogsAzureBlobStorage)(ptr)
	var objs []ServiceSlotSpecLogsHttpLogsAzureBlobStorage
	if obj != nil {
		objs = []ServiceSlotSpecLogsHttpLogsAzureBlobStorage{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogsHttpLogsAzureBlobStorage{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSlotSpecLogsHttpLogsAzureBlobStorageCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSlotSpecLogsHttpLogsAzureBlobStorage)(ptr) = ServiceSlotSpecLogsHttpLogsAzureBlobStorage{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSlotSpecLogsHttpLogsAzureBlobStorage

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogsHttpLogsAzureBlobStorage{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSlotSpecLogsHttpLogsAzureBlobStorage)(ptr) = objs[0]
			} else {
				*(*ServiceSlotSpecLogsHttpLogsAzureBlobStorage)(ptr) = ServiceSlotSpecLogsHttpLogsAzureBlobStorage{}
			}
		} else {
			*(*ServiceSlotSpecLogsHttpLogsAzureBlobStorage)(ptr) = ServiceSlotSpecLogsHttpLogsAzureBlobStorage{}
		}
	default:
		iter.ReportError("decode ServiceSlotSpecLogsHttpLogsAzureBlobStorage", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSlotSpecLogsHttpLogsFileSystemCodec struct {
}

func (ServiceSlotSpecLogsHttpLogsFileSystemCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSlotSpecLogsHttpLogsFileSystem)(ptr) == nil
}

func (ServiceSlotSpecLogsHttpLogsFileSystemCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSlotSpecLogsHttpLogsFileSystem)(ptr)
	var objs []ServiceSlotSpecLogsHttpLogsFileSystem
	if obj != nil {
		objs = []ServiceSlotSpecLogsHttpLogsFileSystem{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogsHttpLogsFileSystem{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSlotSpecLogsHttpLogsFileSystemCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSlotSpecLogsHttpLogsFileSystem)(ptr) = ServiceSlotSpecLogsHttpLogsFileSystem{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSlotSpecLogsHttpLogsFileSystem

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecLogsHttpLogsFileSystem{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSlotSpecLogsHttpLogsFileSystem)(ptr) = objs[0]
			} else {
				*(*ServiceSlotSpecLogsHttpLogsFileSystem)(ptr) = ServiceSlotSpecLogsHttpLogsFileSystem{}
			}
		} else {
			*(*ServiceSlotSpecLogsHttpLogsFileSystem)(ptr) = ServiceSlotSpecLogsHttpLogsFileSystem{}
		}
	default:
		iter.ReportError("decode ServiceSlotSpecLogsHttpLogsFileSystem", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSlotSpecSiteConfigCodec struct {
}

func (ServiceSlotSpecSiteConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSlotSpecSiteConfig)(ptr) == nil
}

func (ServiceSlotSpecSiteConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSlotSpecSiteConfig)(ptr)
	var objs []ServiceSlotSpecSiteConfig
	if obj != nil {
		objs = []ServiceSlotSpecSiteConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecSiteConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSlotSpecSiteConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSlotSpecSiteConfig)(ptr) = ServiceSlotSpecSiteConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSlotSpecSiteConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecSiteConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSlotSpecSiteConfig)(ptr) = objs[0]
			} else {
				*(*ServiceSlotSpecSiteConfig)(ptr) = ServiceSlotSpecSiteConfig{}
			}
		} else {
			*(*ServiceSlotSpecSiteConfig)(ptr) = ServiceSlotSpecSiteConfig{}
		}
	default:
		iter.ReportError("decode ServiceSlotSpecSiteConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSlotSpecSiteConfigCorsCodec struct {
}

func (ServiceSlotSpecSiteConfigCorsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSlotSpecSiteConfigCors)(ptr) == nil
}

func (ServiceSlotSpecSiteConfigCorsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSlotSpecSiteConfigCors)(ptr)
	var objs []ServiceSlotSpecSiteConfigCors
	if obj != nil {
		objs = []ServiceSlotSpecSiteConfigCors{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecSiteConfigCors{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSlotSpecSiteConfigCorsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSlotSpecSiteConfigCors)(ptr) = ServiceSlotSpecSiteConfigCors{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSlotSpecSiteConfigCors

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecSiteConfigCors{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSlotSpecSiteConfigCors)(ptr) = objs[0]
			} else {
				*(*ServiceSlotSpecSiteConfigCors)(ptr) = ServiceSlotSpecSiteConfigCors{}
			}
		} else {
			*(*ServiceSlotSpecSiteConfigCors)(ptr) = ServiceSlotSpecSiteConfigCors{}
		}
	default:
		iter.ReportError("decode ServiceSlotSpecSiteConfigCors", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSlotSpecSiteConfigIpRestrictionHeadersCodec struct {
}

func (ServiceSlotSpecSiteConfigIpRestrictionHeadersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSlotSpecSiteConfigIpRestrictionHeaders)(ptr) == nil
}

func (ServiceSlotSpecSiteConfigIpRestrictionHeadersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSlotSpecSiteConfigIpRestrictionHeaders)(ptr)
	var objs []ServiceSlotSpecSiteConfigIpRestrictionHeaders
	if obj != nil {
		objs = []ServiceSlotSpecSiteConfigIpRestrictionHeaders{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecSiteConfigIpRestrictionHeaders{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSlotSpecSiteConfigIpRestrictionHeadersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSlotSpecSiteConfigIpRestrictionHeaders)(ptr) = ServiceSlotSpecSiteConfigIpRestrictionHeaders{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSlotSpecSiteConfigIpRestrictionHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecSiteConfigIpRestrictionHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSlotSpecSiteConfigIpRestrictionHeaders)(ptr) = objs[0]
			} else {
				*(*ServiceSlotSpecSiteConfigIpRestrictionHeaders)(ptr) = ServiceSlotSpecSiteConfigIpRestrictionHeaders{}
			}
		} else {
			*(*ServiceSlotSpecSiteConfigIpRestrictionHeaders)(ptr) = ServiceSlotSpecSiteConfigIpRestrictionHeaders{}
		}
	default:
		iter.ReportError("decode ServiceSlotSpecSiteConfigIpRestrictionHeaders", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type ServiceSlotSpecSiteConfigScmIPRestrictionHeadersCodec struct {
}

func (ServiceSlotSpecSiteConfigScmIPRestrictionHeadersCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*ServiceSlotSpecSiteConfigScmIPRestrictionHeaders)(ptr) == nil
}

func (ServiceSlotSpecSiteConfigScmIPRestrictionHeadersCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*ServiceSlotSpecSiteConfigScmIPRestrictionHeaders)(ptr)
	var objs []ServiceSlotSpecSiteConfigScmIPRestrictionHeaders
	if obj != nil {
		objs = []ServiceSlotSpecSiteConfigScmIPRestrictionHeaders{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecSiteConfigScmIPRestrictionHeaders{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (ServiceSlotSpecSiteConfigScmIPRestrictionHeadersCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*ServiceSlotSpecSiteConfigScmIPRestrictionHeaders)(ptr) = ServiceSlotSpecSiteConfigScmIPRestrictionHeaders{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []ServiceSlotSpecSiteConfigScmIPRestrictionHeaders

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(ServiceSlotSpecSiteConfigScmIPRestrictionHeaders{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*ServiceSlotSpecSiteConfigScmIPRestrictionHeaders)(ptr) = objs[0]
			} else {
				*(*ServiceSlotSpecSiteConfigScmIPRestrictionHeaders)(ptr) = ServiceSlotSpecSiteConfigScmIPRestrictionHeaders{}
			}
		} else {
			*(*ServiceSlotSpecSiteConfigScmIPRestrictionHeaders)(ptr) = ServiceSlotSpecSiteConfigScmIPRestrictionHeaders{}
		}
	default:
		iter.ReportError("decode ServiceSlotSpecSiteConfigScmIPRestrictionHeaders", "unexpected JSON type")
	}
}
