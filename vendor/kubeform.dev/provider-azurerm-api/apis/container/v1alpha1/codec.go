/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerGpu{}).Type1()):            GroupSpecContainerGpuCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerLivenessProbe{}).Type1()):  GroupSpecContainerLivenessProbeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerReadinessProbe{}).Type1()): GroupSpecContainerReadinessProbeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerVolumeGitRepo{}).Type1()):  GroupSpecContainerVolumeGitRepoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDiagnostics{}).Type1()):             GroupSpecDiagnosticsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDiagnosticsLogAnalytics{}).Type1()): GroupSpecDiagnosticsLogAnalyticsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDnsConfig{}).Type1()):               GroupSpecDnsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecIdentity{}).Type1()):                GroupSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecEncryption{}).Type1()):           RegistrySpecEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecIdentity{}).Type1()):             RegistrySpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecNetworkRuleSet{}).Type1()):       RegistrySpecNetworkRuleSetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecRetentionPolicy{}).Type1()):      RegistrySpecRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecTrustPolicy{}).Type1()):          RegistrySpecTrustPolicyCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerGpu{}).Type1()):            GroupSpecContainerGpuCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerLivenessProbe{}).Type1()):  GroupSpecContainerLivenessProbeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerReadinessProbe{}).Type1()): GroupSpecContainerReadinessProbeCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerVolumeGitRepo{}).Type1()):  GroupSpecContainerVolumeGitRepoCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDiagnostics{}).Type1()):             GroupSpecDiagnosticsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDiagnosticsLogAnalytics{}).Type1()): GroupSpecDiagnosticsLogAnalyticsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDnsConfig{}).Type1()):               GroupSpecDnsConfigCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecIdentity{}).Type1()):                GroupSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecEncryption{}).Type1()):           RegistrySpecEncryptionCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecIdentity{}).Type1()):             RegistrySpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecNetworkRuleSet{}).Type1()):       RegistrySpecNetworkRuleSetCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecRetentionPolicy{}).Type1()):      RegistrySpecRetentionPolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecTrustPolicy{}).Type1()):          RegistrySpecTrustPolicyCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type GroupSpecContainerGpuCodec struct {
}

func (GroupSpecContainerGpuCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecContainerGpu)(ptr) == nil
}

func (GroupSpecContainerGpuCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecContainerGpu)(ptr)
	var objs []GroupSpecContainerGpu
	if obj != nil {
		objs = []GroupSpecContainerGpu{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerGpu{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecContainerGpuCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecContainerGpu)(ptr) = GroupSpecContainerGpu{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecContainerGpu

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerGpu{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecContainerGpu)(ptr) = objs[0]
			} else {
				*(*GroupSpecContainerGpu)(ptr) = GroupSpecContainerGpu{}
			}
		} else {
			*(*GroupSpecContainerGpu)(ptr) = GroupSpecContainerGpu{}
		}
	default:
		iter.ReportError("decode GroupSpecContainerGpu", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupSpecContainerLivenessProbeCodec struct {
}

func (GroupSpecContainerLivenessProbeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecContainerLivenessProbe)(ptr) == nil
}

func (GroupSpecContainerLivenessProbeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecContainerLivenessProbe)(ptr)
	var objs []GroupSpecContainerLivenessProbe
	if obj != nil {
		objs = []GroupSpecContainerLivenessProbe{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerLivenessProbe{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecContainerLivenessProbeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecContainerLivenessProbe)(ptr) = GroupSpecContainerLivenessProbe{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecContainerLivenessProbe

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerLivenessProbe{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecContainerLivenessProbe)(ptr) = objs[0]
			} else {
				*(*GroupSpecContainerLivenessProbe)(ptr) = GroupSpecContainerLivenessProbe{}
			}
		} else {
			*(*GroupSpecContainerLivenessProbe)(ptr) = GroupSpecContainerLivenessProbe{}
		}
	default:
		iter.ReportError("decode GroupSpecContainerLivenessProbe", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupSpecContainerReadinessProbeCodec struct {
}

func (GroupSpecContainerReadinessProbeCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecContainerReadinessProbe)(ptr) == nil
}

func (GroupSpecContainerReadinessProbeCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecContainerReadinessProbe)(ptr)
	var objs []GroupSpecContainerReadinessProbe
	if obj != nil {
		objs = []GroupSpecContainerReadinessProbe{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerReadinessProbe{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecContainerReadinessProbeCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecContainerReadinessProbe)(ptr) = GroupSpecContainerReadinessProbe{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecContainerReadinessProbe

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerReadinessProbe{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecContainerReadinessProbe)(ptr) = objs[0]
			} else {
				*(*GroupSpecContainerReadinessProbe)(ptr) = GroupSpecContainerReadinessProbe{}
			}
		} else {
			*(*GroupSpecContainerReadinessProbe)(ptr) = GroupSpecContainerReadinessProbe{}
		}
	default:
		iter.ReportError("decode GroupSpecContainerReadinessProbe", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupSpecContainerVolumeGitRepoCodec struct {
}

func (GroupSpecContainerVolumeGitRepoCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecContainerVolumeGitRepo)(ptr) == nil
}

func (GroupSpecContainerVolumeGitRepoCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecContainerVolumeGitRepo)(ptr)
	var objs []GroupSpecContainerVolumeGitRepo
	if obj != nil {
		objs = []GroupSpecContainerVolumeGitRepo{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerVolumeGitRepo{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecContainerVolumeGitRepoCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecContainerVolumeGitRepo)(ptr) = GroupSpecContainerVolumeGitRepo{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecContainerVolumeGitRepo

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecContainerVolumeGitRepo{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecContainerVolumeGitRepo)(ptr) = objs[0]
			} else {
				*(*GroupSpecContainerVolumeGitRepo)(ptr) = GroupSpecContainerVolumeGitRepo{}
			}
		} else {
			*(*GroupSpecContainerVolumeGitRepo)(ptr) = GroupSpecContainerVolumeGitRepo{}
		}
	default:
		iter.ReportError("decode GroupSpecContainerVolumeGitRepo", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupSpecDiagnosticsCodec struct {
}

func (GroupSpecDiagnosticsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecDiagnostics)(ptr) == nil
}

func (GroupSpecDiagnosticsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecDiagnostics)(ptr)
	var objs []GroupSpecDiagnostics
	if obj != nil {
		objs = []GroupSpecDiagnostics{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDiagnostics{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecDiagnosticsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecDiagnostics)(ptr) = GroupSpecDiagnostics{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecDiagnostics

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDiagnostics{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecDiagnostics)(ptr) = objs[0]
			} else {
				*(*GroupSpecDiagnostics)(ptr) = GroupSpecDiagnostics{}
			}
		} else {
			*(*GroupSpecDiagnostics)(ptr) = GroupSpecDiagnostics{}
		}
	default:
		iter.ReportError("decode GroupSpecDiagnostics", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupSpecDiagnosticsLogAnalyticsCodec struct {
}

func (GroupSpecDiagnosticsLogAnalyticsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecDiagnosticsLogAnalytics)(ptr) == nil
}

func (GroupSpecDiagnosticsLogAnalyticsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecDiagnosticsLogAnalytics)(ptr)
	var objs []GroupSpecDiagnosticsLogAnalytics
	if obj != nil {
		objs = []GroupSpecDiagnosticsLogAnalytics{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDiagnosticsLogAnalytics{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecDiagnosticsLogAnalyticsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecDiagnosticsLogAnalytics)(ptr) = GroupSpecDiagnosticsLogAnalytics{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecDiagnosticsLogAnalytics

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDiagnosticsLogAnalytics{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecDiagnosticsLogAnalytics)(ptr) = objs[0]
			} else {
				*(*GroupSpecDiagnosticsLogAnalytics)(ptr) = GroupSpecDiagnosticsLogAnalytics{}
			}
		} else {
			*(*GroupSpecDiagnosticsLogAnalytics)(ptr) = GroupSpecDiagnosticsLogAnalytics{}
		}
	default:
		iter.ReportError("decode GroupSpecDiagnosticsLogAnalytics", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupSpecDnsConfigCodec struct {
}

func (GroupSpecDnsConfigCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecDnsConfig)(ptr) == nil
}

func (GroupSpecDnsConfigCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecDnsConfig)(ptr)
	var objs []GroupSpecDnsConfig
	if obj != nil {
		objs = []GroupSpecDnsConfig{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDnsConfig{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecDnsConfigCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecDnsConfig)(ptr) = GroupSpecDnsConfig{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecDnsConfig

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecDnsConfig{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecDnsConfig)(ptr) = objs[0]
			} else {
				*(*GroupSpecDnsConfig)(ptr) = GroupSpecDnsConfig{}
			}
		} else {
			*(*GroupSpecDnsConfig)(ptr) = GroupSpecDnsConfig{}
		}
	default:
		iter.ReportError("decode GroupSpecDnsConfig", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type GroupSpecIdentityCodec struct {
}

func (GroupSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*GroupSpecIdentity)(ptr) == nil
}

func (GroupSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*GroupSpecIdentity)(ptr)
	var objs []GroupSpecIdentity
	if obj != nil {
		objs = []GroupSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (GroupSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*GroupSpecIdentity)(ptr) = GroupSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []GroupSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(GroupSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*GroupSpecIdentity)(ptr) = objs[0]
			} else {
				*(*GroupSpecIdentity)(ptr) = GroupSpecIdentity{}
			}
		} else {
			*(*GroupSpecIdentity)(ptr) = GroupSpecIdentity{}
		}
	default:
		iter.ReportError("decode GroupSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegistrySpecEncryptionCodec struct {
}

func (RegistrySpecEncryptionCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegistrySpecEncryption)(ptr) == nil
}

func (RegistrySpecEncryptionCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegistrySpecEncryption)(ptr)
	var objs []RegistrySpecEncryption
	if obj != nil {
		objs = []RegistrySpecEncryption{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecEncryption{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegistrySpecEncryptionCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegistrySpecEncryption)(ptr) = RegistrySpecEncryption{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegistrySpecEncryption

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecEncryption{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegistrySpecEncryption)(ptr) = objs[0]
			} else {
				*(*RegistrySpecEncryption)(ptr) = RegistrySpecEncryption{}
			}
		} else {
			*(*RegistrySpecEncryption)(ptr) = RegistrySpecEncryption{}
		}
	default:
		iter.ReportError("decode RegistrySpecEncryption", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegistrySpecIdentityCodec struct {
}

func (RegistrySpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegistrySpecIdentity)(ptr) == nil
}

func (RegistrySpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegistrySpecIdentity)(ptr)
	var objs []RegistrySpecIdentity
	if obj != nil {
		objs = []RegistrySpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegistrySpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegistrySpecIdentity)(ptr) = RegistrySpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegistrySpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegistrySpecIdentity)(ptr) = objs[0]
			} else {
				*(*RegistrySpecIdentity)(ptr) = RegistrySpecIdentity{}
			}
		} else {
			*(*RegistrySpecIdentity)(ptr) = RegistrySpecIdentity{}
		}
	default:
		iter.ReportError("decode RegistrySpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegistrySpecNetworkRuleSetCodec struct {
}

func (RegistrySpecNetworkRuleSetCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegistrySpecNetworkRuleSet)(ptr) == nil
}

func (RegistrySpecNetworkRuleSetCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegistrySpecNetworkRuleSet)(ptr)
	var objs []RegistrySpecNetworkRuleSet
	if obj != nil {
		objs = []RegistrySpecNetworkRuleSet{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecNetworkRuleSet{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegistrySpecNetworkRuleSetCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegistrySpecNetworkRuleSet)(ptr) = RegistrySpecNetworkRuleSet{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegistrySpecNetworkRuleSet

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecNetworkRuleSet{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegistrySpecNetworkRuleSet)(ptr) = objs[0]
			} else {
				*(*RegistrySpecNetworkRuleSet)(ptr) = RegistrySpecNetworkRuleSet{}
			}
		} else {
			*(*RegistrySpecNetworkRuleSet)(ptr) = RegistrySpecNetworkRuleSet{}
		}
	default:
		iter.ReportError("decode RegistrySpecNetworkRuleSet", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegistrySpecRetentionPolicyCodec struct {
}

func (RegistrySpecRetentionPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegistrySpecRetentionPolicy)(ptr) == nil
}

func (RegistrySpecRetentionPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegistrySpecRetentionPolicy)(ptr)
	var objs []RegistrySpecRetentionPolicy
	if obj != nil {
		objs = []RegistrySpecRetentionPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecRetentionPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegistrySpecRetentionPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegistrySpecRetentionPolicy)(ptr) = RegistrySpecRetentionPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegistrySpecRetentionPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecRetentionPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegistrySpecRetentionPolicy)(ptr) = objs[0]
			} else {
				*(*RegistrySpecRetentionPolicy)(ptr) = RegistrySpecRetentionPolicy{}
			}
		} else {
			*(*RegistrySpecRetentionPolicy)(ptr) = RegistrySpecRetentionPolicy{}
		}
	default:
		iter.ReportError("decode RegistrySpecRetentionPolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type RegistrySpecTrustPolicyCodec struct {
}

func (RegistrySpecTrustPolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*RegistrySpecTrustPolicy)(ptr) == nil
}

func (RegistrySpecTrustPolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*RegistrySpecTrustPolicy)(ptr)
	var objs []RegistrySpecTrustPolicy
	if obj != nil {
		objs = []RegistrySpecTrustPolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecTrustPolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (RegistrySpecTrustPolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*RegistrySpecTrustPolicy)(ptr) = RegistrySpecTrustPolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []RegistrySpecTrustPolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(RegistrySpecTrustPolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*RegistrySpecTrustPolicy)(ptr) = objs[0]
			} else {
				*(*RegistrySpecTrustPolicy)(ptr) = RegistrySpecTrustPolicy{}
			}
		} else {
			*(*RegistrySpecTrustPolicy)(ptr) = RegistrySpecTrustPolicy{}
		}
	default:
		iter.ReportError("decode RegistrySpecTrustPolicy", "unexpected JSON type")
	}
}
