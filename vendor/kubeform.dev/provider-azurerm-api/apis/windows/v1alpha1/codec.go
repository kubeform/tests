/*
Copyright AppsCode Inc. and Contributors

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by Kubeform. DO NOT EDIT.

package v1alpha1

import (
	"unsafe"

	jsoniter "github.com/json-iterator/go"
	"github.com/modern-go/reflect2"
)

func GetEncoder() map[string]jsoniter.ValEncoder {
	return map[string]jsoniter.ValEncoder{
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecAdditionalCapabilities{}).Type1()):           VirtualMachineSpecAdditionalCapabilitiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecBootDiagnostics{}).Type1()):                  VirtualMachineSpecBootDiagnosticsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecIdentity{}).Type1()):                         VirtualMachineSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecOsDisk{}).Type1()):                           VirtualMachineSpecOsDiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecOsDiskDiffDiskSettings{}).Type1()):           VirtualMachineSpecOsDiskDiffDiskSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecPlan{}).Type1()):                             VirtualMachineSpecPlanCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecSourceImageReference{}).Type1()):             VirtualMachineSpecSourceImageReferenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecAdditionalCapabilities{}).Type1()):   VirtualMachineScaleSetSpecAdditionalCapabilitiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecAutomaticInstanceRepair{}).Type1()):  VirtualMachineScaleSetSpecAutomaticInstanceRepairCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecAutomaticOsUpgradePolicy{}).Type1()): VirtualMachineScaleSetSpecAutomaticOsUpgradePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecBootDiagnostics{}).Type1()):          VirtualMachineScaleSetSpecBootDiagnosticsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecIdentity{}).Type1()):                 VirtualMachineScaleSetSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecOsDisk{}).Type1()):                   VirtualMachineScaleSetSpecOsDiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecOsDiskDiffDiskSettings{}).Type1()):   VirtualMachineScaleSetSpecOsDiskDiffDiskSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecPlan{}).Type1()):                     VirtualMachineScaleSetSpecPlanCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecRollingUpgradePolicy{}).Type1()):     VirtualMachineScaleSetSpecRollingUpgradePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecSourceImageReference{}).Type1()):     VirtualMachineScaleSetSpecSourceImageReferenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecTerminateNotification{}).Type1()):    VirtualMachineScaleSetSpecTerminateNotificationCodec{},
	}
}

func GetDecoder() map[string]jsoniter.ValDecoder {
	return map[string]jsoniter.ValDecoder{
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecAdditionalCapabilities{}).Type1()):           VirtualMachineSpecAdditionalCapabilitiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecBootDiagnostics{}).Type1()):                  VirtualMachineSpecBootDiagnosticsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecIdentity{}).Type1()):                         VirtualMachineSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecOsDisk{}).Type1()):                           VirtualMachineSpecOsDiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecOsDiskDiffDiskSettings{}).Type1()):           VirtualMachineSpecOsDiskDiffDiskSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecPlan{}).Type1()):                             VirtualMachineSpecPlanCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecSourceImageReference{}).Type1()):             VirtualMachineSpecSourceImageReferenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecAdditionalCapabilities{}).Type1()):   VirtualMachineScaleSetSpecAdditionalCapabilitiesCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecAutomaticInstanceRepair{}).Type1()):  VirtualMachineScaleSetSpecAutomaticInstanceRepairCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecAutomaticOsUpgradePolicy{}).Type1()): VirtualMachineScaleSetSpecAutomaticOsUpgradePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecBootDiagnostics{}).Type1()):          VirtualMachineScaleSetSpecBootDiagnosticsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecIdentity{}).Type1()):                 VirtualMachineScaleSetSpecIdentityCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecOsDisk{}).Type1()):                   VirtualMachineScaleSetSpecOsDiskCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecOsDiskDiffDiskSettings{}).Type1()):   VirtualMachineScaleSetSpecOsDiskDiffDiskSettingsCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecPlan{}).Type1()):                     VirtualMachineScaleSetSpecPlanCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecRollingUpgradePolicy{}).Type1()):     VirtualMachineScaleSetSpecRollingUpgradePolicyCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecSourceImageReference{}).Type1()):     VirtualMachineScaleSetSpecSourceImageReferenceCodec{},
		jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecTerminateNotification{}).Type1()):    VirtualMachineScaleSetSpecTerminateNotificationCodec{},
	}
}

func getEncodersWithout(typ string) map[string]jsoniter.ValEncoder {
	origMap := GetEncoder()
	delete(origMap, typ)
	return origMap
}

func getDecodersWithout(typ string) map[string]jsoniter.ValDecoder {
	origMap := GetDecoder()
	delete(origMap, typ)
	return origMap
}

// +k8s:deepcopy-gen=false
type VirtualMachineSpecAdditionalCapabilitiesCodec struct {
}

func (VirtualMachineSpecAdditionalCapabilitiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineSpecAdditionalCapabilities)(ptr) == nil
}

func (VirtualMachineSpecAdditionalCapabilitiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineSpecAdditionalCapabilities)(ptr)
	var objs []VirtualMachineSpecAdditionalCapabilities
	if obj != nil {
		objs = []VirtualMachineSpecAdditionalCapabilities{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecAdditionalCapabilities{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineSpecAdditionalCapabilitiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineSpecAdditionalCapabilities)(ptr) = VirtualMachineSpecAdditionalCapabilities{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineSpecAdditionalCapabilities

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecAdditionalCapabilities{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineSpecAdditionalCapabilities)(ptr) = objs[0]
			} else {
				*(*VirtualMachineSpecAdditionalCapabilities)(ptr) = VirtualMachineSpecAdditionalCapabilities{}
			}
		} else {
			*(*VirtualMachineSpecAdditionalCapabilities)(ptr) = VirtualMachineSpecAdditionalCapabilities{}
		}
	default:
		iter.ReportError("decode VirtualMachineSpecAdditionalCapabilities", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineSpecBootDiagnosticsCodec struct {
}

func (VirtualMachineSpecBootDiagnosticsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineSpecBootDiagnostics)(ptr) == nil
}

func (VirtualMachineSpecBootDiagnosticsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineSpecBootDiagnostics)(ptr)
	var objs []VirtualMachineSpecBootDiagnostics
	if obj != nil {
		objs = []VirtualMachineSpecBootDiagnostics{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecBootDiagnostics{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineSpecBootDiagnosticsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineSpecBootDiagnostics)(ptr) = VirtualMachineSpecBootDiagnostics{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineSpecBootDiagnostics

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecBootDiagnostics{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineSpecBootDiagnostics)(ptr) = objs[0]
			} else {
				*(*VirtualMachineSpecBootDiagnostics)(ptr) = VirtualMachineSpecBootDiagnostics{}
			}
		} else {
			*(*VirtualMachineSpecBootDiagnostics)(ptr) = VirtualMachineSpecBootDiagnostics{}
		}
	default:
		iter.ReportError("decode VirtualMachineSpecBootDiagnostics", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineSpecIdentityCodec struct {
}

func (VirtualMachineSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineSpecIdentity)(ptr) == nil
}

func (VirtualMachineSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineSpecIdentity)(ptr)
	var objs []VirtualMachineSpecIdentity
	if obj != nil {
		objs = []VirtualMachineSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineSpecIdentity)(ptr) = VirtualMachineSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineSpecIdentity)(ptr) = objs[0]
			} else {
				*(*VirtualMachineSpecIdentity)(ptr) = VirtualMachineSpecIdentity{}
			}
		} else {
			*(*VirtualMachineSpecIdentity)(ptr) = VirtualMachineSpecIdentity{}
		}
	default:
		iter.ReportError("decode VirtualMachineSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineSpecOsDiskCodec struct {
}

func (VirtualMachineSpecOsDiskCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineSpecOsDisk)(ptr) == nil
}

func (VirtualMachineSpecOsDiskCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineSpecOsDisk)(ptr)
	var objs []VirtualMachineSpecOsDisk
	if obj != nil {
		objs = []VirtualMachineSpecOsDisk{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecOsDisk{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineSpecOsDiskCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineSpecOsDisk)(ptr) = VirtualMachineSpecOsDisk{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineSpecOsDisk

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecOsDisk{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineSpecOsDisk)(ptr) = objs[0]
			} else {
				*(*VirtualMachineSpecOsDisk)(ptr) = VirtualMachineSpecOsDisk{}
			}
		} else {
			*(*VirtualMachineSpecOsDisk)(ptr) = VirtualMachineSpecOsDisk{}
		}
	default:
		iter.ReportError("decode VirtualMachineSpecOsDisk", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineSpecOsDiskDiffDiskSettingsCodec struct {
}

func (VirtualMachineSpecOsDiskDiffDiskSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineSpecOsDiskDiffDiskSettings)(ptr) == nil
}

func (VirtualMachineSpecOsDiskDiffDiskSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineSpecOsDiskDiffDiskSettings)(ptr)
	var objs []VirtualMachineSpecOsDiskDiffDiskSettings
	if obj != nil {
		objs = []VirtualMachineSpecOsDiskDiffDiskSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecOsDiskDiffDiskSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineSpecOsDiskDiffDiskSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineSpecOsDiskDiffDiskSettings)(ptr) = VirtualMachineSpecOsDiskDiffDiskSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineSpecOsDiskDiffDiskSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecOsDiskDiffDiskSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineSpecOsDiskDiffDiskSettings)(ptr) = objs[0]
			} else {
				*(*VirtualMachineSpecOsDiskDiffDiskSettings)(ptr) = VirtualMachineSpecOsDiskDiffDiskSettings{}
			}
		} else {
			*(*VirtualMachineSpecOsDiskDiffDiskSettings)(ptr) = VirtualMachineSpecOsDiskDiffDiskSettings{}
		}
	default:
		iter.ReportError("decode VirtualMachineSpecOsDiskDiffDiskSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineSpecPlanCodec struct {
}

func (VirtualMachineSpecPlanCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineSpecPlan)(ptr) == nil
}

func (VirtualMachineSpecPlanCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineSpecPlan)(ptr)
	var objs []VirtualMachineSpecPlan
	if obj != nil {
		objs = []VirtualMachineSpecPlan{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecPlan{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineSpecPlanCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineSpecPlan)(ptr) = VirtualMachineSpecPlan{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineSpecPlan

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecPlan{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineSpecPlan)(ptr) = objs[0]
			} else {
				*(*VirtualMachineSpecPlan)(ptr) = VirtualMachineSpecPlan{}
			}
		} else {
			*(*VirtualMachineSpecPlan)(ptr) = VirtualMachineSpecPlan{}
		}
	default:
		iter.ReportError("decode VirtualMachineSpecPlan", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineSpecSourceImageReferenceCodec struct {
}

func (VirtualMachineSpecSourceImageReferenceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineSpecSourceImageReference)(ptr) == nil
}

func (VirtualMachineSpecSourceImageReferenceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineSpecSourceImageReference)(ptr)
	var objs []VirtualMachineSpecSourceImageReference
	if obj != nil {
		objs = []VirtualMachineSpecSourceImageReference{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecSourceImageReference{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineSpecSourceImageReferenceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineSpecSourceImageReference)(ptr) = VirtualMachineSpecSourceImageReference{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineSpecSourceImageReference

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineSpecSourceImageReference{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineSpecSourceImageReference)(ptr) = objs[0]
			} else {
				*(*VirtualMachineSpecSourceImageReference)(ptr) = VirtualMachineSpecSourceImageReference{}
			}
		} else {
			*(*VirtualMachineSpecSourceImageReference)(ptr) = VirtualMachineSpecSourceImageReference{}
		}
	default:
		iter.ReportError("decode VirtualMachineSpecSourceImageReference", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineScaleSetSpecAdditionalCapabilitiesCodec struct {
}

func (VirtualMachineScaleSetSpecAdditionalCapabilitiesCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineScaleSetSpecAdditionalCapabilities)(ptr) == nil
}

func (VirtualMachineScaleSetSpecAdditionalCapabilitiesCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineScaleSetSpecAdditionalCapabilities)(ptr)
	var objs []VirtualMachineScaleSetSpecAdditionalCapabilities
	if obj != nil {
		objs = []VirtualMachineScaleSetSpecAdditionalCapabilities{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecAdditionalCapabilities{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineScaleSetSpecAdditionalCapabilitiesCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineScaleSetSpecAdditionalCapabilities)(ptr) = VirtualMachineScaleSetSpecAdditionalCapabilities{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineScaleSetSpecAdditionalCapabilities

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecAdditionalCapabilities{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineScaleSetSpecAdditionalCapabilities)(ptr) = objs[0]
			} else {
				*(*VirtualMachineScaleSetSpecAdditionalCapabilities)(ptr) = VirtualMachineScaleSetSpecAdditionalCapabilities{}
			}
		} else {
			*(*VirtualMachineScaleSetSpecAdditionalCapabilities)(ptr) = VirtualMachineScaleSetSpecAdditionalCapabilities{}
		}
	default:
		iter.ReportError("decode VirtualMachineScaleSetSpecAdditionalCapabilities", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineScaleSetSpecAutomaticInstanceRepairCodec struct {
}

func (VirtualMachineScaleSetSpecAutomaticInstanceRepairCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineScaleSetSpecAutomaticInstanceRepair)(ptr) == nil
}

func (VirtualMachineScaleSetSpecAutomaticInstanceRepairCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineScaleSetSpecAutomaticInstanceRepair)(ptr)
	var objs []VirtualMachineScaleSetSpecAutomaticInstanceRepair
	if obj != nil {
		objs = []VirtualMachineScaleSetSpecAutomaticInstanceRepair{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecAutomaticInstanceRepair{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineScaleSetSpecAutomaticInstanceRepairCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineScaleSetSpecAutomaticInstanceRepair)(ptr) = VirtualMachineScaleSetSpecAutomaticInstanceRepair{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineScaleSetSpecAutomaticInstanceRepair

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecAutomaticInstanceRepair{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineScaleSetSpecAutomaticInstanceRepair)(ptr) = objs[0]
			} else {
				*(*VirtualMachineScaleSetSpecAutomaticInstanceRepair)(ptr) = VirtualMachineScaleSetSpecAutomaticInstanceRepair{}
			}
		} else {
			*(*VirtualMachineScaleSetSpecAutomaticInstanceRepair)(ptr) = VirtualMachineScaleSetSpecAutomaticInstanceRepair{}
		}
	default:
		iter.ReportError("decode VirtualMachineScaleSetSpecAutomaticInstanceRepair", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineScaleSetSpecAutomaticOsUpgradePolicyCodec struct {
}

func (VirtualMachineScaleSetSpecAutomaticOsUpgradePolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineScaleSetSpecAutomaticOsUpgradePolicy)(ptr) == nil
}

func (VirtualMachineScaleSetSpecAutomaticOsUpgradePolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineScaleSetSpecAutomaticOsUpgradePolicy)(ptr)
	var objs []VirtualMachineScaleSetSpecAutomaticOsUpgradePolicy
	if obj != nil {
		objs = []VirtualMachineScaleSetSpecAutomaticOsUpgradePolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecAutomaticOsUpgradePolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineScaleSetSpecAutomaticOsUpgradePolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineScaleSetSpecAutomaticOsUpgradePolicy)(ptr) = VirtualMachineScaleSetSpecAutomaticOsUpgradePolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineScaleSetSpecAutomaticOsUpgradePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecAutomaticOsUpgradePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineScaleSetSpecAutomaticOsUpgradePolicy)(ptr) = objs[0]
			} else {
				*(*VirtualMachineScaleSetSpecAutomaticOsUpgradePolicy)(ptr) = VirtualMachineScaleSetSpecAutomaticOsUpgradePolicy{}
			}
		} else {
			*(*VirtualMachineScaleSetSpecAutomaticOsUpgradePolicy)(ptr) = VirtualMachineScaleSetSpecAutomaticOsUpgradePolicy{}
		}
	default:
		iter.ReportError("decode VirtualMachineScaleSetSpecAutomaticOsUpgradePolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineScaleSetSpecBootDiagnosticsCodec struct {
}

func (VirtualMachineScaleSetSpecBootDiagnosticsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineScaleSetSpecBootDiagnostics)(ptr) == nil
}

func (VirtualMachineScaleSetSpecBootDiagnosticsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineScaleSetSpecBootDiagnostics)(ptr)
	var objs []VirtualMachineScaleSetSpecBootDiagnostics
	if obj != nil {
		objs = []VirtualMachineScaleSetSpecBootDiagnostics{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecBootDiagnostics{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineScaleSetSpecBootDiagnosticsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineScaleSetSpecBootDiagnostics)(ptr) = VirtualMachineScaleSetSpecBootDiagnostics{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineScaleSetSpecBootDiagnostics

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecBootDiagnostics{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineScaleSetSpecBootDiagnostics)(ptr) = objs[0]
			} else {
				*(*VirtualMachineScaleSetSpecBootDiagnostics)(ptr) = VirtualMachineScaleSetSpecBootDiagnostics{}
			}
		} else {
			*(*VirtualMachineScaleSetSpecBootDiagnostics)(ptr) = VirtualMachineScaleSetSpecBootDiagnostics{}
		}
	default:
		iter.ReportError("decode VirtualMachineScaleSetSpecBootDiagnostics", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineScaleSetSpecIdentityCodec struct {
}

func (VirtualMachineScaleSetSpecIdentityCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineScaleSetSpecIdentity)(ptr) == nil
}

func (VirtualMachineScaleSetSpecIdentityCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineScaleSetSpecIdentity)(ptr)
	var objs []VirtualMachineScaleSetSpecIdentity
	if obj != nil {
		objs = []VirtualMachineScaleSetSpecIdentity{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecIdentity{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineScaleSetSpecIdentityCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineScaleSetSpecIdentity)(ptr) = VirtualMachineScaleSetSpecIdentity{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineScaleSetSpecIdentity

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecIdentity{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineScaleSetSpecIdentity)(ptr) = objs[0]
			} else {
				*(*VirtualMachineScaleSetSpecIdentity)(ptr) = VirtualMachineScaleSetSpecIdentity{}
			}
		} else {
			*(*VirtualMachineScaleSetSpecIdentity)(ptr) = VirtualMachineScaleSetSpecIdentity{}
		}
	default:
		iter.ReportError("decode VirtualMachineScaleSetSpecIdentity", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineScaleSetSpecOsDiskCodec struct {
}

func (VirtualMachineScaleSetSpecOsDiskCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineScaleSetSpecOsDisk)(ptr) == nil
}

func (VirtualMachineScaleSetSpecOsDiskCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineScaleSetSpecOsDisk)(ptr)
	var objs []VirtualMachineScaleSetSpecOsDisk
	if obj != nil {
		objs = []VirtualMachineScaleSetSpecOsDisk{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecOsDisk{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineScaleSetSpecOsDiskCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineScaleSetSpecOsDisk)(ptr) = VirtualMachineScaleSetSpecOsDisk{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineScaleSetSpecOsDisk

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecOsDisk{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineScaleSetSpecOsDisk)(ptr) = objs[0]
			} else {
				*(*VirtualMachineScaleSetSpecOsDisk)(ptr) = VirtualMachineScaleSetSpecOsDisk{}
			}
		} else {
			*(*VirtualMachineScaleSetSpecOsDisk)(ptr) = VirtualMachineScaleSetSpecOsDisk{}
		}
	default:
		iter.ReportError("decode VirtualMachineScaleSetSpecOsDisk", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineScaleSetSpecOsDiskDiffDiskSettingsCodec struct {
}

func (VirtualMachineScaleSetSpecOsDiskDiffDiskSettingsCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineScaleSetSpecOsDiskDiffDiskSettings)(ptr) == nil
}

func (VirtualMachineScaleSetSpecOsDiskDiffDiskSettingsCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineScaleSetSpecOsDiskDiffDiskSettings)(ptr)
	var objs []VirtualMachineScaleSetSpecOsDiskDiffDiskSettings
	if obj != nil {
		objs = []VirtualMachineScaleSetSpecOsDiskDiffDiskSettings{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecOsDiskDiffDiskSettings{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineScaleSetSpecOsDiskDiffDiskSettingsCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineScaleSetSpecOsDiskDiffDiskSettings)(ptr) = VirtualMachineScaleSetSpecOsDiskDiffDiskSettings{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineScaleSetSpecOsDiskDiffDiskSettings

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecOsDiskDiffDiskSettings{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineScaleSetSpecOsDiskDiffDiskSettings)(ptr) = objs[0]
			} else {
				*(*VirtualMachineScaleSetSpecOsDiskDiffDiskSettings)(ptr) = VirtualMachineScaleSetSpecOsDiskDiffDiskSettings{}
			}
		} else {
			*(*VirtualMachineScaleSetSpecOsDiskDiffDiskSettings)(ptr) = VirtualMachineScaleSetSpecOsDiskDiffDiskSettings{}
		}
	default:
		iter.ReportError("decode VirtualMachineScaleSetSpecOsDiskDiffDiskSettings", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineScaleSetSpecPlanCodec struct {
}

func (VirtualMachineScaleSetSpecPlanCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineScaleSetSpecPlan)(ptr) == nil
}

func (VirtualMachineScaleSetSpecPlanCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineScaleSetSpecPlan)(ptr)
	var objs []VirtualMachineScaleSetSpecPlan
	if obj != nil {
		objs = []VirtualMachineScaleSetSpecPlan{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecPlan{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineScaleSetSpecPlanCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineScaleSetSpecPlan)(ptr) = VirtualMachineScaleSetSpecPlan{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineScaleSetSpecPlan

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecPlan{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineScaleSetSpecPlan)(ptr) = objs[0]
			} else {
				*(*VirtualMachineScaleSetSpecPlan)(ptr) = VirtualMachineScaleSetSpecPlan{}
			}
		} else {
			*(*VirtualMachineScaleSetSpecPlan)(ptr) = VirtualMachineScaleSetSpecPlan{}
		}
	default:
		iter.ReportError("decode VirtualMachineScaleSetSpecPlan", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineScaleSetSpecRollingUpgradePolicyCodec struct {
}

func (VirtualMachineScaleSetSpecRollingUpgradePolicyCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineScaleSetSpecRollingUpgradePolicy)(ptr) == nil
}

func (VirtualMachineScaleSetSpecRollingUpgradePolicyCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineScaleSetSpecRollingUpgradePolicy)(ptr)
	var objs []VirtualMachineScaleSetSpecRollingUpgradePolicy
	if obj != nil {
		objs = []VirtualMachineScaleSetSpecRollingUpgradePolicy{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecRollingUpgradePolicy{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineScaleSetSpecRollingUpgradePolicyCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineScaleSetSpecRollingUpgradePolicy)(ptr) = VirtualMachineScaleSetSpecRollingUpgradePolicy{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineScaleSetSpecRollingUpgradePolicy

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecRollingUpgradePolicy{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineScaleSetSpecRollingUpgradePolicy)(ptr) = objs[0]
			} else {
				*(*VirtualMachineScaleSetSpecRollingUpgradePolicy)(ptr) = VirtualMachineScaleSetSpecRollingUpgradePolicy{}
			}
		} else {
			*(*VirtualMachineScaleSetSpecRollingUpgradePolicy)(ptr) = VirtualMachineScaleSetSpecRollingUpgradePolicy{}
		}
	default:
		iter.ReportError("decode VirtualMachineScaleSetSpecRollingUpgradePolicy", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineScaleSetSpecSourceImageReferenceCodec struct {
}

func (VirtualMachineScaleSetSpecSourceImageReferenceCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineScaleSetSpecSourceImageReference)(ptr) == nil
}

func (VirtualMachineScaleSetSpecSourceImageReferenceCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineScaleSetSpecSourceImageReference)(ptr)
	var objs []VirtualMachineScaleSetSpecSourceImageReference
	if obj != nil {
		objs = []VirtualMachineScaleSetSpecSourceImageReference{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecSourceImageReference{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineScaleSetSpecSourceImageReferenceCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineScaleSetSpecSourceImageReference)(ptr) = VirtualMachineScaleSetSpecSourceImageReference{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineScaleSetSpecSourceImageReference

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecSourceImageReference{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineScaleSetSpecSourceImageReference)(ptr) = objs[0]
			} else {
				*(*VirtualMachineScaleSetSpecSourceImageReference)(ptr) = VirtualMachineScaleSetSpecSourceImageReference{}
			}
		} else {
			*(*VirtualMachineScaleSetSpecSourceImageReference)(ptr) = VirtualMachineScaleSetSpecSourceImageReference{}
		}
	default:
		iter.ReportError("decode VirtualMachineScaleSetSpecSourceImageReference", "unexpected JSON type")
	}
}

// +k8s:deepcopy-gen=false
type VirtualMachineScaleSetSpecTerminateNotificationCodec struct {
}

func (VirtualMachineScaleSetSpecTerminateNotificationCodec) IsEmpty(ptr unsafe.Pointer) bool {
	return (*VirtualMachineScaleSetSpecTerminateNotification)(ptr) == nil
}

func (VirtualMachineScaleSetSpecTerminateNotificationCodec) Encode(ptr unsafe.Pointer, stream *jsoniter.Stream) {
	obj := (*VirtualMachineScaleSetSpecTerminateNotification)(ptr)
	var objs []VirtualMachineScaleSetSpecTerminateNotification
	if obj != nil {
		objs = []VirtualMachineScaleSetSpecTerminateNotification{*obj}
	}

	jsonit := jsoniter.Config{
		EscapeHTML:             true,
		SortMapKeys:            true,
		ValidateJsonRawMessage: true,
		TagKey:                 "tf",
		TypeEncoders:           getEncodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecTerminateNotification{}).Type1())),
	}.Froze()

	byt, _ := jsonit.Marshal(objs)

	stream.Write(byt)
}

func (VirtualMachineScaleSetSpecTerminateNotificationCodec) Decode(ptr unsafe.Pointer, iter *jsoniter.Iterator) {
	switch iter.WhatIsNext() {
	case jsoniter.NilValue:
		iter.Skip()
		*(*VirtualMachineScaleSetSpecTerminateNotification)(ptr) = VirtualMachineScaleSetSpecTerminateNotification{}
		return
	case jsoniter.ArrayValue:
		objsByte := iter.SkipAndReturnBytes()
		if len(objsByte) > 0 {
			var objs []VirtualMachineScaleSetSpecTerminateNotification

			jsonit := jsoniter.Config{
				EscapeHTML:             true,
				SortMapKeys:            true,
				ValidateJsonRawMessage: true,
				TagKey:                 "tf",
				TypeDecoders:           getDecodersWithout(jsoniter.MustGetKind(reflect2.TypeOf(VirtualMachineScaleSetSpecTerminateNotification{}).Type1())),
			}.Froze()
			jsonit.Unmarshal(objsByte, &objs)

			if len(objs) > 0 {
				*(*VirtualMachineScaleSetSpecTerminateNotification)(ptr) = objs[0]
			} else {
				*(*VirtualMachineScaleSetSpecTerminateNotification)(ptr) = VirtualMachineScaleSetSpecTerminateNotification{}
			}
		} else {
			*(*VirtualMachineScaleSetSpecTerminateNotification)(ptr) = VirtualMachineScaleSetSpecTerminateNotification{}
		}
	default:
		iter.ReportError("decode VirtualMachineScaleSetSpecTerminateNotification", "unexpected JSON type")
	}
}
